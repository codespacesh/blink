// Copyright 2023, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file includes work covered by the following copyright and permission notices:
//
// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.9.0 with parameter "target=ts"
// @generated from file opentelemetry/proto/profiles/v1development/profiles.proto (package opentelemetry.proto.profiles.v1development, syntax proto3)
/* eslint-disable */

import type { Message } from "@bufbuild/protobuf";
import type {
  GenEnum,
  GenFile,
  GenMessage,
} from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { AnyValue, InstrumentationScope } from "../../common/v1/common_pb";
import { file_opentelemetry_proto_common_v1_common } from "../../common/v1/common_pb";
import type { Resource } from "../../resource/v1/resource_pb";
import { file_opentelemetry_proto_resource_v1_resource } from "../../resource/v1/resource_pb";

/**
 * Describes the file opentelemetry/proto/profiles/v1development/profiles.proto.
 */
export const file_opentelemetry_proto_profiles_v1development_profiles: GenFile =
  /*@__PURE__*/
  fileDesc(
    "CjlvcGVudGVsZW1ldHJ5L3Byb3RvL3Byb2ZpbGVzL3YxZGV2ZWxvcG1lbnQvcHJvZmlsZXMucHJvdG8SKm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudCL2AwoSUHJvZmlsZXNEaWN0aW9uYXJ5EkoKDW1hcHBpbmdfdGFibGUYASADKAsyMy5vcGVudGVsZW1ldHJ5LnByb3RvLnByb2ZpbGVzLnYxZGV2ZWxvcG1lbnQuTWFwcGluZxJMCg5sb2NhdGlvbl90YWJsZRgCIAMoCzI0Lm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5Mb2NhdGlvbhJMCg5mdW5jdGlvbl90YWJsZRgDIAMoCzI0Lm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5GdW5jdGlvbhJECgpsaW5rX3RhYmxlGAQgAygLMjAub3BlbnRlbGVtZXRyeS5wcm90by5wcm9maWxlcy52MWRldmVsb3BtZW50LkxpbmsSFAoMc3RyaW5nX3RhYmxlGAUgAygJElQKD2F0dHJpYnV0ZV90YWJsZRgGIAMoCzI7Lm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5LZXlWYWx1ZUFuZFVuaXQSRgoLc3RhY2tfdGFibGUYByADKAsyMS5vcGVudGVsZW1ldHJ5LnByb3RvLnByb2ZpbGVzLnYxZGV2ZWxvcG1lbnQuU3RhY2siuwEKDFByb2ZpbGVzRGF0YRJXChFyZXNvdXJjZV9wcm9maWxlcxgBIAMoCzI8Lm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5SZXNvdXJjZVByb2ZpbGVzElIKCmRpY3Rpb25hcnkYAiABKAsyPi5vcGVudGVsZW1ldHJ5LnByb3RvLnByb2ZpbGVzLnYxZGV2ZWxvcG1lbnQuUHJvZmlsZXNEaWN0aW9uYXJ5Ir4BChBSZXNvdXJjZVByb2ZpbGVzEjsKCHJlc291cmNlGAEgASgLMikub3BlbnRlbGVtZXRyeS5wcm90by5yZXNvdXJjZS52MS5SZXNvdXJjZRJRCg5zY29wZV9wcm9maWxlcxgCIAMoCzI5Lm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5TY29wZVByb2ZpbGVzEhIKCnNjaGVtYV91cmwYAyABKAlKBgjoBxDpByKuAQoNU2NvcGVQcm9maWxlcxJCCgVzY29wZRgBIAEoCzIzLm9wZW50ZWxlbWV0cnkucHJvdG8uY29tbW9uLnYxLkluc3RydW1lbnRhdGlvblNjb3BlEkUKCHByb2ZpbGVzGAIgAygLMjMub3BlbnRlbGVtZXRyeS5wcm90by5wcm9maWxlcy52MWRldmVsb3BtZW50LlByb2ZpbGUSEgoKc2NoZW1hX3VybBgDIAEoCSLMAwoHUHJvZmlsZRJKCgtzYW1wbGVfdHlwZRgBIAEoCzI1Lm9wZW50ZWxlbWV0cnkucHJvdG8ucHJvZmlsZXMudjFkZXZlbG9wbWVudC5WYWx1ZVR5cGUSQgoGc2FtcGxlGAIgAygLMjIub3BlbnRlbGVtZXRyeS5wcm90by5wcm9maWxlcy52MWRldmVsb3BtZW50LlNhbXBsZRIWCg50aW1lX3VuaXhfbmFubxgDIAEoBhIVCg1kdXJhdGlvbl9uYW5vGAQgASgEEkoKC3BlcmlvZF90eXBlGAUgASgLMjUub3BlbnRlbGVtZXRyeS5wcm90by5wcm9maWxlcy52MWRldmVsb3BtZW50LlZhbHVlVHlwZRIOCgZwZXJpb2QYBiABKAMSGgoSY29tbWVudF9zdHJpbmRpY2VzGAcgAygFEhIKCnByb2ZpbGVfaWQYCCABKAwSIAoYZHJvcHBlZF9hdHRyaWJ1dGVzX2NvdW50GAkgASgNEh8KF29yaWdpbmFsX3BheWxvYWRfZm9ybWF0GAogASgJEhgKEG9yaWdpbmFsX3BheWxvYWQYCyABKAwSGQoRYXR0cmlidXRlX2luZGljZXMYDCADKAUiKQoETGluaxIQCgh0cmFjZV9pZBgBIAEoDBIPCgdzcGFuX2lkGAIgASgMIp4BCglWYWx1ZVR5cGUSFQoNdHlwZV9zdHJpbmRleBgBIAEoBRIVCg11bml0X3N0cmluZGV4GAIgASgFEmMKF2FnZ3JlZ2F0aW9uX3RlbXBvcmFsaXR5GAMgASgOMkIub3BlbnRlbGVtZXRyeS5wcm90by5wcm9maWxlcy52MWRldmVsb3BtZW50LkFnZ3JlZ2F0aW9uVGVtcG9yYWxpdHkiegoGU2FtcGxlEhMKC3N0YWNrX2luZGV4GAEgASgFEg4KBnZhbHVlcxgCIAMoAxIZChFhdHRyaWJ1dGVfaW5kaWNlcxgDIAMoBRISCgpsaW5rX2luZGV4GAQgASgFEhwKFHRpbWVzdGFtcHNfdW5peF9uYW5vGAUgAygGIoABCgdNYXBwaW5nEhQKDG1lbW9yeV9zdGFydBgBIAEoBBIUCgxtZW1vcnlfbGltaXQYAiABKAQSEwoLZmlsZV9vZmZzZXQYAyABKAQSGQoRZmlsZW5hbWVfc3RyaW5kZXgYBCABKAUSGQoRYXR0cmlidXRlX2luZGljZXMYBSADKAUiIQoFU3RhY2sSGAoQbG9jYXRpb25faW5kaWNlcxgBIAMoBSKNAQoITG9jYXRpb24SFQoNbWFwcGluZ19pbmRleBgBIAEoBRIPCgdhZGRyZXNzGAIgASgEEj4KBGxpbmUYAyADKAsyMC5vcGVudGVsZW1ldHJ5LnByb3RvLnByb2ZpbGVzLnYxZGV2ZWxvcG1lbnQuTGluZRIZChFhdHRyaWJ1dGVfaW5kaWNlcxgEIAMoBSI8CgRMaW5lEhYKDmZ1bmN0aW9uX2luZGV4GAEgASgFEgwKBGxpbmUYAiABKAMSDgoGY29sdW1uGAMgASgDIm4KCEZ1bmN0aW9uEhUKDW5hbWVfc3RyaW5kZXgYASABKAUSHAoUc3lzdGVtX25hbWVfc3RyaW5kZXgYAiABKAUSGQoRZmlsZW5hbWVfc3RyaW5kZXgYAyABKAUSEgoKc3RhcnRfbGluZRgEIAEoAyJ2Cg9LZXlWYWx1ZUFuZFVuaXQSFAoMa2V5X3N0cmluZGV4GAEgASgFEjYKBXZhbHVlGAIgASgLMicub3BlbnRlbGVtZXRyeS5wcm90by5jb21tb24udjEuQW55VmFsdWUSFQoNdW5pdF9zdHJpbmRleBgDIAEoBSqMAQoWQWdncmVnYXRpb25UZW1wb3JhbGl0eRInCiNBR0dSRUdBVElPTl9URU1QT1JBTElUWV9VTlNQRUNJRklFRBAAEiEKHUFHR1JFR0FUSU9OX1RFTVBPUkFMSVRZX0RFTFRBEAESJgoiQUdHUkVHQVRJT05fVEVNUE9SQUxJVFlfQ1VNVUxBVElWRRACQqQBCi1pby5vcGVudGVsZW1ldHJ5LnByb3RvLnByb2ZpbGVzLnYxZGV2ZWxvcG1lbnRCDVByb2ZpbGVzUHJvdG9QAVo1Z28ub3BlbnRlbGVtZXRyeS5pby9wcm90by9vdGxwL3Byb2ZpbGVzL3YxZGV2ZWxvcG1lbnSqAipPcGVuVGVsZW1ldHJ5LlByb3RvLlByb2ZpbGVzLlYxRGV2ZWxvcG1lbnRiBnByb3RvMw",
    [
      file_opentelemetry_proto_common_v1_common,
      file_opentelemetry_proto_resource_v1_resource,
    ]
  );

/**
 * ProfilesDictionary represents the profiles data shared across the
 * entire message being sent.
 *
 * Note that all fields in this message MUST have a zero value encoded as the first element.
 * This allows for _index fields pointing into the dictionary to use a 0 pointer value
 * to indicate 'null' / 'not set'. Unless otherwise defined, a 'zero value' message value
 * is one with all default field values, so as to minimize wire encoded size.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ProfilesDictionary
 */
export type ProfilesDictionary =
  Message<"opentelemetry.proto.profiles.v1development.ProfilesDictionary"> & {
    /**
     * Mappings from address ranges to the image/binary/library mapped
     * into that address range referenced by locations via Location.mapping_index.
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.Mapping mapping_table = 1;
     */
    mappingTable: Mapping[];

    /**
     * Locations referenced by samples via Stack.location_indices.
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.Location location_table = 2;
     */
    locationTable: Location[];

    /**
     * Functions referenced by locations via Line.function_index.
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.Function function_table = 3;
     */
    functionTable: Function[];

    /**
     * Links referenced by samples via Sample.link_index.
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.Link link_table = 4;
     */
    linkTable: Link[];

    /**
     * A common table for strings referenced by various messages.
     * string_table[0] must always be "".
     *
     * @generated from field: repeated string string_table = 5;
     */
    stringTable: string[];

    /**
     * A common table for attributes referenced by various messages.
     * It is a collection of key/value pairs. Note, global attributes
     * like server name can be set using the resource API. Examples of attributes:
     *
     *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
     *     "/http/server_latency": 300
     *     "abc.com/myattribute": true
     *     "abc.com/score": 10.239
     *
     * The attribute values SHOULD NOT contain empty values.
     * The attribute values SHOULD NOT contain bytes values.
     * The attribute values SHOULD NOT contain array values different than array of string values, bool values, int values,
     * double values.
     * The attribute values SHOULD NOT contain kvlist values.
     * The behavior of software that receives attributes containing such values can be unpredictable.
     * These restrictions can change in a minor release.
     * The restrictions take origin from the OpenTelemetry specification:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/v1.47.0/specification/common/README.md#attribute.
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.KeyValueAndUnit attribute_table = 6;
     */
    attributeTable: KeyValueAndUnit[];

    /**
     * Stacks referenced by samples via Sample.stack_index.
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.Stack stack_table = 7;
     */
    stackTable: Stack[];
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ProfilesDictionary.
 * Use `create(ProfilesDictionarySchema)` to create a new message.
 */
export const ProfilesDictionarySchema: GenMessage<ProfilesDictionary> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 0);

/**
 * ProfilesData represents the profiles data that can be stored in persistent storage,
 * OR can be embedded by other protocols that transfer OTLP profiles data but do not
 * implement the OTLP protocol.
 *
 * The main difference between this message and collector protocol is that
 * in this message there will not be any "control" or "metadata" specific to
 * OTLP protocol.
 *
 * When new fields are added into this message, the OTLP request MUST be updated
 * as well.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ProfilesData
 */
export type ProfilesData =
  Message<"opentelemetry.proto.profiles.v1development.ProfilesData"> & {
    /**
     * An array of ResourceProfiles.
     * For data coming from an SDK profiler, this array will typically contain one
     * element. Host-level profilers will usually create one ResourceProfile per
     * container, as well as one additional ResourceProfile grouping all samples
     * from non-containerized processes.
     * Other resource groupings are possible as well and clarified via
     * Resource.attributes and semantic conventions.
     * Tools that visualize profiles should prefer displaying
     * resources_profiles[0].scope_profiles[0].profiles[0] by default.
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.ResourceProfiles resource_profiles = 1;
     */
    resourceProfiles: ResourceProfiles[];

    /**
     * One instance of ProfilesDictionary
     *
     * @generated from field: opentelemetry.proto.profiles.v1development.ProfilesDictionary dictionary = 2;
     */
    dictionary?: ProfilesDictionary;
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ProfilesData.
 * Use `create(ProfilesDataSchema)` to create a new message.
 */
export const ProfilesDataSchema: GenMessage<ProfilesData> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 1);

/**
 * A collection of ScopeProfiles from a Resource.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ResourceProfiles
 */
export type ResourceProfiles =
  Message<"opentelemetry.proto.profiles.v1development.ResourceProfiles"> & {
    /**
     * The resource for the profiles in this message.
     * If this field is not set then no resource info is known.
     *
     * @generated from field: opentelemetry.proto.resource.v1.Resource resource = 1;
     */
    resource?: Resource;

    /**
     * A list of ScopeProfiles that originate from a resource.
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.ScopeProfiles scope_profiles = 2;
     */
    scopeProfiles: ScopeProfiles[];

    /**
     * The Schema URL, if known. This is the identifier of the Schema that the resource data
     * is recorded in. Notably, the last part of the URL path is the version number of the
     * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
     * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
     * This schema_url applies to the data in the "resource" field. It does not apply
     * to the data in the "scope_profiles" field which have their own schema_url field.
     *
     * @generated from field: string schema_url = 3;
     */
    schemaUrl: string;
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ResourceProfiles.
 * Use `create(ResourceProfilesSchema)` to create a new message.
 */
export const ResourceProfilesSchema: GenMessage<ResourceProfiles> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 2);

/**
 * A collection of Profiles produced by an InstrumentationScope.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ScopeProfiles
 */
export type ScopeProfiles =
  Message<"opentelemetry.proto.profiles.v1development.ScopeProfiles"> & {
    /**
     * The instrumentation scope information for the profiles in this message.
     * Semantically when InstrumentationScope isn't set, it is equivalent with
     * an empty instrumentation scope name (unknown).
     *
     * @generated from field: opentelemetry.proto.common.v1.InstrumentationScope scope = 1;
     */
    scope?: InstrumentationScope;

    /**
     * A list of Profiles that originate from an instrumentation scope.
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.Profile profiles = 2;
     */
    profiles: Profile[];

    /**
     * The Schema URL, if known. This is the identifier of the Schema that the profile data
     * is recorded in. Notably, the last part of the URL path is the version number of the
     * schema: http[s]://server[:port]/path/<version>. To learn more about Schema URL see
     * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
     * This schema_url applies to all profiles in the "profiles" field.
     *
     * @generated from field: string schema_url = 3;
     */
    schemaUrl: string;
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ScopeProfiles.
 * Use `create(ScopeProfilesSchema)` to create a new message.
 */
export const ScopeProfilesSchema: GenMessage<ScopeProfiles> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 3);

/**
 * Represents a complete profile, including sample types, samples, mappings to
 * binaries, stacks, locations, functions, string table, and additional
 * metadata. It modifies and annotates pprof Profile with OpenTelemetry
 * specific fields.
 *
 * Note that whilst fields in this message retain the name and field id from pprof in most cases
 * for ease of understanding data migration, it is not intended that pprof:Profile and
 * OpenTelemetry:Profile encoding be wire compatible.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Profile
 */
export type Profile =
  Message<"opentelemetry.proto.profiles.v1development.Profile"> & {
    /**
     * The type and unit of all Sample.values in this profile.
     * For a cpu or off-cpu profile this might be:
     *   ["cpu","nanoseconds"] or ["off_cpu","nanoseconds"]
     * For a heap profile, this might be:
     *   ["allocated_objects","count"] or ["allocated_space","bytes"],
     *
     * @generated from field: opentelemetry.proto.profiles.v1development.ValueType sample_type = 1;
     */
    sampleType?: ValueType;

    /**
     * The set of samples recorded in this profile.
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.Sample sample = 2;
     */
    sample: Sample[];

    /**
     * Time of collection (UTC) represented as nanoseconds past the epoch.
     *
     * @generated from field: fixed64 time_unix_nano = 3;
     */
    timeUnixNano: bigint;

    /**
     * Duration of the profile, if a duration makes sense.
     *
     * @generated from field: uint64 duration_nano = 4;
     */
    durationNano: bigint;

    /**
     * The kind of events between sampled occurrences.
     * e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
     *
     * @generated from field: opentelemetry.proto.profiles.v1development.ValueType period_type = 5;
     */
    periodType?: ValueType;

    /**
     * The number of events between sampled occurrences.
     *
     * @generated from field: int64 period = 6;
     */
    period: bigint;

    /**
     * Free-form text associated with the profile. The text is displayed as is
     * to the user by the tools that read profiles (e.g. by pprof). This field
     * should not be used to store any machine-readable information, it is only
     * for human-friendly content. The profile must stay functional if this field
     * is cleaned.
     *
     * Indices into ProfilesDictionary.string_table.
     *
     * @generated from field: repeated int32 comment_strindices = 7;
     */
    commentStrindices: number[];

    /**
     * A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
     * all zeroes is considered invalid. It may be used for deduplication and signal
     * correlation purposes. It is acceptable to treat two profiles with different values
     * in this field as not equal, even if they represented the same object at an earlier
     * time.
     * This field is optional; an ID may be assigned to an ID-less profile in a later step.
     *
     * @generated from field: bytes profile_id = 8;
     */
    profileId: Uint8Array;

    /**
     * dropped_attributes_count is the number of attributes that were discarded. Attributes
     * can be discarded because their keys are too long or because there are too many
     * attributes. If this value is 0, then no attributes were dropped.
     *
     * @generated from field: uint32 dropped_attributes_count = 9;
     */
    droppedAttributesCount: number;

    /**
     * Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
     *
     * @generated from field: string original_payload_format = 10;
     */
    originalPayloadFormat: string;

    /**
     * Original payload can be stored in this field. This can be useful for users who want to get the original payload.
     * Formats such as JFR are highly extensible and can contain more information than what is defined in this spec.
     * Inclusion of original payload should be configurable by the user. Default behavior should be to not include the original payload.
     * If the original payload is in pprof format, it SHOULD not be included in this field.
     * The field is optional, however if it is present then equivalent converted data should be populated in other fields
     * of this message as far as is practicable.
     *
     * @generated from field: bytes original_payload = 11;
     */
    originalPayload: Uint8Array;

    /**
     * References to attributes in attribute_table. [optional]
     *
     * @generated from field: repeated int32 attribute_indices = 12;
     */
    attributeIndices: number[];
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Profile.
 * Use `create(ProfileSchema)` to create a new message.
 */
export const ProfileSchema: GenMessage<Profile> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 4);

/**
 * A pointer from a profile Sample to a trace Span.
 * Connects a profile sample to a trace span, identified by unique trace and span IDs.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Link
 */
export type Link =
  Message<"opentelemetry.proto.profiles.v1development.Link"> & {
    /**
     * A unique identifier of a trace that this linked span is part of. The ID is a
     * 16-byte array.
     *
     * @generated from field: bytes trace_id = 1;
     */
    traceId: Uint8Array;

    /**
     * A unique identifier for the linked span. The ID is an 8-byte array.
     *
     * @generated from field: bytes span_id = 2;
     */
    spanId: Uint8Array;
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Link.
 * Use `create(LinkSchema)` to create a new message.
 */
export const LinkSchema: GenMessage<Link> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 5);

/**
 * ValueType describes the type and units of a value, with an optional aggregation temporality.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.ValueType
 */
export type ValueType =
  Message<"opentelemetry.proto.profiles.v1development.ValueType"> & {
    /**
     * Index into ProfilesDictionary.string_table.
     *
     * @generated from field: int32 type_strindex = 1;
     */
    typeStrindex: number;

    /**
     * Index into ProfilesDictionary.string_table.
     *
     * @generated from field: int32 unit_strindex = 2;
     */
    unitStrindex: number;

    /**
     * @generated from field: opentelemetry.proto.profiles.v1development.AggregationTemporality aggregation_temporality = 3;
     */
    aggregationTemporality: AggregationTemporality;
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.ValueType.
 * Use `create(ValueTypeSchema)` to create a new message.
 */
export const ValueTypeSchema: GenMessage<ValueType> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 6);

/**
 * Each Sample records values encountered in some program context. The program
 * context is typically a stack trace, perhaps augmented with auxiliary
 * information like the thread-id, some indicator of a higher level request
 * being handled etc.
 *
 * A Sample MUST have have at least one values or timestamps_unix_nano entry. If
 * both fields are populated, they MUST contain the same number of elements, and
 * the elements at the same index MUST refer to the same event.
 *
 * Examples of different ways of representing a sample with the total value of 10:
 *
 * Report of a stacktrace at 10 timestamps (consumers must assume the value is 1 for each point):
 *    values: []
 *    timestamps_unix_nano: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 *
 * Report of a stacktrace with an aggregated value without timestamps:
 *   values: [10]
 *    timestamps_unix_nano: []
 *
 * Report of a stacktrace at 4 timestamps where each point records a specific value:
 *    values: [2, 2, 3, 3]
 *    timestamps_unix_nano: [1, 2, 3, 4]
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Sample
 */
export type Sample =
  Message<"opentelemetry.proto.profiles.v1development.Sample"> & {
    /**
     * Reference to stack in ProfilesDictionary.stack_table.
     *
     * @generated from field: int32 stack_index = 1;
     */
    stackIndex: number;

    /**
     * The type and unit of each value is defined by Profile.sample_type.
     *
     * @generated from field: repeated int64 values = 2;
     */
    values: bigint[];

    /**
     * References to attributes in ProfilesDictionary.attribute_table. [optional]
     *
     * @generated from field: repeated int32 attribute_indices = 3;
     */
    attributeIndices: number[];

    /**
     * Reference to link in ProfilesDictionary.link_table. [optional]
     * It can be unset / set to 0 if no link exists, as link_table[0] is always a 'null' default value.
     *
     * @generated from field: int32 link_index = 4;
     */
    linkIndex: number;

    /**
     * Timestamps associated with Sample represented in nanoseconds. These
     * timestamps should fall within the Profile's time range.
     *
     * @generated from field: repeated fixed64 timestamps_unix_nano = 5;
     */
    timestampsUnixNano: bigint[];
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Sample.
 * Use `create(SampleSchema)` to create a new message.
 */
export const SampleSchema: GenMessage<Sample> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 7);

/**
 * Describes the mapping of a binary in memory, including its address range,
 * file offset, and metadata like build ID
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Mapping
 */
export type Mapping =
  Message<"opentelemetry.proto.profiles.v1development.Mapping"> & {
    /**
     * Address at which the binary (or DLL) is loaded into memory.
     *
     * @generated from field: uint64 memory_start = 1;
     */
    memoryStart: bigint;

    /**
     * The limit of the address range occupied by this mapping.
     *
     * @generated from field: uint64 memory_limit = 2;
     */
    memoryLimit: bigint;

    /**
     * Offset in the binary that corresponds to the first mapped address.
     *
     * @generated from field: uint64 file_offset = 3;
     */
    fileOffset: bigint;

    /**
     * The object this entry is loaded from.  This can be a filename on
     * disk for the main binary and shared libraries, or virtual
     * abstractions like "[vdso]".
     *
     * Index into ProfilesDictionary.string_table.
     *
     * @generated from field: int32 filename_strindex = 4;
     */
    filenameStrindex: number;

    /**
     * References to attributes in ProfilesDictionary.attribute_table. [optional]
     *
     * @generated from field: repeated int32 attribute_indices = 5;
     */
    attributeIndices: number[];
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Mapping.
 * Use `create(MappingSchema)` to create a new message.
 */
export const MappingSchema: GenMessage<Mapping> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 8);

/**
 * A Stack represents a stack trace as a list of locations.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Stack
 */
export type Stack =
  Message<"opentelemetry.proto.profiles.v1development.Stack"> & {
    /**
     * References to locations in ProfilesDictionary.location_table.
     * The first location is the leaf frame.
     *
     * @generated from field: repeated int32 location_indices = 1;
     */
    locationIndices: number[];
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Stack.
 * Use `create(StackSchema)` to create a new message.
 */
export const StackSchema: GenMessage<Stack> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 9);

/**
 * Describes function and line table debug information.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Location
 */
export type Location =
  Message<"opentelemetry.proto.profiles.v1development.Location"> & {
    /**
     * Reference to mapping in ProfilesDictionary.mapping_table.
     * It can be unset / set to 0 if the mapping is unknown or not applicable for
     * this profile type, as mapping_table[0] is always a 'null' default mapping.
     *
     * @generated from field: int32 mapping_index = 1;
     */
    mappingIndex: number;

    /**
     * The instruction address for this location, if available.  It
     * should be within [Mapping.memory_start...Mapping.memory_limit]
     * for the corresponding mapping. A non-leaf address may be in the
     * middle of a call instruction. It is up to display tools to find
     * the beginning of the instruction if necessary.
     *
     * @generated from field: uint64 address = 2;
     */
    address: bigint;

    /**
     * Multiple line indicates this location has inlined functions,
     * where the last entry represents the caller into which the
     * preceding entries were inlined.
     *
     * E.g., if memcpy() is inlined into printf:
     *    line[0].function_name == "memcpy"
     *    line[1].function_name == "printf"
     *
     * @generated from field: repeated opentelemetry.proto.profiles.v1development.Line line = 3;
     */
    line: Line[];

    /**
     * References to attributes in ProfilesDictionary.attribute_table. [optional]
     *
     * @generated from field: repeated int32 attribute_indices = 4;
     */
    attributeIndices: number[];
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Location.
 * Use `create(LocationSchema)` to create a new message.
 */
export const LocationSchema: GenMessage<Location> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 10);

/**
 * Details a specific line in a source code, linked to a function.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Line
 */
export type Line =
  Message<"opentelemetry.proto.profiles.v1development.Line"> & {
    /**
     * Reference to function in ProfilesDictionary.function_table.
     *
     * @generated from field: int32 function_index = 1;
     */
    functionIndex: number;

    /**
     * Line number in source code. 0 means unset.
     *
     * @generated from field: int64 line = 2;
     */
    line: bigint;

    /**
     * Column number in source code. 0 means unset.
     *
     * @generated from field: int64 column = 3;
     */
    column: bigint;
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Line.
 * Use `create(LineSchema)` to create a new message.
 */
export const LineSchema: GenMessage<Line> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 11);

/**
 * Describes a function, including its human-readable name, system name,
 * source file, and starting line number in the source.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.Function
 */
export type Function =
  Message<"opentelemetry.proto.profiles.v1development.Function"> & {
    /**
     * Function name. Empty string if not available.
     *
     * @generated from field: int32 name_strindex = 1;
     */
    nameStrindex: number;

    /**
     * Function name, as identified by the system. For instance,
     * it can be a C++ mangled name. Empty string if not available.
     *
     * @generated from field: int32 system_name_strindex = 2;
     */
    systemNameStrindex: number;

    /**
     * Source file containing the function. Empty string if not available.
     *
     * @generated from field: int32 filename_strindex = 3;
     */
    filenameStrindex: number;

    /**
     * Line number in source file. 0 means unset.
     *
     * @generated from field: int64 start_line = 4;
     */
    startLine: bigint;
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.Function.
 * Use `create(FunctionSchema)` to create a new message.
 */
export const FunctionSchema: GenMessage<Function> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 12);

/**
 * A custom 'dictionary native' style of encoding attributes which is more convenient
 * for profiles than opentelemetry.proto.common.v1.KeyValue
 * Specifically, uses the string table for keys and allows optional unit information.
 *
 * @generated from message opentelemetry.proto.profiles.v1development.KeyValueAndUnit
 */
export type KeyValueAndUnit =
  Message<"opentelemetry.proto.profiles.v1development.KeyValueAndUnit"> & {
    /**
     * @generated from field: int32 key_strindex = 1;
     */
    keyStrindex: number;

    /**
     * @generated from field: opentelemetry.proto.common.v1.AnyValue value = 2;
     */
    value?: AnyValue;

    /**
     * zero indicates implicit (by semconv) or non-defined unit.
     *
     * @generated from field: int32 unit_strindex = 3;
     */
    unitStrindex: number;
  };

/**
 * Describes the message opentelemetry.proto.profiles.v1development.KeyValueAndUnit.
 * Use `create(KeyValueAndUnitSchema)` to create a new message.
 */
export const KeyValueAndUnitSchema: GenMessage<KeyValueAndUnit> =
  /*@__PURE__*/
  messageDesc(file_opentelemetry_proto_profiles_v1development_profiles, 13);

/**
 * Specifies the method of aggregating metric values, either DELTA (change since last report)
 * or CUMULATIVE (total since a fixed start time).
 *
 * @generated from enum opentelemetry.proto.profiles.v1development.AggregationTemporality
 */
export enum AggregationTemporality {
  /**
   * UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
   *
   * @generated from enum value: AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * * DELTA is an AggregationTemporality for a profiler which reports
   * changes since last report time. Successive metrics contain aggregation of
   * values from continuous and non-overlapping intervals.
   *
   * The values for a DELTA metric are based only on the time interval
   * associated with one measurement cycle. There is no dependency on
   * previous measurements like is the case for CUMULATIVE metrics.
   *
   * For example, consider a system measuring the number of requests that
   * it receives and reports the sum of these requests every second as a
   * DELTA metric:
   *
   * 1. The system starts receiving at time=t_0.
   * 2. A request is received, the system measures 1 request.
   * 3. A request is received, the system measures 1 request.
   * 4. A request is received, the system measures 1 request.
   * 5. The 1 second collection cycle ends. A metric is exported for the
   * number of requests received over the interval of time t_0 to
   * t_0+1 with a value of 3.
   * 6. A request is received, the system measures 1 request.
   * 7. A request is received, the system measures 1 request.
   * 8. The 1 second collection cycle ends. A metric is exported for the
   * number of requests received over the interval of time t_0+1 to
   * t_0+2 with a value of 2.
   *
   * @generated from enum value: AGGREGATION_TEMPORALITY_DELTA = 1;
   */
  DELTA = 1,

  /**
   * * CUMULATIVE is an AggregationTemporality for a profiler which
   * reports changes since a fixed start time. This means that current values
   * of a CUMULATIVE metric depend on all previous measurements since the
   * start time. Because of this, the sender is required to retain this state
   * in some form. If this state is lost or invalidated, the CUMULATIVE metric
   * values MUST be reset and a new fixed start time following the last
   * reported measurement time sent MUST be used.
   *
   * For example, consider a system measuring the number of requests that
   * it receives and reports the sum of these requests every second as a
   * CUMULATIVE metric:
   *
   * 1. The system starts receiving at time=t_0.
   * 2. A request is received, the system measures 1 request.
   * 3. A request is received, the system measures 1 request.
   * 4. A request is received, the system measures 1 request.
   * 5. The 1 second collection cycle ends. A metric is exported for the
   * number of requests received over the interval of time t_0 to
   * t_0+1 with a value of 3.
   * 6. A request is received, the system measures 1 request.
   * 7. A request is received, the system measures 1 request.
   * 8. The 1 second collection cycle ends. A metric is exported for the
   * number of requests received over the interval of time t_0 to
   * t_0+2 with a value of 5.
   * 9. The system experiences a fault and loses state.
   * 10. The system recovers and resumes receiving at time=t_1.
   * 11. A request is received, the system measures 1 request.
   * 12. The 1 second collection cycle ends. A metric is exported for the
   * number of requests received over the interval of time t_1 to
   * t_1+1 with a value of 1.
   *
   * Note: Even though, when reporting changes since last report time, using
   * CUMULATIVE is valid, it is not recommended.
   *
   * @generated from enum value: AGGREGATION_TEMPORALITY_CUMULATIVE = 2;
   */
  CUMULATIVE = 2,
}

/**
 * Describes the enum opentelemetry.proto.profiles.v1development.AggregationTemporality.
 */
export const AggregationTemporalitySchema: GenEnum<AggregationTemporality> =
  /*@__PURE__*/
  enumDesc(file_opentelemetry_proto_profiles_v1development_profiles, 0);
