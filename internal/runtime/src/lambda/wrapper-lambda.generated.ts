// This file has been generated by the /home/kyle/projects/coder/blink.so/packages/runtime/scripts/generate.ts script.
// Do not edit this file manually.

export default 'import { createRequire } from "node:module";\nvar __defProp = Object.defineProperty;\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, {\n      get: all[name],\n      enumerable: true,\n      configurable: true,\n      set: (newValue) => all[name] = () => newValue\n    });\n};\nvar __require = /* @__PURE__ */ createRequire(import.meta.url);\n\n// ../../node_modules/@whatwg-node/fetch/dist/shouldSkipPonyfill.js\nvar require_shouldSkipPonyfill = __commonJS((exports, module) => {\n  function isNextJs() {\n    return Object.keys(globalThis).some((key) => key.startsWith("__NEXT"));\n  }\n  module.exports = function shouldSkipPonyfill() {\n    if (globalThis.Deno) {\n      return true;\n    }\n    if (globalThis.Bun) {\n      return true;\n    }\n    if (isNextJs()) {\n      return true;\n    }\n    return false;\n  };\n});\n\n// ../../node_modules/urlpattern-polyfill/dist/urlpattern.cjs\nvar require_urlpattern = __commonJS((exports, module) => {\n  var U = Object.defineProperty;\n  var Re = Object.getOwnPropertyDescriptor;\n  var Ee = Object.getOwnPropertyNames;\n  var Oe = Object.prototype.hasOwnProperty;\n  var a = (e, t) => U(e, "name", { value: t, configurable: true });\n  var ke = (e, t) => {\n    for (var r in t)\n      U(e, r, { get: t[r], enumerable: true });\n  };\n  var Te = (e, t, r, n) => {\n    if (t && typeof t == "object" || typeof t == "function")\n      for (let o of Ee(t))\n        !Oe.call(e, o) && o !== r && U(e, o, { get: () => t[o], enumerable: !(n = Re(t, o)) || n.enumerable });\n    return e;\n  };\n  var Ae = (e) => Te(U({}, "__esModule", { value: true }), e);\n  var He = {};\n  ke(He, { URLPattern: () => M });\n  module.exports = Ae(He);\n  var P = class {\n    type = 3;\n    name = "";\n    prefix = "";\n    value = "";\n    suffix = "";\n    modifier = 3;\n    constructor(t, r, n, o, l, f) {\n      this.type = t, this.name = r, this.prefix = n, this.value = o, this.suffix = l, this.modifier = f;\n    }\n    hasCustomName() {\n      return this.name !== "" && typeof this.name != "number";\n    }\n  };\n  a(P, "Part");\n  var ye = /[$_\\p{ID_Start}]/u;\n  var we = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\n  var F = ".*";\n  function Ce(e, t) {\n    return (t ? /^[\\x00-\\xFF]*$/ : /^[\\x00-\\x7F]*$/).test(e);\n  }\n  a(Ce, "isASCII");\n  function W(e, t = false) {\n    let r = [], n = 0;\n    for (;n < e.length; ) {\n      let o = e[n], l = a(function(f) {\n        if (!t)\n          throw new TypeError(f);\n        r.push({ type: "INVALID_CHAR", index: n, value: e[n++] });\n      }, "ErrorOrInvalid");\n      if (o === "*") {\n        r.push({ type: "ASTERISK", index: n, value: e[n++] });\n        continue;\n      }\n      if (o === "+" || o === "?") {\n        r.push({ type: "OTHER_MODIFIER", index: n, value: e[n++] });\n        continue;\n      }\n      if (o === "\\\\") {\n        r.push({ type: "ESCAPED_CHAR", index: n++, value: e[n++] });\n        continue;\n      }\n      if (o === "{") {\n        r.push({ type: "OPEN", index: n, value: e[n++] });\n        continue;\n      }\n      if (o === "}") {\n        r.push({ type: "CLOSE", index: n, value: e[n++] });\n        continue;\n      }\n      if (o === ":") {\n        let f = "", s = n + 1;\n        for (;s < e.length; ) {\n          let i = e.substr(s, 1);\n          if (s === n + 1 && ye.test(i) || s !== n + 1 && we.test(i)) {\n            f += e[s++];\n            continue;\n          }\n          break;\n        }\n        if (!f) {\n          l(`Missing parameter name at ${n}`);\n          continue;\n        }\n        r.push({ type: "NAME", index: n, value: f }), n = s;\n        continue;\n      }\n      if (o === "(") {\n        let f = 1, s = "", i = n + 1, c = false;\n        if (e[i] === "?") {\n          l(`Pattern cannot start with "?" at ${i}`);\n          continue;\n        }\n        for (;i < e.length; ) {\n          if (!Ce(e[i], false)) {\n            l(`Invalid character \'${e[i]}\' at ${i}.`), c = true;\n            break;\n          }\n          if (e[i] === "\\\\") {\n            s += e[i++] + e[i++];\n            continue;\n          }\n          if (e[i] === ")") {\n            if (f--, f === 0) {\n              i++;\n              break;\n            }\n          } else if (e[i] === "(" && (f++, e[i + 1] !== "?")) {\n            l(`Capturing groups are not allowed at ${i}`), c = true;\n            break;\n          }\n          s += e[i++];\n        }\n        if (c)\n          continue;\n        if (f) {\n          l(`Unbalanced pattern at ${n}`);\n          continue;\n        }\n        if (!s) {\n          l(`Missing pattern at ${n}`);\n          continue;\n        }\n        r.push({ type: "REGEX", index: n, value: s }), n = i;\n        continue;\n      }\n      r.push({ type: "CHAR", index: n, value: e[n++] });\n    }\n    return r.push({ type: "END", index: n, value: "" }), r;\n  }\n  a(W, "lexer");\n  function _(e, t = {}) {\n    let r = W(e);\n    t.delimiter ??= "/#?", t.prefixes ??= "./";\n    let n = `[^${x(t.delimiter)}]+?`, o = [], l = 0, f = 0, s = "", i = new Set, c = a((u) => {\n      if (f < r.length && r[f].type === u)\n        return r[f++].value;\n    }, "tryConsume"), h = a(() => c("OTHER_MODIFIER") ?? c("ASTERISK"), "tryConsumeModifier"), p = a((u) => {\n      let d = c(u);\n      if (d !== undefined)\n        return d;\n      let { type: g, index: y } = r[f];\n      throw new TypeError(`Unexpected ${g} at ${y}, expected ${u}`);\n    }, "mustConsume"), A = a(() => {\n      let u = "", d;\n      for (;d = c("CHAR") ?? c("ESCAPED_CHAR"); )\n        u += d;\n      return u;\n    }, "consumeText"), be = a((u) => u, "DefaultEncodePart"), N = t.encodePart || be, H = "", v = a((u) => {\n      H += u;\n    }, "appendToPendingFixedValue"), D = a(() => {\n      H.length && (o.push(new P(3, "", "", N(H), "", 3)), H = "");\n    }, "maybeAddPartFromPendingFixedValue"), Z = a((u, d, g, y, B) => {\n      let m = 3;\n      switch (B) {\n        case "?":\n          m = 1;\n          break;\n        case "*":\n          m = 0;\n          break;\n        case "+":\n          m = 2;\n          break;\n      }\n      if (!d && !g && m === 3) {\n        v(u);\n        return;\n      }\n      if (D(), !d && !g) {\n        if (!u)\n          return;\n        o.push(new P(3, "", "", N(u), "", m));\n        return;\n      }\n      let S;\n      g ? g === "*" ? S = F : S = g : S = n;\n      let k = 2;\n      S === n ? (k = 1, S = "") : S === F && (k = 0, S = "");\n      let E;\n      if (d ? E = d : g && (E = l++), i.has(E))\n        throw new TypeError(`Duplicate name \'${E}\'.`);\n      i.add(E), o.push(new P(k, E, N(u), S, N(y), m));\n    }, "addPart");\n    for (;f < r.length; ) {\n      let u = c("CHAR"), d = c("NAME"), g = c("REGEX");\n      if (!d && !g && (g = c("ASTERISK")), d || g) {\n        let m = u ?? "";\n        t.prefixes.indexOf(m) === -1 && (v(m), m = ""), D();\n        let S = h();\n        Z(m, d, g, "", S);\n        continue;\n      }\n      let y = u ?? c("ESCAPED_CHAR");\n      if (y) {\n        v(y);\n        continue;\n      }\n      if (c("OPEN")) {\n        let m = A(), S = c("NAME"), k = c("REGEX");\n        !S && !k && (k = c("ASTERISK"));\n        let E = A();\n        p("CLOSE");\n        let Pe = h();\n        Z(m, S, k, E, Pe);\n        continue;\n      }\n      D(), p("END");\n    }\n    return o;\n  }\n  a(_, "parse");\n  function x(e) {\n    return e.replace(/([.+*?^${}()[\\]|/\\\\])/g, "\\\\$1");\n  }\n  a(x, "escapeString");\n  function q(e) {\n    return e && e.ignoreCase ? "ui" : "u";\n  }\n  a(q, "flags");\n  function J(e, t, r) {\n    return z(_(e, r), t, r);\n  }\n  a(J, "stringToRegexp");\n  function T(e) {\n    switch (e) {\n      case 0:\n        return "*";\n      case 1:\n        return "?";\n      case 2:\n        return "+";\n      case 3:\n        return "";\n    }\n  }\n  a(T, "modifierToString");\n  function z(e, t, r = {}) {\n    r.delimiter ??= "/#?", r.prefixes ??= "./", r.sensitive ??= false, r.strict ??= false, r.end ??= true, r.start ??= true, r.endsWith = "";\n    let n = r.start ? "^" : "";\n    for (let s of e) {\n      if (s.type === 3) {\n        s.modifier === 3 ? n += x(s.value) : n += `(?:${x(s.value)})${T(s.modifier)}`;\n        continue;\n      }\n      t && t.push(s.name);\n      let i = `[^${x(r.delimiter)}]+?`, c = s.value;\n      if (s.type === 1 ? c = i : s.type === 0 && (c = F), !s.prefix.length && !s.suffix.length) {\n        s.modifier === 3 || s.modifier === 1 ? n += `(${c})${T(s.modifier)}` : n += `((?:${c})${T(s.modifier)})`;\n        continue;\n      }\n      if (s.modifier === 3 || s.modifier === 1) {\n        n += `(?:${x(s.prefix)}(${c})${x(s.suffix)})`, n += T(s.modifier);\n        continue;\n      }\n      n += `(?:${x(s.prefix)}`, n += `((?:${c})(?:`, n += x(s.suffix), n += x(s.prefix), n += `(?:${c}))*)${x(s.suffix)})`, s.modifier === 0 && (n += "?");\n    }\n    let o = `[${x(r.endsWith)}]|$`, l = `[${x(r.delimiter)}]`;\n    if (r.end)\n      return r.strict || (n += `${l}?`), r.endsWith.length ? n += `(?=${o})` : n += "$", new RegExp(n, q(r));\n    r.strict || (n += `(?:${l}(?=${o}))?`);\n    let f = false;\n    if (e.length) {\n      let s = e[e.length - 1];\n      s.type === 3 && s.modifier === 3 && (f = r.delimiter.indexOf(s) > -1);\n    }\n    return f || (n += `(?=${l}|${o})`), new RegExp(n, q(r));\n  }\n  a(z, "partsToRegexp");\n  var b = { delimiter: "", prefixes: "", sensitive: true, strict: true };\n  var Q = { delimiter: ".", prefixes: "", sensitive: true, strict: true };\n  var ee = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };\n  function te(e, t) {\n    return e.length ? e[0] === "/" ? true : !t || e.length < 2 ? false : (e[0] == "\\\\" || e[0] == "{") && e[1] == "/" : false;\n  }\n  a(te, "isAbsolutePathname");\n  function re(e, t) {\n    return e.startsWith(t) ? e.substring(t.length, e.length) : e;\n  }\n  a(re, "maybeStripPrefix");\n  function Le(e, t) {\n    return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;\n  }\n  a(Le, "maybeStripSuffix");\n  function j(e) {\n    return !e || e.length < 2 ? false : e[0] === "[" || (e[0] === "\\\\" || e[0] === "{") && e[1] === "[";\n  }\n  a(j, "treatAsIPv6Hostname");\n  var ne = ["ftp", "file", "http", "https", "ws", "wss"];\n  function $(e) {\n    if (!e)\n      return true;\n    for (let t of ne)\n      if (e.test(t))\n        return true;\n    return false;\n  }\n  a($, "isSpecialScheme");\n  function se(e, t) {\n    if (e = re(e, "#"), t || e === "")\n      return e;\n    let r = new URL("https://example.com");\n    return r.hash = e, r.hash ? r.hash.substring(1, r.hash.length) : "";\n  }\n  a(se, "canonicalizeHash");\n  function ie(e, t) {\n    if (e = re(e, "?"), t || e === "")\n      return e;\n    let r = new URL("https://example.com");\n    return r.search = e, r.search ? r.search.substring(1, r.search.length) : "";\n  }\n  a(ie, "canonicalizeSearch");\n  function ae(e, t) {\n    return t || e === "" ? e : j(e) ? V(e) : G(e);\n  }\n  a(ae, "canonicalizeHostname");\n  function oe(e, t) {\n    if (t || e === "")\n      return e;\n    let r = new URL("https://example.com");\n    return r.password = e, r.password;\n  }\n  a(oe, "canonicalizePassword");\n  function ce(e, t) {\n    if (t || e === "")\n      return e;\n    let r = new URL("https://example.com");\n    return r.username = e, r.username;\n  }\n  a(ce, "canonicalizeUsername");\n  function le(e, t, r) {\n    if (r || e === "")\n      return e;\n    if (t && !ne.includes(t))\n      return new URL(`${t}:${e}`).pathname;\n    let n = e[0] == "/";\n    return e = new URL(n ? e : "/-" + e, "https://example.com").pathname, n || (e = e.substring(2, e.length)), e;\n  }\n  a(le, "canonicalizePathname");\n  function fe(e, t, r) {\n    return K(t) === e && (e = ""), r || e === "" ? e : Y(e);\n  }\n  a(fe, "canonicalizePort");\n  function he(e, t) {\n    return e = Le(e, ":"), t || e === "" ? e : w(e);\n  }\n  a(he, "canonicalizeProtocol");\n  function K(e) {\n    switch (e) {\n      case "ws":\n      case "http":\n        return "80";\n      case "wws":\n      case "https":\n        return "443";\n      case "ftp":\n        return "21";\n      default:\n        return "";\n    }\n  }\n  a(K, "defaultPortForProtocol");\n  function w(e) {\n    if (e === "")\n      return e;\n    if (/^[-+.A-Za-z0-9]*$/.test(e))\n      return e.toLowerCase();\n    throw new TypeError(`Invalid protocol \'${e}\'.`);\n  }\n  a(w, "protocolEncodeCallback");\n  function ue(e) {\n    if (e === "")\n      return e;\n    let t = new URL("https://example.com");\n    return t.username = e, t.username;\n  }\n  a(ue, "usernameEncodeCallback");\n  function de(e) {\n    if (e === "")\n      return e;\n    let t = new URL("https://example.com");\n    return t.password = e, t.password;\n  }\n  a(de, "passwordEncodeCallback");\n  function G(e) {\n    if (e === "")\n      return e;\n    if (/[\\t\\n\\r #%/:<>?@[\\]^\\\\|]/g.test(e))\n      throw new TypeError(`Invalid hostname \'${e}\'`);\n    let t = new URL("https://example.com");\n    return t.hostname = e, t.hostname;\n  }\n  a(G, "hostnameEncodeCallback");\n  function V(e) {\n    if (e === "")\n      return e;\n    if (/[^0-9a-fA-F[\\]:]/g.test(e))\n      throw new TypeError(`Invalid IPv6 hostname \'${e}\'`);\n    return e.toLowerCase();\n  }\n  a(V, "ipv6HostnameEncodeCallback");\n  function Y(e) {\n    if (e === "" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535)\n      return e;\n    throw new TypeError(`Invalid port \'${e}\'.`);\n  }\n  a(Y, "portEncodeCallback");\n  function pe(e) {\n    if (e === "")\n      return e;\n    let t = new URL("https://example.com");\n    return t.pathname = e[0] !== "/" ? "/-" + e : e, e[0] !== "/" ? t.pathname.substring(2, t.pathname.length) : t.pathname;\n  }\n  a(pe, "standardURLPathnameEncodeCallback");\n  function ge(e) {\n    return e === "" ? e : new URL(`data:${e}`).pathname;\n  }\n  a(ge, "pathURLPathnameEncodeCallback");\n  function me(e) {\n    if (e === "")\n      return e;\n    let t = new URL("https://example.com");\n    return t.search = e, t.search.substring(1, t.search.length);\n  }\n  a(me, "searchEncodeCallback");\n  function Se(e) {\n    if (e === "")\n      return e;\n    let t = new URL("https://example.com");\n    return t.hash = e, t.hash.substring(1, t.hash.length);\n  }\n  a(Se, "hashEncodeCallback");\n  var C = class {\n    #i;\n    #n = [];\n    #t = {};\n    #e = 0;\n    #s = 1;\n    #l = 0;\n    #o = 0;\n    #d = 0;\n    #p = 0;\n    #g = false;\n    constructor(t) {\n      this.#i = t;\n    }\n    get result() {\n      return this.#t;\n    }\n    parse() {\n      for (this.#n = W(this.#i, true);this.#e < this.#n.length; this.#e += this.#s) {\n        if (this.#s = 1, this.#n[this.#e].type === "END") {\n          if (this.#o === 0) {\n            this.#b(), this.#f() ? this.#r(9, 1) : this.#h() ? this.#r(8, 1) : this.#r(7, 0);\n            continue;\n          } else if (this.#o === 2) {\n            this.#u(5);\n            continue;\n          }\n          this.#r(10, 0);\n          break;\n        }\n        if (this.#d > 0)\n          if (this.#A())\n            this.#d -= 1;\n          else\n            continue;\n        if (this.#T()) {\n          this.#d += 1;\n          continue;\n        }\n        switch (this.#o) {\n          case 0:\n            this.#P() && this.#u(1);\n            break;\n          case 1:\n            if (this.#P()) {\n              this.#C();\n              let t = 7, r = 1;\n              this.#E() ? (t = 2, r = 3) : this.#g && (t = 2), this.#r(t, r);\n            }\n            break;\n          case 2:\n            this.#S() ? this.#u(3) : (this.#x() || this.#h() || this.#f()) && this.#u(5);\n            break;\n          case 3:\n            this.#O() ? this.#r(4, 1) : this.#S() && this.#r(5, 1);\n            break;\n          case 4:\n            this.#S() && this.#r(5, 1);\n            break;\n          case 5:\n            this.#y() ? this.#p += 1 : this.#w() && (this.#p -= 1), this.#k() && !this.#p ? this.#r(6, 1) : this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);\n            break;\n          case 6:\n            this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);\n            break;\n          case 7:\n            this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);\n            break;\n          case 8:\n            this.#f() && this.#r(9, 1);\n            break;\n          case 9:\n            break;\n          case 10:\n            break;\n        }\n      }\n      this.#t.hostname !== undefined && this.#t.port === undefined && (this.#t.port = "");\n    }\n    #r(t, r) {\n      switch (this.#o) {\n        case 0:\n          break;\n        case 1:\n          this.#t.protocol = this.#c();\n          break;\n        case 2:\n          break;\n        case 3:\n          this.#t.username = this.#c();\n          break;\n        case 4:\n          this.#t.password = this.#c();\n          break;\n        case 5:\n          this.#t.hostname = this.#c();\n          break;\n        case 6:\n          this.#t.port = this.#c();\n          break;\n        case 7:\n          this.#t.pathname = this.#c();\n          break;\n        case 8:\n          this.#t.search = this.#c();\n          break;\n        case 9:\n          this.#t.hash = this.#c();\n          break;\n        case 10:\n          break;\n      }\n      this.#o !== 0 && t !== 10 && ([1, 2, 3, 4].includes(this.#o) && [6, 7, 8, 9].includes(t) && (this.#t.hostname ??= ""), [1, 2, 3, 4, 5, 6].includes(this.#o) && [8, 9].includes(t) && (this.#t.pathname ??= this.#g ? "/" : ""), [1, 2, 3, 4, 5, 6, 7].includes(this.#o) && t === 9 && (this.#t.search ??= "")), this.#R(t, r);\n    }\n    #R(t, r) {\n      this.#o = t, this.#l = this.#e + r, this.#e += r, this.#s = 0;\n    }\n    #b() {\n      this.#e = this.#l, this.#s = 0;\n    }\n    #u(t) {\n      this.#b(), this.#o = t;\n    }\n    #m(t) {\n      return t < 0 && (t = this.#n.length - t), t < this.#n.length ? this.#n[t] : this.#n[this.#n.length - 1];\n    }\n    #a(t, r) {\n      let n = this.#m(t);\n      return n.value === r && (n.type === "CHAR" || n.type === "ESCAPED_CHAR" || n.type === "INVALID_CHAR");\n    }\n    #P() {\n      return this.#a(this.#e, ":");\n    }\n    #E() {\n      return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");\n    }\n    #S() {\n      return this.#a(this.#e, "@");\n    }\n    #O() {\n      return this.#a(this.#e, ":");\n    }\n    #k() {\n      return this.#a(this.#e, ":");\n    }\n    #x() {\n      return this.#a(this.#e, "/");\n    }\n    #h() {\n      if (this.#a(this.#e, "?"))\n        return true;\n      if (this.#n[this.#e].value !== "?")\n        return false;\n      let t = this.#m(this.#e - 1);\n      return t.type !== "NAME" && t.type !== "REGEX" && t.type !== "CLOSE" && t.type !== "ASTERISK";\n    }\n    #f() {\n      return this.#a(this.#e, "#");\n    }\n    #T() {\n      return this.#n[this.#e].type == "OPEN";\n    }\n    #A() {\n      return this.#n[this.#e].type == "CLOSE";\n    }\n    #y() {\n      return this.#a(this.#e, "[");\n    }\n    #w() {\n      return this.#a(this.#e, "]");\n    }\n    #c() {\n      let t = this.#n[this.#e], r = this.#m(this.#l).index;\n      return this.#i.substring(r, t.index);\n    }\n    #C() {\n      let t = {};\n      Object.assign(t, b), t.encodePart = w;\n      let r = J(this.#c(), undefined, t);\n      this.#g = $(r);\n    }\n  };\n  a(C, "Parser");\n  var X = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];\n  var O = "*";\n  function xe(e, t) {\n    if (typeof e != "string")\n      throw new TypeError("parameter 1 is not of type \'string\'.");\n    let r = new URL(e, t);\n    return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== "" ? r.search.substring(1, r.search.length) : undefined, hash: r.hash !== "" ? r.hash.substring(1, r.hash.length) : undefined };\n  }\n  a(xe, "extractValues");\n  function R(e, t) {\n    return t ? I(e) : e;\n  }\n  a(R, "processBaseURLString");\n  function L(e, t, r) {\n    let n;\n    if (typeof t.baseURL == "string")\n      try {\n        n = new URL(t.baseURL), t.protocol === undefined && (e.protocol = R(n.protocol.substring(0, n.protocol.length - 1), r)), !r && t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.username === undefined && (e.username = R(n.username, r)), !r && t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.username === undefined && t.password === undefined && (e.password = R(n.password, r)), t.protocol === undefined && t.hostname === undefined && (e.hostname = R(n.hostname, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && (e.port = R(n.port, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && (e.pathname = R(n.pathname, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && t.search === undefined && (e.search = R(n.search.substring(1, n.search.length), r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && t.search === undefined && t.hash === undefined && (e.hash = R(n.hash.substring(1, n.hash.length), r));\n      } catch {\n        throw new TypeError(`invalid baseURL \'${t.baseURL}\'.`);\n      }\n    if (typeof t.protocol == "string" && (e.protocol = he(t.protocol, r)), typeof t.username == "string" && (e.username = ce(t.username, r)), typeof t.password == "string" && (e.password = oe(t.password, r)), typeof t.hostname == "string" && (e.hostname = ae(t.hostname, r)), typeof t.port == "string" && (e.port = fe(t.port, e.protocol, r)), typeof t.pathname == "string") {\n      if (e.pathname = t.pathname, n && !te(e.pathname, r)) {\n        let o = n.pathname.lastIndexOf("/");\n        o >= 0 && (e.pathname = R(n.pathname.substring(0, o + 1), r) + e.pathname);\n      }\n      e.pathname = le(e.pathname, e.protocol, r);\n    }\n    return typeof t.search == "string" && (e.search = ie(t.search, r)), typeof t.hash == "string" && (e.hash = se(t.hash, r)), e;\n  }\n  a(L, "applyInit");\n  function I(e) {\n    return e.replace(/([+*?:{}()\\\\])/g, "\\\\$1");\n  }\n  a(I, "escapePatternString");\n  function Ie(e) {\n    return e.replace(/([.+*?^${}()[\\]|/\\\\])/g, "\\\\$1");\n  }\n  a(Ie, "escapeRegexpString");\n  function Ne(e, t) {\n    t.delimiter ??= "/#?", t.prefixes ??= "./", t.sensitive ??= false, t.strict ??= false, t.end ??= true, t.start ??= true, t.endsWith = "";\n    let r = ".*", n = `[^${Ie(t.delimiter)}]+?`, o = /[$_\\u200C\\u200D\\p{ID_Continue}]/u, l = "";\n    for (let f = 0;f < e.length; ++f) {\n      let s = e[f];\n      if (s.type === 3) {\n        if (s.modifier === 3) {\n          l += I(s.value);\n          continue;\n        }\n        l += `{${I(s.value)}}${T(s.modifier)}`;\n        continue;\n      }\n      let i = s.hasCustomName(), c = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t.prefixes.includes(s.prefix)), h = f > 0 ? e[f - 1] : null, p = f < e.length - 1 ? e[f + 1] : null;\n      if (!c && i && s.type === 1 && s.modifier === 3 && p && !p.prefix.length && !p.suffix.length)\n        if (p.type === 3) {\n          let A = p.value.length > 0 ? p.value[0] : "";\n          c = o.test(A);\n        } else\n          c = !p.hasCustomName();\n      if (!c && !s.prefix.length && h && h.type === 3) {\n        let A = h.value[h.value.length - 1];\n        c = t.prefixes.includes(A);\n      }\n      c && (l += "{"), l += I(s.prefix), i && (l += `:${s.name}`), s.type === 2 ? l += `(${s.value})` : s.type === 1 ? i || (l += `(${n})`) : s.type === 0 && (!i && (!h || h.type === 3 || h.modifier !== 3 || c || s.prefix !== "") ? l += "*" : l += `(${r})`), s.type === 1 && i && s.suffix.length && o.test(s.suffix[0]) && (l += "\\\\"), l += I(s.suffix), c && (l += "}"), s.modifier !== 3 && (l += T(s.modifier));\n    }\n    return l;\n  }\n  a(Ne, "partsToPattern");\n  var M = class {\n    #i;\n    #n = {};\n    #t = {};\n    #e = {};\n    #s = {};\n    #l = false;\n    constructor(t = {}, r, n) {\n      try {\n        let o;\n        if (typeof r == "string" ? o = r : n = r, typeof t == "string") {\n          let i = new C(t);\n          if (i.parse(), t = i.result, o === undefined && typeof t.protocol != "string")\n            throw new TypeError("A base URL must be provided for a relative constructor string.");\n          t.baseURL = o;\n        } else {\n          if (!t || typeof t != "object")\n            throw new TypeError("parameter 1 is not of type \'string\' and cannot convert to dictionary.");\n          if (o)\n            throw new TypeError("parameter 1 is not of type \'string\'.");\n        }\n        typeof n > "u" && (n = { ignoreCase: false });\n        let l = { ignoreCase: n.ignoreCase === true }, f = { pathname: O, protocol: O, username: O, password: O, hostname: O, port: O, search: O, hash: O };\n        this.#i = L(f, t, true), K(this.#i.protocol) === this.#i.port && (this.#i.port = "");\n        let s;\n        for (s of X) {\n          if (!(s in this.#i))\n            continue;\n          let i = {}, c = this.#i[s];\n          switch (this.#t[s] = [], s) {\n            case "protocol":\n              Object.assign(i, b), i.encodePart = w;\n              break;\n            case "username":\n              Object.assign(i, b), i.encodePart = ue;\n              break;\n            case "password":\n              Object.assign(i, b), i.encodePart = de;\n              break;\n            case "hostname":\n              Object.assign(i, Q), j(c) ? i.encodePart = V : i.encodePart = G;\n              break;\n            case "port":\n              Object.assign(i, b), i.encodePart = Y;\n              break;\n            case "pathname":\n              $(this.#n.protocol) ? (Object.assign(i, ee, l), i.encodePart = pe) : (Object.assign(i, b, l), i.encodePart = ge);\n              break;\n            case "search":\n              Object.assign(i, b, l), i.encodePart = me;\n              break;\n            case "hash":\n              Object.assign(i, b, l), i.encodePart = Se;\n              break;\n          }\n          try {\n            this.#s[s] = _(c, i), this.#n[s] = z(this.#s[s], this.#t[s], i), this.#e[s] = Ne(this.#s[s], i), this.#l = this.#l || this.#s[s].some((h) => h.type === 2);\n          } catch {\n            throw new TypeError(`invalid ${s} pattern \'${this.#i[s]}\'.`);\n          }\n        }\n      } catch (o) {\n        throw new TypeError(`Failed to construct \'URLPattern\': ${o.message}`);\n      }\n    }\n    get [Symbol.toStringTag]() {\n      return "URLPattern";\n    }\n    test(t = {}, r) {\n      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };\n      if (typeof t != "string" && r)\n        throw new TypeError("parameter 1 is not of type \'string\'.");\n      if (typeof t > "u")\n        return false;\n      try {\n        typeof t == "object" ? n = L(n, t, false) : n = L(n, xe(t, r), false);\n      } catch {\n        return false;\n      }\n      let o;\n      for (o of X)\n        if (!this.#n[o].exec(n[o]))\n          return false;\n      return true;\n    }\n    exec(t = {}, r) {\n      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };\n      if (typeof t != "string" && r)\n        throw new TypeError("parameter 1 is not of type \'string\'.");\n      if (typeof t > "u")\n        return;\n      try {\n        typeof t == "object" ? n = L(n, t, false) : n = L(n, xe(t, r), false);\n      } catch {\n        return null;\n      }\n      let o = {};\n      r ? o.inputs = [t, r] : o.inputs = [t];\n      let l;\n      for (l of X) {\n        let f = this.#n[l].exec(n[l]);\n        if (!f)\n          return null;\n        let s = {};\n        for (let [i, c] of this.#t[l].entries())\n          if (typeof c == "string" || typeof c == "number") {\n            let h = f[i + 1];\n            s[c] = h;\n          }\n        o[l] = { input: n[l] ?? "", groups: s };\n      }\n      return o;\n    }\n    static compareComponent(t, r, n) {\n      let o = a((i, c) => {\n        for (let h of ["type", "modifier", "prefix", "value", "suffix"]) {\n          if (i[h] < c[h])\n            return -1;\n          if (i[h] === c[h])\n            continue;\n          return 1;\n        }\n        return 0;\n      }, "comparePart"), l = new P(3, "", "", "", "", 3), f = new P(0, "", "", "", "", 3), s = a((i, c) => {\n        let h = 0;\n        for (;h < Math.min(i.length, c.length); ++h) {\n          let p = o(i[h], c[h]);\n          if (p)\n            return p;\n        }\n        return i.length === c.length ? 0 : o(i[h] ?? l, c[h] ?? l);\n      }, "comparePartList");\n      return !r.#e[t] && !n.#e[t] ? 0 : r.#e[t] && !n.#e[t] ? s(r.#s[t], [f]) : !r.#e[t] && n.#e[t] ? s([f], n.#s[t]) : s(r.#s[t], n.#s[t]);\n    }\n    get protocol() {\n      return this.#e.protocol;\n    }\n    get username() {\n      return this.#e.username;\n    }\n    get password() {\n      return this.#e.password;\n    }\n    get hostname() {\n      return this.#e.hostname;\n    }\n    get port() {\n      return this.#e.port;\n    }\n    get pathname() {\n      return this.#e.pathname;\n    }\n    get search() {\n      return this.#e.search;\n    }\n    get hash() {\n      return this.#e.hash;\n    }\n    get hasRegExpGroups() {\n      return this.#l;\n    }\n  };\n  a(M, "URLPattern");\n});\n\n// ../../node_modules/urlpattern-polyfill/index.cjs\nvar require_urlpattern_polyfill = __commonJS((exports, module) => {\n  var { URLPattern } = require_urlpattern();\n  module.exports = { URLPattern };\n  if (!globalThis.URLPattern) {\n    globalThis.URLPattern = URLPattern;\n  }\n});\n\n// ../../node_modules/@whatwg-node/promise-helpers/cjs/index.js\nvar require_cjs = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.isPromise = isPromise2;\n  exports.isActualPromise = isActualPromise2;\n  exports.handleMaybePromise = handleMaybePromise2;\n  exports.fakePromise = fakePromise2;\n  exports.createDeferredPromise = createDeferredPromise2;\n  exports.iterateAsync = iterateAsync2;\n  exports.iterateAsyncVoid = iterateAsync2;\n  exports.fakeRejectPromise = fakeRejectPromise2;\n  exports.mapMaybePromise = mapMaybePromise;\n  exports.mapAsyncIterator = mapAsyncIterator;\n  exports.promiseLikeFinally = promiseLikeFinally2;\n  exports.unfakePromise = unfakePromise2;\n  var kFakePromise2 = Symbol.for("@whatwg-node/promise-helpers/FakePromise");\n  function isPromise2(value) {\n    return value?.then != null;\n  }\n  function isActualPromise2(value) {\n    const maybePromise = value;\n    return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;\n  }\n  function handleMaybePromise2(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {\n    let result$ = fakePromise2().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);\n    if (finallyFactory) {\n      result$ = result$.finally(finallyFactory);\n    }\n    return unfakePromise2(result$);\n  }\n  function fakePromise2(value) {\n    if (value && isActualPromise2(value)) {\n      return value;\n    }\n    if (isPromise2(value)) {\n      return {\n        then: (resolve, reject) => fakePromise2(value.then(resolve, reject)),\n        catch: (reject) => fakePromise2(value.then((res) => res, reject)),\n        finally: (cb) => fakePromise2(cb ? promiseLikeFinally2(value, cb) : value),\n        [Symbol.toStringTag]: "Promise"\n      };\n    }\n    return {\n      then(resolve) {\n        if (resolve) {\n          try {\n            return fakePromise2(resolve(value));\n          } catch (err) {\n            return fakeRejectPromise2(err);\n          }\n        }\n        return this;\n      },\n      catch() {\n        return this;\n      },\n      finally(cb) {\n        if (cb) {\n          try {\n            return fakePromise2(cb()).then(() => value, () => value);\n          } catch (err) {\n            return fakeRejectPromise2(err);\n          }\n        }\n        return this;\n      },\n      [Symbol.toStringTag]: "Promise",\n      __fakePromiseValue: value,\n      [kFakePromise2]: "resolved"\n    };\n  }\n  function createDeferredPromise2() {\n    if (Promise.withResolvers) {\n      return Promise.withResolvers();\n    }\n    let resolveFn;\n    let rejectFn;\n    const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {\n      resolveFn = resolve;\n      rejectFn = reject;\n    });\n    return {\n      promise,\n      get resolve() {\n        return resolveFn;\n      },\n      get reject() {\n        return rejectFn;\n      }\n    };\n  }\n  function iterateAsync2(iterable, callback, results) {\n    if (iterable?.length === 0) {\n      return;\n    }\n    const iterator = iterable[Symbol.iterator]();\n    let index = 0;\n    function iterate() {\n      const { done: endOfIterator, value } = iterator.next();\n      if (endOfIterator) {\n        return;\n      }\n      let endedEarly = false;\n      function endEarly() {\n        endedEarly = true;\n      }\n      return handleMaybePromise2(function handleCallback() {\n        return callback(value, endEarly, index++);\n      }, function handleCallbackResult(result) {\n        if (result) {\n          results?.push(result);\n        }\n        if (endedEarly) {\n          return;\n        }\n        return iterate();\n      });\n    }\n    return iterate();\n  }\n  function fakeRejectPromise2(error) {\n    return {\n      then(_resolve, reject) {\n        if (reject) {\n          try {\n            return fakePromise2(reject(error));\n          } catch (err) {\n            return fakeRejectPromise2(err);\n          }\n        }\n        return this;\n      },\n      catch(reject) {\n        if (reject) {\n          try {\n            return fakePromise2(reject(error));\n          } catch (err) {\n            return fakeRejectPromise2(err);\n          }\n        }\n        return this;\n      },\n      finally(cb) {\n        if (cb) {\n          try {\n            cb();\n          } catch (err) {\n            return fakeRejectPromise2(err);\n          }\n        }\n        return this;\n      },\n      __fakeRejectError: error,\n      [Symbol.toStringTag]: "Promise",\n      [kFakePromise2]: "rejected"\n    };\n  }\n  function mapMaybePromise(input, onSuccess, onError) {\n    return handleMaybePromise2(() => input, onSuccess, onError);\n  }\n  function mapAsyncIterator(iterator, onNext, onError, onEnd) {\n    if (Symbol.asyncIterator in iterator) {\n      iterator = iterator[Symbol.asyncIterator]();\n    }\n    let $return;\n    let abruptClose;\n    let onEndWithValue;\n    if (onEnd) {\n      let onEndWithValueResult;\n      onEndWithValue = (value) => {\n        onEndWithValueResult ||= handleMaybePromise2(onEnd, () => value, () => value);\n        return onEndWithValueResult;\n      };\n    }\n    if (typeof iterator.return === "function") {\n      $return = iterator.return;\n      abruptClose = (error) => {\n        const rethrow = () => {\n          throw error;\n        };\n        return $return.call(iterator).then(rethrow, rethrow);\n      };\n    }\n    function mapResult(result) {\n      if (result.done) {\n        return onEndWithValue ? onEndWithValue(result) : result;\n      }\n      return handleMaybePromise2(() => result.value, (value) => handleMaybePromise2(() => onNext(value), iteratorResult, abruptClose));\n    }\n    let mapReject;\n    if (onError) {\n      let onErrorResult;\n      const reject = onError;\n      mapReject = (error) => {\n        onErrorResult ||= handleMaybePromise2(() => error, (error2) => handleMaybePromise2(() => reject(error2), iteratorResult, abruptClose));\n        return onErrorResult;\n      };\n    }\n    return {\n      next() {\n        return iterator.next().then(mapResult, mapReject);\n      },\n      return() {\n        const res$ = $return ? $return.call(iterator).then(mapResult, mapReject) : fakePromise2({ value: undefined, done: true });\n        return onEndWithValue ? res$.then(onEndWithValue) : res$;\n      },\n      throw(error) {\n        if (typeof iterator.throw === "function") {\n          return iterator.throw(error).then(mapResult, mapReject);\n        }\n        if (abruptClose) {\n          return abruptClose(error);\n        }\n        return fakeRejectPromise2(error);\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      }\n    };\n  }\n  function iteratorResult(value) {\n    return { value, done: false };\n  }\n  function isFakePromise2(value) {\n    return value?.[kFakePromise2] === "resolved";\n  }\n  function isFakeRejectPromise2(value) {\n    return value?.[kFakePromise2] === "rejected";\n  }\n  function promiseLikeFinally2(value, onFinally) {\n    if ("finally" in value) {\n      return value.finally(onFinally);\n    }\n    return value.then((res) => {\n      const finallyRes = onFinally();\n      return isPromise2(finallyRes) ? finallyRes.then(() => res) : res;\n    }, (err) => {\n      const finallyRes = onFinally();\n      if (isPromise2(finallyRes)) {\n        return finallyRes.then(() => {\n          throw err;\n        });\n      } else {\n        throw err;\n      }\n    });\n  }\n  function unfakePromise2(promise) {\n    if (isFakePromise2(promise)) {\n      return promise.__fakePromiseValue;\n    }\n    if (isFakeRejectPromise2(promise)) {\n      throw promise.__fakeRejectError;\n    }\n    return promise;\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js\nvar require_sbmh = __commonJS((exports, module) => {\n  var { EventEmitter } = __require("node:events");\n  var { inherits } = __require("node:util");\n  function SBMH(needle) {\n    if (typeof needle === "string") {\n      needle = Buffer.from(needle);\n    }\n    if (!Buffer.isBuffer(needle)) {\n      throw new TypeError("The needle has to be a String or a Buffer.");\n    }\n    const needleLength = needle.length;\n    const needleLastCharIndex = needleLength - 1;\n    if (needleLength === 0) {\n      throw new Error("The needle cannot be an empty String/Buffer.");\n    }\n    if (needleLength > 256) {\n      throw new Error("The needle cannot have a length bigger than 256.");\n    }\n    this.maxMatches = Infinity;\n    this.matches = 0;\n    this._occ = new Uint8Array(256).fill(needleLength);\n    this._lookbehind_size = 0;\n    this._needle = needle;\n    this._bufpos = 0;\n    this._lookbehind = Buffer.alloc(needleLastCharIndex);\n    for (var i = 0;i < needleLastCharIndex; ++i) {\n      this._occ[needle[i]] = needleLastCharIndex - i;\n    }\n  }\n  inherits(SBMH, EventEmitter);\n  SBMH.prototype.reset = function() {\n    this._lookbehind_size = 0;\n    this.matches = 0;\n    this._bufpos = 0;\n  };\n  SBMH.prototype.push = function(chunk, pos) {\n    if (!Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, "binary");\n    }\n    const chlen = chunk.length;\n    this._bufpos = pos || 0;\n    let r;\n    while (r !== chlen && this.matches < this.maxMatches) {\n      r = this._sbmh_feed(chunk);\n    }\n    return r;\n  };\n  SBMH.prototype._sbmh_feed = function(data) {\n    const len = data.length;\n    const needle = this._needle;\n    const needleLength = needle.length;\n    const needleLastCharIndex = needleLength - 1;\n    const needleLastChar = needle[needleLastCharIndex];\n    let pos = -this._lookbehind_size;\n    let ch;\n    if (pos < 0) {\n      while (pos < 0 && pos <= len - needleLength) {\n        ch = data[pos + needleLastCharIndex];\n        if (ch === needleLastChar && this._sbmh_memcmp(data, pos, needleLastCharIndex)) {\n          this._lookbehind_size = 0;\n          ++this.matches;\n          this.emit("info", true);\n          return this._bufpos = pos + needleLength;\n        }\n        pos += this._occ[ch];\n      }\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {\n        ++pos;\n      }\n      if (pos >= 0) {\n        this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);\n        this._lookbehind_size = 0;\n      } else {\n        const bytesToCutOff = this._lookbehind_size + pos;\n        if (bytesToCutOff > 0) {\n          this.emit("info", false, this._lookbehind, 0, bytesToCutOff);\n        }\n        this._lookbehind_size -= bytesToCutOff;\n        this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size);\n        data.copy(this._lookbehind, this._lookbehind_size);\n        this._lookbehind_size += len;\n        this._bufpos = len;\n        return len;\n      }\n    }\n    pos = data.indexOf(needle, pos + this._bufpos);\n    if (pos !== -1) {\n      ++this.matches;\n      if (pos === 0) {\n        this.emit("info", true);\n      } else {\n        this.emit("info", true, data, this._bufpos, pos);\n      }\n      return this._bufpos = pos + needleLength;\n    }\n    pos = len - needleLastCharIndex;\n    if (pos < 0) {\n      pos = 0;\n    }\n    while (pos !== len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos + 1, len), needle.subarray(1, len - pos)) !== 0)) {\n      ++pos;\n    }\n    if (pos !== len) {\n      data.copy(this._lookbehind, 0, pos, len);\n      this._lookbehind_size = len - pos;\n    }\n    if (pos !== 0) {\n      this.emit("info", false, data, this._bufpos, pos);\n    }\n    this._bufpos = len;\n    return len;\n  };\n  SBMH.prototype._sbmh_lookup_char = function(data, pos) {\n    return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];\n  };\n  SBMH.prototype._sbmh_memcmp = function(data, pos, len) {\n    for (var i = 0;i < len; ++i) {\n      if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n  module.exports = SBMH;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js\nvar require_PartStream = __commonJS((exports, module) => {\n  var inherits = __require("node:util").inherits;\n  var ReadableStream2 = __require("node:stream").Readable;\n  function PartStream(opts) {\n    ReadableStream2.call(this, opts);\n  }\n  inherits(PartStream, ReadableStream2);\n  PartStream.prototype._read = function(n) {};\n  module.exports = PartStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/lib/utils/getLimit.js\nvar require_getLimit = __commonJS((exports, module) => {\n  module.exports = function getLimit(limits, name, defaultLimit) {\n    if (!limits || limits[name] === undefined || limits[name] === null) {\n      return defaultLimit;\n    }\n    if (typeof limits[name] !== "number" || isNaN(limits[name])) {\n      throw new TypeError("Limit " + name + " is not a valid number");\n    }\n    return limits[name];\n  };\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js\nvar require_HeaderParser = __commonJS((exports, module) => {\n  var EventEmitter = __require("node:events").EventEmitter;\n  var inherits = __require("node:util").inherits;\n  var getLimit = require_getLimit();\n  var StreamSearch = require_sbmh();\n  var B_DCRLF = Buffer.from(`\\r\n\\r\n`);\n  var RE_CRLF = /\\r\\n/g;\n  var RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/;\n  function HeaderParser(cfg) {\n    EventEmitter.call(this);\n    cfg = cfg || {};\n    const self2 = this;\n    this.nread = 0;\n    this.maxed = false;\n    this.npairs = 0;\n    this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2000);\n    this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);\n    this.buffer = "";\n    this.header = {};\n    this.finished = false;\n    this.ss = new StreamSearch(B_DCRLF);\n    this.ss.on("info", function(isMatch, data, start, end) {\n      if (data && !self2.maxed) {\n        if (self2.nread + end - start >= self2.maxHeaderSize) {\n          end = self2.maxHeaderSize - self2.nread + start;\n          self2.nread = self2.maxHeaderSize;\n          self2.maxed = true;\n        } else {\n          self2.nread += end - start;\n        }\n        self2.buffer += data.toString("binary", start, end);\n      }\n      if (isMatch) {\n        self2._finish();\n      }\n    });\n  }\n  inherits(HeaderParser, EventEmitter);\n  HeaderParser.prototype.push = function(data) {\n    const r = this.ss.push(data);\n    if (this.finished) {\n      return r;\n    }\n  };\n  HeaderParser.prototype.reset = function() {\n    this.finished = false;\n    this.buffer = "";\n    this.header = {};\n    this.ss.reset();\n  };\n  HeaderParser.prototype._finish = function() {\n    if (this.buffer) {\n      this._parseHeader();\n    }\n    this.ss.matches = this.ss.maxMatches;\n    const header = this.header;\n    this.header = {};\n    this.buffer = "";\n    this.finished = true;\n    this.nread = this.npairs = 0;\n    this.maxed = false;\n    this.emit("header", header);\n  };\n  HeaderParser.prototype._parseHeader = function() {\n    if (this.npairs === this.maxHeaderPairs) {\n      return;\n    }\n    const lines = this.buffer.split(RE_CRLF);\n    const len = lines.length;\n    let m, h;\n    for (var i = 0;i < len; ++i) {\n      if (lines[i].length === 0) {\n        continue;\n      }\n      if (lines[i][0] === "\\t" || lines[i][0] === " ") {\n        if (h) {\n          this.header[h][this.header[h].length - 1] += lines[i];\n          continue;\n        }\n      }\n      const posColon = lines[i].indexOf(":");\n      if (posColon === -1 || posColon === 0) {\n        return;\n      }\n      m = RE_HDR.exec(lines[i]);\n      h = m[1].toLowerCase();\n      this.header[h] = this.header[h] || [];\n      this.header[h].push(m[2] || "");\n      if (++this.npairs === this.maxHeaderPairs) {\n        break;\n      }\n    }\n  };\n  module.exports = HeaderParser;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js\nvar require_Dicer = __commonJS((exports, module) => {\n  var WritableStream2 = __require("node:stream").Writable;\n  var inherits = __require("node:util").inherits;\n  var StreamSearch = require_sbmh();\n  var PartStream = require_PartStream();\n  var HeaderParser = require_HeaderParser();\n  var DASH = 45;\n  var B_ONEDASH = Buffer.from("-");\n  var B_CRLF = Buffer.from(`\\r\n`);\n  var EMPTY_FN = function() {};\n  function Dicer(cfg) {\n    if (!(this instanceof Dicer)) {\n      return new Dicer(cfg);\n    }\n    WritableStream2.call(this, cfg);\n    if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {\n      throw new TypeError("Boundary required");\n    }\n    if (typeof cfg.boundary === "string") {\n      this.setBoundary(cfg.boundary);\n    } else {\n      this._bparser = undefined;\n    }\n    this._headerFirst = cfg.headerFirst;\n    this._dashes = 0;\n    this._parts = 0;\n    this._finished = false;\n    this._realFinish = false;\n    this._isPreamble = true;\n    this._justMatched = false;\n    this._firstWrite = true;\n    this._inHeader = true;\n    this._part = undefined;\n    this._cb = undefined;\n    this._ignoreData = false;\n    this._partOpts = { highWaterMark: cfg.partHwm };\n    this._pause = false;\n    const self2 = this;\n    this._hparser = new HeaderParser(cfg);\n    this._hparser.on("header", function(header) {\n      self2._inHeader = false;\n      self2._part.emit("header", header);\n    });\n  }\n  inherits(Dicer, WritableStream2);\n  Dicer.prototype.emit = function(ev) {\n    if (ev === "finish" && !this._realFinish) {\n      if (!this._finished) {\n        const self2 = this;\n        process.nextTick(function() {\n          self2.emit("error", new Error("Unexpected end of multipart data"));\n          if (self2._part && !self2._ignoreData) {\n            const type = self2._isPreamble ? "Preamble" : "Part";\n            self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));\n            self2._part.push(null);\n            process.nextTick(function() {\n              self2._realFinish = true;\n              self2.emit("finish");\n              self2._realFinish = false;\n            });\n            return;\n          }\n          self2._realFinish = true;\n          self2.emit("finish");\n          self2._realFinish = false;\n        });\n      }\n    } else {\n      WritableStream2.prototype.emit.apply(this, arguments);\n    }\n  };\n  Dicer.prototype._write = function(data, encoding, cb) {\n    if (!this._hparser && !this._bparser) {\n      return cb();\n    }\n    if (this._headerFirst && this._isPreamble) {\n      if (!this._part) {\n        this._part = new PartStream(this._partOpts);\n        if (this.listenerCount("preamble") !== 0) {\n          this.emit("preamble", this._part);\n        } else {\n          this._ignore();\n        }\n      }\n      const r = this._hparser.push(data);\n      if (!this._inHeader && r !== undefined && r < data.length) {\n        data = data.slice(r);\n      } else {\n        return cb();\n      }\n    }\n    if (this._firstWrite) {\n      this._bparser.push(B_CRLF);\n      this._firstWrite = false;\n    }\n    this._bparser.push(data);\n    if (this._pause) {\n      this._cb = cb;\n    } else {\n      cb();\n    }\n  };\n  Dicer.prototype.reset = function() {\n    this._part = undefined;\n    this._bparser = undefined;\n    this._hparser = undefined;\n  };\n  Dicer.prototype.setBoundary = function(boundary) {\n    const self2 = this;\n    this._bparser = new StreamSearch(`\\r\n--` + boundary);\n    this._bparser.on("info", function(isMatch, data, start, end) {\n      self2._oninfo(isMatch, data, start, end);\n    });\n  };\n  Dicer.prototype._ignore = function() {\n    if (this._part && !this._ignoreData) {\n      this._ignoreData = true;\n      this._part.on("error", EMPTY_FN);\n      this._part.resume();\n    }\n  };\n  Dicer.prototype._oninfo = function(isMatch, data, start, end) {\n    let buf;\n    const self2 = this;\n    let i = 0;\n    let r;\n    let shouldWriteMore = true;\n    if (!this._part && this._justMatched && data) {\n      while (this._dashes < 2 && start + i < end) {\n        if (data[start + i] === DASH) {\n          ++i;\n          ++this._dashes;\n        } else {\n          if (this._dashes) {\n            buf = B_ONEDASH;\n          }\n          this._dashes = 0;\n          break;\n        }\n      }\n      if (this._dashes === 2) {\n        if (start + i < end && this.listenerCount("trailer") !== 0) {\n          this.emit("trailer", data.slice(start + i, end));\n        }\n        this.reset();\n        this._finished = true;\n        if (self2._parts === 0) {\n          self2._realFinish = true;\n          self2.emit("finish");\n          self2._realFinish = false;\n        }\n      }\n      if (this._dashes) {\n        return;\n      }\n    }\n    if (this._justMatched) {\n      this._justMatched = false;\n    }\n    if (!this._part) {\n      this._part = new PartStream(this._partOpts);\n      this._part._read = function(n) {\n        self2._unpause();\n      };\n      if (this._isPreamble && this.listenerCount("preamble") !== 0) {\n        this.emit("preamble", this._part);\n      } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {\n        this.emit("part", this._part);\n      } else {\n        this._ignore();\n      }\n      if (!this._isPreamble) {\n        this._inHeader = true;\n      }\n    }\n    if (data && start < end && !this._ignoreData) {\n      if (this._isPreamble || !this._inHeader) {\n        if (buf) {\n          shouldWriteMore = this._part.push(buf);\n        }\n        shouldWriteMore = this._part.push(data.slice(start, end));\n        if (!shouldWriteMore) {\n          this._pause = true;\n        }\n      } else if (!this._isPreamble && this._inHeader) {\n        if (buf) {\n          this._hparser.push(buf);\n        }\n        r = this._hparser.push(data.slice(start, end));\n        if (!this._inHeader && r !== undefined && r < end) {\n          this._oninfo(false, data, start + r, end);\n        }\n      }\n    }\n    if (isMatch) {\n      this._hparser.reset();\n      if (this._isPreamble) {\n        this._isPreamble = false;\n      } else {\n        if (start !== end) {\n          ++this._parts;\n          this._part.on("end", function() {\n            if (--self2._parts === 0) {\n              if (self2._finished) {\n                self2._realFinish = true;\n                self2.emit("finish");\n                self2._realFinish = false;\n              } else {\n                self2._unpause();\n              }\n            }\n          });\n        }\n      }\n      this._part.push(null);\n      this._part = undefined;\n      this._ignoreData = false;\n      this._justMatched = true;\n      this._dashes = 0;\n    }\n  };\n  Dicer.prototype._unpause = function() {\n    if (!this._pause) {\n      return;\n    }\n    this._pause = false;\n    if (this._cb) {\n      const cb = this._cb;\n      this._cb = undefined;\n      cb();\n    }\n  };\n  module.exports = Dicer;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/lib/utils/decodeText.js\nvar require_decodeText = __commonJS((exports, module) => {\n  var utf8Decoder = new TextDecoder("utf-8");\n  var textDecoders = new Map([\n    ["utf-8", utf8Decoder],\n    ["utf8", utf8Decoder]\n  ]);\n  function getDecoder(charset) {\n    let lc;\n    while (true) {\n      switch (charset) {\n        case "utf-8":\n        case "utf8":\n          return decoders.utf8;\n        case "latin1":\n        case "ascii":\n        case "us-ascii":\n        case "iso-8859-1":\n        case "iso8859-1":\n        case "iso88591":\n        case "iso_8859-1":\n        case "windows-1252":\n        case "iso_8859-1:1987":\n        case "cp1252":\n        case "x-cp1252":\n          return decoders.latin1;\n        case "utf16le":\n        case "utf-16le":\n        case "ucs2":\n        case "ucs-2":\n          return decoders.utf16le;\n        case "base64":\n          return decoders.base64;\n        default:\n          if (lc === undefined) {\n            lc = true;\n            charset = charset.toLowerCase();\n            continue;\n          }\n          return decoders.other.bind(charset);\n      }\n    }\n  }\n  var decoders = {\n    utf8: (data, sourceEncoding) => {\n      if (data.length === 0) {\n        return "";\n      }\n      if (typeof data === "string") {\n        data = Buffer.from(data, sourceEncoding);\n      }\n      return data.utf8Slice(0, data.length);\n    },\n    latin1: (data, sourceEncoding) => {\n      if (data.length === 0) {\n        return "";\n      }\n      if (typeof data === "string") {\n        return data;\n      }\n      return data.latin1Slice(0, data.length);\n    },\n    utf16le: (data, sourceEncoding) => {\n      if (data.length === 0) {\n        return "";\n      }\n      if (typeof data === "string") {\n        data = Buffer.from(data, sourceEncoding);\n      }\n      return data.ucs2Slice(0, data.length);\n    },\n    base64: (data, sourceEncoding) => {\n      if (data.length === 0) {\n        return "";\n      }\n      if (typeof data === "string") {\n        data = Buffer.from(data, sourceEncoding);\n      }\n      return data.base64Slice(0, data.length);\n    },\n    other: (data, sourceEncoding) => {\n      if (data.length === 0) {\n        return "";\n      }\n      if (typeof data === "string") {\n        data = Buffer.from(data, sourceEncoding);\n      }\n      if (textDecoders.has(exports.toString())) {\n        try {\n          return textDecoders.get(exports).decode(data);\n        } catch {}\n      }\n      return typeof data === "string" ? data : data.toString();\n    }\n  };\n  function decodeText(text, sourceEncoding, destEncoding) {\n    if (text) {\n      return getDecoder(destEncoding)(text, sourceEncoding);\n    }\n    return text;\n  }\n  module.exports = decodeText;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/lib/utils/parseParams.js\nvar require_parseParams = __commonJS((exports, module) => {\n  var decodeText = require_decodeText();\n  var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;\n  var EncodedLookup = {\n    "%00": "\\x00",\n    "%01": "\\x01",\n    "%02": "\\x02",\n    "%03": "\\x03",\n    "%04": "\\x04",\n    "%05": "\\x05",\n    "%06": "\\x06",\n    "%07": "\\x07",\n    "%08": "\\b",\n    "%09": "\\t",\n    "%0a": `\n`,\n    "%0A": `\n`,\n    "%0b": "\\v",\n    "%0B": "\\v",\n    "%0c": "\\f",\n    "%0C": "\\f",\n    "%0d": "\\r",\n    "%0D": "\\r",\n    "%0e": "\\x0E",\n    "%0E": "\\x0E",\n    "%0f": "\\x0F",\n    "%0F": "\\x0F",\n    "%10": "\\x10",\n    "%11": "\\x11",\n    "%12": "\\x12",\n    "%13": "\\x13",\n    "%14": "\\x14",\n    "%15": "\\x15",\n    "%16": "\\x16",\n    "%17": "\\x17",\n    "%18": "\\x18",\n    "%19": "\\x19",\n    "%1a": "\\x1A",\n    "%1A": "\\x1A",\n    "%1b": "\\x1B",\n    "%1B": "\\x1B",\n    "%1c": "\\x1C",\n    "%1C": "\\x1C",\n    "%1d": "\\x1D",\n    "%1D": "\\x1D",\n    "%1e": "\\x1E",\n    "%1E": "\\x1E",\n    "%1f": "\\x1F",\n    "%1F": "\\x1F",\n    "%20": " ",\n    "%21": "!",\n    "%22": \'"\',\n    "%23": "#",\n    "%24": "$",\n    "%25": "%",\n    "%26": "&",\n    "%27": "\'",\n    "%28": "(",\n    "%29": ")",\n    "%2a": "*",\n    "%2A": "*",\n    "%2b": "+",\n    "%2B": "+",\n    "%2c": ",",\n    "%2C": ",",\n    "%2d": "-",\n    "%2D": "-",\n    "%2e": ".",\n    "%2E": ".",\n    "%2f": "/",\n    "%2F": "/",\n    "%30": "0",\n    "%31": "1",\n    "%32": "2",\n    "%33": "3",\n    "%34": "4",\n    "%35": "5",\n    "%36": "6",\n    "%37": "7",\n    "%38": "8",\n    "%39": "9",\n    "%3a": ":",\n    "%3A": ":",\n    "%3b": ";",\n    "%3B": ";",\n    "%3c": "<",\n    "%3C": "<",\n    "%3d": "=",\n    "%3D": "=",\n    "%3e": ">",\n    "%3E": ">",\n    "%3f": "?",\n    "%3F": "?",\n    "%40": "@",\n    "%41": "A",\n    "%42": "B",\n    "%43": "C",\n    "%44": "D",\n    "%45": "E",\n    "%46": "F",\n    "%47": "G",\n    "%48": "H",\n    "%49": "I",\n    "%4a": "J",\n    "%4A": "J",\n    "%4b": "K",\n    "%4B": "K",\n    "%4c": "L",\n    "%4C": "L",\n    "%4d": "M",\n    "%4D": "M",\n    "%4e": "N",\n    "%4E": "N",\n    "%4f": "O",\n    "%4F": "O",\n    "%50": "P",\n    "%51": "Q",\n    "%52": "R",\n    "%53": "S",\n    "%54": "T",\n    "%55": "U",\n    "%56": "V",\n    "%57": "W",\n    "%58": "X",\n    "%59": "Y",\n    "%5a": "Z",\n    "%5A": "Z",\n    "%5b": "[",\n    "%5B": "[",\n    "%5c": "\\\\",\n    "%5C": "\\\\",\n    "%5d": "]",\n    "%5D": "]",\n    "%5e": "^",\n    "%5E": "^",\n    "%5f": "_",\n    "%5F": "_",\n    "%60": "`",\n    "%61": "a",\n    "%62": "b",\n    "%63": "c",\n    "%64": "d",\n    "%65": "e",\n    "%66": "f",\n    "%67": "g",\n    "%68": "h",\n    "%69": "i",\n    "%6a": "j",\n    "%6A": "j",\n    "%6b": "k",\n    "%6B": "k",\n    "%6c": "l",\n    "%6C": "l",\n    "%6d": "m",\n    "%6D": "m",\n    "%6e": "n",\n    "%6E": "n",\n    "%6f": "o",\n    "%6F": "o",\n    "%70": "p",\n    "%71": "q",\n    "%72": "r",\n    "%73": "s",\n    "%74": "t",\n    "%75": "u",\n    "%76": "v",\n    "%77": "w",\n    "%78": "x",\n    "%79": "y",\n    "%7a": "z",\n    "%7A": "z",\n    "%7b": "{",\n    "%7B": "{",\n    "%7c": "|",\n    "%7C": "|",\n    "%7d": "}",\n    "%7D": "}",\n    "%7e": "~",\n    "%7E": "~",\n    "%7f": "",\n    "%7F": "",\n    "%80": "",\n    "%81": "",\n    "%82": "",\n    "%83": "",\n    "%84": "",\n    "%85": "",\n    "%86": "",\n    "%87": "",\n    "%88": "",\n    "%89": "",\n    "%8a": "",\n    "%8A": "",\n    "%8b": "",\n    "%8B": "",\n    "%8c": "",\n    "%8C": "",\n    "%8d": "",\n    "%8D": "",\n    "%8e": "",\n    "%8E": "",\n    "%8f": "",\n    "%8F": "",\n    "%90": "",\n    "%91": "",\n    "%92": "",\n    "%93": "",\n    "%94": "",\n    "%95": "",\n    "%96": "",\n    "%97": "",\n    "%98": "",\n    "%99": "",\n    "%9a": "",\n    "%9A": "",\n    "%9b": "",\n    "%9B": "",\n    "%9c": "",\n    "%9C": "",\n    "%9d": "",\n    "%9D": "",\n    "%9e": "",\n    "%9E": "",\n    "%9f": "",\n    "%9F": "",\n    "%a0": "",\n    "%A0": "",\n    "%a1": "",\n    "%A1": "",\n    "%a2": "",\n    "%A2": "",\n    "%a3": "",\n    "%A3": "",\n    "%a4": "",\n    "%A4": "",\n    "%a5": "",\n    "%A5": "",\n    "%a6": "",\n    "%A6": "",\n    "%a7": "",\n    "%A7": "",\n    "%a8": "",\n    "%A8": "",\n    "%a9": "",\n    "%A9": "",\n    "%aa": "",\n    "%Aa": "",\n    "%aA": "",\n    "%AA": "",\n    "%ab": "",\n    "%Ab": "",\n    "%aB": "",\n    "%AB": "",\n    "%ac": "",\n    "%Ac": "",\n    "%aC": "",\n    "%AC": "",\n    "%ad": "",\n    "%Ad": "",\n    "%aD": "",\n    "%AD": "",\n    "%ae": "",\n    "%Ae": "",\n    "%aE": "",\n    "%AE": "",\n    "%af": "",\n    "%Af": "",\n    "%aF": "",\n    "%AF": "",\n    "%b0": "",\n    "%B0": "",\n    "%b1": "",\n    "%B1": "",\n    "%b2": "",\n    "%B2": "",\n    "%b3": "",\n    "%B3": "",\n    "%b4": "",\n    "%B4": "",\n    "%b5": "",\n    "%B5": "",\n    "%b6": "",\n    "%B6": "",\n    "%b7": "",\n    "%B7": "",\n    "%b8": "",\n    "%B8": "",\n    "%b9": "",\n    "%B9": "",\n    "%ba": "",\n    "%Ba": "",\n    "%bA": "",\n    "%BA": "",\n    "%bb": "",\n    "%Bb": "",\n    "%bB": "",\n    "%BB": "",\n    "%bc": "",\n    "%Bc": "",\n    "%bC": "",\n    "%BC": "",\n    "%bd": "",\n    "%Bd": "",\n    "%bD": "",\n    "%BD": "",\n    "%be": "",\n    "%Be": "",\n    "%bE": "",\n    "%BE": "",\n    "%bf": "",\n    "%Bf": "",\n    "%bF": "",\n    "%BF": "",\n    "%c0": "",\n    "%C0": "",\n    "%c1": "",\n    "%C1": "",\n    "%c2": "",\n    "%C2": "",\n    "%c3": "",\n    "%C3": "",\n    "%c4": "",\n    "%C4": "",\n    "%c5": "",\n    "%C5": "",\n    "%c6": "",\n    "%C6": "",\n    "%c7": "",\n    "%C7": "",\n    "%c8": "",\n    "%C8": "",\n    "%c9": "",\n    "%C9": "",\n    "%ca": "",\n    "%Ca": "",\n    "%cA": "",\n    "%CA": "",\n    "%cb": "",\n    "%Cb": "",\n    "%cB": "",\n    "%CB": "",\n    "%cc": "",\n    "%Cc": "",\n    "%cC": "",\n    "%CC": "",\n    "%cd": "",\n    "%Cd": "",\n    "%cD": "",\n    "%CD": "",\n    "%ce": "",\n    "%Ce": "",\n    "%cE": "",\n    "%CE": "",\n    "%cf": "",\n    "%Cf": "",\n    "%cF": "",\n    "%CF": "",\n    "%d0": "",\n    "%D0": "",\n    "%d1": "",\n    "%D1": "",\n    "%d2": "",\n    "%D2": "",\n    "%d3": "",\n    "%D3": "",\n    "%d4": "",\n    "%D4": "",\n    "%d5": "",\n    "%D5": "",\n    "%d6": "",\n    "%D6": "",\n    "%d7": "",\n    "%D7": "",\n    "%d8": "",\n    "%D8": "",\n    "%d9": "",\n    "%D9": "",\n    "%da": "",\n    "%Da": "",\n    "%dA": "",\n    "%DA": "",\n    "%db": "",\n    "%Db": "",\n    "%dB": "",\n    "%DB": "",\n    "%dc": "",\n    "%Dc": "",\n    "%dC": "",\n    "%DC": "",\n    "%dd": "",\n    "%Dd": "",\n    "%dD": "",\n    "%DD": "",\n    "%de": "",\n    "%De": "",\n    "%dE": "",\n    "%DE": "",\n    "%df": "",\n    "%Df": "",\n    "%dF": "",\n    "%DF": "",\n    "%e0": "",\n    "%E0": "",\n    "%e1": "",\n    "%E1": "",\n    "%e2": "",\n    "%E2": "",\n    "%e3": "",\n    "%E3": "",\n    "%e4": "",\n    "%E4": "",\n    "%e5": "",\n    "%E5": "",\n    "%e6": "",\n    "%E6": "",\n    "%e7": "",\n    "%E7": "",\n    "%e8": "",\n    "%E8": "",\n    "%e9": "",\n    "%E9": "",\n    "%ea": "",\n    "%Ea": "",\n    "%eA": "",\n    "%EA": "",\n    "%eb": "",\n    "%Eb": "",\n    "%eB": "",\n    "%EB": "",\n    "%ec": "",\n    "%Ec": "",\n    "%eC": "",\n    "%EC": "",\n    "%ed": "",\n    "%Ed": "",\n    "%eD": "",\n    "%ED": "",\n    "%ee": "",\n    "%Ee": "",\n    "%eE": "",\n    "%EE": "",\n    "%ef": "",\n    "%Ef": "",\n    "%eF": "",\n    "%EF": "",\n    "%f0": "",\n    "%F0": "",\n    "%f1": "",\n    "%F1": "",\n    "%f2": "",\n    "%F2": "",\n    "%f3": "",\n    "%F3": "",\n    "%f4": "",\n    "%F4": "",\n    "%f5": "",\n    "%F5": "",\n    "%f6": "",\n    "%F6": "",\n    "%f7": "",\n    "%F7": "",\n    "%f8": "",\n    "%F8": "",\n    "%f9": "",\n    "%F9": "",\n    "%fa": "",\n    "%Fa": "",\n    "%fA": "",\n    "%FA": "",\n    "%fb": "",\n    "%Fb": "",\n    "%fB": "",\n    "%FB": "",\n    "%fc": "",\n    "%Fc": "",\n    "%fC": "",\n    "%FC": "",\n    "%fd": "",\n    "%Fd": "",\n    "%fD": "",\n    "%FD": "",\n    "%fe": "",\n    "%Fe": "",\n    "%fE": "",\n    "%FE": "",\n    "%ff": "",\n    "%Ff": "",\n    "%fF": "",\n    "%FF": ""\n  };\n  function encodedReplacer(match) {\n    return EncodedLookup[match];\n  }\n  var STATE_KEY = 0;\n  var STATE_VALUE = 1;\n  var STATE_CHARSET = 2;\n  var STATE_LANG = 3;\n  function parseParams(str) {\n    const res = [];\n    let state = STATE_KEY;\n    let charset = "";\n    let inquote = false;\n    let escaping = false;\n    let p = 0;\n    let tmp = "";\n    const len = str.length;\n    for (var i = 0;i < len; ++i) {\n      const char = str[i];\n      if (char === "\\\\" && inquote) {\n        if (escaping) {\n          escaping = false;\n        } else {\n          escaping = true;\n          continue;\n        }\n      } else if (char === \'"\') {\n        if (!escaping) {\n          if (inquote) {\n            inquote = false;\n            state = STATE_KEY;\n            while (i + 1 < len && str[i + 1] !== ";") {\n              ++i;\n            }\n          } else {\n            inquote = true;\n          }\n          continue;\n        } else {\n          escaping = false;\n        }\n      } else {\n        if (escaping && inquote) {\n          tmp += "\\\\";\n        }\n        escaping = false;\n        if ((state === STATE_CHARSET || state === STATE_LANG) && char === "\'") {\n          if (state === STATE_CHARSET) {\n            state = STATE_LANG;\n            charset = tmp.substring(1);\n          } else {\n            state = STATE_VALUE;\n          }\n          tmp = "";\n          continue;\n        } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {\n          state = char === "*" ? STATE_CHARSET : STATE_VALUE;\n          res[p] = [tmp, undefined];\n          tmp = "";\n          continue;\n        } else if (!inquote && char === ";") {\n          state = STATE_KEY;\n          if (charset) {\n            if (tmp.length) {\n              tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);\n            }\n            charset = "";\n          } else if (tmp.length) {\n            tmp = decodeText(tmp, "binary", "utf8");\n          }\n          if (res[p] === undefined) {\n            res[p] = tmp;\n          } else {\n            res[p][1] = tmp;\n          }\n          tmp = "";\n          ++p;\n          continue;\n        } else if (!inquote && (char === " " || char === "\\t")) {\n          continue;\n        }\n      }\n      tmp += char;\n    }\n    if (charset && tmp.length) {\n      tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);\n    } else if (tmp) {\n      tmp = decodeText(tmp, "binary", "utf8");\n    }\n    if (res[p] === undefined) {\n      if (tmp) {\n        res[p] = tmp;\n      }\n    } else {\n      res[p][1] = tmp;\n    }\n    return res;\n  }\n  module.exports = parseParams;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/lib/utils/basename.js\nvar require_basename = __commonJS((exports, module) => {\n  module.exports = function basename(path) {\n    if (typeof path !== "string") {\n      return "";\n    }\n    for (var i = path.length - 1;i >= 0; --i) {\n      switch (path.charCodeAt(i)) {\n        case 47:\n        case 92:\n          path = path.slice(i + 1);\n          return path === ".." || path === "." ? "" : path;\n      }\n    }\n    return path === ".." || path === "." ? "" : path;\n  };\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/lib/types/multipart.js\nvar require_multipart = __commonJS((exports, module) => {\n  var { Readable } = __require("node:stream");\n  var { inherits } = __require("node:util");\n  var Dicer = require_Dicer();\n  var parseParams = require_parseParams();\n  var decodeText = require_decodeText();\n  var basename = require_basename();\n  var getLimit = require_getLimit();\n  var RE_BOUNDARY = /^boundary$/i;\n  var RE_FIELD = /^form-data$/i;\n  var RE_CHARSET = /^charset$/i;\n  var RE_FILENAME = /^filename$/i;\n  var RE_NAME = /^name$/i;\n  Multipart.detect = /^multipart\\/form-data/i;\n  function Multipart(boy, cfg) {\n    let i;\n    let len;\n    const self2 = this;\n    let boundary;\n    const limits = cfg.limits;\n    const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== undefined);\n    const parsedConType = cfg.parsedConType || [];\n    const defCharset = cfg.defCharset || "utf8";\n    const preservePath = cfg.preservePath;\n    const fileOpts = { highWaterMark: cfg.fileHwm };\n    for (i = 0, len = parsedConType.length;i < len; ++i) {\n      if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {\n        boundary = parsedConType[i][1];\n        break;\n      }\n    }\n    function checkFinished() {\n      if (nends === 0 && finished && !boy._done) {\n        finished = false;\n        self2.end();\n      }\n    }\n    if (typeof boundary !== "string") {\n      throw new Error("Multipart: Boundary not found");\n    }\n    const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);\n    const fileSizeLimit = getLimit(limits, "fileSize", Infinity);\n    const filesLimit = getLimit(limits, "files", Infinity);\n    const fieldsLimit = getLimit(limits, "fields", Infinity);\n    const partsLimit = getLimit(limits, "parts", Infinity);\n    const headerPairsLimit = getLimit(limits, "headerPairs", 2000);\n    const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);\n    let nfiles = 0;\n    let nfields = 0;\n    let nends = 0;\n    let curFile;\n    let curField;\n    let finished = false;\n    this._needDrain = false;\n    this._pause = false;\n    this._cb = undefined;\n    this._nparts = 0;\n    this._boy = boy;\n    const parserCfg = {\n      boundary,\n      maxHeaderPairs: headerPairsLimit,\n      maxHeaderSize: headerSizeLimit,\n      partHwm: fileOpts.highWaterMark,\n      highWaterMark: cfg.highWaterMark\n    };\n    this.parser = new Dicer(parserCfg);\n    this.parser.on("drain", function() {\n      self2._needDrain = false;\n      if (self2._cb && !self2._pause) {\n        const cb = self2._cb;\n        self2._cb = undefined;\n        cb();\n      }\n    }).on("part", function onPart(part) {\n      if (++self2._nparts > partsLimit) {\n        self2.parser.removeListener("part", onPart);\n        self2.parser.on("part", skipPart);\n        boy.hitPartsLimit = true;\n        boy.emit("partsLimit");\n        return skipPart(part);\n      }\n      if (curField) {\n        const field = curField;\n        field.emit("end");\n        field.removeAllListeners("end");\n      }\n      part.on("header", function(header) {\n        let contype;\n        let fieldname;\n        let parsed;\n        let charset;\n        let encoding;\n        let filename;\n        let nsize = 0;\n        if (header["content-type"]) {\n          parsed = parseParams(header["content-type"][0]);\n          if (parsed[0]) {\n            contype = parsed[0].toLowerCase();\n            for (i = 0, len = parsed.length;i < len; ++i) {\n              if (RE_CHARSET.test(parsed[i][0])) {\n                charset = parsed[i][1].toLowerCase();\n                break;\n              }\n            }\n          }\n        }\n        if (contype === undefined) {\n          contype = "text/plain";\n        }\n        if (charset === undefined) {\n          charset = defCharset;\n        }\n        if (header["content-disposition"]) {\n          parsed = parseParams(header["content-disposition"][0]);\n          if (!RE_FIELD.test(parsed[0])) {\n            return skipPart(part);\n          }\n          for (i = 0, len = parsed.length;i < len; ++i) {\n            if (RE_NAME.test(parsed[i][0])) {\n              fieldname = parsed[i][1];\n            } else if (RE_FILENAME.test(parsed[i][0])) {\n              filename = parsed[i][1];\n              if (!preservePath) {\n                filename = basename(filename);\n              }\n            }\n          }\n        } else {\n          return skipPart(part);\n        }\n        if (header["content-transfer-encoding"]) {\n          encoding = header["content-transfer-encoding"][0].toLowerCase();\n        } else {\n          encoding = "7bit";\n        }\n        let onData, onEnd;\n        if (isPartAFile(fieldname, contype, filename)) {\n          if (nfiles === filesLimit) {\n            if (!boy.hitFilesLimit) {\n              boy.hitFilesLimit = true;\n              boy.emit("filesLimit");\n            }\n            return skipPart(part);\n          }\n          ++nfiles;\n          if (boy.listenerCount("file") === 0) {\n            self2.parser._ignore();\n            return;\n          }\n          ++nends;\n          const file = new FileStream(fileOpts);\n          curFile = file;\n          file.on("end", function() {\n            --nends;\n            self2._pause = false;\n            checkFinished();\n            if (self2._cb && !self2._needDrain) {\n              const cb = self2._cb;\n              self2._cb = undefined;\n              cb();\n            }\n          });\n          file._read = function(n) {\n            if (!self2._pause) {\n              return;\n            }\n            self2._pause = false;\n            if (self2._cb && !self2._needDrain) {\n              const cb = self2._cb;\n              self2._cb = undefined;\n              cb();\n            }\n          };\n          boy.emit("file", fieldname, file, filename, encoding, contype);\n          onData = function(data) {\n            if ((nsize += data.length) > fileSizeLimit) {\n              const extralen = fileSizeLimit - nsize + data.length;\n              if (extralen > 0) {\n                file.push(data.slice(0, extralen));\n              }\n              file.truncated = true;\n              file.bytesRead = fileSizeLimit;\n              part.removeAllListeners("data");\n              file.emit("limit");\n              return;\n            } else if (!file.push(data)) {\n              self2._pause = true;\n            }\n            file.bytesRead = nsize;\n          };\n          onEnd = function() {\n            curFile = undefined;\n            file.push(null);\n          };\n        } else {\n          if (nfields === fieldsLimit) {\n            if (!boy.hitFieldsLimit) {\n              boy.hitFieldsLimit = true;\n              boy.emit("fieldsLimit");\n            }\n            return skipPart(part);\n          }\n          ++nfields;\n          ++nends;\n          let buffer = "";\n          let truncated = false;\n          curField = part;\n          onData = function(data) {\n            if ((nsize += data.length) > fieldSizeLimit) {\n              const extralen = fieldSizeLimit - (nsize - data.length);\n              buffer += data.toString("binary", 0, extralen);\n              truncated = true;\n              part.removeAllListeners("data");\n            } else {\n              buffer += data.toString("binary");\n            }\n          };\n          onEnd = function() {\n            curField = undefined;\n            if (buffer.length) {\n              buffer = decodeText(buffer, "binary", charset);\n            }\n            boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);\n            --nends;\n            checkFinished();\n          };\n        }\n        part._readableState.sync = false;\n        part.on("data", onData);\n        part.on("end", onEnd);\n      }).on("error", function(err) {\n        if (curFile) {\n          curFile.emit("error", err);\n        }\n      });\n    }).on("error", function(err) {\n      boy.emit("error", err);\n    }).on("finish", function() {\n      finished = true;\n      checkFinished();\n    });\n  }\n  Multipart.prototype.write = function(chunk, cb) {\n    const r = this.parser.write(chunk);\n    if (r && !this._pause) {\n      cb();\n    } else {\n      this._needDrain = !r;\n      this._cb = cb;\n    }\n  };\n  Multipart.prototype.end = function() {\n    const self2 = this;\n    if (self2.parser.writable) {\n      self2.parser.end();\n    } else if (!self2._boy._done) {\n      process.nextTick(function() {\n        self2._boy._done = true;\n        self2._boy.emit("finish");\n      });\n    }\n  };\n  function skipPart(part) {\n    part.resume();\n  }\n  function FileStream(opts) {\n    Readable.call(this, opts);\n    this.bytesRead = 0;\n    this.truncated = false;\n  }\n  inherits(FileStream, Readable);\n  FileStream.prototype._read = function(n) {};\n  module.exports = Multipart;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/lib/utils/Decoder.js\nvar require_Decoder = __commonJS((exports, module) => {\n  var RE_PLUS = /\\+/g;\n  var HEX = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  ];\n  function Decoder() {\n    this.buffer = undefined;\n  }\n  Decoder.prototype.write = function(str) {\n    str = str.replace(RE_PLUS, " ");\n    let res = "";\n    let i = 0;\n    let p = 0;\n    const len = str.length;\n    for (;i < len; ++i) {\n      if (this.buffer !== undefined) {\n        if (!HEX[str.charCodeAt(i)]) {\n          res += "%" + this.buffer;\n          this.buffer = undefined;\n          --i;\n        } else {\n          this.buffer += str[i];\n          ++p;\n          if (this.buffer.length === 2) {\n            res += String.fromCharCode(parseInt(this.buffer, 16));\n            this.buffer = undefined;\n          }\n        }\n      } else if (str[i] === "%") {\n        if (i > p) {\n          res += str.substring(p, i);\n          p = i;\n        }\n        this.buffer = "";\n        ++p;\n      }\n    }\n    if (p < len && this.buffer === undefined) {\n      res += str.substring(p);\n    }\n    return res;\n  };\n  Decoder.prototype.reset = function() {\n    this.buffer = undefined;\n  };\n  module.exports = Decoder;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/lib/types/urlencoded.js\nvar require_urlencoded = __commonJS((exports, module) => {\n  var Decoder = require_Decoder();\n  var decodeText = require_decodeText();\n  var getLimit = require_getLimit();\n  var RE_CHARSET = /^charset$/i;\n  UrlEncoded.detect = /^application\\/x-www-form-urlencoded/i;\n  function UrlEncoded(boy, cfg) {\n    const limits = cfg.limits;\n    const parsedConType = cfg.parsedConType;\n    this.boy = boy;\n    this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);\n    this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);\n    this.fieldsLimit = getLimit(limits, "fields", Infinity);\n    let charset;\n    for (var i = 0, len = parsedConType.length;i < len; ++i) {\n      if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {\n        charset = parsedConType[i][1].toLowerCase();\n        break;\n      }\n    }\n    if (charset === undefined) {\n      charset = cfg.defCharset || "utf8";\n    }\n    this.decoder = new Decoder;\n    this.charset = charset;\n    this._fields = 0;\n    this._state = "key";\n    this._checkingBytes = true;\n    this._bytesKey = 0;\n    this._bytesVal = 0;\n    this._key = "";\n    this._val = "";\n    this._keyTrunc = false;\n    this._valTrunc = false;\n    this._hitLimit = false;\n  }\n  UrlEncoded.prototype.write = function(data, cb) {\n    if (this._fields === this.fieldsLimit) {\n      if (!this.boy.hitFieldsLimit) {\n        this.boy.hitFieldsLimit = true;\n        this.boy.emit("fieldsLimit");\n      }\n      return cb();\n    }\n    let idxeq;\n    let idxamp;\n    let i;\n    let p = 0;\n    const len = data.length;\n    while (p < len) {\n      if (this._state === "key") {\n        idxeq = idxamp = undefined;\n        for (i = p;i < len; ++i) {\n          if (!this._checkingBytes) {\n            ++p;\n          }\n          if (data[i] === 61) {\n            idxeq = i;\n            break;\n          } else if (data[i] === 38) {\n            idxamp = i;\n            break;\n          }\n          if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {\n            this._hitLimit = true;\n            break;\n          } else if (this._checkingBytes) {\n            ++this._bytesKey;\n          }\n        }\n        if (idxeq !== undefined) {\n          if (idxeq > p) {\n            this._key += this.decoder.write(data.toString("binary", p, idxeq));\n          }\n          this._state = "val";\n          this._hitLimit = false;\n          this._checkingBytes = true;\n          this._val = "";\n          this._bytesVal = 0;\n          this._valTrunc = false;\n          this.decoder.reset();\n          p = idxeq + 1;\n        } else if (idxamp !== undefined) {\n          ++this._fields;\n          let key;\n          const keyTrunc = this._keyTrunc;\n          if (idxamp > p) {\n            key = this._key += this.decoder.write(data.toString("binary", p, idxamp));\n          } else {\n            key = this._key;\n          }\n          this._hitLimit = false;\n          this._checkingBytes = true;\n          this._key = "";\n          this._bytesKey = 0;\n          this._keyTrunc = false;\n          this.decoder.reset();\n          if (key.length) {\n            this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, false);\n          }\n          p = idxamp + 1;\n          if (this._fields === this.fieldsLimit) {\n            return cb();\n          }\n        } else if (this._hitLimit) {\n          if (i > p) {\n            this._key += this.decoder.write(data.toString("binary", p, i));\n          }\n          p = i;\n          if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {\n            this._checkingBytes = false;\n            this._keyTrunc = true;\n          }\n        } else {\n          if (p < len) {\n            this._key += this.decoder.write(data.toString("binary", p));\n          }\n          p = len;\n        }\n      } else {\n        idxamp = undefined;\n        for (i = p;i < len; ++i) {\n          if (!this._checkingBytes) {\n            ++p;\n          }\n          if (data[i] === 38) {\n            idxamp = i;\n            break;\n          }\n          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {\n            this._hitLimit = true;\n            break;\n          } else if (this._checkingBytes) {\n            ++this._bytesVal;\n          }\n        }\n        if (idxamp !== undefined) {\n          ++this._fields;\n          if (idxamp > p) {\n            this._val += this.decoder.write(data.toString("binary", p, idxamp));\n          }\n          this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);\n          this._state = "key";\n          this._hitLimit = false;\n          this._checkingBytes = true;\n          this._key = "";\n          this._bytesKey = 0;\n          this._keyTrunc = false;\n          this.decoder.reset();\n          p = idxamp + 1;\n          if (this._fields === this.fieldsLimit) {\n            return cb();\n          }\n        } else if (this._hitLimit) {\n          if (i > p) {\n            this._val += this.decoder.write(data.toString("binary", p, i));\n          }\n          p = i;\n          if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {\n            this._checkingBytes = false;\n            this._valTrunc = true;\n          }\n        } else {\n          if (p < len) {\n            this._val += this.decoder.write(data.toString("binary", p));\n          }\n          p = len;\n        }\n      }\n    }\n    cb();\n  };\n  UrlEncoded.prototype.end = function() {\n    if (this.boy._done) {\n      return;\n    }\n    if (this._state === "key" && this._key.length > 0) {\n      this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, false);\n    } else if (this._state === "val") {\n      this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);\n    }\n    this.boy._done = true;\n    this.boy.emit("finish");\n  };\n  module.exports = UrlEncoded;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/node_modules/@fastify/busboy/lib/main.js\nvar require_main = __commonJS((exports, module) => {\n  var WritableStream2 = __require("node:stream").Writable;\n  var { inherits } = __require("node:util");\n  var Dicer = require_Dicer();\n  var MultipartParser = require_multipart();\n  var UrlencodedParser = require_urlencoded();\n  var parseParams = require_parseParams();\n  function Busboy(opts) {\n    if (!(this instanceof Busboy)) {\n      return new Busboy(opts);\n    }\n    if (typeof opts !== "object") {\n      throw new TypeError("Busboy expected an options-Object.");\n    }\n    if (typeof opts.headers !== "object") {\n      throw new TypeError("Busboy expected an options-Object with headers-attribute.");\n    }\n    if (typeof opts.headers["content-type"] !== "string") {\n      throw new TypeError("Missing Content-Type-header.");\n    }\n    const {\n      headers,\n      ...streamOptions\n    } = opts;\n    this.opts = {\n      autoDestroy: false,\n      ...streamOptions\n    };\n    WritableStream2.call(this, this.opts);\n    this._done = false;\n    this._parser = this.getParserByHeaders(headers);\n    this._finished = false;\n  }\n  inherits(Busboy, WritableStream2);\n  Busboy.prototype.emit = function(ev) {\n    if (ev === "finish") {\n      if (!this._done) {\n        this._parser?.end();\n        return;\n      } else if (this._finished) {\n        return;\n      }\n      this._finished = true;\n    }\n    WritableStream2.prototype.emit.apply(this, arguments);\n  };\n  Busboy.prototype.getParserByHeaders = function(headers) {\n    const parsed = parseParams(headers["content-type"]);\n    const cfg = {\n      defCharset: this.opts.defCharset,\n      fileHwm: this.opts.fileHwm,\n      headers,\n      highWaterMark: this.opts.highWaterMark,\n      isPartAFile: this.opts.isPartAFile,\n      limits: this.opts.limits,\n      parsedConType: parsed,\n      preservePath: this.opts.preservePath\n    };\n    if (MultipartParser.detect.test(parsed[0])) {\n      return new MultipartParser(this, cfg);\n    }\n    if (UrlencodedParser.detect.test(parsed[0])) {\n      return new UrlencodedParser(this, cfg);\n    }\n    throw new Error("Unsupported Content-Type.");\n  };\n  Busboy.prototype._write = function(chunk, encoding, cb) {\n    this._parser.write(chunk, cb);\n  };\n  module.exports = Busboy;\n  module.exports.default = Busboy;\n  module.exports.Busboy = Busboy;\n  module.exports.Dicer = Dicer;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/utils.js\nvar require_utils = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.fakePromise = undefined;\n  exports.getHeadersObj = getHeadersObj;\n  exports.defaultHeadersSerializer = defaultHeadersSerializer;\n  exports.isArrayBufferView = isArrayBufferView;\n  exports.isNodeReadable = isNodeReadable;\n  exports.isIterable = isIterable;\n  exports.shouldRedirect = shouldRedirect;\n  exports.pipeThrough = pipeThrough;\n  exports.endStream = endStream;\n  exports.safeWrite = safeWrite;\n  var node_events_1 = __require("node:events");\n  function isHeadersInstance(obj) {\n    return obj?.forEach != null;\n  }\n  function getHeadersObj(headers) {\n    if (headers == null || !isHeadersInstance(headers)) {\n      return headers;\n    }\n    if (headers.headersInit && !headers._map && !isHeadersInstance(headers.headersInit)) {\n      return headers.headersInit;\n    }\n    return Object.fromEntries(headers.entries());\n  }\n  function defaultHeadersSerializer(headers, onContentLength) {\n    const headerArray = [];\n    headers.forEach((value, key) => {\n      if (onContentLength && key === "content-length") {\n        onContentLength(value);\n      }\n      headerArray.push(`${key}: ${value}`);\n    });\n    return headerArray;\n  }\n  var promise_helpers_1 = require_cjs();\n  Object.defineProperty(exports, "fakePromise", { enumerable: true, get: function() {\n    return promise_helpers_1.fakePromise;\n  } });\n  function isArrayBufferView(obj) {\n    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;\n  }\n  function isNodeReadable(obj) {\n    return obj != null && obj.pipe != null;\n  }\n  function isIterable(value) {\n    return value?.[Symbol.iterator] != null;\n  }\n  function shouldRedirect(status) {\n    return status === 301 || status === 302 || status === 303 || status === 307 || status === 308;\n  }\n  function pipeThrough({ src, dest, signal, onError }) {\n    if (onError) {\n      dest.once("error", onError);\n    }\n    src.once("error", (e) => {\n      dest.destroy(e);\n    });\n    dest.once("close", () => {\n      if (!src.destroyed) {\n        src.destroy();\n      }\n    });\n    if (signal) {\n      let cleanup = function() {\n        signalRef.deref()?.removeEventListener("abort", onAbort);\n        srcRef.deref()?.removeListener("end", cleanup);\n        srcRef.deref()?.removeListener("error", cleanup);\n        srcRef.deref()?.removeListener("close", cleanup);\n      }, onAbort = function() {\n        srcRef.deref()?.destroy(new AbortError);\n        cleanup();\n      };\n      const srcRef = new WeakRef(src);\n      const signalRef = new WeakRef(signal);\n      signal.addEventListener("abort", onAbort, { once: true });\n      src.once("end", cleanup);\n      src.once("error", cleanup);\n      src.once("close", cleanup);\n    }\n    src.pipe(dest, { end: true });\n  }\n  function endStream(stream) {\n    return stream.end(null, null, null);\n  }\n  function safeWrite(chunk, stream) {\n    const result = stream.write(chunk);\n    if (!result) {\n      return (0, node_events_1.once)(stream, "drain");\n    }\n  }\n\n  class AbortError extends Error {\n    constructor(message = "The operation was aborted", options = undefined) {\n      super(message, options);\n      this.name = "AbortError";\n    }\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js\nvar require_ReadableStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillReadableStream = undefined;\n  var node_buffer_1 = __require("node:buffer");\n  var node_events_1 = __require("node:events");\n  var node_stream_1 = __require("node:stream");\n  var promises_1 = __require("node:stream/promises");\n  var promise_helpers_1 = require_cjs();\n  var utils_js_1 = require_utils();\n  function createController(desiredSize, readable) {\n    let chunks = [];\n    let _closed = false;\n    let flushed = false;\n    return {\n      desiredSize,\n      enqueue(chunk) {\n        const buf = typeof chunk === "string" ? node_buffer_1.Buffer.from(chunk) : chunk;\n        if (!flushed) {\n          chunks.push(buf);\n        } else {\n          readable.push(buf);\n        }\n      },\n      close() {\n        if (chunks.length > 0) {\n          this._flush();\n        }\n        readable.push(null);\n        _closed = true;\n      },\n      error(error) {\n        if (chunks.length > 0) {\n          this._flush();\n        }\n        readable.destroy(error);\n      },\n      get _closed() {\n        return _closed;\n      },\n      _flush() {\n        flushed = true;\n        if (chunks.length > 0) {\n          const concatenated = chunks.length > 1 ? node_buffer_1.Buffer.concat(chunks) : chunks[0];\n          readable.push(concatenated);\n          chunks = [];\n        }\n      }\n    };\n  }\n  function isNodeReadable(obj) {\n    return obj?.read != null;\n  }\n  function isReadableStream(obj) {\n    return obj?.getReader != null;\n  }\n\n  class PonyfillReadableStream {\n    readable;\n    constructor(underlyingSource) {\n      if (underlyingSource instanceof PonyfillReadableStream && underlyingSource.readable != null) {\n        this.readable = underlyingSource.readable;\n      } else if (isNodeReadable(underlyingSource)) {\n        this.readable = underlyingSource;\n      } else if (isReadableStream(underlyingSource)) {\n        this.readable = node_stream_1.Readable.fromWeb(underlyingSource);\n      } else {\n        let started = false;\n        let ongoing = false;\n        const handleStart = (desiredSize) => {\n          if (!started) {\n            const controller = createController(desiredSize, this.readable);\n            started = true;\n            return (0, promise_helpers_1.handleMaybePromise)(() => underlyingSource?.start?.(controller), () => {\n              controller._flush();\n              if (controller._closed) {\n                return false;\n              }\n              return true;\n            });\n          }\n          return true;\n        };\n        const readImpl = (desiredSize) => {\n          return (0, promise_helpers_1.handleMaybePromise)(() => handleStart(desiredSize), (shouldContinue) => {\n            if (!shouldContinue) {\n              return;\n            }\n            const controller = createController(desiredSize, this.readable);\n            return (0, promise_helpers_1.handleMaybePromise)(() => underlyingSource?.pull?.(controller), () => {\n              controller._flush();\n              ongoing = false;\n            });\n          });\n        };\n        this.readable = new node_stream_1.Readable({\n          read(desiredSize) {\n            if (ongoing) {\n              return;\n            }\n            ongoing = true;\n            return readImpl(desiredSize);\n          },\n          destroy(err, callback) {\n            if (underlyingSource?.cancel) {\n              try {\n                const res$ = underlyingSource.cancel(err);\n                if (res$?.then) {\n                  return res$.then(() => {\n                    callback(null);\n                  }, (err2) => {\n                    callback(err2);\n                  });\n                }\n              } catch (err2) {\n                callback(err2);\n                return;\n              }\n            }\n            callback(null);\n          }\n        });\n      }\n    }\n    cancel(reason) {\n      this.readable.destroy(reason);\n      return (0, node_events_1.once)(this.readable, "close");\n    }\n    locked = false;\n    getReader(_options) {\n      const iterator = this.readable[Symbol.asyncIterator]();\n      this.locked = true;\n      const thisReadable = this.readable;\n      return {\n        read() {\n          return iterator.next();\n        },\n        releaseLock: () => {\n          if (iterator.return) {\n            const retResult$ = iterator.return();\n            if (retResult$.then) {\n              retResult$.then(() => {\n                this.locked = false;\n              });\n              return;\n            }\n          }\n          this.locked = false;\n        },\n        cancel: (reason) => {\n          if (iterator.return) {\n            const retResult$ = iterator.return(reason);\n            if (retResult$.then) {\n              return retResult$.then(() => {\n                this.locked = false;\n              });\n            }\n          }\n          this.locked = false;\n          return (0, utils_js_1.fakePromise)();\n        },\n        get closed() {\n          return Promise.race([\n            (0, node_events_1.once)(thisReadable, "end"),\n            (0, node_events_1.once)(thisReadable, "error").then((err) => Promise.reject(err))\n          ]);\n        }\n      };\n    }\n    [Symbol.asyncIterator]() {\n      const iterator = this.readable[Symbol.asyncIterator]();\n      return {\n        [Symbol.asyncIterator]() {\n          return this;\n        },\n        next: () => iterator.next(),\n        return: () => {\n          if (!this.readable.destroyed) {\n            this.readable.destroy();\n          }\n          return iterator.return?.() || (0, utils_js_1.fakePromise)({ done: true, value: undefined });\n        },\n        throw: (err) => {\n          if (!this.readable.destroyed) {\n            this.readable.destroy(err);\n          }\n          return iterator.throw?.(err) || (0, utils_js_1.fakePromise)({ done: true, value: undefined });\n        }\n      };\n    }\n    tee() {\n      throw new Error("Not implemented");\n    }\n    async pipeToWriter(writer) {\n      try {\n        for await (const chunk of this) {\n          await writer.write(chunk);\n        }\n        await writer.close();\n      } catch (err) {\n        await writer.abort(err);\n      }\n    }\n    pipeTo(destination) {\n      if (isPonyfillWritableStream(destination)) {\n        return (0, promises_1.pipeline)(this.readable, destination.writable, {\n          end: true\n        });\n      } else {\n        const writer = destination.getWriter();\n        return this.pipeToWriter(writer);\n      }\n    }\n    pipeThrough({ writable, readable }) {\n      this.pipeTo(writable).catch((err) => {\n        this.readable.destroy(err);\n      });\n      if (isPonyfillReadableStream(readable)) {\n        readable.readable.once("error", (err) => this.readable.destroy(err));\n        readable.readable.once("finish", () => this.readable.push(null));\n        readable.readable.once("close", () => this.readable.push(null));\n      }\n      return readable;\n    }\n    static [Symbol.hasInstance](instance) {\n      return isReadableStream(instance);\n    }\n    static from(iterable) {\n      return new PonyfillReadableStream(node_stream_1.Readable.from(iterable));\n    }\n    [Symbol.toStringTag] = "ReadableStream";\n  }\n  exports.PonyfillReadableStream = PonyfillReadableStream;\n  function isPonyfillReadableStream(obj) {\n    return obj?.readable != null;\n  }\n  function isPonyfillWritableStream(obj) {\n    return obj?.writable != null;\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/Blob.js\nvar require_Blob = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillBlob = undefined;\n  exports.hasBufferMethod = hasBufferMethod;\n  exports.hasArrayBufferMethod = hasArrayBufferMethod;\n  exports.hasBytesMethod = hasBytesMethod;\n  exports.hasTextMethod = hasTextMethod;\n  exports.hasSizeProperty = hasSizeProperty;\n  exports.hasStreamMethod = hasStreamMethod;\n  exports.hasBlobSignature = hasBlobSignature;\n  exports.isArrayBuffer = isArrayBuffer;\n  var node_buffer_1 = __require("node:buffer");\n  var ReadableStream_js_1 = require_ReadableStream();\n  var utils_js_1 = require_utils();\n  function getBlobPartAsBuffer(blobPart) {\n    if (typeof blobPart === "string") {\n      return node_buffer_1.Buffer.from(blobPart);\n    } else if (node_buffer_1.Buffer.isBuffer(blobPart)) {\n      return blobPart;\n    } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {\n      return node_buffer_1.Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);\n    } else {\n      return node_buffer_1.Buffer.from(blobPart);\n    }\n  }\n  function hasBufferMethod(obj) {\n    return obj != null && obj.buffer != null && typeof obj.buffer === "function";\n  }\n  function hasArrayBufferMethod(obj) {\n    return obj != null && obj.arrayBuffer != null && typeof obj.arrayBuffer === "function";\n  }\n  function hasBytesMethod(obj) {\n    return obj != null && obj.bytes != null && typeof obj.bytes === "function";\n  }\n  function hasTextMethod(obj) {\n    return obj != null && obj.text != null && typeof obj.text === "function";\n  }\n  function hasSizeProperty(obj) {\n    return obj != null && typeof obj.size === "number";\n  }\n  function hasStreamMethod(obj) {\n    return obj != null && obj.stream != null && typeof obj.stream === "function";\n  }\n  function hasBlobSignature(obj) {\n    return obj != null && obj[Symbol.toStringTag] === "Blob";\n  }\n  function isArrayBuffer(obj) {\n    return obj != null && obj.byteLength != null && obj.slice != null;\n  }\n\n  class PonyfillBlob {\n    blobParts;\n    type;\n    encoding;\n    _size = null;\n    constructor(blobParts = [], options) {\n      this.blobParts = blobParts;\n      this.type = options?.type || "application/octet-stream";\n      this.encoding = options?.encoding || "utf8";\n      this._size = options?.size || null;\n      if (blobParts.length === 1 && hasBlobSignature(blobParts[0])) {\n        return blobParts[0];\n      }\n    }\n    _buffer = null;\n    buffer() {\n      if (this._buffer) {\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      if (this.blobParts.length === 1) {\n        const blobPart = this.blobParts[0];\n        if (hasBufferMethod(blobPart)) {\n          return blobPart.buffer().then((buf) => {\n            this._buffer = buf;\n            return this._buffer;\n          });\n        }\n        if (hasBytesMethod(blobPart)) {\n          return blobPart.bytes().then((bytes) => {\n            this._buffer = node_buffer_1.Buffer.from(bytes);\n            return this._buffer;\n          });\n        }\n        if (hasArrayBufferMethod(blobPart)) {\n          return blobPart.arrayBuffer().then((arrayBuf) => {\n            this._buffer = node_buffer_1.Buffer.from(arrayBuf, undefined, blobPart.size);\n            return this._buffer;\n          });\n        }\n        this._buffer = getBlobPartAsBuffer(blobPart);\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      const jobs = [];\n      const bufferChunks = this.blobParts.map((blobPart, i) => {\n        if (hasBufferMethod(blobPart)) {\n          jobs.push(blobPart.buffer().then((buf) => {\n            bufferChunks[i] = buf;\n          }));\n          return;\n        } else if (hasArrayBufferMethod(blobPart)) {\n          jobs.push(blobPart.arrayBuffer().then((arrayBuf) => {\n            bufferChunks[i] = node_buffer_1.Buffer.from(arrayBuf, undefined, blobPart.size);\n          }));\n          return;\n        } else if (hasBytesMethod(blobPart)) {\n          jobs.push(blobPart.bytes().then((bytes) => {\n            bufferChunks[i] = node_buffer_1.Buffer.from(bytes);\n          }));\n          return;\n        } else {\n          return getBlobPartAsBuffer(blobPart);\n        }\n      });\n      if (jobs.length > 0) {\n        return Promise.all(jobs).then(() => node_buffer_1.Buffer.concat(bufferChunks, this._size || undefined));\n      }\n      return (0, utils_js_1.fakePromise)(node_buffer_1.Buffer.concat(bufferChunks, this._size || undefined));\n    }\n    arrayBuffer() {\n      if (this._buffer) {\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      if (this.blobParts.length === 1) {\n        if (isArrayBuffer(this.blobParts[0])) {\n          return (0, utils_js_1.fakePromise)(this.blobParts[0]);\n        }\n        if (hasArrayBufferMethod(this.blobParts[0])) {\n          return this.blobParts[0].arrayBuffer();\n        }\n      }\n      return this.buffer();\n    }\n    bytes() {\n      if (this._buffer) {\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      if (this.blobParts.length === 1) {\n        if (node_buffer_1.Buffer.isBuffer(this.blobParts[0])) {\n          this._buffer = this.blobParts[0];\n          return (0, utils_js_1.fakePromise)(this._buffer);\n        }\n        if (this.blobParts[0] instanceof Uint8Array) {\n          this._buffer = node_buffer_1.Buffer.from(this.blobParts[0]);\n          return (0, utils_js_1.fakePromise)(this._buffer);\n        }\n        if (hasBytesMethod(this.blobParts[0])) {\n          return this.blobParts[0].bytes();\n        }\n        if (hasBufferMethod(this.blobParts[0])) {\n          return this.blobParts[0].buffer();\n        }\n      }\n      return this.buffer();\n    }\n    _text = null;\n    text() {\n      if (this._text) {\n        return (0, utils_js_1.fakePromise)(this._text);\n      }\n      if (this.blobParts.length === 1) {\n        const blobPart = this.blobParts[0];\n        if (typeof blobPart === "string") {\n          this._text = blobPart;\n          return (0, utils_js_1.fakePromise)(this._text);\n        }\n        if (hasTextMethod(blobPart)) {\n          return blobPart.text().then((text) => {\n            this._text = text;\n            return this._text;\n          });\n        }\n        const buf = getBlobPartAsBuffer(blobPart);\n        this._text = buf.toString(this.encoding);\n        return (0, utils_js_1.fakePromise)(this._text);\n      }\n      return this.buffer().then((buf) => {\n        this._text = buf.toString(this.encoding);\n        return this._text;\n      });\n    }\n    _json = null;\n    json() {\n      if (this._json) {\n        return (0, utils_js_1.fakePromise)(this._json);\n      }\n      return this.text().then((text) => {\n        this._json = JSON.parse(text);\n        return this._json;\n      });\n    }\n    _formData = null;\n    formData() {\n      if (this._formData) {\n        return (0, utils_js_1.fakePromise)(this._formData);\n      }\n      throw new Error("Not implemented");\n    }\n    get size() {\n      if (this._size == null) {\n        this._size = 0;\n        for (const blobPart of this.blobParts) {\n          if (typeof blobPart === "string") {\n            this._size += node_buffer_1.Buffer.byteLength(blobPart);\n          } else if (hasSizeProperty(blobPart)) {\n            this._size += blobPart.size;\n          } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {\n            this._size += blobPart.byteLength;\n          }\n        }\n      }\n      return this._size;\n    }\n    stream() {\n      if (this.blobParts.length === 1) {\n        const blobPart = this.blobParts[0];\n        if (hasStreamMethod(blobPart)) {\n          return blobPart.stream();\n        }\n        const buf = getBlobPartAsBuffer(blobPart);\n        return new ReadableStream_js_1.PonyfillReadableStream({\n          start: (controller) => {\n            controller.enqueue(buf);\n            controller.close();\n          }\n        });\n      }\n      if (this._buffer != null) {\n        return new ReadableStream_js_1.PonyfillReadableStream({\n          start: (controller) => {\n            controller.enqueue(this._buffer);\n            controller.close();\n          }\n        });\n      }\n      let blobPartIterator;\n      return new ReadableStream_js_1.PonyfillReadableStream({\n        start: (controller) => {\n          if (this.blobParts.length === 0) {\n            controller.close();\n            return;\n          }\n          blobPartIterator = this.blobParts[Symbol.iterator]();\n        },\n        pull: (controller) => {\n          const { value: blobPart, done } = blobPartIterator.next();\n          if (done) {\n            controller.close();\n            return;\n          }\n          if (blobPart) {\n            if (hasBufferMethod(blobPart)) {\n              return blobPart.buffer().then((buf2) => {\n                controller.enqueue(buf2);\n              });\n            }\n            if (hasBytesMethod(blobPart)) {\n              return blobPart.bytes().then((bytes) => {\n                const buf2 = node_buffer_1.Buffer.from(bytes);\n                controller.enqueue(buf2);\n              });\n            }\n            if (hasArrayBufferMethod(blobPart)) {\n              return blobPart.arrayBuffer().then((arrayBuffer) => {\n                const buf2 = node_buffer_1.Buffer.from(arrayBuffer, undefined, blobPart.size);\n                controller.enqueue(buf2);\n              });\n            }\n            const buf = getBlobPartAsBuffer(blobPart);\n            controller.enqueue(buf);\n          }\n        }\n      });\n    }\n    slice() {\n      throw new Error("Not implemented");\n    }\n  }\n  exports.PonyfillBlob = PonyfillBlob;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/File.js\nvar require_File = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillFile = undefined;\n  var Blob_js_1 = require_Blob();\n\n  class PonyfillFile extends Blob_js_1.PonyfillBlob {\n    name;\n    lastModified;\n    constructor(fileBits, name, options) {\n      super(fileBits, options);\n      this.name = name;\n      this.lastModified = options?.lastModified || Date.now();\n    }\n    webkitRelativePath = "";\n  }\n  exports.PonyfillFile = PonyfillFile;\n});\n\n// ../../node_modules/tslib/tslib.js\nvar require_tslib = __commonJS((exports, module) => {\n  var __extends;\n  var __assign;\n  var __rest;\n  var __decorate;\n  var __param;\n  var __esDecorate;\n  var __runInitializers;\n  var __propKey;\n  var __setFunctionName;\n  var __metadata;\n  var __awaiter;\n  var __generator;\n  var __exportStar;\n  var __values;\n  var __read;\n  var __spread;\n  var __spreadArrays;\n  var __spreadArray;\n  var __await;\n  var __asyncGenerator;\n  var __asyncDelegator;\n  var __asyncValues;\n  var __makeTemplateObject;\n  var __importStar;\n  var __importDefault;\n  var __classPrivateFieldGet;\n  var __classPrivateFieldSet;\n  var __classPrivateFieldIn;\n  var __createBinding;\n  var __addDisposableResource;\n  var __disposeResources;\n  var __rewriteRelativeImportExtension;\n  (function(factory) {\n    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};\n    if (typeof define === "function" && define.amd) {\n      define("tslib", ["exports"], function(exports2) {\n        factory(createExporter(root, createExporter(exports2)));\n      });\n    } else if (typeof module === "object" && typeof exports === "object") {\n      factory(createExporter(root, createExporter(exports)));\n    } else {\n      factory(createExporter(root));\n    }\n    function createExporter(exports2, previous) {\n      if (exports2 !== root) {\n        if (typeof Object.create === "function") {\n          Object.defineProperty(exports2, "__esModule", { value: true });\n        } else {\n          exports2.__esModule = true;\n        }\n      }\n      return function(id, v) {\n        return exports2[id] = previous ? previous(id, v) : v;\n      };\n    }\n  })(function(exporter) {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {\n      d.__proto__ = b;\n    } || function(d, b) {\n      for (var p in b)\n        if (Object.prototype.hasOwnProperty.call(b, p))\n          d[p] = b[p];\n    };\n    __extends = function(d, b) {\n      if (typeof b !== "function" && b !== null)\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n      extendStatics(d, b);\n      function __() {\n        this.constructor = d;\n      }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);\n    };\n    __assign = Object.assign || function(t) {\n      for (var s, i = 1, n = arguments.length;i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n          if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n      }\n      return t;\n    };\n    __rest = function(s, e) {\n      var t = {};\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n          t[p] = s[p];\n      if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n            t[p[i]] = s[p[i]];\n        }\n      return t;\n    };\n    __decorate = function(decorators, target, key, desc) {\n      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")\n        r = Reflect.decorate(decorators, target, key, desc);\n      else\n        for (var i = decorators.length - 1;i >= 0; i--)\n          if (d = decorators[i])\n            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n      return c > 3 && r && Object.defineProperty(target, key, r), r;\n    };\n    __param = function(paramIndex, decorator) {\n      return function(target, key) {\n        decorator(target, key, paramIndex);\n      };\n    };\n    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n      function accept(f) {\n        if (f !== undefined && typeof f !== "function")\n          throw new TypeError("Function expected");\n        return f;\n      }\n      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";\n      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;\n      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n      var _, done = false;\n      for (var i = decorators.length - 1;i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn)\n          context[p] = p === "access" ? {} : contextIn[p];\n        for (var p in contextIn.access)\n          context.access[p] = contextIn.access[p];\n        context.addInitializer = function(f) {\n          if (done)\n            throw new TypeError("Cannot add initializers after decoration has completed");\n          extraInitializers.push(accept(f || null));\n        };\n        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === "accessor") {\n          if (result === undefined)\n            continue;\n          if (result === null || typeof result !== "object")\n            throw new TypeError("Object expected");\n          if (_ = accept(result.get))\n            descriptor.get = _;\n          if (_ = accept(result.set))\n            descriptor.set = _;\n          if (_ = accept(result.init))\n            initializers.unshift(_);\n        } else if (_ = accept(result)) {\n          if (kind === "field")\n            initializers.unshift(_);\n          else\n            descriptor[key] = _;\n        }\n      }\n      if (target)\n        Object.defineProperty(target, contextIn.name, descriptor);\n      done = true;\n    };\n    __runInitializers = function(thisArg, initializers, value) {\n      var useValue = arguments.length > 2;\n      for (var i = 0;i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n      }\n      return useValue ? value : undefined;\n    };\n    __propKey = function(x) {\n      return typeof x === "symbol" ? x : "".concat(x);\n    };\n    __setFunctionName = function(f, name, prefix) {\n      if (typeof name === "symbol")\n        name = name.description ? "[".concat(name.description, "]") : "";\n      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });\n    };\n    __metadata = function(metadataKey, metadataValue) {\n      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")\n        return Reflect.metadata(metadataKey, metadataValue);\n    };\n    __awaiter = function(thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator["throw"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    __generator = function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);\n      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError("Generator is already executing.");\n        while (g && (g = 0, op[0] && (_ = 0)), _)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : undefined, done: true };\n      }\n    };\n    __exportStar = function(m, o) {\n      for (var p in m)\n        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))\n          __createBinding(o, m, p);\n    };\n    __createBinding = Object.create ? function(o, m, k, k2) {\n      if (k2 === undefined)\n        k2 = k;\n      var desc = Object.getOwnPropertyDescriptor(m, k);\n      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function() {\n          return m[k];\n        } };\n      }\n      Object.defineProperty(o, k2, desc);\n    } : function(o, m, k, k2) {\n      if (k2 === undefined)\n        k2 = k;\n      o[k2] = m[k];\n    };\n    __values = function(o) {\n      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === "number")\n        return {\n          next: function() {\n            if (o && i >= o.length)\n              o = undefined;\n            return { value: o && o[i++], done: !o };\n          }\n        };\n      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n    };\n    __read = function(o, n) {\n      var m = typeof Symbol === "function" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i = m.call(o), r, ar = [], e;\n      try {\n        while ((n === undefined || n-- > 0) && !(r = i.next()).done)\n          ar.push(r.value);\n      } catch (error) {\n        e = { error };\n      } finally {\n        try {\n          if (r && !r.done && (m = i["return"]))\n            m.call(i);\n        } finally {\n          if (e)\n            throw e.error;\n        }\n      }\n      return ar;\n    };\n    __spread = function() {\n      for (var ar = [], i = 0;i < arguments.length; i++)\n        ar = ar.concat(__read(arguments[i]));\n      return ar;\n    };\n    __spreadArrays = function() {\n      for (var s = 0, i = 0, il = arguments.length;i < il; i++)\n        s += arguments[i].length;\n      for (var r = Array(s), k = 0, i = 0;i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)\n          r[k] = a[j];\n      return r;\n    };\n    __spreadArray = function(to, from, pack) {\n      if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar;i < l; i++) {\n          if (ar || !(i in from)) {\n            if (!ar)\n              ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n          }\n        }\n      return to.concat(ar || Array.prototype.slice.call(from));\n    };\n    __await = function(v) {\n      return this instanceof __await ? (this.v = v, this) : new __await(v);\n    };\n    __asyncGenerator = function(thisArg, _arguments, generator) {\n      if (!Symbol.asyncIterator)\n        throw new TypeError("Symbol.asyncIterator is not defined.");\n      var g = generator.apply(thisArg, _arguments || []), i, q = [];\n      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n      }, i;\n      function awaitReturn(f) {\n        return function(v) {\n          return Promise.resolve(v).then(f, reject);\n        };\n      }\n      function verb(n, f) {\n        if (g[n]) {\n          i[n] = function(v) {\n            return new Promise(function(a, b) {\n              q.push([n, v, a, b]) > 1 || resume(n, v);\n            });\n          };\n          if (f)\n            i[n] = f(i[n]);\n        }\n      }\n      function resume(n, v) {\n        try {\n          step(g[n](v));\n        } catch (e) {\n          settle(q[0][3], e);\n        }\n      }\n      function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n      }\n      function fulfill(value) {\n        resume("next", value);\n      }\n      function reject(value) {\n        resume("throw", value);\n      }\n      function settle(f, v) {\n        if (f(v), q.shift(), q.length)\n          resume(q[0][0], q[0][1]);\n      }\n    };\n    __asyncDelegator = function(o) {\n      var i, p;\n      return i = {}, verb("next"), verb("throw", function(e) {\n        throw e;\n      }), verb("return"), i[Symbol.iterator] = function() {\n        return this;\n      }, i;\n      function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;\n        } : f;\n      }\n    };\n    __asyncValues = function(o) {\n      if (!Symbol.asyncIterator)\n        throw new TypeError("Symbol.asyncIterator is not defined.");\n      var m = o[Symbol.asyncIterator], i;\n      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {\n        return this;\n      }, i);\n      function verb(n) {\n        i[n] = o[n] && function(v) {\n          return new Promise(function(resolve, reject) {\n            v = o[n](v), settle(resolve, reject, v.done, v.value);\n          });\n        };\n      }\n      function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v2) {\n          resolve({ value: v2, done: d });\n        }, reject);\n      }\n    };\n    __makeTemplateObject = function(cooked, raw) {\n      if (Object.defineProperty) {\n        Object.defineProperty(cooked, "raw", { value: raw });\n      } else {\n        cooked.raw = raw;\n      }\n      return cooked;\n    };\n    var __setModuleDefault = Object.create ? function(o, v) {\n      Object.defineProperty(o, "default", { enumerable: true, value: v });\n    } : function(o, v) {\n      o["default"] = v;\n    };\n    var ownKeys = function(o) {\n      ownKeys = Object.getOwnPropertyNames || function(o2) {\n        var ar = [];\n        for (var k in o2)\n          if (Object.prototype.hasOwnProperty.call(o2, k))\n            ar[ar.length] = k;\n        return ar;\n      };\n      return ownKeys(o);\n    };\n    __importStar = function(mod) {\n      if (mod && mod.__esModule)\n        return mod;\n      var result = {};\n      if (mod != null) {\n        for (var k = ownKeys(mod), i = 0;i < k.length; i++)\n          if (k[i] !== "default")\n            __createBinding(result, mod, k[i]);\n      }\n      __setModuleDefault(result, mod);\n      return result;\n    };\n    __importDefault = function(mod) {\n      return mod && mod.__esModule ? mod : { default: mod };\n    };\n    __classPrivateFieldGet = function(receiver, state, kind, f) {\n      if (kind === "a" && !f)\n        throw new TypeError("Private accessor was defined without a getter");\n      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))\n        throw new TypeError("Cannot read private member from an object whose class did not declare it");\n      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\n    };\n    __classPrivateFieldSet = function(receiver, state, value, kind, f) {\n      if (kind === "m")\n        throw new TypeError("Private method is not writable");\n      if (kind === "a" && !f)\n        throw new TypeError("Private accessor was defined without a setter");\n      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))\n        throw new TypeError("Cannot write private member to an object whose class did not declare it");\n      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n    };\n    __classPrivateFieldIn = function(state, receiver) {\n      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")\n        throw new TypeError("Cannot use \'in\' operator on non-object");\n      return typeof state === "function" ? receiver === state : state.has(receiver);\n    };\n    __addDisposableResource = function(env, value, async) {\n      if (value !== null && value !== undefined) {\n        if (typeof value !== "object" && typeof value !== "function")\n          throw new TypeError("Object expected.");\n        var dispose, inner;\n        if (async) {\n          if (!Symbol.asyncDispose)\n            throw new TypeError("Symbol.asyncDispose is not defined.");\n          dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === undefined) {\n          if (!Symbol.dispose)\n            throw new TypeError("Symbol.dispose is not defined.");\n          dispose = value[Symbol.dispose];\n          if (async)\n            inner = dispose;\n        }\n        if (typeof dispose !== "function")\n          throw new TypeError("Object not disposable.");\n        if (inner)\n          dispose = function() {\n            try {\n              inner.call(this);\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          };\n        env.stack.push({ value, dispose, async });\n      } else if (async) {\n        env.stack.push({ async: true });\n      }\n      return value;\n    };\n    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {\n      var e = new Error(message);\n      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;\n    };\n    __disposeResources = function(env) {\n      function fail(e) {\n        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;\n        env.hasError = true;\n      }\n      var r, s = 0;\n      function next() {\n        while (r = env.stack.pop()) {\n          try {\n            if (!r.async && s === 1)\n              return s = 0, env.stack.push(r), Promise.resolve().then(next);\n            if (r.dispose) {\n              var result = r.dispose.call(r.value);\n              if (r.async)\n                return s |= 2, Promise.resolve(result).then(next, function(e) {\n                  fail(e);\n                  return next();\n                });\n            } else\n              s |= 1;\n          } catch (e) {\n            fail(e);\n          }\n        }\n        if (s === 1)\n          return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n        if (env.hasError)\n          throw env.error;\n      }\n      return next();\n    };\n    __rewriteRelativeImportExtension = function(path, preserveJsx) {\n      if (typeof path === "string" && /^\\.\\.?\\//.test(path)) {\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";\n        });\n      }\n      return path;\n    };\n    exporter("__extends", __extends);\n    exporter("__assign", __assign);\n    exporter("__rest", __rest);\n    exporter("__decorate", __decorate);\n    exporter("__param", __param);\n    exporter("__esDecorate", __esDecorate);\n    exporter("__runInitializers", __runInitializers);\n    exporter("__propKey", __propKey);\n    exporter("__setFunctionName", __setFunctionName);\n    exporter("__metadata", __metadata);\n    exporter("__awaiter", __awaiter);\n    exporter("__generator", __generator);\n    exporter("__exportStar", __exportStar);\n    exporter("__createBinding", __createBinding);\n    exporter("__values", __values);\n    exporter("__read", __read);\n    exporter("__spread", __spread);\n    exporter("__spreadArrays", __spreadArrays);\n    exporter("__spreadArray", __spreadArray);\n    exporter("__await", __await);\n    exporter("__asyncGenerator", __asyncGenerator);\n    exporter("__asyncDelegator", __asyncDelegator);\n    exporter("__asyncValues", __asyncValues);\n    exporter("__makeTemplateObject", __makeTemplateObject);\n    exporter("__importStar", __importStar);\n    exporter("__importDefault", __importDefault);\n    exporter("__classPrivateFieldGet", __classPrivateFieldGet);\n    exporter("__classPrivateFieldSet", __classPrivateFieldSet);\n    exporter("__classPrivateFieldIn", __classPrivateFieldIn);\n    exporter("__addDisposableResource", __addDisposableResource);\n    exporter("__disposeResources", __disposeResources);\n    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);\n  });\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/SupressedError.js\nvar require_SupressedError = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillSuppressedError = undefined;\n\n  class PonyfillSuppressedError2 extends Error {\n    error;\n    suppressed;\n    constructor(error, suppressed, message) {\n      super(message);\n      this.error = error;\n      this.suppressed = suppressed;\n      this.name = "SuppressedError";\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n  exports.PonyfillSuppressedError = PonyfillSuppressedError2;\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/symbols.js\nvar require_symbols = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.DisposableSymbols = undefined;\n  exports.patchSymbols = patchSymbols;\n  exports.DisposableSymbols = {\n    get dispose() {\n      return Symbol.dispose || Symbol.for("dispose");\n    },\n    get asyncDispose() {\n      return Symbol.asyncDispose || Symbol.for("asyncDispose");\n    }\n  };\n  function patchSymbols() {\n    Symbol.dispose ||= Symbol.for("dispose");\n    Symbol.asyncDispose ||= Symbol.for("asyncDispose");\n  }\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/utils.js\nvar require_utils2 = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.isSyncDisposable = isSyncDisposable2;\n  exports.isAsyncDisposable = isAsyncDisposable2;\n  var symbols_js_1 = require_symbols();\n  function isSyncDisposable2(obj) {\n    return obj?.[symbols_js_1.DisposableSymbols.dispose] != null;\n  }\n  function isAsyncDisposable2(obj) {\n    return obj?.[symbols_js_1.DisposableSymbols.asyncDispose] != null;\n  }\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/AsyncDisposableStack.js\nvar require_AsyncDisposableStack = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillAsyncDisposableStack = undefined;\n  var promise_helpers_1 = require_cjs();\n  var SupressedError_js_1 = require_SupressedError();\n  var symbols_js_1 = require_symbols();\n  var utils_js_1 = require_utils2();\n  var SuppressedError5 = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;\n\n  class PonyfillAsyncDisposableStack2 {\n    callbacks = [];\n    get disposed() {\n      return this.callbacks.length === 0;\n    }\n    use(value) {\n      if ((0, utils_js_1.isAsyncDisposable)(value)) {\n        this.callbacks.push(() => value[symbols_js_1.DisposableSymbols.asyncDispose]());\n      } else if ((0, utils_js_1.isSyncDisposable)(value)) {\n        this.callbacks.push(() => value[symbols_js_1.DisposableSymbols.dispose]());\n      }\n      return value;\n    }\n    adopt(value, onDisposeAsync) {\n      if (onDisposeAsync) {\n        this.callbacks.push(() => onDisposeAsync(value));\n      }\n      return value;\n    }\n    defer(onDisposeAsync) {\n      if (onDisposeAsync) {\n        this.callbacks.push(onDisposeAsync);\n      }\n    }\n    move() {\n      const stack = new PonyfillAsyncDisposableStack2;\n      stack.callbacks = this.callbacks;\n      this.callbacks = [];\n      return stack;\n    }\n    disposeAsync() {\n      return this[symbols_js_1.DisposableSymbols.asyncDispose]();\n    }\n    _error;\n    _iterateCallbacks() {\n      const cb = this.callbacks.pop();\n      if (cb) {\n        return (0, promise_helpers_1.handleMaybePromise)(cb, () => this._iterateCallbacks(), (error) => {\n          this._error = this._error ? new SuppressedError5(error, this._error) : error;\n          return this._iterateCallbacks();\n        });\n      }\n    }\n    [symbols_js_1.DisposableSymbols.asyncDispose]() {\n      const res$ = this._iterateCallbacks();\n      if (res$?.then) {\n        return res$.then(() => {\n          if (this._error) {\n            const error = this._error;\n            this._error = undefined;\n            throw error;\n          }\n        });\n      }\n      if (this._error) {\n        const error = this._error;\n        this._error = undefined;\n        throw error;\n      }\n      return;\n    }\n    [Symbol.toStringTag] = "AsyncDisposableStack";\n  }\n  exports.PonyfillAsyncDisposableStack = PonyfillAsyncDisposableStack2;\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/DisposableStack.js\nvar require_DisposableStack = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillDisposableStack = undefined;\n  var SupressedError_js_1 = require_SupressedError();\n  var symbols_js_1 = require_symbols();\n  var utils_js_1 = require_utils2();\n  var SuppressedError5 = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;\n\n  class PonyfillDisposableStack2 {\n    callbacks = [];\n    get disposed() {\n      return this.callbacks.length === 0;\n    }\n    use(value) {\n      if ((0, utils_js_1.isSyncDisposable)(value)) {\n        this.callbacks.push(() => value[symbols_js_1.DisposableSymbols.dispose]());\n      }\n      return value;\n    }\n    adopt(value, onDispose) {\n      if (onDispose) {\n        this.callbacks.push(() => onDispose(value));\n      }\n      return value;\n    }\n    defer(onDispose) {\n      if (onDispose) {\n        this.callbacks.push(onDispose);\n      }\n    }\n    move() {\n      const stack = new PonyfillDisposableStack2;\n      stack.callbacks = this.callbacks;\n      this.callbacks = [];\n      return stack;\n    }\n    dispose() {\n      return this[symbols_js_1.DisposableSymbols.dispose]();\n    }\n    _error;\n    _iterateCallbacks() {\n      const cb = this.callbacks.pop();\n      if (cb) {\n        try {\n          cb();\n        } catch (error) {\n          this._error = this._error ? new SuppressedError5(error, this._error) : error;\n        }\n        return this._iterateCallbacks();\n      }\n    }\n    [symbols_js_1.DisposableSymbols.dispose]() {\n      this._iterateCallbacks();\n      if (this._error) {\n        const error = this._error;\n        this._error = undefined;\n        throw error;\n      }\n    }\n    [Symbol.toStringTag] = "DisposableStack";\n  }\n  exports.PonyfillDisposableStack = PonyfillDisposableStack2;\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/index.js\nvar require_cjs2 = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.SuppressedError = exports.AsyncDisposableStack = exports.DisposableStack = undefined;\n  var tslib_1 = require_tslib();\n  var AsyncDisposableStack_js_1 = require_AsyncDisposableStack();\n  var DisposableStack_js_1 = require_DisposableStack();\n  var SupressedError_js_1 = require_SupressedError();\n  exports.DisposableStack = globalThis.DisposableStack || DisposableStack_js_1.PonyfillDisposableStack;\n  exports.AsyncDisposableStack = globalThis.AsyncDisposableStack || AsyncDisposableStack_js_1.PonyfillAsyncDisposableStack;\n  exports.SuppressedError = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;\n  tslib_1.__exportStar(require_symbols(), exports);\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/IteratorObject.js\nvar require_IteratorObject = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillIteratorObject = undefined;\n  var node_util_1 = __require("node:util");\n  var disposablestack_1 = require_cjs2();\n  var utils_js_1 = require_utils();\n\n  class PonyfillIteratorObject {\n    iterableIterator;\n    [Symbol.toStringTag] = "IteratorObject";\n    constructor(iterableIterator, className) {\n      this.iterableIterator = iterableIterator;\n      this[Symbol.toStringTag] = className;\n    }\n    *map(callbackfn) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        yield callbackfn(value, index++);\n      }\n      return;\n    }\n    *filter(callbackfn) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (callbackfn(value, index++)) {\n          yield value;\n        }\n      }\n      return;\n    }\n    reduce(callbackfn, initialValue) {\n      let index = 0;\n      let accumulator = initialValue;\n      for (const value of this.iterableIterator) {\n        accumulator = callbackfn(accumulator, value, index++);\n      }\n      return accumulator;\n    }\n    forEach(callbackfn) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        callbackfn(value, index++);\n      }\n    }\n    *take(limit) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (index >= limit) {\n          break;\n        }\n        yield value;\n        index++;\n      }\n      return;\n    }\n    *drop(count) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (index >= count) {\n          yield value;\n        }\n        index++;\n      }\n      return;\n    }\n    *flatMap(callback) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        const iteratorOrIterable = callback(value, index++);\n        if ((0, utils_js_1.isIterable)(iteratorOrIterable)) {\n          for (const innerValue of iteratorOrIterable) {\n            yield innerValue;\n          }\n        } else {\n          for (const innerValue of {\n            [Symbol.iterator]: () => iteratorOrIterable\n          }) {\n            yield innerValue;\n          }\n        }\n      }\n      return;\n    }\n    some(predicate) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (predicate(value, index++)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    every(predicate) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (!predicate(value, index++)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    find(predicate) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (predicate(value, index++)) {\n          return value;\n        }\n      }\n      return;\n    }\n    toArray() {\n      return Array.from(this.iterableIterator);\n    }\n    [disposablestack_1.DisposableSymbols.dispose]() {\n      this.iterableIterator.return?.();\n    }\n    next(...[value]) {\n      return this.iterableIterator.next(value);\n    }\n    [Symbol.iterator]() {\n      return this;\n    }\n    [Symbol.for("nodejs.util.inspect.custom")]() {\n      const record = {};\n      this.forEach((value, key) => {\n        const inspectedValue = (0, node_util_1.inspect)(value);\n        record[key] = inspectedValue.includes(",") ? inspectedValue.split(",").map((el) => el.trim()) : inspectedValue;\n      });\n      return `${this[Symbol.toStringTag]} ${(0, node_util_1.inspect)(record)}`;\n    }\n  }\n  exports.PonyfillIteratorObject = PonyfillIteratorObject;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/FormData.js\nvar require_FormData = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillFormData = undefined;\n  exports.getStreamFromFormData = getStreamFromFormData;\n  var node_buffer_1 = __require("node:buffer");\n  var IteratorObject_js_1 = require_IteratorObject();\n  var ReadableStream_js_1 = require_ReadableStream();\n\n  class PonyfillFormData {\n    map = new Map;\n    append(name, value, fileName) {\n      let values = this.map.get(name);\n      if (!values) {\n        values = [];\n        this.map.set(name, values);\n      }\n      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;\n      values.push(entry);\n    }\n    delete(name) {\n      this.map.delete(name);\n    }\n    get(name) {\n      const values = this.map.get(name);\n      return values ? values[0] : null;\n    }\n    getAll(name) {\n      return this.map.get(name) || [];\n    }\n    has(name) {\n      return this.map.has(name);\n    }\n    set(name, value, fileName) {\n      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;\n      this.map.set(name, [entry]);\n    }\n    [Symbol.iterator]() {\n      return this._entries();\n    }\n    *_entries() {\n      for (const [key, values] of this.map) {\n        for (const value of values) {\n          yield [key, value];\n        }\n      }\n    }\n    entries() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._entries(), "FormDataIterator");\n    }\n    _keys() {\n      return this.map.keys();\n    }\n    keys() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._keys(), "FormDataIterator");\n    }\n    *_values() {\n      for (const values of this.map.values()) {\n        for (const value of values) {\n          yield value;\n        }\n      }\n    }\n    values() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._values(), "FormDataIterator");\n    }\n    forEach(callback) {\n      for (const [key, value] of this) {\n        callback(value, key, this);\n      }\n    }\n  }\n  exports.PonyfillFormData = PonyfillFormData;\n  function getStreamFromFormData(formData, boundary = "---") {\n    let entriesIterator;\n    let sentInitialHeader = false;\n    let currentAsyncIterator;\n    let hasBefore = false;\n    function handleNextEntry(controller) {\n      const { done, value } = entriesIterator.next();\n      if (done) {\n        controller.enqueue(node_buffer_1.Buffer.from(`\\r\n--${boundary}--\\r\n`));\n        return controller.close();\n      }\n      if (hasBefore) {\n        controller.enqueue(node_buffer_1.Buffer.from(`\\r\n--${boundary}\\r\n`));\n      }\n      if (value) {\n        const [key, blobOrString] = value;\n        if (typeof blobOrString === "string") {\n          controller.enqueue(node_buffer_1.Buffer.from(`Content-Disposition: form-data; name="${key}"\\r\n\\r\n`));\n          controller.enqueue(node_buffer_1.Buffer.from(blobOrString));\n        } else {\n          let filenamePart = "";\n          if (blobOrString.name) {\n            filenamePart = `; filename="${blobOrString.name}"`;\n          }\n          controller.enqueue(node_buffer_1.Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\\r\n`));\n          controller.enqueue(node_buffer_1.Buffer.from(`Content-Type: ${blobOrString.type || "application/octet-stream"}\\r\n\\r\n`));\n          const entryStream = blobOrString.stream();\n          currentAsyncIterator = entryStream[Symbol.asyncIterator]();\n        }\n        hasBefore = true;\n      }\n    }\n    return new ReadableStream_js_1.PonyfillReadableStream({\n      start: () => {\n        entriesIterator = formData.entries();\n      },\n      pull: (controller) => {\n        if (!sentInitialHeader) {\n          sentInitialHeader = true;\n          return controller.enqueue(node_buffer_1.Buffer.from(`--${boundary}\\r\n`));\n        }\n        if (currentAsyncIterator) {\n          return currentAsyncIterator.next().then(({ done, value }) => {\n            if (done) {\n              currentAsyncIterator = undefined;\n            }\n            if (value) {\n              return controller.enqueue(value);\n            } else {\n              return handleNextEntry(controller);\n            }\n          });\n        }\n        return handleNextEntry(controller);\n      },\n      cancel: (err) => {\n        entriesIterator?.return?.(err);\n        currentAsyncIterator?.return?.(err);\n      }\n    });\n  }\n  function getNormalizedFile(name, blob, fileName) {\n    Object.defineProperty(blob, "name", {\n      configurable: true,\n      enumerable: true,\n      value: fileName || blob.name || name\n    });\n    return blob;\n  }\n  function isBlob(value) {\n    return value?.arrayBuffer != null;\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/Body.js\nvar require_Body = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillBody = undefined;\n  var node_buffer_1 = __require("node:buffer");\n  var node_stream_1 = __require("node:stream");\n  var busboy_1 = require_main();\n  var promise_helpers_1 = require_cjs();\n  var Blob_js_1 = require_Blob();\n  var File_js_1 = require_File();\n  var FormData_js_1 = require_FormData();\n  var ReadableStream_js_1 = require_ReadableStream();\n  var utils_js_1 = require_utils();\n  var BodyInitType;\n  (function(BodyInitType2) {\n    BodyInitType2["ReadableStream"] = "ReadableStream";\n    BodyInitType2["Blob"] = "Blob";\n    BodyInitType2["FormData"] = "FormData";\n    BodyInitType2["String"] = "String";\n    BodyInitType2["Readable"] = "Readable";\n    BodyInitType2["Buffer"] = "Buffer";\n    BodyInitType2["AsyncIterable"] = "AsyncIterable";\n  })(BodyInitType || (BodyInitType = {}));\n\n  class PonyfillBody {\n    bodyInit;\n    options;\n    bodyUsed = false;\n    contentType = null;\n    contentLength = null;\n    constructor(bodyInit, options = {}) {\n      this.bodyInit = bodyInit;\n      this.options = options;\n      const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit);\n      this._bodyFactory = bodyFactory;\n      this.contentType = contentType;\n      this.contentLength = contentLength;\n      this.bodyType = bodyType;\n      this._buffer = buffer;\n      this._signal = options.signal;\n    }\n    bodyType;\n    _bodyFactory = () => null;\n    _generatedBody = null;\n    _buffer;\n    _signal;\n    generateBody() {\n      if (this._generatedBody?.readable?.destroyed && this._buffer) {\n        this._generatedBody.readable = node_stream_1.Readable.from(this._buffer);\n      }\n      if (this._generatedBody) {\n        return this._generatedBody;\n      }\n      const body = this._bodyFactory();\n      this._generatedBody = body;\n      return body;\n    }\n    handleContentLengthHeader(forceSet = false) {\n      const contentTypeInHeaders = this.headers.get("content-type");\n      if (!contentTypeInHeaders) {\n        if (this.contentType) {\n          this.headers.set("content-type", this.contentType);\n        }\n      } else {\n        this.contentType = contentTypeInHeaders;\n      }\n      const contentLengthInHeaders = this.headers.get("content-length");\n      if (forceSet && this.bodyInit == null && !contentLengthInHeaders) {\n        this.contentLength = 0;\n        this.headers.set("content-length", "0");\n      }\n      if (!contentLengthInHeaders) {\n        if (this.contentLength) {\n          this.headers.set("content-length", this.contentLength.toString());\n        }\n      } else {\n        this.contentLength = parseInt(contentLengthInHeaders, 10);\n      }\n    }\n    get body() {\n      const _body = this.generateBody();\n      if (_body != null) {\n        const ponyfillReadableStream = _body;\n        const readable = _body.readable;\n        return new Proxy(_body.readable, {\n          get(_, prop) {\n            if (prop in ponyfillReadableStream) {\n              const ponyfillReadableStreamProp = ponyfillReadableStream[prop];\n              if (typeof ponyfillReadableStreamProp === "function") {\n                return ponyfillReadableStreamProp.bind(ponyfillReadableStream);\n              }\n              return ponyfillReadableStreamProp;\n            }\n            if (prop in readable) {\n              const readableProp = readable[prop];\n              if (typeof readableProp === "function") {\n                return readableProp.bind(readable);\n              }\n              return readableProp;\n            }\n          }\n        });\n      }\n      return null;\n    }\n    _chunks = null;\n    _doCollectChunksFromReadableJob() {\n      if (this.bodyType === BodyInitType.AsyncIterable) {\n        if (Array.fromAsync) {\n          return (0, promise_helpers_1.handleMaybePromise)(() => Array.fromAsync(this.bodyInit), (chunks3) => {\n            this._chunks = chunks3;\n            return this._chunks;\n          });\n        }\n        const iterator = this.bodyInit[Symbol.asyncIterator]();\n        const chunks2 = [];\n        const collectValue = () => (0, promise_helpers_1.handleMaybePromise)(() => iterator.next(), ({ value, done }) => {\n          if (value) {\n            chunks2.push(value);\n          }\n          if (!done) {\n            return collectValue();\n          }\n          this._chunks = chunks2;\n          return this._chunks;\n        });\n        return collectValue();\n      }\n      const _body = this.generateBody();\n      if (!_body) {\n        this._chunks = [];\n        return (0, utils_js_1.fakePromise)(this._chunks);\n      }\n      if (_body.readable.destroyed) {\n        return (0, utils_js_1.fakePromise)(this._chunks = []);\n      }\n      const chunks = [];\n      return new Promise((resolve, reject) => {\n        _body.readable.on("data", (chunk) => {\n          chunks.push(chunk);\n        });\n        _body.readable.once("error", reject);\n        _body.readable.once("end", () => {\n          resolve(this._chunks = chunks);\n        });\n      });\n    }\n    _collectChunksFromReadable() {\n      if (this._chunks) {\n        return (0, utils_js_1.fakePromise)(this._chunks);\n      }\n      this._chunks ||= this._doCollectChunksFromReadableJob();\n      return this._chunks;\n    }\n    _blob = null;\n    blob() {\n      if (this._blob) {\n        return (0, utils_js_1.fakePromise)(this._blob);\n      }\n      if (this.bodyType === BodyInitType.String) {\n        this._text = this.bodyInit;\n        this._blob = new Blob_js_1.PonyfillBlob([this._text], {\n          type: this.contentType || "text/plain;charset=UTF-8",\n          size: this.contentLength\n        });\n      }\n      if (this.bodyType === BodyInitType.Blob) {\n        this._blob = this.bodyInit;\n        return (0, utils_js_1.fakePromise)(this._blob);\n      }\n      if (this._buffer) {\n        this._blob = new Blob_js_1.PonyfillBlob([this._buffer], {\n          type: this.contentType || "",\n          size: this.contentLength\n        });\n        return (0, utils_js_1.fakePromise)(this._blob);\n      }\n      return (0, utils_js_1.fakePromise)((0, promise_helpers_1.handleMaybePromise)(() => this._collectChunksFromReadable(), (chunks) => {\n        this._blob = new Blob_js_1.PonyfillBlob(chunks, {\n          type: this.contentType || "",\n          size: this.contentLength\n        });\n        return this._blob;\n      }));\n    }\n    _formData = null;\n    formData(opts) {\n      if (this._formData) {\n        return (0, utils_js_1.fakePromise)(this._formData);\n      }\n      if (this.bodyType === BodyInitType.FormData) {\n        this._formData = this.bodyInit;\n        return (0, utils_js_1.fakePromise)(this._formData);\n      }\n      this._formData = new FormData_js_1.PonyfillFormData;\n      const _body = this.generateBody();\n      if (_body == null) {\n        return (0, utils_js_1.fakePromise)(this._formData);\n      }\n      const formDataLimits = {\n        ...this.options.formDataLimits,\n        ...opts?.formDataLimits\n      };\n      return new Promise((resolve, reject) => {\n        const stream = this.body?.readable;\n        if (!stream) {\n          return reject(new Error("No stream available"));\n        }\n        let currFile = null;\n        const bb = new busboy_1.Busboy({\n          headers: {\n            "content-length": typeof this.contentLength === "number" ? this.contentLength.toString() : this.contentLength || "",\n            "content-type": this.contentType || ""\n          },\n          limits: formDataLimits,\n          defCharset: "utf-8"\n        });\n        if (this._signal) {\n          (0, node_stream_1.addAbortSignal)(this._signal, bb);\n        }\n        let completed = false;\n        const complete = (err) => {\n          if (completed)\n            return;\n          completed = true;\n          stream.unpipe(bb);\n          bb.destroy();\n          if (currFile) {\n            currFile.destroy();\n            currFile = null;\n          }\n          if (err) {\n            reject(err);\n          } else {\n            resolve(this._formData);\n          }\n        };\n        stream.on("error", complete);\n        bb.on("field", (name, value, fieldnameTruncated, valueTruncated) => {\n          if (fieldnameTruncated) {\n            return complete(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));\n          }\n          if (valueTruncated) {\n            return complete(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));\n          }\n          this._formData.set(name, value);\n        });\n        bb.on("file", (name, fileStream, filename, _transferEncoding, mimeType) => {\n          currFile = fileStream;\n          const chunks = [];\n          fileStream.on("data", (chunk) => {\n            chunks.push(chunk);\n          });\n          fileStream.on("error", complete);\n          fileStream.on("limit", () => {\n            complete(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));\n          });\n          fileStream.on("close", () => {\n            if (fileStream.truncated) {\n              complete(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));\n            }\n            currFile = null;\n            const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });\n            this._formData.set(name, file);\n          });\n        });\n        bb.on("fieldsLimit", () => {\n          complete(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));\n        });\n        bb.on("filesLimit", () => {\n          complete(new Error(`Files limit exceeded: ${formDataLimits?.files}`));\n        });\n        bb.on("partsLimit", () => {\n          complete(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));\n        });\n        bb.on("end", complete);\n        bb.on("finish", complete);\n        bb.on("close", complete);\n        bb.on("error", complete);\n        stream.pipe(bb);\n      });\n    }\n    buffer() {\n      if (this._buffer) {\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      if (this._text) {\n        this._buffer = node_buffer_1.Buffer.from(this._text, "utf-8");\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      if (this.bodyType === BodyInitType.String) {\n        return this.text().then((text) => {\n          this._text = text;\n          this._buffer = node_buffer_1.Buffer.from(text, "utf-8");\n          return this._buffer;\n        });\n      }\n      if (this.bodyType === BodyInitType.Blob) {\n        if ((0, Blob_js_1.hasBufferMethod)(this.bodyInit)) {\n          return this.bodyInit.buffer().then((buf) => {\n            this._buffer = buf;\n            return this._buffer;\n          });\n        }\n        if ((0, Blob_js_1.hasBytesMethod)(this.bodyInit)) {\n          return this.bodyInit.bytes().then((bytes) => {\n            this._buffer = node_buffer_1.Buffer.from(bytes);\n            return this._buffer;\n          });\n        }\n        if ((0, Blob_js_1.hasArrayBufferMethod)(this.bodyInit)) {\n          return this.bodyInit.arrayBuffer().then((buf) => {\n            this._buffer = node_buffer_1.Buffer.from(buf, undefined, buf.byteLength);\n            return this._buffer;\n          });\n        }\n      }\n      return (0, utils_js_1.fakePromise)((0, promise_helpers_1.handleMaybePromise)(() => this._collectChunksFromReadable(), (chunks) => {\n        if (chunks.length === 1) {\n          this._buffer = chunks[0];\n          return this._buffer;\n        }\n        this._buffer = node_buffer_1.Buffer.concat(chunks);\n        return this._buffer;\n      }));\n    }\n    bytes() {\n      return this.buffer();\n    }\n    arrayBuffer() {\n      return this.buffer();\n    }\n    _json = null;\n    json() {\n      if (this._json) {\n        return (0, utils_js_1.fakePromise)(this._json);\n      }\n      return this.text().then((text) => {\n        try {\n          this._json = JSON.parse(text);\n        } catch (e) {\n          if (e instanceof SyntaxError) {\n            e.message += `, "${text}" is not valid JSON`;\n          }\n          throw e;\n        }\n        return this._json;\n      });\n    }\n    _text = null;\n    text() {\n      if (this._text) {\n        return (0, utils_js_1.fakePromise)(this._text);\n      }\n      if (this.bodyType === BodyInitType.String) {\n        this._text = this.bodyInit;\n        return (0, utils_js_1.fakePromise)(this._text);\n      }\n      return this.buffer().then((buffer) => {\n        this._text = buffer.toString("utf-8");\n        return this._text;\n      });\n    }\n  }\n  exports.PonyfillBody = PonyfillBody;\n  function processBodyInit(bodyInit) {\n    if (bodyInit == null) {\n      return {\n        bodyFactory: () => null,\n        contentType: null,\n        contentLength: null\n      };\n    }\n    if (typeof bodyInit === "string") {\n      const contentLength = node_buffer_1.Buffer.byteLength(bodyInit);\n      return {\n        bodyType: BodyInitType.String,\n        contentType: "text/plain;charset=UTF-8",\n        contentLength,\n        bodyFactory() {\n          const readable = node_stream_1.Readable.from(node_buffer_1.Buffer.from(bodyInit, "utf-8"));\n          return new ReadableStream_js_1.PonyfillReadableStream(readable);\n        }\n      };\n    }\n    if (node_buffer_1.Buffer.isBuffer(bodyInit)) {\n      const buffer = bodyInit;\n      return {\n        bodyType: BodyInitType.Buffer,\n        contentType: null,\n        contentLength: bodyInit.length,\n        buffer: bodyInit,\n        bodyFactory() {\n          const readable = node_stream_1.Readable.from(buffer);\n          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);\n          return body;\n        }\n      };\n    }\n    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {\n      const buffer = node_buffer_1.Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);\n      return {\n        bodyType: BodyInitType.Buffer,\n        contentLength: bodyInit.byteLength,\n        contentType: null,\n        buffer,\n        bodyFactory() {\n          const readable = node_stream_1.Readable.from(buffer);\n          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);\n          return body;\n        }\n      };\n    }\n    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream && bodyInit.readable != null) {\n      const readableStream = bodyInit;\n      return {\n        bodyType: BodyInitType.ReadableStream,\n        bodyFactory: () => readableStream,\n        contentType: null,\n        contentLength: null\n      };\n    }\n    if (isBlob(bodyInit)) {\n      const blob = bodyInit;\n      return {\n        bodyType: BodyInitType.Blob,\n        contentType: bodyInit.type,\n        contentLength: bodyInit.size,\n        bodyFactory() {\n          return blob.stream();\n        }\n      };\n    }\n    if (bodyInit instanceof ArrayBuffer) {\n      const contentLength = bodyInit.byteLength;\n      const buffer = node_buffer_1.Buffer.from(bodyInit, undefined, bodyInit.byteLength);\n      return {\n        bodyType: BodyInitType.Buffer,\n        contentType: null,\n        contentLength,\n        buffer,\n        bodyFactory() {\n          const readable = node_stream_1.Readable.from(buffer);\n          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);\n          return body;\n        }\n      };\n    }\n    if (bodyInit instanceof node_stream_1.Readable) {\n      return {\n        bodyType: BodyInitType.Readable,\n        contentType: null,\n        contentLength: null,\n        bodyFactory() {\n          const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);\n          return body;\n        }\n      };\n    }\n    if (isURLSearchParams(bodyInit)) {\n      const contentType = "application/x-www-form-urlencoded;charset=UTF-8";\n      return {\n        bodyType: BodyInitType.String,\n        contentType,\n        contentLength: null,\n        bodyFactory() {\n          const body = new ReadableStream_js_1.PonyfillReadableStream(node_stream_1.Readable.from(bodyInit.toString()));\n          return body;\n        }\n      };\n    }\n    if (isFormData(bodyInit)) {\n      const boundary = Math.random().toString(36).substr(2);\n      const contentType = `multipart/form-data; boundary=${boundary}`;\n      return {\n        bodyType: BodyInitType.FormData,\n        contentType,\n        contentLength: null,\n        bodyFactory() {\n          return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);\n        }\n      };\n    }\n    if (isReadableStream(bodyInit)) {\n      return {\n        contentType: null,\n        contentLength: null,\n        bodyFactory() {\n          return new ReadableStream_js_1.PonyfillReadableStream(bodyInit);\n        }\n      };\n    }\n    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {\n      return {\n        contentType: null,\n        contentLength: null,\n        bodyType: BodyInitType.AsyncIterable,\n        bodyFactory() {\n          const readable = node_stream_1.Readable.from(bodyInit);\n          return new ReadableStream_js_1.PonyfillReadableStream(readable);\n        }\n      };\n    }\n    throw new Error("Unknown body type");\n  }\n  function isFormData(value) {\n    return value?.forEach != null;\n  }\n  function isBlob(value) {\n    return value?.stream != null && typeof value.stream === "function";\n  }\n  function isURLSearchParams(value) {\n    return value?.sort != null;\n  }\n  function isReadableStream(value) {\n    return value?.getReader != null;\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/Headers.js\nvar require_Headers = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillHeaders = undefined;\n  exports.isHeadersLike = isHeadersLike;\n  var node_util_1 = __require("node:util");\n  var IteratorObject_js_1 = require_IteratorObject();\n  function isHeadersLike(headers) {\n    return headers?.get && headers?.forEach;\n  }\n\n  class PonyfillHeaders {\n    headersInit;\n    _map;\n    objectNormalizedKeysOfHeadersInit = [];\n    objectOriginalKeysOfHeadersInit = [];\n    _setCookies;\n    constructor(headersInit) {\n      this.headersInit = headersInit;\n    }\n    _get(key) {\n      const normalized = key.toLowerCase();\n      if (normalized === "set-cookie" && this._setCookies?.length) {\n        return this._setCookies.join(", ");\n      }\n      if (this._map) {\n        return this._map.get(normalized) || null;\n      }\n      if (this.headersInit == null) {\n        return null;\n      }\n      if (Array.isArray(this.headersInit)) {\n        const found = this.headersInit.filter(([headerKey]) => headerKey.toLowerCase() === normalized);\n        if (found.length === 0) {\n          return null;\n        }\n        if (found.length === 1) {\n          return found[0][1];\n        }\n        return found.map(([, value]) => value).join(", ");\n      } else if (isHeadersLike(this.headersInit)) {\n        return this.headersInit.get(normalized);\n      } else {\n        const initValue = this.headersInit[key] || this.headersInit[normalized];\n        if (initValue != null) {\n          return initValue;\n        }\n        if (!this.objectNormalizedKeysOfHeadersInit.length) {\n          Object.keys(this.headersInit).forEach((k) => {\n            this.objectOriginalKeysOfHeadersInit.push(k);\n            this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());\n          });\n        }\n        const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);\n        if (index === -1) {\n          return null;\n        }\n        const originalKey = this.objectOriginalKeysOfHeadersInit[index];\n        return this.headersInit[originalKey];\n      }\n    }\n    getMap() {\n      if (!this._map) {\n        this._setCookies ||= [];\n        if (this.headersInit != null) {\n          if (Array.isArray(this.headersInit)) {\n            this._map = new Map;\n            for (const [key, value] of this.headersInit) {\n              const normalizedKey = key.toLowerCase();\n              if (normalizedKey === "set-cookie") {\n                this._setCookies.push(value);\n                continue;\n              }\n              this._map.set(normalizedKey, value);\n            }\n          } else if (isHeadersLike(this.headersInit)) {\n            this._map = new Map;\n            this.headersInit.forEach((value, key) => {\n              if (key === "set-cookie") {\n                this._setCookies ||= [];\n                this._setCookies.push(value);\n                return;\n              }\n              this._map.set(key, value);\n            });\n          } else {\n            this._map = new Map;\n            for (const initKey in this.headersInit) {\n              const initValue = this.headersInit[initKey];\n              if (initValue != null) {\n                const normalizedKey = initKey.toLowerCase();\n                if (normalizedKey === "set-cookie") {\n                  this._setCookies ||= [];\n                  this._setCookies.push(initValue);\n                  continue;\n                }\n                this._map.set(normalizedKey, initValue);\n              }\n            }\n          }\n        } else {\n          this._map = new Map;\n        }\n      }\n      return this._map;\n    }\n    append(name, value) {\n      const key = name.toLowerCase();\n      if (key === "set-cookie") {\n        this._setCookies ||= [];\n        this._setCookies.push(value);\n        return;\n      }\n      const existingValue = this.getMap().get(key);\n      const finalValue = existingValue ? `${existingValue}, ${value}` : value;\n      this.getMap().set(key, finalValue);\n    }\n    get(name) {\n      const value = this._get(name);\n      if (value == null) {\n        return null;\n      }\n      return value.toString();\n    }\n    has(name) {\n      const key = name.toLowerCase();\n      if (key === "set-cookie") {\n        return !!this._setCookies?.length;\n      }\n      return !!this._get(name);\n    }\n    set(name, value) {\n      const key = name.toLowerCase();\n      if (key === "set-cookie") {\n        this._setCookies = [value];\n        return;\n      }\n      if (!this._map && this.headersInit != null) {\n        if (Array.isArray(this.headersInit)) {\n          const found = this.headersInit.find(([headerKey]) => headerKey.toLowerCase() === key);\n          if (found) {\n            found[1] = value;\n          } else {\n            this.headersInit.push([key, value]);\n          }\n          return;\n        } else if (isHeadersLike(this.headersInit)) {\n          this.headersInit.set(key, value);\n          return;\n        } else {\n          this.headersInit[key] = value;\n          return;\n        }\n      }\n      this.getMap().set(key, value);\n    }\n    delete(name) {\n      const key = name.toLowerCase();\n      if (key === "set-cookie") {\n        this._setCookies = [];\n        return;\n      }\n      this.getMap().delete(key);\n    }\n    forEach(callback) {\n      this._setCookies?.forEach((setCookie) => {\n        callback(setCookie, "set-cookie", this);\n      });\n      if (!this._map) {\n        if (this.headersInit) {\n          if (Array.isArray(this.headersInit)) {\n            this.headersInit.forEach(([key, value]) => {\n              callback(value, key, this);\n            });\n            return;\n          }\n          if (isHeadersLike(this.headersInit)) {\n            this.headersInit.forEach(callback);\n            return;\n          }\n          Object.entries(this.headersInit).forEach(([key, value]) => {\n            if (value != null) {\n              callback(value, key, this);\n            }\n          });\n        }\n        return;\n      }\n      this.getMap().forEach((value, key) => {\n        callback(value, key, this);\n      });\n    }\n    *_keys() {\n      if (this._setCookies?.length) {\n        yield "set-cookie";\n      }\n      if (!this._map) {\n        if (this.headersInit) {\n          if (Array.isArray(this.headersInit)) {\n            yield* this.headersInit.map(([key]) => key)[Symbol.iterator]();\n            return;\n          }\n          if (isHeadersLike(this.headersInit)) {\n            yield* this.headersInit.keys();\n            return;\n          }\n          yield* Object.keys(this.headersInit)[Symbol.iterator]();\n          return;\n        }\n      }\n      yield* this.getMap().keys();\n    }\n    keys() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._keys(), "HeadersIterator");\n    }\n    *_values() {\n      if (this._setCookies?.length) {\n        yield* this._setCookies;\n      }\n      if (!this._map) {\n        if (this.headersInit) {\n          if (Array.isArray(this.headersInit)) {\n            yield* this.headersInit.map(([, value]) => value)[Symbol.iterator]();\n            return;\n          }\n          if (isHeadersLike(this.headersInit)) {\n            yield* this.headersInit.values();\n            return;\n          }\n          yield* Object.values(this.headersInit)[Symbol.iterator]();\n          return;\n        }\n      }\n      yield* this.getMap().values();\n    }\n    values() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._values(), "HeadersIterator");\n    }\n    *_entries() {\n      if (this._setCookies?.length) {\n        yield* this._setCookies.map((cookie) => ["set-cookie", cookie]);\n      }\n      if (!this._map) {\n        if (this.headersInit) {\n          if (Array.isArray(this.headersInit)) {\n            yield* this.headersInit;\n            return;\n          }\n          if (isHeadersLike(this.headersInit)) {\n            yield* this.headersInit.entries();\n            return;\n          }\n          yield* Object.entries(this.headersInit);\n          return;\n        }\n      }\n      yield* this.getMap().entries();\n    }\n    entries() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._entries(), "HeadersIterator");\n    }\n    getSetCookie() {\n      if (!this._setCookies) {\n        this.getMap();\n      }\n      return this._setCookies;\n    }\n    [Symbol.iterator]() {\n      return this.entries();\n    }\n    [Symbol.for("nodejs.util.inspect.custom")]() {\n      const record = {};\n      this.forEach((value, key) => {\n        if (key === "set-cookie") {\n          record["set-cookie"] = this._setCookies || [];\n        } else {\n          record[key] = value?.includes(",") ? value.split(",").map((el) => el.trim()) : value;\n        }\n      });\n      return `Headers ${(0, node_util_1.inspect)(record)}`;\n    }\n  }\n  exports.PonyfillHeaders = PonyfillHeaders;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/Response.js\nvar require_Response = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillResponse = undefined;\n  var node_http_1 = __require("node:http");\n  var Body_js_1 = require_Body();\n  var Headers_js_1 = require_Headers();\n  var JSON_CONTENT_TYPE = "application/json; charset=utf-8";\n\n  class PonyfillResponse extends Body_js_1.PonyfillBody {\n    headers;\n    constructor(body, init) {\n      super(body || null, init);\n      this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);\n      this.status = init?.status || 200;\n      this.statusText = init?.statusText || node_http_1.STATUS_CODES[this.status] || "OK";\n      this.url = init?.url || "";\n      this.redirected = init?.redirected || false;\n      this.type = init?.type || "default";\n      this.handleContentLengthHeader();\n    }\n    get ok() {\n      return this.status >= 200 && this.status < 300;\n    }\n    status;\n    statusText;\n    url;\n    redirected;\n    type;\n    clone() {\n      return this;\n    }\n    static error() {\n      return new PonyfillResponse(null, {\n        status: 500,\n        statusText: "Internal Server Error"\n      });\n    }\n    static redirect(url, status = 302) {\n      if (status < 300 || status > 399) {\n        throw new RangeError("Invalid status code");\n      }\n      return new PonyfillResponse(null, {\n        headers: {\n          location: url\n        },\n        status\n      });\n    }\n    static json(data, init) {\n      const bodyInit = JSON.stringify(data);\n      if (!init) {\n        init = {\n          headers: {\n            "content-type": JSON_CONTENT_TYPE,\n            "content-length": Buffer.byteLength(bodyInit).toString()\n          }\n        };\n      } else if (!init.headers) {\n        init.headers = {\n          "content-type": JSON_CONTENT_TYPE,\n          "content-length": Buffer.byteLength(bodyInit).toString()\n        };\n      } else if ((0, Headers_js_1.isHeadersLike)(init.headers)) {\n        if (!init.headers.has("content-type")) {\n          init.headers.set("content-type", JSON_CONTENT_TYPE);\n        }\n        if (!init.headers.has("content-length")) {\n          init.headers.set("content-length", Buffer.byteLength(bodyInit).toString());\n        }\n      } else if (Array.isArray(init.headers)) {\n        let contentTypeExists = false;\n        let contentLengthExists = false;\n        for (const [key] of init.headers) {\n          if (contentLengthExists && contentTypeExists) {\n            break;\n          }\n          if (!contentTypeExists && key.toLowerCase() === "content-type") {\n            contentTypeExists = true;\n          } else if (!contentLengthExists && key.toLowerCase() === "content-length") {\n            contentLengthExists = true;\n          }\n        }\n        if (!contentTypeExists) {\n          init.headers.push(["content-type", JSON_CONTENT_TYPE]);\n        }\n        if (!contentLengthExists) {\n          init.headers.push(["content-length", Buffer.byteLength(bodyInit).toString()]);\n        }\n      } else if (typeof init.headers === "object") {\n        if (init.headers?.["content-type"] == null) {\n          init.headers["content-type"] = JSON_CONTENT_TYPE;\n        }\n        if (init.headers?.["content-length"] == null) {\n          init.headers["content-length"] = Buffer.byteLength(bodyInit).toString();\n        }\n      }\n      return new PonyfillResponse(bodyInit, init);\n    }\n    [Symbol.toStringTag] = "Response";\n  }\n  exports.PonyfillResponse = PonyfillResponse;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js\nvar require_fetchCurl = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.fetchCurl = fetchCurl;\n  var node_stream_1 = __require("node:stream");\n  var node_tls_1 = __require("node:tls");\n  var promise_helpers_1 = require_cjs();\n  var Response_js_1 = require_Response();\n  var utils_js_1 = require_utils();\n  function fetchCurl(fetchRequest) {\n    const { Curl, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];\n    const curlHandle = new Curl;\n    curlHandle.enable(CurlFeature.NoDataParsing);\n    curlHandle.setOpt("URL", fetchRequest.url);\n    if (process.env.NODE_TLS_REJECT_UNAUTHORIZED === "0") {\n      curlHandle.setOpt("SSL_VERIFYPEER", false);\n    }\n    if (process.env.NODE_EXTRA_CA_CERTS) {\n      curlHandle.setOpt("CAINFO", process.env.NODE_EXTRA_CA_CERTS);\n    } else {\n      curlHandle.setOpt("CAINFO_BLOB", node_tls_1.rootCertificates.join(`\n`));\n    }\n    curlHandle.enable(CurlFeature.StreamResponse);\n    let signal;\n    if (fetchRequest._signal === null) {\n      signal = undefined;\n    } else if (fetchRequest._signal) {\n      signal = fetchRequest._signal;\n    }\n    curlHandle.setStreamProgressCallback(function() {\n      return signal?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;\n    });\n    if (fetchRequest["bodyType"] === "String") {\n      curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);\n    } else {\n      const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;\n      if (nodeReadable) {\n        curlHandle.setOpt("UPLOAD", true);\n        curlHandle.setUploadStream(nodeReadable);\n      }\n    }\n    if (process.env.DEBUG) {\n      curlHandle.setOpt("VERBOSE", true);\n    }\n    curlHandle.setOpt("TRANSFER_ENCODING", false);\n    curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);\n    curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");\n    curlHandle.setOpt("MAXREDIRS", 20);\n    curlHandle.setOpt("ACCEPT_ENCODING", "");\n    curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);\n    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;\n    let size;\n    const curlHeaders = headersSerializer(fetchRequest.headers, (value) => {\n      size = Number(value);\n    });\n    if (size != null) {\n      curlHandle.setOpt("INFILESIZE", size);\n    }\n    curlHandle.setOpt("HTTPHEADER", curlHeaders);\n    curlHandle.enable(CurlFeature.NoHeaderParsing);\n    const deferredPromise = (0, promise_helpers_1.createDeferredPromise)();\n    let streamResolved;\n    function onAbort() {\n      if (curlHandle.isOpen) {\n        try {\n          curlHandle.pause(CurlPause.Recv);\n        } catch (e) {\n          deferredPromise.reject(e);\n        }\n      }\n    }\n    signal?.addEventListener("abort", onAbort, { once: true });\n    curlHandle.once("end", function endListener() {\n      try {\n        curlHandle.close();\n      } catch (e) {\n        deferredPromise.reject(e);\n      }\n      signal?.removeEventListener("abort", onAbort);\n    });\n    curlHandle.once("error", function errorListener(error) {\n      if (streamResolved && !streamResolved.closed && !streamResolved.destroyed) {\n        streamResolved.destroy(error);\n      } else {\n        if (error.message === "Operation was aborted by an application callback") {\n          error.message = "The operation was aborted.";\n        }\n        deferredPromise.reject(error);\n      }\n      try {\n        curlHandle.close();\n      } catch (e) {\n        deferredPromise.reject(e);\n      }\n    });\n    curlHandle.once("stream", function streamListener(stream, status, headersBuf) {\n      const outputStream = stream.pipe(new node_stream_1.PassThrough, {\n        end: true\n      });\n      const headersFlat = headersBuf.toString("utf8").split(/\\r?\\n|\\r/g).filter((headerFilter) => {\n        if (headerFilter && !headerFilter.startsWith("HTTP/")) {\n          if (fetchRequest.redirect === "error" && headerFilter.toLowerCase().includes("location") && (0, utils_js_1.shouldRedirect)(status)) {\n            if (!stream.destroyed) {\n              stream.resume();\n            }\n            outputStream.destroy();\n            deferredPromise.reject(new Error("redirect is not allowed"));\n          }\n          return true;\n        }\n        return false;\n      });\n      const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\\s(.+)/).slice(0, 2));\n      const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream, {\n        status,\n        headers: headersInit,\n        url: curlHandle.getInfo(Curl.info.REDIRECT_URL)?.toString() || fetchRequest.url,\n        redirected: Number(curlHandle.getInfo(Curl.info.REDIRECT_COUNT)) > 0\n      });\n      deferredPromise.resolve(ponyfillResponse);\n      streamResolved = outputStream;\n    });\n    setImmediate(() => {\n      curlHandle.perform();\n    });\n    return deferredPromise.promise;\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/URL.js\nvar require_URL = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillURL = undefined;\n  var tslib_1 = require_tslib();\n  var node_buffer_1 = tslib_1.__importDefault(__require("node:buffer"));\n  var node_crypto_1 = __require("node:crypto");\n  var NativeURL = globalThis.URL;\n\n  class URL2 extends NativeURL {\n    static blobRegistry = new Map;\n    static createObjectURL(blob) {\n      const blobUrl = `blob:whatwgnode:${(0, node_crypto_1.randomUUID)()}`;\n      this.blobRegistry.set(blobUrl, blob);\n      return blobUrl;\n    }\n    static revokeObjectURL(url) {\n      if (!this.blobRegistry.has(url)) {\n        NativeURL.revokeObjectURL(url);\n      } else {\n        this.blobRegistry.delete(url);\n      }\n    }\n    static getBlobFromURL(url) {\n      return this.blobRegistry.get(url) || node_buffer_1.default?.resolveObjectURL?.(url);\n    }\n  }\n  exports.PonyfillURL = URL2;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/Request.js\nvar require_Request = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillRequest = undefined;\n  var node_http_1 = __require("node:http");\n  var node_https_1 = __require("node:https");\n  var Body_js_1 = require_Body();\n  var Headers_js_1 = require_Headers();\n  var URL_js_1 = require_URL();\n  function isRequest(input) {\n    return input[Symbol.toStringTag] === "Request";\n  }\n  function isURL(obj) {\n    return obj?.href != null;\n  }\n\n  class PonyfillRequest extends Body_js_1.PonyfillBody {\n    constructor(input, options) {\n      let _url;\n      let _parsedUrl;\n      let bodyInit = null;\n      let requestInit;\n      if (typeof input === "string") {\n        _url = input;\n      } else if (isURL(input)) {\n        _parsedUrl = input;\n      } else if (isRequest(input)) {\n        if (input._parsedUrl) {\n          _parsedUrl = input._parsedUrl;\n        } else if (input._url) {\n          _url = input._url;\n        } else {\n          _url = input.url;\n        }\n        bodyInit = input.body;\n        requestInit = input;\n      }\n      if (options != null) {\n        bodyInit = options.body || null;\n        requestInit = options;\n      }\n      super(bodyInit, requestInit);\n      this._url = _url;\n      this._parsedUrl = _parsedUrl;\n      this.cache = requestInit?.cache || "default";\n      this.credentials = requestInit?.credentials || "same-origin";\n      this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);\n      this.integrity = requestInit?.integrity || "";\n      this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;\n      this.method = requestInit?.method?.toUpperCase() || "GET";\n      this.mode = requestInit?.mode || "cors";\n      this.redirect = requestInit?.redirect || "follow";\n      this.referrer = requestInit?.referrer || "about:client";\n      this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";\n      this.headersSerializer = requestInit?.headersSerializer;\n      this.duplex = requestInit?.duplex || "half";\n      this.destination = "document";\n      this.priority = "auto";\n      if (this.method !== "GET" && this.method !== "HEAD") {\n        this.handleContentLengthHeader(true);\n      }\n      if (requestInit?.agent != null) {\n        const protocol = _parsedUrl?.protocol || _url || this.url;\n        if (requestInit.agent === false) {\n          this.agent = false;\n        } else if (protocol.startsWith("http:") && requestInit.agent instanceof node_http_1.Agent) {\n          this.agent = requestInit.agent;\n        } else if (protocol.startsWith("https:") && requestInit.agent instanceof node_https_1.Agent) {\n          this.agent = requestInit.agent;\n        }\n      }\n    }\n    headersSerializer;\n    cache;\n    credentials;\n    destination;\n    headers;\n    integrity;\n    keepalive;\n    method;\n    mode;\n    priority;\n    redirect;\n    referrer;\n    referrerPolicy;\n    _url;\n    get signal() {\n      this._signal ||= new AbortController().signal;\n      return this._signal;\n    }\n    get url() {\n      if (this._url == null) {\n        if (this._parsedUrl) {\n          this._url = this._parsedUrl.toString();\n        } else {\n          throw new TypeError("Invalid URL");\n        }\n      }\n      return this._url;\n    }\n    _parsedUrl;\n    get parsedUrl() {\n      if (this._parsedUrl == null) {\n        if (this._url != null) {\n          this._parsedUrl = new URL_js_1.PonyfillURL(this._url, "http://localhost");\n        } else {\n          throw new TypeError("Invalid URL");\n        }\n      }\n      return this._parsedUrl;\n    }\n    duplex;\n    agent;\n    clone() {\n      return this;\n    }\n    [Symbol.toStringTag] = "Request";\n  }\n  exports.PonyfillRequest = PonyfillRequest;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js\nvar require_fetchNodeHttp = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.fetchNodeHttp = fetchNodeHttp;\n  var node_http_1 = __require("node:http");\n  var node_https_1 = __require("node:https");\n  var node_stream_1 = __require("node:stream");\n  var node_zlib_1 = __require("node:zlib");\n  var promise_helpers_1 = require_cjs();\n  var Request_js_1 = require_Request();\n  var Response_js_1 = require_Response();\n  var URL_js_1 = require_URL();\n  var utils_js_1 = require_utils();\n  function getRequestFnForProtocol(url) {\n    if (url.startsWith("http:")) {\n      return node_http_1.request;\n    } else if (url.startsWith("https:")) {\n      return node_https_1.request;\n    }\n    throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);\n  }\n  function fetchNodeHttp(fetchRequest) {\n    return new Promise((resolve, reject) => {\n      try {\n        const requestFn = getRequestFnForProtocol(fetchRequest.parsedUrl?.protocol || fetchRequest.url);\n        const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;\n        const nodeHeaders = headersSerializer(fetchRequest.headers);\n        nodeHeaders["accept-encoding"] ||= "gzip, deflate, br";\n        nodeHeaders["user-agent"] ||= "node";\n        let signal;\n        if (fetchRequest._signal == null) {\n          signal = undefined;\n        } else if (fetchRequest._signal) {\n          signal = fetchRequest._signal;\n        }\n        let nodeRequest;\n        if (fetchRequest.parsedUrl) {\n          nodeRequest = requestFn(fetchRequest.parsedUrl, {\n            method: fetchRequest.method,\n            headers: nodeHeaders,\n            signal,\n            agent: fetchRequest.agent\n          });\n        } else {\n          nodeRequest = requestFn(fetchRequest.url, {\n            method: fetchRequest.method,\n            headers: nodeHeaders,\n            signal,\n            agent: fetchRequest.agent\n          });\n        }\n        nodeRequest.once("error", reject);\n        nodeRequest.once("response", (nodeResponse) => {\n          let outputStream;\n          const contentEncoding = nodeResponse.headers["content-encoding"];\n          switch (contentEncoding) {\n            case "x-gzip":\n            case "gzip":\n              outputStream = (0, node_zlib_1.createGunzip)();\n              break;\n            case "x-deflate":\n            case "deflate":\n              outputStream = (0, node_zlib_1.createInflate)();\n              break;\n            case "x-deflate-raw":\n            case "deflate-raw":\n              outputStream = (0, node_zlib_1.createInflateRaw)();\n              break;\n            case "br":\n              outputStream = (0, node_zlib_1.createBrotliDecompress)();\n              break;\n          }\n          if (nodeResponse.headers.location && (0, utils_js_1.shouldRedirect)(nodeResponse.statusCode)) {\n            if (fetchRequest.redirect === "error") {\n              const redirectError = new Error("Redirects are not allowed");\n              reject(redirectError);\n              nodeResponse.resume();\n              return;\n            }\n            if (fetchRequest.redirect === "follow") {\n              const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.parsedUrl || fetchRequest.url);\n              const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));\n              resolve(redirectResponse$.then((redirectResponse) => {\n                redirectResponse.redirected = true;\n                return redirectResponse;\n              }));\n              nodeResponse.resume();\n              return;\n            }\n          }\n          outputStream ||= new node_stream_1.PassThrough;\n          (0, utils_js_1.pipeThrough)({\n            src: nodeResponse,\n            dest: outputStream,\n            signal,\n            onError: (e) => {\n              if (!nodeResponse.destroyed) {\n                nodeResponse.destroy(e);\n              }\n              if (!outputStream.destroyed) {\n                outputStream.destroy(e);\n              }\n              reject(e);\n            }\n          });\n          const statusCode = nodeResponse.statusCode || 200;\n          let statusText = nodeResponse.statusMessage || node_http_1.STATUS_CODES[statusCode];\n          if (statusText == null) {\n            statusText = "";\n          }\n          const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream || nodeResponse, {\n            status: statusCode,\n            statusText,\n            headers: nodeResponse.headers,\n            url: fetchRequest.url,\n            signal\n          });\n          resolve(ponyfillResponse);\n        });\n        if (fetchRequest["_buffer"] != null) {\n          (0, promise_helpers_1.handleMaybePromise)(() => (0, utils_js_1.safeWrite)(fetchRequest["_buffer"], nodeRequest), () => (0, utils_js_1.endStream)(nodeRequest), reject);\n        } else {\n          const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;\n          if (nodeReadable) {\n            nodeReadable.pipe(nodeRequest);\n          } else {\n            (0, utils_js_1.endStream)(nodeRequest);\n          }\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/fetch.js\nvar require_fetch = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.fetchPonyfill = fetchPonyfill;\n  var node_buffer_1 = __require("node:buffer");\n  var node_fs_1 = __require("node:fs");\n  var node_url_1 = __require("node:url");\n  var fetchCurl_js_1 = require_fetchCurl();\n  var fetchNodeHttp_js_1 = require_fetchNodeHttp();\n  var Request_js_1 = require_Request();\n  var Response_js_1 = require_Response();\n  var URL_js_1 = require_URL();\n  var utils_js_1 = require_utils();\n  var BASE64_SUFFIX = ";base64";\n  async function getResponseForFile(url) {\n    const path = (0, node_url_1.fileURLToPath)(url);\n    try {\n      await node_fs_1.promises.access(path, node_fs_1.promises.constants.R_OK);\n      const stats = await node_fs_1.promises.stat(path, {\n        bigint: true\n      });\n      const readable = (0, node_fs_1.createReadStream)(path);\n      return new Response_js_1.PonyfillResponse(readable, {\n        status: 200,\n        statusText: "OK",\n        headers: {\n          "content-type": "application/octet-stream",\n          "last-modified": stats.mtime.toUTCString()\n        }\n      });\n    } catch (err) {\n      if (err.code === "ENOENT") {\n        return new Response_js_1.PonyfillResponse(null, {\n          status: 404,\n          statusText: "Not Found"\n        });\n      } else if (err.code === "EACCES") {\n        return new Response_js_1.PonyfillResponse(null, {\n          status: 403,\n          statusText: "Forbidden"\n        });\n      }\n      throw err;\n    }\n  }\n  function getResponseForDataUri(url) {\n    const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");\n    const data = decodeURIComponent(datas.join(","));\n    if (mimeType.endsWith(BASE64_SUFFIX)) {\n      const buffer = node_buffer_1.Buffer.from(data, "base64url");\n      const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);\n      return new Response_js_1.PonyfillResponse(buffer, {\n        status: 200,\n        statusText: "OK",\n        headers: {\n          "content-type": realMimeType\n        }\n      });\n    }\n    return new Response_js_1.PonyfillResponse(data, {\n      status: 200,\n      statusText: "OK",\n      headers: {\n        "content-type": mimeType\n      }\n    });\n  }\n  function getResponseForBlob(url) {\n    const blob = URL_js_1.PonyfillURL.getBlobFromURL(url);\n    if (!blob) {\n      throw new TypeError("Invalid Blob URL");\n    }\n    return new Response_js_1.PonyfillResponse(blob, {\n      status: 200,\n      headers: {\n        "content-type": blob.type,\n        "content-length": blob.size.toString()\n      }\n    });\n  }\n  function isURL(obj) {\n    return obj != null && obj.href != null;\n  }\n  function fetchPonyfill(info, init) {\n    if (typeof info === "string" || isURL(info)) {\n      const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);\n      return fetchPonyfill(ponyfillRequest);\n    }\n    const fetchRequest = info;\n    if (fetchRequest.url.startsWith("data:")) {\n      const response = getResponseForDataUri(fetchRequest.url);\n      return (0, utils_js_1.fakePromise)(response);\n    }\n    if (fetchRequest.url.startsWith("file:")) {\n      const response = getResponseForFile(fetchRequest.url);\n      return response;\n    }\n    if (fetchRequest.url.startsWith("blob:")) {\n      const response = getResponseForBlob(fetchRequest.url);\n      return (0, utils_js_1.fakePromise)(response);\n    }\n    if (globalThis.libcurl && !fetchRequest.agent) {\n      return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);\n    }\n    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js\nvar require_TextEncoderDecoder = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = undefined;\n  exports.PonyfillBtoa = PonyfillBtoa;\n  var node_buffer_1 = __require("node:buffer");\n  var utils_js_1 = require_utils();\n\n  class PonyfillTextEncoder {\n    encoding;\n    constructor(encoding = "utf-8") {\n      this.encoding = encoding;\n    }\n    encode(input) {\n      return node_buffer_1.Buffer.from(input, this.encoding);\n    }\n    encodeInto(source, destination) {\n      const buffer = this.encode(source);\n      const copied = buffer.copy(destination);\n      return {\n        read: copied,\n        written: copied\n      };\n    }\n  }\n  exports.PonyfillTextEncoder = PonyfillTextEncoder;\n\n  class PonyfillTextDecoder {\n    encoding;\n    fatal = false;\n    ignoreBOM = false;\n    constructor(encoding = "utf-8", options) {\n      this.encoding = encoding;\n      if (options) {\n        this.fatal = options.fatal || false;\n        this.ignoreBOM = options.ignoreBOM || false;\n      }\n    }\n    decode(input) {\n      if (node_buffer_1.Buffer.isBuffer(input)) {\n        return input.toString(this.encoding);\n      }\n      if ((0, utils_js_1.isArrayBufferView)(input)) {\n        return node_buffer_1.Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);\n      }\n      return node_buffer_1.Buffer.from(input).toString(this.encoding);\n    }\n  }\n  exports.PonyfillTextDecoder = PonyfillTextDecoder;\n  function PonyfillBtoa(input) {\n    return node_buffer_1.Buffer.from(input, "binary").toString("base64");\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js\nvar require_URLSearchParams = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillURLSearchParams = undefined;\n  exports.PonyfillURLSearchParams = globalThis.URLSearchParams;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/WritableStream.js\nvar require_WritableStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillWritableStream = undefined;\n  var node_events_1 = __require("node:events");\n  var node_stream_1 = __require("node:stream");\n  var promise_helpers_1 = require_cjs();\n  var utils_js_1 = require_utils();\n\n  class PonyfillWritableStream {\n    writable;\n    constructor(underlyingSink) {\n      if (underlyingSink instanceof node_stream_1.Writable) {\n        this.writable = underlyingSink;\n      } else if (underlyingSink) {\n        const writable = new node_stream_1.Writable({\n          write(chunk, _encoding, callback) {\n            try {\n              const result = underlyingSink.write?.(chunk, controller);\n              if (result instanceof Promise) {\n                result.then(() => {\n                  callback();\n                }, (err) => {\n                  callback(err);\n                });\n              } else {\n                callback();\n              }\n            } catch (err) {\n              callback(err);\n            }\n          },\n          final(callback) {\n            const result = underlyingSink.close?.();\n            if (result instanceof Promise) {\n              result.then(() => {\n                callback();\n              }, (err) => {\n                callback(err);\n              });\n            } else {\n              callback();\n            }\n          }\n        });\n        this.writable = writable;\n        const abortCtrl = new AbortController;\n        const controller = {\n          signal: abortCtrl.signal,\n          error(e) {\n            writable.destroy(e);\n          }\n        };\n        writable.once("error", (err) => abortCtrl.abort(err));\n        writable.once("close", () => abortCtrl.abort());\n      } else {\n        this.writable = new node_stream_1.Writable;\n      }\n    }\n    getWriter() {\n      const writable = this.writable;\n      return {\n        get closed() {\n          return (0, node_events_1.once)(writable, "close");\n        },\n        get desiredSize() {\n          return writable.writableLength;\n        },\n        get ready() {\n          return (0, node_events_1.once)(writable, "drain");\n        },\n        releaseLock() {},\n        write(chunk) {\n          const promise = (0, utils_js_1.fakePromise)();\n          if (chunk == null) {\n            return promise;\n          }\n          return promise.then(() => (0, utils_js_1.safeWrite)(chunk, writable));\n        },\n        close() {\n          if (!writable.errored && writable.closed) {\n            return (0, utils_js_1.fakePromise)();\n          }\n          if (writable.errored) {\n            return (0, promise_helpers_1.fakeRejectPromise)(writable.errored);\n          }\n          return (0, utils_js_1.fakePromise)().then(() => (0, utils_js_1.endStream)(writable));\n        },\n        abort(reason) {\n          writable.destroy(reason);\n          return (0, node_events_1.once)(writable, "close");\n        }\n      };\n    }\n    close() {\n      if (!this.writable.errored && this.writable.closed) {\n        return (0, utils_js_1.fakePromise)();\n      }\n      if (this.writable.errored) {\n        return (0, promise_helpers_1.fakeRejectPromise)(this.writable.errored);\n      }\n      return (0, utils_js_1.fakePromise)().then(() => (0, utils_js_1.endStream)(this.writable));\n    }\n    abort(reason) {\n      this.writable.destroy(reason);\n      return (0, node_events_1.once)(this.writable, "close");\n    }\n    locked = false;\n  }\n  exports.PonyfillWritableStream = PonyfillWritableStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/TransformStream.js\nvar require_TransformStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillTransformStream = undefined;\n  var node_stream_1 = __require("node:stream");\n  var ReadableStream_js_1 = require_ReadableStream();\n  var utils_js_1 = require_utils();\n  var WritableStream_js_1 = require_WritableStream();\n\n  class PonyfillTransformStream {\n    transform;\n    writable;\n    readable;\n    constructor(transformer) {\n      if (transformer instanceof node_stream_1.Transform) {\n        this.transform = transformer;\n      } else if (transformer) {\n        const controller = {\n          enqueue(chunk) {\n            transform.push(chunk);\n          },\n          error(reason) {\n            transform.destroy(reason);\n          },\n          terminate() {\n            (0, utils_js_1.endStream)(transform);\n          },\n          get desiredSize() {\n            return transform.writableLength;\n          }\n        };\n        const transform = new node_stream_1.Transform({\n          read() {},\n          write(chunk, _encoding, callback) {\n            try {\n              const result = transformer.transform?.(chunk, controller);\n              if (result instanceof Promise) {\n                result.then(() => {\n                  callback();\n                }, (err) => {\n                  callback(err);\n                });\n              } else {\n                callback();\n              }\n            } catch (err) {\n              callback(err);\n            }\n          },\n          final(callback) {\n            try {\n              const result = transformer.flush?.(controller);\n              if (result instanceof Promise) {\n                result.then(() => {\n                  callback();\n                }, (err) => {\n                  callback(err);\n                });\n              } else {\n                callback();\n              }\n            } catch (err) {\n              callback(err);\n            }\n          }\n        });\n        this.transform = transform;\n      } else {\n        this.transform = new node_stream_1.Transform;\n      }\n      this.writable = new WritableStream_js_1.PonyfillWritableStream(this.transform);\n      this.readable = new ReadableStream_js_1.PonyfillReadableStream(this.transform);\n    }\n  }\n  exports.PonyfillTransformStream = PonyfillTransformStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/CompressionStream.js\nvar require_CompressionStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillCompressionStream = undefined;\n  var node_zlib_1 = __require("node:zlib");\n  var TransformStream_js_1 = require_TransformStream();\n\n  class PonyfillCompressionStream extends TransformStream_js_1.PonyfillTransformStream {\n    static supportedFormats = globalThis.process?.version?.startsWith("v2") ? ["gzip", "deflate", "br"] : ["gzip", "deflate", "deflate-raw", "br"];\n    constructor(compressionFormat) {\n      switch (compressionFormat) {\n        case "x-gzip":\n        case "gzip":\n          super((0, node_zlib_1.createGzip)());\n          break;\n        case "x-deflate":\n        case "deflate":\n          super((0, node_zlib_1.createDeflate)());\n          break;\n        case "deflate-raw":\n          super((0, node_zlib_1.createDeflateRaw)());\n          break;\n        case "br":\n          super((0, node_zlib_1.createBrotliCompress)());\n          break;\n        default:\n          throw new Error(`Unsupported compression format: ${compressionFormat}`);\n      }\n    }\n  }\n  exports.PonyfillCompressionStream = PonyfillCompressionStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/DecompressionStream.js\nvar require_DecompressionStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillDecompressionStream = undefined;\n  var node_zlib_1 = __require("node:zlib");\n  var TransformStream_js_1 = require_TransformStream();\n\n  class PonyfillDecompressionStream extends TransformStream_js_1.PonyfillTransformStream {\n    static supportedFormats = globalThis.process?.version?.startsWith("v2") ? ["gzip", "deflate", "br"] : ["gzip", "deflate", "deflate-raw", "br"];\n    constructor(compressionFormat) {\n      switch (compressionFormat) {\n        case "x-gzip":\n        case "gzip":\n          super((0, node_zlib_1.createGunzip)());\n          break;\n        case "x-deflate":\n        case "deflate":\n          super((0, node_zlib_1.createInflate)());\n          break;\n        case "deflate-raw":\n          super((0, node_zlib_1.createInflateRaw)());\n          break;\n        case "br":\n          super((0, node_zlib_1.createBrotliDecompress)());\n          break;\n        default:\n          throw new TypeError(`Unsupported compression format: \'${compressionFormat}\'`);\n      }\n    }\n  }\n  exports.PonyfillDecompressionStream = PonyfillDecompressionStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoderStream.js\nvar require_TextEncoderDecoderStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillTextEncoderStream = exports.PonyfillTextDecoderStream = undefined;\n  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();\n  var TransformStream_js_1 = require_TransformStream();\n\n  class PonyfillTextDecoderStream extends TransformStream_js_1.PonyfillTransformStream {\n    textDecoder;\n    constructor(encoding, options) {\n      super({\n        transform: (chunk, controller) => controller.enqueue(this.textDecoder.decode(chunk, { stream: true }))\n      });\n      this.textDecoder = new TextEncoderDecoder_js_1.PonyfillTextDecoder(encoding, options);\n    }\n    get encoding() {\n      return this.textDecoder.encoding;\n    }\n    get fatal() {\n      return this.textDecoder.fatal;\n    }\n    get ignoreBOM() {\n      return this.textDecoder.ignoreBOM;\n    }\n  }\n  exports.PonyfillTextDecoderStream = PonyfillTextDecoderStream;\n\n  class PonyfillTextEncoderStream extends TransformStream_js_1.PonyfillTransformStream {\n    textEncoder;\n    constructor(encoding) {\n      super({\n        transform: (chunk, controller) => controller.enqueue(this.textEncoder.encode(chunk))\n      });\n      this.textEncoder = new TextEncoderDecoder_js_1.PonyfillTextEncoder(encoding);\n    }\n    get encoding() {\n      return this.textEncoder.encoding;\n    }\n    encode(input) {\n      return this.textEncoder.encode(input);\n    }\n  }\n  exports.PonyfillTextEncoderStream = PonyfillTextEncoderStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/index.js\nvar require_cjs3 = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.TextEncoderStream = exports.TextDecoderStream = exports.IteratorObject = exports.DecompressionStream = exports.CompressionStream = exports.TransformStream = exports.WritableStream = exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = undefined;\n  var fetch_js_1 = require_fetch();\n  Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {\n    return fetch_js_1.fetchPonyfill;\n  } });\n  var Headers_js_1 = require_Headers();\n  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {\n    return Headers_js_1.PonyfillHeaders;\n  } });\n  var Body_js_1 = require_Body();\n  Object.defineProperty(exports, "Body", { enumerable: true, get: function() {\n    return Body_js_1.PonyfillBody;\n  } });\n  var Request_js_1 = require_Request();\n  Object.defineProperty(exports, "Request", { enumerable: true, get: function() {\n    return Request_js_1.PonyfillRequest;\n  } });\n  var Response_js_1 = require_Response();\n  Object.defineProperty(exports, "Response", { enumerable: true, get: function() {\n    return Response_js_1.PonyfillResponse;\n  } });\n  var ReadableStream_js_1 = require_ReadableStream();\n  Object.defineProperty(exports, "ReadableStream", { enumerable: true, get: function() {\n    return ReadableStream_js_1.PonyfillReadableStream;\n  } });\n  var File_js_1 = require_File();\n  Object.defineProperty(exports, "File", { enumerable: true, get: function() {\n    return File_js_1.PonyfillFile;\n  } });\n  var FormData_js_1 = require_FormData();\n  Object.defineProperty(exports, "FormData", { enumerable: true, get: function() {\n    return FormData_js_1.PonyfillFormData;\n  } });\n  var Blob_js_1 = require_Blob();\n  Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {\n    return Blob_js_1.PonyfillBlob;\n  } });\n  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();\n  Object.defineProperty(exports, "TextEncoder", { enumerable: true, get: function() {\n    return TextEncoderDecoder_js_1.PonyfillTextEncoder;\n  } });\n  Object.defineProperty(exports, "TextDecoder", { enumerable: true, get: function() {\n    return TextEncoderDecoder_js_1.PonyfillTextDecoder;\n  } });\n  Object.defineProperty(exports, "btoa", { enumerable: true, get: function() {\n    return TextEncoderDecoder_js_1.PonyfillBtoa;\n  } });\n  var URL_js_1 = require_URL();\n  Object.defineProperty(exports, "URL", { enumerable: true, get: function() {\n    return URL_js_1.PonyfillURL;\n  } });\n  var URLSearchParams_js_1 = require_URLSearchParams();\n  Object.defineProperty(exports, "URLSearchParams", { enumerable: true, get: function() {\n    return URLSearchParams_js_1.PonyfillURLSearchParams;\n  } });\n  var WritableStream_js_1 = require_WritableStream();\n  Object.defineProperty(exports, "WritableStream", { enumerable: true, get: function() {\n    return WritableStream_js_1.PonyfillWritableStream;\n  } });\n  var TransformStream_js_1 = require_TransformStream();\n  Object.defineProperty(exports, "TransformStream", { enumerable: true, get: function() {\n    return TransformStream_js_1.PonyfillTransformStream;\n  } });\n  var CompressionStream_js_1 = require_CompressionStream();\n  Object.defineProperty(exports, "CompressionStream", { enumerable: true, get: function() {\n    return CompressionStream_js_1.PonyfillCompressionStream;\n  } });\n  var DecompressionStream_js_1 = require_DecompressionStream();\n  Object.defineProperty(exports, "DecompressionStream", { enumerable: true, get: function() {\n    return DecompressionStream_js_1.PonyfillDecompressionStream;\n  } });\n  var IteratorObject_js_1 = require_IteratorObject();\n  Object.defineProperty(exports, "IteratorObject", { enumerable: true, get: function() {\n    return IteratorObject_js_1.PonyfillIteratorObject;\n  } });\n  var TextEncoderDecoderStream_js_1 = require_TextEncoderDecoderStream();\n  Object.defineProperty(exports, "TextDecoderStream", { enumerable: true, get: function() {\n    return TextEncoderDecoderStream_js_1.PonyfillTextDecoderStream;\n  } });\n  Object.defineProperty(exports, "TextEncoderStream", { enumerable: true, get: function() {\n    return TextEncoderDecoderStream_js_1.PonyfillTextEncoderStream;\n  } });\n});\n\n// ../../node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js\nvar require_create_node_ponyfill = __commonJS((exports, module) => {\n  var shouldSkipPonyfill = require_shouldSkipPonyfill();\n  var newNodeFetch;\n  module.exports = function createNodePonyfill(opts = {}) {\n    const ponyfills = {};\n    ponyfills.URLPattern = globalThis.URLPattern;\n    if (!ponyfills.URLPattern) {\n      const urlPatternModule = require_urlpattern_polyfill();\n      ponyfills.URLPattern = urlPatternModule.URLPattern;\n    }\n    if (opts.skipPonyfill || shouldSkipPonyfill()) {\n      return {\n        fetch: globalThis.fetch,\n        Headers: globalThis.Headers,\n        Request: globalThis.Request,\n        Response: globalThis.Response,\n        FormData: globalThis.FormData,\n        ReadableStream: globalThis.ReadableStream,\n        WritableStream: globalThis.WritableStream,\n        TransformStream: globalThis.TransformStream,\n        CompressionStream: globalThis.CompressionStream,\n        DecompressionStream: globalThis.DecompressionStream,\n        TextDecoderStream: globalThis.TextDecoderStream,\n        TextEncoderStream: globalThis.TextEncoderStream,\n        Blob: globalThis.Blob,\n        File: globalThis.File,\n        crypto: globalThis.crypto,\n        btoa: globalThis.btoa,\n        TextEncoder: globalThis.TextEncoder,\n        TextDecoder: globalThis.TextDecoder,\n        URLPattern: ponyfills.URLPattern,\n        URL: globalThis.URL,\n        URLSearchParams: globalThis.URLSearchParams\n      };\n    }\n    newNodeFetch ||= require_cjs3();\n    ponyfills.fetch = newNodeFetch.fetch;\n    ponyfills.Request = newNodeFetch.Request;\n    ponyfills.Response = newNodeFetch.Response;\n    ponyfills.Headers = newNodeFetch.Headers;\n    ponyfills.FormData = newNodeFetch.FormData;\n    ponyfills.ReadableStream = newNodeFetch.ReadableStream;\n    ponyfills.URL = newNodeFetch.URL;\n    ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;\n    ponyfills.WritableStream = newNodeFetch.WritableStream;\n    ponyfills.TransformStream = newNodeFetch.TransformStream;\n    ponyfills.CompressionStream = newNodeFetch.CompressionStream;\n    ponyfills.DecompressionStream = newNodeFetch.DecompressionStream;\n    ponyfills.TextDecoderStream = newNodeFetch.TextDecoderStream;\n    ponyfills.TextEncoderStream = newNodeFetch.TextEncoderStream;\n    ponyfills.Blob = newNodeFetch.Blob;\n    ponyfills.File = newNodeFetch.File;\n    ponyfills.crypto = globalThis.crypto;\n    ponyfills.btoa = newNodeFetch.btoa;\n    ponyfills.TextEncoder = newNodeFetch.TextEncoder;\n    ponyfills.TextDecoder = newNodeFetch.TextDecoder;\n    if (opts.formDataLimits) {\n      ponyfills.Body = class Body extends newNodeFetch.Body {\n        constructor(body, userOpts) {\n          super(body, {\n            formDataLimits: opts.formDataLimits,\n            ...userOpts\n          });\n        }\n      };\n      ponyfills.Request = class Request2 extends newNodeFetch.Request {\n        constructor(input, userOpts) {\n          super(input, {\n            formDataLimits: opts.formDataLimits,\n            ...userOpts\n          });\n        }\n      };\n      ponyfills.Response = class Response2 extends newNodeFetch.Response {\n        constructor(body, userOpts) {\n          super(body, {\n            formDataLimits: opts.formDataLimits,\n            ...userOpts\n          });\n        }\n      };\n    }\n    if (!ponyfills.crypto) {\n      const cryptoModule = __require("crypto");\n      ponyfills.crypto = cryptoModule.webcrypto;\n    }\n    return ponyfills;\n  };\n});\n\n// src/types.ts\nvar BlinkInvocationTokenHeader = "x-blink-invocation-token";\nvar InternalAPIServerURLEnvironmentVariable = "INTERNAL_BLINK_API_SERVER_URL";\nvar InternalAPIServerListenPortEnvironmentVariable = "INTERNAL_BLINK_API_SERVER_LISTEN_PORT";\n\n// src/lambda/wrapper-lambda.ts\nimport { resolve } from "node:path";\nimport { Writable } from "node:stream";\n\n// src/server.ts\nimport { createServer, Server } from "node:http";\n\n// ../../node_modules/@whatwg-node/promise-helpers/esm/index.js\nvar kFakePromise = Symbol.for("@whatwg-node/promise-helpers/FakePromise");\nfunction isPromise(value) {\n  return value?.then != null;\n}\nfunction isActualPromise(value) {\n  const maybePromise = value;\n  return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;\n}\nfunction handleMaybePromise(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {\n  let result$ = fakePromise().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);\n  if (finallyFactory) {\n    result$ = result$.finally(finallyFactory);\n  }\n  return unfakePromise(result$);\n}\nfunction fakePromise(value) {\n  if (value && isActualPromise(value)) {\n    return value;\n  }\n  if (isPromise(value)) {\n    return {\n      then: (resolve, reject) => fakePromise(value.then(resolve, reject)),\n      catch: (reject) => fakePromise(value.then((res) => res, reject)),\n      finally: (cb) => fakePromise(cb ? promiseLikeFinally(value, cb) : value),\n      [Symbol.toStringTag]: "Promise"\n    };\n  }\n  return {\n    then(resolve) {\n      if (resolve) {\n        try {\n          return fakePromise(resolve(value));\n        } catch (err) {\n          return fakeRejectPromise(err);\n        }\n      }\n      return this;\n    },\n    catch() {\n      return this;\n    },\n    finally(cb) {\n      if (cb) {\n        try {\n          return fakePromise(cb()).then(() => value, () => value);\n        } catch (err) {\n          return fakeRejectPromise(err);\n        }\n      }\n      return this;\n    },\n    [Symbol.toStringTag]: "Promise",\n    __fakePromiseValue: value,\n    [kFakePromise]: "resolved"\n  };\n}\nfunction createDeferredPromise() {\n  if (Promise.withResolvers) {\n    return Promise.withResolvers();\n  }\n  let resolveFn;\n  let rejectFn;\n  const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {\n    resolveFn = resolve;\n    rejectFn = reject;\n  });\n  return {\n    promise,\n    get resolve() {\n      return resolveFn;\n    },\n    get reject() {\n      return rejectFn;\n    }\n  };\n}\nfunction iterateAsync(iterable, callback, results) {\n  if (iterable?.length === 0) {\n    return;\n  }\n  const iterator = iterable[Symbol.iterator]();\n  let index = 0;\n  function iterate() {\n    const { done: endOfIterator, value } = iterator.next();\n    if (endOfIterator) {\n      return;\n    }\n    let endedEarly = false;\n    function endEarly() {\n      endedEarly = true;\n    }\n    return handleMaybePromise(function handleCallback() {\n      return callback(value, endEarly, index++);\n    }, function handleCallbackResult(result) {\n      if (result) {\n        results?.push(result);\n      }\n      if (endedEarly) {\n        return;\n      }\n      return iterate();\n    });\n  }\n  return iterate();\n}\nfunction fakeRejectPromise(error) {\n  return {\n    then(_resolve, reject) {\n      if (reject) {\n        try {\n          return fakePromise(reject(error));\n        } catch (err) {\n          return fakeRejectPromise(err);\n        }\n      }\n      return this;\n    },\n    catch(reject) {\n      if (reject) {\n        try {\n          return fakePromise(reject(error));\n        } catch (err) {\n          return fakeRejectPromise(err);\n        }\n      }\n      return this;\n    },\n    finally(cb) {\n      if (cb) {\n        try {\n          cb();\n        } catch (err) {\n          return fakeRejectPromise(err);\n        }\n      }\n      return this;\n    },\n    __fakeRejectError: error,\n    [Symbol.toStringTag]: "Promise",\n    [kFakePromise]: "rejected"\n  };\n}\nfunction isFakePromise(value) {\n  return value?.[kFakePromise] === "resolved";\n}\nfunction isFakeRejectPromise(value) {\n  return value?.[kFakePromise] === "rejected";\n}\nfunction promiseLikeFinally(value, onFinally) {\n  if ("finally" in value) {\n    return value.finally(onFinally);\n  }\n  return value.then((res) => {\n    const finallyRes = onFinally();\n    return isPromise(finallyRes) ? finallyRes.then(() => res) : res;\n  }, (err) => {\n    const finallyRes = onFinally();\n    if (isPromise(finallyRes)) {\n      return finallyRes.then(() => {\n        throw err;\n      });\n    } else {\n      throw err;\n    }\n  });\n}\nfunction unfakePromise(promise) {\n  if (isFakePromise(promise)) {\n    return promise.__fakePromiseValue;\n  }\n  if (isFakeRejectPromise(promise)) {\n    throw promise.__fakeRejectError;\n  }\n  return promise;\n}\n\n// ../../node_modules/@envelop/instrumentation/esm/instrumentation.js\nfunction chain(first, next) {\n  const merged = { ...next, ...first };\n  for (const key of Object.keys(merged)) {\n    if (key in first && key in next) {\n      merged[key] = (payload, wrapped) => first[key](payload, () => next[key](payload, wrapped));\n    }\n  }\n  return merged;\n}\nvar getInstrumented = (payload) => ({\n  fn(instrument, wrapped) {\n    if (!instrument) {\n      return wrapped;\n    }\n    return (...args) => {\n      let result;\n      instrument(payload, () => {\n        result = wrapped(...args);\n      });\n      return result;\n    };\n  },\n  asyncFn(instrument, wrapped) {\n    if (!instrument) {\n      return wrapped;\n    }\n    return (...args) => {\n      let result;\n      return handleMaybePromise(() => instrument(payload, () => {\n        result = wrapped(...args);\n        return isPromise(result) ? result.then(() => {\n          return;\n        }) : undefined;\n      }), () => {\n        return result;\n      });\n    };\n  }\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/SupressedError.js\nclass PonyfillSuppressedError extends Error {\n  error;\n  suppressed;\n  constructor(error, suppressed, message) {\n    super(message);\n    this.error = error;\n    this.suppressed = suppressed;\n    this.name = "SuppressedError";\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/symbols.js\nvar DisposableSymbols = {\n  get dispose() {\n    return Symbol.dispose || Symbol.for("dispose");\n  },\n  get asyncDispose() {\n    return Symbol.asyncDispose || Symbol.for("asyncDispose");\n  }\n};\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/utils.js\nfunction isSyncDisposable(obj) {\n  return obj?.[DisposableSymbols.dispose] != null;\n}\nfunction isAsyncDisposable(obj) {\n  return obj?.[DisposableSymbols.asyncDispose] != null;\n}\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/AsyncDisposableStack.js\nvar SuppressedError2 = globalThis.SuppressedError || PonyfillSuppressedError;\n\nclass PonyfillAsyncDisposableStack {\n  callbacks = [];\n  get disposed() {\n    return this.callbacks.length === 0;\n  }\n  use(value) {\n    if (isAsyncDisposable(value)) {\n      this.callbacks.push(() => value[DisposableSymbols.asyncDispose]());\n    } else if (isSyncDisposable(value)) {\n      this.callbacks.push(() => value[DisposableSymbols.dispose]());\n    }\n    return value;\n  }\n  adopt(value, onDisposeAsync) {\n    if (onDisposeAsync) {\n      this.callbacks.push(() => onDisposeAsync(value));\n    }\n    return value;\n  }\n  defer(onDisposeAsync) {\n    if (onDisposeAsync) {\n      this.callbacks.push(onDisposeAsync);\n    }\n  }\n  move() {\n    const stack = new PonyfillAsyncDisposableStack;\n    stack.callbacks = this.callbacks;\n    this.callbacks = [];\n    return stack;\n  }\n  disposeAsync() {\n    return this[DisposableSymbols.asyncDispose]();\n  }\n  _error;\n  _iterateCallbacks() {\n    const cb = this.callbacks.pop();\n    if (cb) {\n      return handleMaybePromise(cb, () => this._iterateCallbacks(), (error) => {\n        this._error = this._error ? new SuppressedError2(error, this._error) : error;\n        return this._iterateCallbacks();\n      });\n    }\n  }\n  [DisposableSymbols.asyncDispose]() {\n    const res$ = this._iterateCallbacks();\n    if (res$?.then) {\n      return res$.then(() => {\n        if (this._error) {\n          const error = this._error;\n          this._error = undefined;\n          throw error;\n        }\n      });\n    }\n    if (this._error) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n    return;\n  }\n  [Symbol.toStringTag] = "AsyncDisposableStack";\n}\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/DisposableStack.js\nvar SuppressedError3 = globalThis.SuppressedError || PonyfillSuppressedError;\n\nclass PonyfillDisposableStack {\n  callbacks = [];\n  get disposed() {\n    return this.callbacks.length === 0;\n  }\n  use(value) {\n    if (isSyncDisposable(value)) {\n      this.callbacks.push(() => value[DisposableSymbols.dispose]());\n    }\n    return value;\n  }\n  adopt(value, onDispose) {\n    if (onDispose) {\n      this.callbacks.push(() => onDispose(value));\n    }\n    return value;\n  }\n  defer(onDispose) {\n    if (onDispose) {\n      this.callbacks.push(onDispose);\n    }\n  }\n  move() {\n    const stack = new PonyfillDisposableStack;\n    stack.callbacks = this.callbacks;\n    this.callbacks = [];\n    return stack;\n  }\n  dispose() {\n    return this[DisposableSymbols.dispose]();\n  }\n  _error;\n  _iterateCallbacks() {\n    const cb = this.callbacks.pop();\n    if (cb) {\n      try {\n        cb();\n      } catch (error) {\n        this._error = this._error ? new SuppressedError3(error, this._error) : error;\n      }\n      return this._iterateCallbacks();\n    }\n  }\n  [DisposableSymbols.dispose]() {\n    this._iterateCallbacks();\n    if (this._error) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n  }\n  [Symbol.toStringTag] = "DisposableStack";\n}\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/index.js\nvar DisposableStack = globalThis.DisposableStack || PonyfillDisposableStack;\nvar AsyncDisposableStack = globalThis.AsyncDisposableStack || PonyfillAsyncDisposableStack;\nvar SuppressedError4 = globalThis.SuppressedError || PonyfillSuppressedError;\n\n// ../../node_modules/@whatwg-node/fetch/dist/node-ponyfill.js\nvar exports_node_ponyfill = {};\n__export(exports_node_ponyfill, {\n  fetch: () => $fetch,\n  crypto: () => $crypto,\n  createFetch: () => $createFetch,\n  btoa: () => $btoa,\n  WritableStream: () => $WritableStream,\n  URLSearchParams: () => $URLSearchParams,\n  URLPattern: () => $URLPattern,\n  URL: () => $URL,\n  TransformStream: () => $TransformStream,\n  TextEncoderStream: () => $TextEncoderStream,\n  TextEncoder: () => $TextEncoder,\n  TextDecoderStream: () => $TextDecoderStream,\n  TextDecoder: () => $TextDecoder,\n  Response: () => $Response,\n  Request: () => $Request,\n  ReadableStream: () => $ReadableStream,\n  Headers: () => $Headers,\n  FormData: () => $FormData,\n  File: () => $File,\n  DecompressionStream: () => $DecompressionStream,\n  CompressionStream: () => $CompressionStream,\n  Blob: () => $Blob\n});\nvar createNodePonyfill = require_create_node_ponyfill();\nvar shouldSkipPonyfill = require_shouldSkipPonyfill();\nvar ponyfills = createNodePonyfill();\nif (!shouldSkipPonyfill()) {\n  try {\n    const nodelibcurlName = "node-libcurl";\n    globalThis.libcurl = globalThis.libcurl || __require(nodelibcurlName);\n  } catch (e) {}\n}\nvar $fetch = ponyfills.fetch;\nvar $Headers = ponyfills.Headers;\nvar $Request = ponyfills.Request;\nvar $Response = ponyfills.Response;\nvar $FormData = ponyfills.FormData;\nvar $ReadableStream = ponyfills.ReadableStream;\nvar $WritableStream = ponyfills.WritableStream;\nvar $TransformStream = ponyfills.TransformStream;\nvar $CompressionStream = ponyfills.CompressionStream;\nvar $DecompressionStream = ponyfills.DecompressionStream;\nvar $TextDecoderStream = ponyfills.TextDecoderStream;\nvar $TextEncoderStream = ponyfills.TextEncoderStream;\nvar $Blob = ponyfills.Blob;\nvar $File = ponyfills.File;\nvar $crypto = ponyfills.crypto;\nvar $btoa = ponyfills.btoa;\nvar $TextEncoder = ponyfills.TextEncoder;\nvar $TextDecoder = ponyfills.TextDecoder;\nvar $URLPattern = ponyfills.URLPattern;\nvar $URL = ponyfills.URL;\nvar $URLSearchParams = ponyfills.URLSearchParams;\nvar $createFetch = createNodePonyfill;\n// ../../node_modules/@whatwg-node/server/esm/utils.js\nfunction isAsyncIterable(body) {\n  return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";\n}\nfunction getPort(nodeRequest) {\n  if (nodeRequest.socket?.localPort) {\n    return nodeRequest.socket?.localPort;\n  }\n  const hostInHeader = nodeRequest.headers?.[":authority"] || nodeRequest.headers?.host;\n  const portInHeader = hostInHeader?.split(":")?.[1];\n  if (portInHeader) {\n    return portInHeader;\n  }\n  return 80;\n}\nfunction getHostnameWithPort(nodeRequest) {\n  if (nodeRequest.headers?.[":authority"]) {\n    return nodeRequest.headers?.[":authority"];\n  }\n  if (nodeRequest.headers?.host) {\n    return nodeRequest.headers?.host;\n  }\n  const port = getPort(nodeRequest);\n  if (nodeRequest.hostname) {\n    return nodeRequest.hostname + ":" + port;\n  }\n  const localIp = nodeRequest.socket?.localAddress;\n  if (localIp && !localIp?.includes("::") && !localIp?.includes("ffff")) {\n    return `${localIp}:${port}`;\n  }\n  return "localhost";\n}\nfunction buildFullUrl(nodeRequest) {\n  const hostnameWithPort = getHostnameWithPort(nodeRequest);\n  const protocol = nodeRequest.protocol || (nodeRequest.socket?.encrypted ? "https" : "http");\n  const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";\n  return `${protocol}://${hostnameWithPort}${endpoint}`;\n}\nfunction isRequestBody(body) {\n  const stringTag = body[Symbol.toStringTag];\n  if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable(body)) {\n    return true;\n  }\n  return false;\n}\nfunction normalizeNodeRequest(nodeRequest, fetchAPI, nodeResponse, __useCustomAbortCtrl) {\n  const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;\n  let fullUrl = buildFullUrl(rawRequest);\n  if (nodeRequest.query) {\n    const url = new fetchAPI.URL(fullUrl);\n    for (const key in nodeRequest.query) {\n      url.searchParams.set(key, nodeRequest.query[key]);\n    }\n    fullUrl = url.toString();\n  }\n  let normalizedHeaders = nodeRequest.headers;\n  if (nodeRequest.headers?.[":method"]) {\n    normalizedHeaders = {};\n    for (const key in nodeRequest.headers) {\n      if (!key.startsWith(":")) {\n        normalizedHeaders[key] = nodeRequest.headers[key];\n      }\n    }\n  }\n  const controller = __useCustomAbortCtrl ? createCustomAbortControllerSignal() : new AbortController;\n  if (nodeResponse?.once) {\n    const closeEventListener = () => {\n      if (!controller.signal.aborted) {\n        Object.defineProperty(rawRequest, "aborted", { value: true });\n        controller.abort(nodeResponse.errored ?? undefined);\n      }\n    };\n    nodeResponse.once("error", closeEventListener);\n    nodeResponse.once("close", closeEventListener);\n    nodeResponse.once("finish", () => {\n      nodeResponse.removeListener("close", closeEventListener);\n    });\n  }\n  if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {\n    return new fetchAPI.Request(fullUrl, {\n      method: nodeRequest.method,\n      headers: normalizedHeaders,\n      signal: controller.signal\n    });\n  }\n  const maybeParsedBody = nodeRequest.body;\n  if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {\n    if (isRequestBody(maybeParsedBody)) {\n      return new fetchAPI.Request(fullUrl, {\n        method: nodeRequest.method || "GET",\n        headers: normalizedHeaders,\n        body: maybeParsedBody,\n        signal: controller.signal\n      });\n    }\n    const request = new fetchAPI.Request(fullUrl, {\n      method: nodeRequest.method || "GET",\n      headers: normalizedHeaders,\n      signal: controller.signal\n    });\n    if (!request.headers.get("content-type")?.includes("json")) {\n      request.headers.set("content-type", "application/json; charset=utf-8");\n    }\n    return new Proxy(request, {\n      get: (target, prop, receiver) => {\n        switch (prop) {\n          case "json":\n            return () => fakePromise(maybeParsedBody);\n          case "text":\n            return () => fakePromise(JSON.stringify(maybeParsedBody));\n          default:\n            if (globalThis.Bun) {\n              return Reflect.get(target, prop);\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n      }\n    });\n  }\n  return new fetchAPI.Request(fullUrl, {\n    method: nodeRequest.method,\n    headers: normalizedHeaders,\n    signal: controller.signal,\n    body: rawRequest,\n    duplex: "half"\n  });\n}\nfunction isReadable(stream) {\n  return stream.read != null;\n}\nfunction isNodeRequest(request) {\n  return isReadable(request);\n}\nfunction isServerResponse(stream) {\n  return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;\n}\nfunction isReadableStream(stream) {\n  return stream != null && stream.getReader != null;\n}\nfunction isFetchEvent(event) {\n  return event != null && event.request != null && event.respondWith != null;\n}\nfunction configureSocket(rawRequest) {\n  rawRequest?.socket?.setTimeout?.(0);\n  rawRequest?.socket?.setNoDelay?.(true);\n  rawRequest?.socket?.setKeepAlive?.(true);\n}\nfunction endResponse(serverResponse) {\n  serverResponse.end(null, null, null);\n}\nfunction sendAsyncIterable(serverResponse, asyncIterable) {\n  let closed = false;\n  const closeEventListener = () => {\n    closed = true;\n  };\n  serverResponse.once("error", closeEventListener);\n  serverResponse.once("close", closeEventListener);\n  serverResponse.once("finish", () => {\n    serverResponse.removeListener("close", closeEventListener);\n    serverResponse.removeListener("error", closeEventListener);\n  });\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  const pump = () => iterator.next().then(({ done, value }) => {\n    if (closed || done) {\n      return;\n    }\n    return handleMaybePromise(() => safeWrite(value, serverResponse), () => closed ? endResponse(serverResponse) : pump());\n  });\n  return pump();\n}\nfunction safeWrite(chunk, serverResponse) {\n  const result = serverResponse.write(chunk);\n  if (!result) {\n    return new Promise((resolve) => serverResponse.once("drain", resolve));\n  }\n}\nfunction sendNodeResponse(fetchResponse, serverResponse, nodeRequest, __useSingleWriteHead) {\n  if (serverResponse.closed || serverResponse.destroyed || serverResponse.writableEnded) {\n    return;\n  }\n  if (!fetchResponse) {\n    serverResponse.statusCode = 404;\n    endResponse(serverResponse);\n    return;\n  }\n  if (__useSingleWriteHead && fetchResponse.headers?.headersInit && !Array.isArray(fetchResponse.headers.headersInit) && !fetchResponse.headers.headersInit.get && !fetchResponse.headers._map && !fetchResponse.headers._setCookies?.length) {\n    serverResponse.writeHead(fetchResponse.status, fetchResponse.statusText, fetchResponse.headers.headersInit);\n  } else {\n    if (serverResponse.setHeaders) {\n      serverResponse.setHeaders(fetchResponse.headers);\n    } else {\n      let setCookiesSet = false;\n      fetchResponse.headers.forEach((value, key) => {\n        if (key === "set-cookie") {\n          if (setCookiesSet) {\n            return;\n          }\n          setCookiesSet = true;\n          const setCookies = fetchResponse.headers.getSetCookie?.();\n          if (setCookies) {\n            serverResponse.setHeader("set-cookie", setCookies);\n            return;\n          }\n        }\n        serverResponse.setHeader(key, value);\n      });\n    }\n    serverResponse.writeHead(fetchResponse.status, fetchResponse.statusText);\n  }\n  if (fetchResponse["bodyType"] === "String") {\n    return handleMaybePromise(() => safeWrite(fetchResponse.bodyInit, serverResponse), () => endResponse(serverResponse));\n  }\n  const bufOfRes = fetchResponse._buffer;\n  if (bufOfRes) {\n    return handleMaybePromise(() => safeWrite(bufOfRes, serverResponse), () => endResponse(serverResponse));\n  }\n  const fetchBody = fetchResponse.body;\n  if (fetchBody == null) {\n    endResponse(serverResponse);\n    return;\n  }\n  if (fetchBody[Symbol.toStringTag] === "Uint8Array") {\n    return handleMaybePromise(() => safeWrite(fetchBody, serverResponse), () => endResponse(serverResponse));\n  }\n  configureSocket(nodeRequest);\n  if (isReadable(fetchBody)) {\n    serverResponse.once("close", () => {\n      fetchBody.destroy();\n    });\n    fetchBody.pipe(serverResponse, {\n      end: true\n    });\n    return;\n  }\n  if (isReadableStream(fetchBody)) {\n    return sendReadableStream(nodeRequest, serverResponse, fetchBody);\n  }\n  if (isAsyncIterable(fetchBody)) {\n    return sendAsyncIterable(serverResponse, fetchBody);\n  }\n}\nfunction sendReadableStream(nodeRequest, serverResponse, readableStream) {\n  const reader = readableStream.getReader();\n  nodeRequest?.once?.("error", (err) => {\n    reader.cancel(err);\n  });\n  function pump() {\n    return reader.read().then(({ done, value }) => done ? endResponse(serverResponse) : handleMaybePromise(() => safeWrite(value, serverResponse), pump));\n  }\n  return pump();\n}\nfunction isRequestInit(val) {\n  return val != null && typeof val === "object" && (("body" in val) || ("cache" in val) || ("credentials" in val) || ("headers" in val) || ("integrity" in val) || ("keepalive" in val) || ("method" in val) || ("mode" in val) || ("redirect" in val) || ("referrer" in val) || ("referrerPolicy" in val) || ("signal" in val) || ("window" in val));\n}\nfunction completeAssign(...args) {\n  const [target, ...sources] = args.filter((arg) => arg != null && typeof arg === "object");\n  sources.forEach((source) => {\n    const descriptors = Object.getOwnPropertyNames(source).reduce((descriptors2, key) => {\n      const descriptor = Object.getOwnPropertyDescriptor(source, key);\n      if (descriptor) {\n        descriptors2[key] = Object.getOwnPropertyDescriptor(source, key);\n      }\n      return descriptors2;\n    }, {});\n    Object.getOwnPropertySymbols(source).forEach((sym) => {\n      const descriptor = Object.getOwnPropertyDescriptor(source, sym);\n      if (descriptor?.enumerable) {\n        descriptors[sym] = descriptor;\n      }\n    });\n    Object.defineProperties(target, descriptors);\n  });\n  return target;\n}\nfunction handleErrorFromRequestHandler(error, ResponseCtor) {\n  return new ResponseCtor(error.stack || error.message || error.toString(), {\n    status: error.status || 500\n  });\n}\nfunction isolateObject(originalCtx, waitUntilFn) {\n  if (originalCtx == null) {\n    if (waitUntilFn == null) {\n      return {};\n    }\n    return {\n      waitUntil: waitUntilFn\n    };\n  }\n  return completeAssign(Object.create(originalCtx), {\n    waitUntil: waitUntilFn\n  }, originalCtx);\n}\nfunction handleAbortSignalAndPromiseResponse(response$, abortSignal) {\n  if (abortSignal?.aborted) {\n    throw abortSignal.reason;\n  }\n  if (isPromise(response$) && abortSignal) {\n    let abortSignalFetchErrorHandler = function() {\n      deferred$.reject(abortSignal.reason);\n    };\n    const deferred$ = createDeferredPromise();\n    abortSignal.addEventListener("abort", abortSignalFetchErrorHandler, { once: true });\n    response$.then(function fetchSuccessHandler(res) {\n      deferred$.resolve(res);\n    }).catch(function fetchErrorHandler(err) {\n      deferred$.reject(err);\n    }).finally(() => {\n      abortSignal.removeEventListener("abort", abortSignalFetchErrorHandler);\n    });\n    return deferred$.promise;\n  }\n  return response$;\n}\nvar decompressedResponseMap = new WeakMap;\nvar supportedEncodingsByFetchAPI = new WeakMap;\nvar terminateEvents = ["SIGINT", "exit", "SIGTERM"];\nvar disposableStacks = new Set;\nvar eventListenerRegistered = false;\nfunction ensureEventListenerForDisposableStacks() {\n  if (eventListenerRegistered) {\n    return;\n  }\n  eventListenerRegistered = true;\n  for (const event of terminateEvents) {\n    globalThis.process.once(event, function terminateHandler() {\n      return Promise.allSettled([...disposableStacks].map((stack) => !stack.disposed && stack.disposeAsync()));\n    });\n  }\n}\nfunction ensureDisposableStackRegisteredForTerminateEvents(disposableStack) {\n  if (globalThis.process) {\n    ensureEventListenerForDisposableStacks();\n    if (!disposableStacks.has(disposableStack)) {\n      disposableStacks.add(disposableStack);\n      disposableStack.defer(() => {\n        disposableStacks.delete(disposableStack);\n      });\n    }\n  }\n}\n\nclass CustomAbortControllerSignal extends EventTarget {\n  aborted = false;\n  _onabort = null;\n  _reason;\n  constructor() {\n    super();\n    const nodeEvents = globalThis.process?.getBuiltinModule?.("node:events");\n    if (nodeEvents?.kMaxEventTargetListeners) {\n      this[nodeEvents.kMaxEventTargetListeners] = 0;\n    }\n  }\n  throwIfAborted() {\n    if (this._nativeCtrl?.signal?.throwIfAborted) {\n      return this._nativeCtrl.signal.throwIfAborted();\n    }\n    if (this.aborted) {\n      throw this._reason;\n    }\n  }\n  _nativeCtrl;\n  ensureNativeCtrl() {\n    if (!this._nativeCtrl) {\n      const isAborted = this.aborted;\n      this._nativeCtrl = new AbortController;\n      if (isAborted) {\n        this._nativeCtrl.abort(this._reason);\n      }\n    }\n    return this._nativeCtrl;\n  }\n  abort(reason) {\n    if (this._nativeCtrl?.abort) {\n      return this._nativeCtrl?.abort(reason);\n    }\n    this._reason = reason || new DOMException("This operation was aborted", "AbortError");\n    this.aborted = true;\n    this.dispatchEvent(new Event("abort"));\n  }\n  get signal() {\n    if (this._nativeCtrl?.signal) {\n      return this._nativeCtrl.signal;\n    }\n    return this;\n  }\n  get reason() {\n    if (this._nativeCtrl?.signal) {\n      return this._nativeCtrl.signal.reason;\n    }\n    return this._reason;\n  }\n  get onabort() {\n    if (this._onabort) {\n      return this._onabort;\n    }\n    return this._onabort;\n  }\n  set onabort(value) {\n    if (this._nativeCtrl?.signal) {\n      this._nativeCtrl.signal.onabort = value;\n      return;\n    }\n    if (this._onabort) {\n      this.removeEventListener("abort", this._onabort);\n    }\n    this._onabort = value;\n    if (value) {\n      this.addEventListener("abort", value);\n    }\n  }\n}\nfunction createCustomAbortControllerSignal() {\n  if (globalThis.Bun || globalThis.Deno) {\n    return new AbortController;\n  }\n  return new Proxy(new CustomAbortControllerSignal, {\n    get(target, prop, receiver) {\n      if (prop.toString().includes("kDependantSignals")) {\n        const nativeCtrl = target.ensureNativeCtrl();\n        return Reflect.get(nativeCtrl.signal, prop, nativeCtrl.signal);\n      }\n      return Reflect.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n      if (prop.toString().includes("kDependantSignals")) {\n        const nativeCtrl = target.ensureNativeCtrl();\n        return Reflect.set(nativeCtrl.signal, prop, value, nativeCtrl.signal);\n      }\n      return Reflect.set(target, prop, value, receiver);\n    },\n    getPrototypeOf() {\n      return AbortSignal.prototype;\n    }\n  });\n}\n\n// ../../node_modules/@whatwg-node/server/esm/uwebsockets.js\nfunction isUWSResponse(res) {\n  return !!res.onData;\n}\nfunction getRequestFromUWSRequest({ req, res, fetchAPI, controller }) {\n  const method = req.getMethod();\n  let duplex;\n  const chunks = [];\n  const pushFns = [\n    (chunk) => {\n      chunks.push(chunk);\n    }\n  ];\n  const push = (chunk) => {\n    for (const pushFn of pushFns) {\n      pushFn(chunk);\n    }\n  };\n  let stopped = false;\n  const stopFns = [\n    () => {\n      stopped = true;\n    }\n  ];\n  const stop = () => {\n    for (const stopFn of stopFns) {\n      stopFn();\n    }\n  };\n  res.onData(function(ab, isLast) {\n    push(Buffer.from(Buffer.from(ab, 0, ab.byteLength)));\n    if (isLast) {\n      stop();\n    }\n  });\n  let getReadableStream;\n  if (method !== "get" && method !== "head") {\n    duplex = "half";\n    controller.signal.addEventListener("abort", () => {\n      stop();\n    }, { once: true });\n    let readableStream;\n    getReadableStream = () => {\n      if (!readableStream) {\n        readableStream = new fetchAPI.ReadableStream({\n          start(streamCtrl) {\n            for (const chunk of chunks) {\n              streamCtrl.enqueue(chunk);\n            }\n            if (stopped) {\n              streamCtrl.close();\n              return;\n            }\n            pushFns.push((chunk) => {\n              streamCtrl.enqueue(chunk);\n            });\n            stopFns.push(() => {\n              if (controller.signal.reason) {\n                streamCtrl.error(controller.signal.reason);\n                return;\n              }\n              if (streamCtrl.desiredSize) {\n                streamCtrl.close();\n              }\n            });\n          }\n        });\n      }\n      return readableStream;\n    };\n  }\n  const headers = new fetchAPI.Headers;\n  req.forEach((key, value) => {\n    headers.append(key, value);\n  });\n  let url = `http://localhost${req.getUrl()}`;\n  const query = req.getQuery();\n  if (query) {\n    url += `?${query}`;\n  }\n  let buffer;\n  function getBody() {\n    if (!getReadableStream) {\n      return null;\n    }\n    if (stopped) {\n      return getBufferFromChunks();\n    }\n    return getReadableStream();\n  }\n  const request = new fetchAPI.Request(url, {\n    method,\n    headers,\n    get body() {\n      return getBody();\n    },\n    signal: controller.signal,\n    duplex\n  });\n  function getBufferFromChunks() {\n    if (!buffer) {\n      buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks);\n    }\n    return buffer;\n  }\n  function collectBuffer() {\n    if (stopped) {\n      return fakePromise(getBufferFromChunks());\n    }\n    return new Promise((resolve, reject) => {\n      try {\n        stopFns.push(() => {\n          resolve(getBufferFromChunks());\n        });\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n  Object.defineProperties(request, {\n    body: {\n      get() {\n        return getBody();\n      },\n      configurable: true,\n      enumerable: true\n    },\n    json: {\n      value() {\n        return collectBuffer().then((b) => b.toString("utf8")).then((t) => JSON.parse(t));\n      },\n      configurable: true,\n      enumerable: true\n    },\n    text: {\n      value() {\n        return collectBuffer().then((b) => b.toString("utf8"));\n      },\n      configurable: true,\n      enumerable: true\n    },\n    arrayBuffer: {\n      value() {\n        return collectBuffer();\n      },\n      configurable: true,\n      enumerable: true\n    }\n  });\n  return request;\n}\nfunction createWritableFromUWS(uwsResponse, fetchAPI) {\n  return new fetchAPI.WritableStream({\n    write(chunk) {\n      uwsResponse.cork(() => {\n        uwsResponse.write(chunk);\n      });\n    },\n    close() {\n      uwsResponse.cork(() => {\n        uwsResponse.end();\n      });\n    }\n  });\n}\nfunction sendResponseToUwsOpts(uwsResponse, fetchResponse, controller, fetchAPI) {\n  if (!fetchResponse) {\n    uwsResponse.writeStatus("404 Not Found");\n    uwsResponse.end();\n    return;\n  }\n  const bufferOfRes = fetchResponse._buffer;\n  const strBody = fetchResponse["bodyType"] === "String" ? fetchResponse.bodyInit : undefined;\n  if (controller.signal.aborted) {\n    return;\n  }\n  uwsResponse.cork(() => {\n    uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);\n    for (const [key, value] of fetchResponse.headers) {\n      if (key !== "content-length") {\n        if (key === "set-cookie") {\n          const setCookies = fetchResponse.headers.getSetCookie?.();\n          if (setCookies) {\n            for (const setCookie of setCookies) {\n              uwsResponse.writeHeader(key, setCookie);\n            }\n            continue;\n          }\n        }\n        uwsResponse.writeHeader(key, value);\n      }\n    }\n    if (strBody) {\n      uwsResponse.end(strBody);\n    } else if (bufferOfRes) {\n      uwsResponse.end(bufferOfRes);\n    } else if (!fetchResponse.body) {\n      uwsResponse.end();\n    }\n  });\n  if (strBody || bufferOfRes || !fetchResponse.body) {\n    return;\n  }\n  controller.signal.addEventListener("abort", () => {\n    if (!fetchResponse.body?.locked) {\n      fetchResponse.body?.cancel(controller.signal.reason);\n    }\n  }, { once: true });\n  return fetchResponse.body.pipeTo(createWritableFromUWS(uwsResponse, fetchAPI), {\n    signal: controller.signal\n  }).catch((err) => {\n    if (controller.signal.aborted) {\n      return;\n    }\n    throw err;\n  });\n}\n\n// ../../node_modules/@whatwg-node/server/esm/createServerAdapter.js\nfunction isRequestAccessible(serverContext) {\n  try {\n    return !!serverContext?.request;\n  } catch {\n    return false;\n  }\n}\nvar EMPTY_OBJECT = {};\nfunction createServerAdapter(serverAdapterBaseObject, options) {\n  const useSingleWriteHead = options?.__useSingleWriteHead == null ? true : options.__useSingleWriteHead;\n  const fetchAPI = {\n    ...exports_node_ponyfill,\n    ...options?.fetchAPI\n  };\n  const useCustomAbortCtrl = options?.__useCustomAbortCtrl == null ? fetchAPI.Request !== globalThis.Request : options.__useCustomAbortCtrl;\n  const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;\n  const onRequestHooks = [];\n  const onResponseHooks = [];\n  let instrumentation;\n  const waitUntilPromises = new Set;\n  let _disposableStack;\n  function ensureDisposableStack() {\n    if (!_disposableStack) {\n      _disposableStack = new AsyncDisposableStack;\n      if (options?.disposeOnProcessTerminate) {\n        ensureDisposableStackRegisteredForTerminateEvents(_disposableStack);\n      }\n      _disposableStack.defer(() => {\n        if (waitUntilPromises.size > 0) {\n          return Promise.allSettled(waitUntilPromises).then(() => {\n            waitUntilPromises.clear();\n          }, () => {\n            waitUntilPromises.clear();\n          });\n        }\n      });\n    }\n    return _disposableStack;\n  }\n  function waitUntil(maybePromise) {\n    if (isPromise(maybePromise)) {\n      ensureDisposableStack();\n      waitUntilPromises.add(maybePromise);\n      maybePromise.then(() => {\n        waitUntilPromises.delete(maybePromise);\n      }, (err) => {\n        console.error(`Unexpected error while waiting: ${err.message || err}`);\n        waitUntilPromises.delete(maybePromise);\n      });\n    }\n  }\n  if (options?.plugins != null) {\n    for (const plugin of options.plugins) {\n      if (plugin.instrumentation) {\n        instrumentation = instrumentation ? chain(instrumentation, plugin.instrumentation) : plugin.instrumentation;\n      }\n      if (plugin.onRequest) {\n        onRequestHooks.push(plugin.onRequest);\n      }\n      if (plugin.onResponse) {\n        onResponseHooks.push(plugin.onResponse);\n      }\n      const disposeFn = plugin[DisposableSymbols.dispose];\n      if (disposeFn) {\n        ensureDisposableStack().defer(disposeFn);\n      }\n      const asyncDisposeFn = plugin[DisposableSymbols.asyncDispose];\n      if (asyncDisposeFn) {\n        ensureDisposableStack().defer(asyncDisposeFn);\n      }\n      if (plugin.onDispose) {\n        ensureDisposableStack().defer(plugin.onDispose);\n      }\n    }\n  }\n  let handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0 ? function handleRequest(request, serverContext) {\n    let requestHandler = givenHandleRequest;\n    let response;\n    if (onRequestHooks.length === 0) {\n      return handleEarlyResponse();\n    }\n    let url = request["parsedUrl"] || new Proxy(EMPTY_OBJECT, {\n      get(_target, prop, _receiver) {\n        url = new fetchAPI.URL(request.url, "http://localhost");\n        return Reflect.get(url, prop, url);\n      }\n    });\n    function handleResponse(response2) {\n      if (onResponseHooks.length === 0) {\n        return response2;\n      }\n      return handleMaybePromise(() => iterateAsync(onResponseHooks, (onResponseHook) => onResponseHook({\n        request,\n        response: response2,\n        serverContext,\n        setResponse(newResponse) {\n          response2 = newResponse;\n        },\n        fetchAPI\n      })), () => response2);\n    }\n    function handleEarlyResponse() {\n      if (!response) {\n        return handleMaybePromise(() => requestHandler(request, serverContext), handleResponse);\n      }\n      return handleResponse(response);\n    }\n    return handleMaybePromise(() => iterateAsync(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({\n      request,\n      setRequest(newRequest) {\n        request = newRequest;\n      },\n      serverContext,\n      fetchAPI,\n      url,\n      requestHandler,\n      setRequestHandler(newRequestHandler) {\n        requestHandler = newRequestHandler;\n      },\n      endResponse(newResponse) {\n        response = newResponse;\n        if (newResponse) {\n          stopEarly();\n        }\n      }\n    })), handleEarlyResponse);\n  } : givenHandleRequest;\n  if (instrumentation?.request) {\n    const originalRequestHandler = handleRequest;\n    handleRequest = (request, initialContext) => {\n      return getInstrumented({ request }).asyncFn(instrumentation.request, originalRequestHandler)(request, initialContext);\n    };\n  }\n  function handleNodeRequest(nodeRequest, ...ctx) {\n    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};\n    if (!serverContext.waitUntil) {\n      serverContext.waitUntil = waitUntil;\n    }\n    const request = normalizeNodeRequest(nodeRequest, fetchAPI, undefined, useCustomAbortCtrl);\n    return handleRequest(request, serverContext);\n  }\n  function handleNodeRequestAndResponse(nodeRequest, nodeResponseOrContainer, ...ctx) {\n    const nodeResponse = nodeResponseOrContainer.raw || nodeResponseOrContainer;\n    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};\n    if (!serverContext.waitUntil) {\n      serverContext.waitUntil = waitUntil;\n    }\n    const request = normalizeNodeRequest(nodeRequest, fetchAPI, nodeResponse, useCustomAbortCtrl);\n    return handleRequest(request, serverContext);\n  }\n  function requestListener(nodeRequest, nodeResponse, ...ctx) {\n    const defaultServerContext = {\n      req: nodeRequest,\n      res: nodeResponse,\n      waitUntil\n    };\n    return unfakePromise(fakePromise().then(() => handleNodeRequestAndResponse(nodeRequest, nodeResponse, defaultServerContext, ...ctx)).catch((err) => handleErrorFromRequestHandler(err, fetchAPI.Response)).then((response) => sendNodeResponse(response, nodeResponse, nodeRequest, useSingleWriteHead)).catch((err) => console.error(`Unexpected error while handling request: ${err.message || err}`)));\n  }\n  function handleUWS(res, req, ...ctx) {\n    const defaultServerContext = {\n      res,\n      req,\n      waitUntil\n    };\n    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);\n    const serverContext = filteredCtxParts.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;\n    const controller = useCustomAbortCtrl ? createCustomAbortControllerSignal() : new AbortController;\n    const originalResEnd = res.end.bind(res);\n    let resEnded = false;\n    res.end = function(data) {\n      resEnded = true;\n      return originalResEnd(data);\n    };\n    const originalOnAborted = res.onAborted.bind(res);\n    originalOnAborted(function() {\n      controller.abort();\n    });\n    res.onAborted = function(cb) {\n      controller.signal.addEventListener("abort", cb, { once: true });\n    };\n    const request = getRequestFromUWSRequest({\n      req,\n      res,\n      fetchAPI,\n      controller\n    });\n    return handleMaybePromise(() => handleMaybePromise(() => handleRequest(request, serverContext), (response) => response, (err) => handleErrorFromRequestHandler(err, fetchAPI.Response)), (response) => {\n      if (!controller.signal.aborted && !resEnded) {\n        return handleMaybePromise(() => sendResponseToUwsOpts(res, response, controller, fetchAPI), (r) => r, (err) => {\n          console.error(`Unexpected error while handling request: ${err.message || err}`);\n        });\n      }\n    });\n  }\n  function handleEvent(event, ...ctx) {\n    if (!event.respondWith || !event.request) {\n      throw new TypeError(`Expected FetchEvent, got ${event}`);\n    }\n    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);\n    const serverContext = filteredCtxParts.length > 0 ? completeAssign({}, event, ...filteredCtxParts) : isolateObject(event);\n    const response$ = handleRequest(event.request, serverContext);\n    event.respondWith(response$);\n  }\n  function handleRequestWithWaitUntil(request, ...ctx) {\n    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);\n    const serverContext = filteredCtxParts.length > 1 ? completeAssign({}, ...filteredCtxParts) : isolateObject(filteredCtxParts[0], filteredCtxParts[0] == null || filteredCtxParts[0].waitUntil == null ? waitUntil : undefined);\n    return handleRequest(request, serverContext);\n  }\n  const fetchFn = (input, ...maybeCtx) => {\n    if (typeof input === "string" || "href" in input) {\n      const [initOrCtx, ...restOfCtx] = maybeCtx;\n      if (isRequestInit(initOrCtx)) {\n        const request2 = new fetchAPI.Request(input, initOrCtx);\n        const res$2 = handleRequestWithWaitUntil(request2, ...restOfCtx);\n        const signal = initOrCtx.signal;\n        if (signal) {\n          return handleAbortSignalAndPromiseResponse(res$2, signal);\n        }\n        return res$2;\n      }\n      const request = new fetchAPI.Request(input);\n      return handleRequestWithWaitUntil(request, ...maybeCtx);\n    }\n    const res$ = handleRequestWithWaitUntil(input, ...maybeCtx);\n    return handleAbortSignalAndPromiseResponse(res$, input.signal);\n  };\n  const genericRequestHandler = (input, ...maybeCtx) => {\n    const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;\n    if (isNodeRequest(input)) {\n      if (!isServerResponse(initOrCtxOrRes)) {\n        throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);\n      }\n      return requestListener(input, initOrCtxOrRes, ...restOfCtx);\n    }\n    if (isUWSResponse(input)) {\n      return handleUWS(input, initOrCtxOrRes, ...restOfCtx);\n    }\n    if (isServerResponse(initOrCtxOrRes)) {\n      throw new TypeError("Got Node response without Node request");\n    }\n    if (isRequestAccessible(input)) {\n      if (isFetchEvent(input)) {\n        return handleEvent(input, ...maybeCtx);\n      }\n      return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);\n    }\n    return fetchFn(input, ...maybeCtx);\n  };\n  const adapterObj = {\n    handleRequest: handleRequestWithWaitUntil,\n    fetch: fetchFn,\n    handleNodeRequest,\n    handleNodeRequestAndResponse,\n    requestListener,\n    handleEvent,\n    handleUWS,\n    handle: genericRequestHandler,\n    get disposableStack() {\n      return ensureDisposableStack();\n    },\n    [DisposableSymbols.asyncDispose]() {\n      if (_disposableStack && !_disposableStack.disposed) {\n        return _disposableStack.disposeAsync();\n      }\n      return fakePromise();\n    },\n    dispose() {\n      if (_disposableStack && !_disposableStack.disposed) {\n        return _disposableStack.disposeAsync();\n      }\n      return fakePromise();\n    },\n    waitUntil\n  };\n  const serverAdapter = new Proxy(genericRequestHandler, {\n    has: (_, prop) => {\n      return prop in adapterObj || prop in genericRequestHandler || serverAdapterBaseObject && prop in serverAdapterBaseObject;\n    },\n    get: (_, prop) => {\n      if (globalThis.Deno || prop === Symbol.asyncDispose || prop === Symbol.dispose) {\n        const adapterProp2 = Reflect.get(adapterObj, prop, adapterObj);\n        if (adapterProp2) {\n          return adapterProp2;\n        }\n      }\n      const adapterProp = adapterObj[prop];\n      if (adapterProp) {\n        if (adapterProp.bind) {\n          return adapterProp.bind(adapterObj);\n        }\n        return adapterProp;\n      }\n      const handleProp = genericRequestHandler[prop];\n      if (handleProp) {\n        if (handleProp.bind) {\n          return handleProp.bind(genericRequestHandler);\n        }\n        return handleProp;\n      }\n      if (serverAdapterBaseObject) {\n        const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];\n        if (serverAdapterBaseObjectProp) {\n          if (serverAdapterBaseObjectProp.bind) {\n            return function(...args) {\n              const returnedVal = serverAdapterBaseObject[prop](...args);\n              if (returnedVal === serverAdapterBaseObject) {\n                return serverAdapter;\n              }\n              return returnedVal;\n            };\n          }\n          return serverAdapterBaseObjectProp;\n        }\n      }\n    },\n    apply(_, __, args) {\n      return genericRequestHandler(...args);\n    }\n  });\n  return serverAdapter;\n}\n\n// ../api/src/routes/agents/me/me.client.ts\nclass AgentInvocationClient {\n  baseURL;\n  authToken;\n  constructor(options) {\n    this.baseURL = options?.baseURL ?? "https://blink.so";\n    this.authToken = options?.authToken;\n  }\n  async deleteStorage(key) {\n    const resp = await this.request("DELETE", `/api/agents/me/storage/${encodeURIComponent(key)}`);\n    await this.assertResponseStatus(resp, 204);\n  }\n  async setStorage(key, value, options) {\n    const searchParams = new URLSearchParams;\n    if (options?.ttl) {\n      searchParams.set("ttl", options.ttl.toString());\n    }\n    const resp = await this.request("PUT", `/api/agents/me/storage/${encodeURIComponent(key)}?${searchParams.toString()}`, value);\n    await this.assertResponseStatus(resp, 204);\n  }\n  async getStorage(key) {\n    const resp = await this.request("GET", `/api/agents/me/storage/${encodeURIComponent(key)}`);\n    if (resp.status === 404) {\n      return;\n    }\n    await this.assertResponseStatus(resp, 200);\n    return await resp.text();\n  }\n  async listStorage(prefix, options) {\n    const resp = await this.request("GET", `/api/agents/me/storage`, JSON.stringify({ prefix, limit: options?.limit, cursor: options?.cursor }));\n    await this.assertResponseStatus(resp, 200);\n    return await resp.json();\n  }\n  async upsertChat(key) {\n    const resp = await this.request("PUT", `/api/agents/me/chats/${encodeURIComponent(key)}`);\n    if (resp.status !== 200 && resp.status !== 204) {\n      await this.assertResponseStatus(resp, 200);\n    }\n    return await resp.json();\n  }\n  async sendMessages(key, request) {\n    const resp = await this.request("POST", `/api/agents/me/chats/${encodeURIComponent(key)}/messages`, JSON.stringify(request));\n    await this.assertResponseStatus(resp, 204);\n  }\n  async getChat(id) {\n    const resp = await this.request("GET", `/api/agents/me/chats/${encodeURIComponent(id)}`);\n    if (resp.status === 404) {\n      return;\n    }\n    await this.assertResponseStatus(resp, 200);\n    return await resp.json();\n  }\n  async deleteChat(id) {\n    const resp = await this.request("DELETE", `/api/agents/me/chats/${encodeURIComponent(id)}`);\n    await this.assertResponseStatus(resp, 204);\n  }\n  async startChat(id) {\n    const resp = await this.request("POST", `/api/agents/me/chats/${encodeURIComponent(id)}/start`);\n    await this.assertResponseStatus(resp, 204);\n  }\n  async stopChat(id) {\n    const resp = await this.request("POST", `/api/agents/me/chats/${encodeURIComponent(id)}/stop`);\n    await this.assertResponseStatus(resp, 204);\n  }\n  async getMessages(id) {\n    const resp = await this.request("GET", `/api/agents/me/chats/${encodeURIComponent(id)}/messages`);\n    await this.assertResponseStatus(resp, 200);\n    return await resp.json();\n  }\n  async deleteMessages(id, messageIds) {\n    const resp = await this.request("POST", `/api/agents/me/chats/${encodeURIComponent(id)}/messages/delete`, JSON.stringify({ message_ids: messageIds }));\n    await this.assertResponseStatus(resp, 204);\n  }\n  async proxyOtlpTraces(request) {\n    if (!this.authToken) {\n      const contentType = request.headers.get("content-type")?.toLowerCase() || "";\n      if (contentType.includes("application/x-protobuf")) {\n        return new Response(new Uint8Array(0), {\n          status: 200,\n          headers: { "Content-Type": "application/x-protobuf" }\n        });\n      }\n      return new Response(JSON.stringify({}), {\n        status: 200,\n        headers: { "Content-Type": "application/json" }\n      });\n    }\n    const hopByHopHeaders = new Set([\n      "transfer-encoding",\n      "content-length",\n      "host",\n      "connection",\n      "keep-alive",\n      "proxy-authenticate",\n      "proxy-authorization",\n      "te",\n      "trailer",\n      "upgrade"\n    ]);\n    const headers = {};\n    request.headers.forEach((value, key) => {\n      if (hopByHopHeaders.has(key.toLowerCase())) {\n        return;\n      }\n      headers[key] = value;\n    });\n    return this.request(request.method, `/api/otlp/v1/traces`, request.body ?? undefined, { headers });\n  }\n  async assertResponseStatus(resp, status) {\n    if (resp.status === status) {\n      return;\n    }\n    const body = await resp.text();\n    try {\n      const parsed = JSON.parse(body);\n      if (parsed.error) {\n        throw new Error(parsed.error);\n      }\n      throw new Error(body);\n    } catch (err) {\n      throw new Error(`Expected status ${status}, got ${resp.status}: ${body}`);\n    }\n  }\n  request(method, path, body, options) {\n    const url = new URL(path, this.baseURL);\n    const headers = new Headers;\n    if (this.authToken) {\n      headers.set("Authorization", `Bearer ${this.authToken}`);\n    }\n    if (typeof body === "string") {\n      headers.set("Content-Type", "application/json");\n    }\n    if (options?.headers) {\n      for (const [key, value] of Object.entries(options.headers)) {\n        headers.set(key, value);\n      }\n    }\n    let signal;\n    if (options?.timeout) {\n      signal = AbortSignal.timeout(options.timeout);\n    }\n    return fetch(url.toString(), {\n      method,\n      headers,\n      body,\n      signal,\n      duplex: body ? "half" : undefined\n    });\n  }\n}\n\n// ../../node_modules/blink/dist/browser/cookie-C6gQJ2Nm.js\nvar e = (e2) => {\n  let t = e2.split(`/`);\n  return t[0] === `` && t.shift(), t;\n};\nvar t = (t2) => {\n  let { groups: i, path: a } = n(t2), o = e(a);\n  return r(o, i);\n};\nvar n = (e2) => {\n  let t2 = [];\n  return e2 = e2.replace(/\\{[^}]+\\}/g, (e3, n2) => {\n    let r = `@${n2}`;\n    return t2.push([r, e3]), r;\n  }), { groups: t2, path: e2 };\n};\nvar r = (e2, t2) => {\n  for (let n2 = t2.length - 1;n2 >= 0; n2--) {\n    let [r2] = t2[n2];\n    for (let i = e2.length - 1;i >= 0; i--)\n      if (e2[i].includes(r2)) {\n        e2[i] = e2[i].replace(r2, t2[n2][1]);\n        break;\n      }\n  }\n  return e2;\n};\nvar i = {};\nvar a = (e2, t2) => {\n  if (e2 === `*`)\n    return `*`;\n  let n2 = e2.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n  if (n2) {\n    let r2 = `${e2}#${t2}`;\n    return i[r2] || (n2[2] ? i[r2] = t2 && t2[0] !== `:` && t2[0] !== `*` ? [r2, n2[1], RegExp(`^${n2[2]}(?=/${t2})`)] : [e2, n2[1], RegExp(`^${n2[2]}$`)] : i[r2] = [e2, n2[1], true]), i[r2];\n  }\n  return null;\n};\nvar o = (e2, t2) => {\n  try {\n    return t2(e2);\n  } catch {\n    return e2.replace(/(?:%[0-9A-Fa-f]{2})+/g, (e3) => {\n      try {\n        return t2(e3);\n      } catch {\n        return e3;\n      }\n    });\n  }\n};\nvar s = (e2) => o(e2, decodeURI);\nvar c = (e2) => {\n  let t2 = e2.url, n2 = t2.indexOf(`/`, t2.indexOf(`:`) + 4), r2 = n2;\n  for (;r2 < t2.length; r2++) {\n    let e3 = t2.charCodeAt(r2);\n    if (e3 === 37) {\n      let e4 = t2.indexOf(`?`, r2), i2 = t2.slice(n2, e4 === -1 ? undefined : e4);\n      return s(i2.includes(`%25`) ? i2.replace(/%25/g, `%2525`) : i2);\n    } else if (e3 === 63)\n      break;\n  }\n  return t2.slice(n2, r2);\n};\nvar l = (e2) => {\n  let t2 = c(e2);\n  return t2.length > 1 && t2.at(-1) === `/` ? t2.slice(0, -1) : t2;\n};\nvar u = (e2, t2, ...n2) => (n2.length && (t2 = u(t2, ...n2)), `${e2?.[0] === `/` ? `` : `/`}${e2}${t2 === `/` ? `` : `${e2?.at(-1) === `/` ? `` : `/`}${t2?.[0] === `/` ? t2.slice(1) : t2}`}`);\nvar d = (e2) => {\n  if (e2.charCodeAt(e2.length - 1) !== 63 || !e2.includes(`:`))\n    return null;\n  let t2 = e2.split(`/`), n2 = [], r2 = ``;\n  return t2.forEach((e3) => {\n    if (e3 !== `` && !/\\:/.test(e3))\n      r2 += `/` + e3;\n    else if (/\\:/.test(e3))\n      if (/\\?/.test(e3)) {\n        n2.length === 0 && r2 === `` ? n2.push(`/`) : n2.push(r2);\n        let t3 = e3.replace(`?`, ``);\n        r2 += `/` + t3, n2.push(r2);\n      } else\n        r2 += `/` + e3;\n  }), n2.filter((e3, t3, n3) => n3.indexOf(e3) === t3);\n};\nvar f = (e2) => /[%+]/.test(e2) ? (e2.indexOf(`+`) !== -1 && (e2 = e2.replace(/\\+/g, ` `)), e2.indexOf(`%`) === -1 ? e2 : o(e2, g)) : e2;\nvar p = (e2, t2, n2) => {\n  let r2;\n  if (!n2 && t2 && !/[%+]/.test(t2)) {\n    let n3 = e2.indexOf(`?${t2}`, 8);\n    for (n3 === -1 && (n3 = e2.indexOf(`&${t2}`, 8));n3 !== -1; ) {\n      let r3 = e2.charCodeAt(n3 + t2.length + 1);\n      if (r3 === 61) {\n        let r4 = n3 + t2.length + 2, i3 = e2.indexOf(`&`, r4);\n        return f(e2.slice(r4, i3 === -1 ? undefined : i3));\n      } else if (r3 == 38 || isNaN(r3))\n        return ``;\n      n3 = e2.indexOf(`&${t2}`, n3 + 1);\n    }\n    if (r2 = /[%+]/.test(e2), !r2)\n      return;\n  }\n  let i2 = {};\n  r2 ??= /[%+]/.test(e2);\n  let a2 = e2.indexOf(`?`, 8);\n  for (;a2 !== -1; ) {\n    let t3 = e2.indexOf(`&`, a2 + 1), o2 = e2.indexOf(`=`, a2);\n    o2 > t3 && t3 !== -1 && (o2 = -1);\n    let s2 = e2.slice(a2 + 1, o2 === -1 ? t3 === -1 ? undefined : t3 : o2);\n    if (r2 && (s2 = f(s2)), a2 = t3, s2 === ``)\n      continue;\n    let c2;\n    o2 === -1 ? c2 = `` : (c2 = e2.slice(o2 + 1, t3 === -1 ? undefined : t3), r2 && (c2 = f(c2))), n2 ? (i2[s2] && Array.isArray(i2[s2]) || (i2[s2] = []), i2[s2].push(c2)) : i2[s2] ??= c2;\n  }\n  return t2 ? i2[t2] : i2;\n};\nvar m = p;\nvar h = (e2, t2) => p(e2, t2, true);\nvar g = decodeURIComponent;\nvar _ = /^[\\w!#$%&\'*.^`|~+-]+$/;\nvar v = /^[ !#-:<-[\\]-~]*$/;\nvar y = (e2, t2) => {\n  if (t2 && e2.indexOf(t2) === -1)\n    return {};\n  let n2 = e2.trim().split(`;`), r2 = {};\n  for (let e3 of n2) {\n    e3 = e3.trim();\n    let n3 = e3.indexOf(`=`);\n    if (n3 === -1)\n      continue;\n    let i2 = e3.substring(0, n3).trim();\n    if (t2 && t2 !== i2 || !_.test(i2))\n      continue;\n    let a2 = e3.substring(n3 + 1).trim();\n    if (a2.startsWith(`"`) && a2.endsWith(`"`) && (a2 = a2.slice(1, -1)), v.test(a2) && (r2[i2] = a2.indexOf(`%`) === -1 ? a2 : o(a2, g), t2))\n      break;\n  }\n  return r2;\n};\n\n// ../../node_modules/blink/dist/browser/control/index.js\nvar f2 = (e2, t2, n2) => (r2, i2) => {\n  let a2 = -1;\n  return o2(0);\n  async function o2(s2) {\n    if (s2 <= a2)\n      throw Error(`next() called multiple times`);\n    a2 = s2;\n    let c2, l2 = false, u2;\n    if (e2[s2] ? (u2 = e2[s2][0][0], r2.req.routeIndex = s2) : u2 = s2 === e2.length && i2 || undefined, u2)\n      try {\n        c2 = await u2(r2, () => o2(s2 + 1));\n      } catch (e3) {\n        if (e3 instanceof Error && t2)\n          r2.error = e3, c2 = await t2(e3, r2), l2 = true;\n        else\n          throw e3;\n      }\n    else\n      r2.finalized === false && n2 && (c2 = await n2(r2));\n    return c2 && (r2.finalized === false || l2) && (r2.res = c2), r2;\n  }\n};\nvar p2 = Symbol();\nvar m2 = async (e2, t2 = Object.create(null)) => {\n  let { all: n2 = false, dot: r2 = false } = t2, i2 = (e2 instanceof y2 ? e2.raw.headers : e2.headers).get(`Content-Type`);\n  return i2?.startsWith(`multipart/form-data`) || i2?.startsWith(`application/x-www-form-urlencoded`) ? h2(e2, { all: n2, dot: r2 }) : {};\n};\nasync function h2(e2, t2) {\n  let n2 = await e2.formData();\n  return n2 ? g2(n2, t2) : {};\n}\nfunction g2(e2, t2) {\n  let n2 = Object.create(null);\n  return e2.forEach((e3, r2) => {\n    t2.all || r2.endsWith(`[]`) ? ee(n2, r2, e3) : n2[r2] = e3;\n  }), t2.dot && Object.entries(n2).forEach(([e3, t3]) => {\n    e3.includes(`.`) && (_2(n2, e3, t3), delete n2[e3]);\n  }), n2;\n}\nvar ee = (e2, t2, n2) => {\n  e2[t2] === undefined ? t2.endsWith(`[]`) ? e2[t2] = [n2] : e2[t2] = n2 : Array.isArray(e2[t2]) ? e2[t2].push(n2) : e2[t2] = [e2[t2], n2];\n};\nvar _2 = (e2, t2, n2) => {\n  let r2 = e2, i2 = t2.split(`.`);\n  i2.forEach((e3, t3) => {\n    t3 === i2.length - 1 ? r2[e3] = n2 : ((!r2[e3] || typeof r2[e3] != `object` || Array.isArray(r2[e3]) || r2[e3] instanceof File) && (r2[e3] = Object.create(null)), r2 = r2[e3]);\n  });\n};\nvar v2 = (e2) => o(e2, g);\nvar y2 = class {\n  raw;\n  #validatedData;\n  #matchResult;\n  routeIndex = 0;\n  path;\n  bodyCache = {};\n  constructor(e2, t2 = `/`, n2 = [[]]) {\n    this.raw = e2, this.path = t2, this.#matchResult = n2, this.#validatedData = {};\n  }\n  param(e2) {\n    return e2 ? this.#getDecodedParam(e2) : this.#getAllDecodedParams();\n  }\n  #getDecodedParam(e2) {\n    let t2 = this.#matchResult[0][this.routeIndex][1][e2], n2 = this.#getParamValue(t2);\n    return n2 && /\\%/.test(n2) ? v2(n2) : n2;\n  }\n  #getAllDecodedParams() {\n    let e2 = {}, t2 = Object.keys(this.#matchResult[0][this.routeIndex][1]);\n    for (let n2 of t2) {\n      let t3 = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][n2]);\n      t3 !== undefined && (e2[n2] = /\\%/.test(t3) ? v2(t3) : t3);\n    }\n    return e2;\n  }\n  #getParamValue(e2) {\n    return this.#matchResult[1] ? this.#matchResult[1][e2] : e2;\n  }\n  query(e2) {\n    return m(this.url, e2);\n  }\n  queries(e2) {\n    return h(this.url, e2);\n  }\n  header(e2) {\n    if (e2)\n      return this.raw.headers.get(e2) ?? undefined;\n    let t2 = {};\n    return this.raw.headers.forEach((e3, n2) => {\n      t2[n2] = e3;\n    }), t2;\n  }\n  async parseBody(e2) {\n    return this.bodyCache.parsedBody ??= await m2(this, e2);\n  }\n  #cachedBody = (e2) => {\n    let { bodyCache: t2, raw: n2 } = this, r2 = t2[e2];\n    if (r2)\n      return r2;\n    let i2 = Object.keys(t2)[0];\n    return i2 ? t2[i2].then((t3) => (i2 === `json` && (t3 = JSON.stringify(t3)), new Response(t3)[e2]())) : t2[e2] = n2[e2]();\n  };\n  json() {\n    return this.#cachedBody(`text`).then((e2) => JSON.parse(e2));\n  }\n  text() {\n    return this.#cachedBody(`text`);\n  }\n  arrayBuffer() {\n    return this.#cachedBody(`arrayBuffer`);\n  }\n  blob() {\n    return this.#cachedBody(`blob`);\n  }\n  formData() {\n    return this.#cachedBody(`formData`);\n  }\n  addValidatedData(e2, t2) {\n    this.#validatedData[e2] = t2;\n  }\n  valid(e2) {\n    return this.#validatedData[e2];\n  }\n  get url() {\n    return this.raw.url;\n  }\n  get method() {\n    return this.raw.method;\n  }\n  get [p2]() {\n    return this.#matchResult;\n  }\n  get matchedRoutes() {\n    return this.#matchResult[0].map(([[, e2]]) => e2);\n  }\n  get routePath() {\n    return this.#matchResult[0].map(([[, e2]]) => e2)[this.routeIndex].path;\n  }\n};\nvar te = { Stringify: 1, BeforeStream: 2, Stream: 3 };\nvar ne = (e2, t2) => {\n  let n2 = new String(e2);\n  return n2.isEscaped = true, n2.callbacks = t2, n2;\n};\nvar b = async (e2, t2, n2, r2, i2) => {\n  typeof e2 == `object` && !(e2 instanceof String) && (e2 instanceof Promise || (e2 = e2.toString()), e2 instanceof Promise && (e2 = await e2));\n  let a2 = e2.callbacks;\n  if (!a2?.length)\n    return Promise.resolve(e2);\n  i2 ? i2[0] += e2 : i2 = [e2];\n  let o2 = Promise.all(a2.map((e3) => e3({ phase: t2, buffer: i2, context: r2 }))).then((e3) => Promise.all(e3.filter(Boolean).map((e4) => b(e4, t2, false, r2, i2))).then(() => i2[0]));\n  return n2 ? ne(await o2, a2) : o2;\n};\nvar x = `text/plain; charset=UTF-8`;\nvar S = (e2, t2) => ({ "Content-Type": e2, ...t2 });\nvar re = class {\n  #rawRequest;\n  #req;\n  env = {};\n  #var;\n  finalized = false;\n  error;\n  #status;\n  #executionCtx;\n  #res;\n  #layout;\n  #renderer;\n  #notFoundHandler;\n  #preparedHeaders;\n  #matchResult;\n  #path;\n  constructor(e2, t2) {\n    this.#rawRequest = e2, t2 && (this.#executionCtx = t2.executionCtx, this.env = t2.env, this.#notFoundHandler = t2.notFoundHandler, this.#path = t2.path, this.#matchResult = t2.matchResult);\n  }\n  get req() {\n    return this.#req ??= new y2(this.#rawRequest, this.#path, this.#matchResult), this.#req;\n  }\n  get event() {\n    if (this.#executionCtx && `respondWith` in this.#executionCtx)\n      return this.#executionCtx;\n    throw Error(`This context has no FetchEvent`);\n  }\n  get executionCtx() {\n    if (this.#executionCtx)\n      return this.#executionCtx;\n    throw Error(`This context has no ExecutionContext`);\n  }\n  get res() {\n    return this.#res ||= new Response(null, { headers: this.#preparedHeaders ??= new Headers });\n  }\n  set res(e2) {\n    if (this.#res && e2) {\n      e2 = new Response(e2.body, e2);\n      for (let [t2, n2] of this.#res.headers.entries())\n        if (t2 !== `content-type`)\n          if (t2 === `set-cookie`) {\n            let t3 = this.#res.headers.getSetCookie();\n            e2.headers.delete(`set-cookie`);\n            for (let n3 of t3)\n              e2.headers.append(`set-cookie`, n3);\n          } else\n            e2.headers.set(t2, n2);\n    }\n    this.#res = e2, this.finalized = true;\n  }\n  render = (...e2) => (this.#renderer ??= (e3) => this.html(e3), this.#renderer(...e2));\n  setLayout = (e2) => this.#layout = e2;\n  getLayout = () => this.#layout;\n  setRenderer = (e2) => {\n    this.#renderer = e2;\n  };\n  header = (e2, t2, n2) => {\n    this.finalized && (this.#res = new Response(this.#res.body, this.#res));\n    let r2 = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers;\n    t2 === undefined ? r2.delete(e2) : n2?.append ? r2.append(e2, t2) : r2.set(e2, t2);\n  };\n  status = (e2) => {\n    this.#status = e2;\n  };\n  set = (e2, t2) => {\n    this.#var ??= new Map, this.#var.set(e2, t2);\n  };\n  get = (e2) => this.#var ? this.#var.get(e2) : undefined;\n  get var() {\n    return this.#var ? Object.fromEntries(this.#var) : {};\n  }\n  #newResponse(e2, t2, n2) {\n    let r2 = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers;\n    if (typeof t2 == `object` && `headers` in t2) {\n      let e3 = t2.headers instanceof Headers ? t2.headers : new Headers(t2.headers);\n      for (let [t3, n3] of e3)\n        t3.toLowerCase() === `set-cookie` ? r2.append(t3, n3) : r2.set(t3, n3);\n    }\n    if (n2)\n      for (let [e3, t3] of Object.entries(n2))\n        if (typeof t3 == `string`)\n          r2.set(e3, t3);\n        else {\n          r2.delete(e3);\n          for (let n3 of t3)\n            r2.append(e3, n3);\n        }\n    let i2 = typeof t2 == `number` ? t2 : t2?.status ?? this.#status;\n    return new Response(e2, { status: i2, headers: r2 });\n  }\n  newResponse = (...e2) => this.#newResponse(...e2);\n  body = (e2, t2, n2) => this.#newResponse(e2, t2, n2);\n  text = (e2, t2, n2) => !this.#preparedHeaders && !this.#status && !t2 && !n2 && !this.finalized ? new Response(e2) : this.#newResponse(e2, t2, S(x, n2));\n  json = (e2, t2, n2) => this.#newResponse(JSON.stringify(e2), t2, S(`application/json`, n2));\n  html = (e2, t2, n2) => {\n    let r2 = (e3) => this.#newResponse(e3, t2, S(`text/html; charset=UTF-8`, n2));\n    return typeof e2 == `object` ? b(e2, te.Stringify, false, {}).then(r2) : r2(e2);\n  };\n  redirect = (e2, t2) => {\n    let n2 = String(e2);\n    return this.header(`Location`, /[^\\x00-\\xFF]/.test(n2) ? encodeURI(n2) : n2), this.newResponse(null, t2 ?? 302);\n  };\n  notFound = () => (this.#notFoundHandler ??= () => new Response, this.#notFoundHandler(this));\n};\nvar C = `ALL`;\nvar ie = `all`;\nvar ae = [`get`, `post`, `put`, `delete`, `options`, `patch`];\nvar w = `Can not add a route since the matcher is already built.`;\nvar T = class extends Error {\n};\nvar E = `__COMPOSED_HANDLER`;\nvar D = (e2) => e2.text(`404 Not Found`, 404);\nvar O = (e2, t2) => {\n  if (`getResponse` in e2) {\n    let n2 = e2.getResponse();\n    return t2.newResponse(n2.body, n2);\n  }\n  return console.error(e2), t2.text(`Internal Server Error`, 500);\n};\nvar k = class {\n  get;\n  post;\n  put;\n  delete;\n  options;\n  patch;\n  all;\n  on;\n  use;\n  router;\n  getPath;\n  _basePath = `/`;\n  #path = `/`;\n  routes = [];\n  constructor(e2 = {}) {\n    [...ae, ie].forEach((e3) => {\n      this[e3] = (t3, ...n2) => (typeof t3 == `string` ? this.#path = t3 : this.#addRoute(e3, this.#path, t3), n2.forEach((t4) => {\n        this.#addRoute(e3, this.#path, t4);\n      }), this);\n    }), this.on = (e3, t3, ...n2) => {\n      for (let r2 of [t3].flat()) {\n        this.#path = r2;\n        for (let t4 of [e3].flat())\n          n2.map((e4) => {\n            this.#addRoute(t4.toUpperCase(), this.#path, e4);\n          });\n      }\n      return this;\n    }, this.use = (e3, ...t3) => (typeof e3 == `string` ? this.#path = e3 : (this.#path = `*`, t3.unshift(e3)), t3.forEach((e4) => {\n      this.#addRoute(C, this.#path, e4);\n    }), this);\n    let { strict: t2, ...i2 } = e2;\n    Object.assign(this, i2), this.getPath = t2 ?? true ? e2.getPath ?? c : l;\n  }\n  #clone() {\n    let e2 = new k({ router: this.router, getPath: this.getPath });\n    return e2.errorHandler = this.errorHandler, e2.#notFoundHandler = this.#notFoundHandler, e2.routes = this.routes, e2;\n  }\n  #notFoundHandler = D;\n  errorHandler = O;\n  route(e2, t2) {\n    let n2 = this.basePath(e2);\n    return t2.routes.map((e3) => {\n      let r2;\n      t2.errorHandler === O ? r2 = e3.handler : (r2 = async (n3, r3) => (await f2([], t2.errorHandler)(n3, () => e3.handler(n3, r3))).res, r2[E] = e3.handler), n2.#addRoute(e3.method, e3.path, r2);\n    }), this;\n  }\n  basePath(e2) {\n    let t2 = this.#clone();\n    return t2._basePath = u(this._basePath, e2), t2;\n  }\n  onError = (e2) => (this.errorHandler = e2, this);\n  notFound = (e2) => (this.#notFoundHandler = e2, this);\n  mount(e2, t2, n2) {\n    let r2, i2;\n    n2 && (typeof n2 == `function` ? i2 = n2 : (i2 = n2.optionHandler, r2 = n2.replaceRequest === false ? (e3) => e3 : n2.replaceRequest));\n    let a2 = i2 ? (e3) => {\n      let t3 = i2(e3);\n      return Array.isArray(t3) ? t3 : [t3];\n    } : (e3) => {\n      let t3;\n      try {\n        t3 = e3.executionCtx;\n      } catch {}\n      return [e3.env, t3];\n    };\n    return r2 ||= (() => {\n      let t3 = u(this._basePath, e2), n3 = t3 === `/` ? 0 : t3.length;\n      return (e3) => {\n        let t4 = new URL(e3.url);\n        return t4.pathname = t4.pathname.slice(n3) || `/`, new Request(t4, e3);\n      };\n    })(), this.#addRoute(C, u(e2, `*`), async (e3, n3) => {\n      let i3 = await t2(r2(e3.req.raw), ...a2(e3));\n      if (i3)\n        return i3;\n      await n3();\n    }), this;\n  }\n  #addRoute(e2, t2, n2) {\n    e2 = e2.toUpperCase(), t2 = u(this._basePath, t2);\n    let r2 = { basePath: this._basePath, path: t2, method: e2, handler: n2 };\n    this.router.add(e2, t2, [n2, r2]), this.routes.push(r2);\n  }\n  #handleError(e2, t2) {\n    if (e2 instanceof Error)\n      return this.errorHandler(e2, t2);\n    throw e2;\n  }\n  #dispatch(e2, t2, n2, r2) {\n    if (r2 === `HEAD`)\n      return (async () => new Response(null, await this.#dispatch(e2, t2, n2, `GET`)))();\n    let i2 = this.getPath(e2, { env: n2 }), a2 = this.router.match(r2, i2), o2 = new re(e2, { path: i2, matchResult: a2, env: n2, executionCtx: t2, notFoundHandler: this.#notFoundHandler });\n    if (a2[0].length === 1) {\n      let e3;\n      try {\n        e3 = a2[0][0][0][0](o2, async () => {\n          o2.res = await this.#notFoundHandler(o2);\n        });\n      } catch (e4) {\n        return this.#handleError(e4, o2);\n      }\n      return e3 instanceof Promise ? e3.then((e4) => e4 || (o2.finalized ? o2.res : this.#notFoundHandler(o2))).catch((e4) => this.#handleError(e4, o2)) : e3 ?? this.#notFoundHandler(o2);\n    }\n    let s2 = f2(a2[0], this.errorHandler, this.#notFoundHandler);\n    return (async () => {\n      try {\n        let e3 = await s2(o2);\n        if (!e3.finalized)\n          throw Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");\n        return e3.res;\n      } catch (e3) {\n        return this.#handleError(e3, o2);\n      }\n    })();\n  }\n  fetch = (e2, ...t2) => this.#dispatch(e2, t2[1], t2[0], e2.method);\n  request = (e2, t2, n2, r2) => e2 instanceof Request ? this.fetch(t2 ? new Request(e2, t2) : e2, n2, r2) : (e2 = e2.toString(), this.fetch(new Request(/^https?:\\/\\//.test(e2) ? e2 : `http://localhost${u(`/`, e2)}`, t2), n2, r2));\n  fire = () => {\n    addEventListener(`fetch`, (e2) => {\n      e2.respondWith(this.#dispatch(e2.request, e2, undefined, e2.request.method));\n    });\n  };\n};\nvar A = `[^/]+`;\nvar j = `.*`;\nvar M = `(?:|/.*)`;\nvar N = Symbol();\nvar oe = new Set(`.\\\\+*[^]$()`);\nfunction se(e2, t2) {\n  return e2.length === 1 ? t2.length === 1 ? e2 < t2 ? -1 : 1 : -1 : t2.length === 1 || e2 === j || e2 === M ? 1 : t2 === j || t2 === M ? -1 : e2 === A ? 1 : t2 === A ? -1 : e2.length === t2.length ? e2 < t2 ? -1 : 1 : t2.length - e2.length;\n}\nvar P = class {\n  #index;\n  #varIndex;\n  #children = Object.create(null);\n  insert(e2, t2, n2, r2, i2) {\n    if (e2.length === 0) {\n      if (this.#index !== undefined)\n        throw N;\n      if (i2)\n        return;\n      this.#index = t2;\n      return;\n    }\n    let [a2, ...o2] = e2, s2 = a2 === `*` ? o2.length === 0 ? [``, ``, j] : [``, ``, A] : a2 === `/*` ? [``, ``, M] : a2.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/), c2;\n    if (s2) {\n      let e3 = s2[1], t3 = s2[2] || A;\n      if (e3 && s2[2] && (t3 === `.*` || (t3 = t3.replace(/^\\((?!\\?:)(?=[^)]+\\)$)/, `(?:`), /\\((?!\\?:)/.test(t3))))\n        throw N;\n      if (c2 = this.#children[t3], !c2) {\n        if (Object.keys(this.#children).some((e4) => e4 !== j && e4 !== M))\n          throw N;\n        if (i2)\n          return;\n        c2 = this.#children[t3] = new P, e3 !== `` && (c2.#varIndex = r2.varIndex++);\n      }\n      !i2 && e3 !== `` && n2.push([e3, c2.#varIndex]);\n    } else if (c2 = this.#children[a2], !c2) {\n      if (Object.keys(this.#children).some((e3) => e3.length > 1 && e3 !== j && e3 !== M))\n        throw N;\n      if (i2)\n        return;\n      c2 = this.#children[a2] = new P;\n    }\n    c2.insert(o2, t2, n2, r2, i2);\n  }\n  buildRegExpStr() {\n    let e2 = Object.keys(this.#children).sort(se).map((e3) => {\n      let t2 = this.#children[e3];\n      return (typeof t2.#varIndex == `number` ? `(${e3})@${t2.#varIndex}` : oe.has(e3) ? `\\\\${e3}` : e3) + t2.buildRegExpStr();\n    });\n    return typeof this.#index == `number` && e2.unshift(`#${this.#index}`), e2.length === 0 ? `` : e2.length === 1 ? e2[0] : `(?:` + e2.join(`|`) + `)`;\n  }\n};\nvar ce = class {\n  #context = { varIndex: 0 };\n  #root = new P;\n  insert(e2, t2, n2) {\n    let r2 = [], i2 = [];\n    for (let t3 = 0;; ) {\n      let n3 = false;\n      if (e2 = e2.replace(/\\{[^}]+\\}/g, (e3) => {\n        let r3 = `@\\\\${t3}`;\n        return i2[t3] = [r3, e3], t3++, n3 = true, r3;\n      }), !n3)\n        break;\n    }\n    let a2 = e2.match(/(?::[^\\/]+)|(?:\\/\\*$)|./g) || [];\n    for (let e3 = i2.length - 1;e3 >= 0; e3--) {\n      let [t3] = i2[e3];\n      for (let n3 = a2.length - 1;n3 >= 0; n3--)\n        if (a2[n3].indexOf(t3) !== -1) {\n          a2[n3] = a2[n3].replace(t3, i2[e3][1]);\n          break;\n        }\n    }\n    return this.#root.insert(a2, t2, r2, this.#context, n2), r2;\n  }\n  buildRegExp() {\n    let e2 = this.#root.buildRegExpStr();\n    if (e2 === ``)\n      return [/^$/, [], []];\n    let t2 = 0, n2 = [], r2 = [];\n    return e2 = e2.replace(/#(\\d+)|@(\\d+)|\\.\\*\\$/g, (e3, i2, a2) => i2 === undefined ? (a2 === undefined || (r2[Number(a2)] = ++t2), ``) : (n2[++t2] = Number(i2), `$()`)), [RegExp(`^${e2}`), n2, r2];\n  }\n};\nvar F = [];\nvar I = [/^$/, [], Object.create(null)];\nvar L = Object.create(null);\nfunction R(e2) {\n  return L[e2] ??= RegExp(e2 === `*` ? `` : `^${e2.replace(/\\/\\*$|([.\\\\+*[^\\]$()])/g, (e3, t2) => t2 ? `\\\\${t2}` : `(?:|/.*)`)}$`);\n}\nfunction z() {\n  L = Object.create(null);\n}\nfunction B(e2) {\n  let t2 = new ce, n2 = [];\n  if (e2.length === 0)\n    return I;\n  let r2 = e2.map((e3) => [!/\\*|\\/:/.test(e3[0]), ...e3]).sort(([e3, t3], [n3, r3]) => e3 ? 1 : n3 ? -1 : t3.length - r3.length), i2 = Object.create(null);\n  for (let e3 = 0, a3 = -1, o3 = r2.length;e3 < o3; e3++) {\n    let [o4, s3, c3] = r2[e3];\n    o4 ? i2[s3] = [c3.map(([e4]) => [e4, Object.create(null)]), F] : a3++;\n    let l2;\n    try {\n      l2 = t2.insert(s3, a3, o4);\n    } catch (e4) {\n      throw e4 === N ? new T(s3) : e4;\n    }\n    o4 || (n2[a3] = c3.map(([e4, t3]) => {\n      let n3 = Object.create(null);\n      for (--t3;t3 >= 0; t3--) {\n        let [e5, r3] = l2[t3];\n        n3[e5] = r3;\n      }\n      return [e4, n3];\n    }));\n  }\n  let [a2, o2, s2] = t2.buildRegExp();\n  for (let e3 = 0, t3 = n2.length;e3 < t3; e3++)\n    for (let t4 = 0, r3 = n2[e3].length;t4 < r3; t4++) {\n      let r4 = n2[e3][t4]?.[1];\n      if (!r4)\n        continue;\n      let i3 = Object.keys(r4);\n      for (let e4 = 0, t5 = i3.length;e4 < t5; e4++)\n        r4[i3[e4]] = s2[r4[i3[e4]]];\n    }\n  let c2 = [];\n  for (let e3 in o2)\n    c2[e3] = n2[o2[e3]];\n  return [a2, c2, i2];\n}\nfunction V(e2, t2) {\n  if (e2) {\n    for (let n2 of Object.keys(e2).sort((e3, t3) => t3.length - e3.length))\n      if (R(n2).test(t2))\n        return [...e2[n2]];\n  }\n}\nvar H = class {\n  name = `RegExpRouter`;\n  #middleware;\n  #routes;\n  constructor() {\n    this.#middleware = { [C]: Object.create(null) }, this.#routes = { [C]: Object.create(null) };\n  }\n  add(t2, n2, r2) {\n    let i2 = this.#middleware, a2 = this.#routes;\n    if (!i2 || !a2)\n      throw Error(w);\n    i2[t2] || [i2, a2].forEach((e2) => {\n      e2[t2] = Object.create(null), Object.keys(e2[C]).forEach((n3) => {\n        e2[t2][n3] = [...e2[C][n3]];\n      });\n    }), n2 === `/*` && (n2 = `*`);\n    let o2 = (n2.match(/\\/:/g) || []).length;\n    if (/\\*$/.test(n2)) {\n      let e2 = R(n2);\n      t2 === C ? Object.keys(i2).forEach((e3) => {\n        i2[e3][n2] ||= V(i2[e3], n2) || V(i2[C], n2) || [];\n      }) : i2[t2][n2] ||= V(i2[t2], n2) || V(i2[C], n2) || [], Object.keys(i2).forEach((n3) => {\n        (t2 === C || t2 === n3) && Object.keys(i2[n3]).forEach((t3) => {\n          e2.test(t3) && i2[n3][t3].push([r2, o2]);\n        });\n      }), Object.keys(a2).forEach((n3) => {\n        (t2 === C || t2 === n3) && Object.keys(a2[n3]).forEach((t3) => e2.test(t3) && a2[n3][t3].push([r2, o2]));\n      });\n      return;\n    }\n    let s2 = d(n2) || [n2];\n    for (let e2 = 0, n3 = s2.length;e2 < n3; e2++) {\n      let c2 = s2[e2];\n      Object.keys(a2).forEach((s3) => {\n        (t2 === C || t2 === s3) && (a2[s3][c2] ||= [...V(i2[s3], c2) || V(i2[C], c2) || []], a2[s3][c2].push([r2, o2 - n3 + e2 + 1]));\n      });\n    }\n  }\n  match(e2, t2) {\n    z();\n    let n2 = this.#buildAllMatchers();\n    return this.match = (e3, t3) => {\n      let r2 = n2[e3] || n2[C], i2 = r2[2][t3];\n      if (i2)\n        return i2;\n      let a2 = t3.match(r2[0]);\n      if (!a2)\n        return [[], F];\n      let o2 = a2.indexOf(``, 1);\n      return [r2[1][o2], a2];\n    }, this.match(e2, t2);\n  }\n  #buildAllMatchers() {\n    let e2 = Object.create(null);\n    return Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((t2) => {\n      e2[t2] ||= this.#buildMatcher(t2);\n    }), this.#middleware = this.#routes = undefined, e2;\n  }\n  #buildMatcher(e2) {\n    let t2 = [], n2 = e2 === C;\n    return [this.#middleware, this.#routes].forEach((r2) => {\n      let i2 = r2[e2] ? Object.keys(r2[e2]).map((t3) => [t3, r2[e2][t3]]) : [];\n      i2.length === 0 ? e2 !== C && t2.push(...Object.keys(r2[C]).map((e3) => [e3, r2[C][e3]])) : (n2 ||= true, t2.push(...i2));\n    }), n2 ? B(t2) : null;\n  }\n};\nvar U = class {\n  name = `SmartRouter`;\n  #routers = [];\n  #routes = [];\n  constructor(e2) {\n    this.#routers = e2.routers;\n  }\n  add(e2, t2, n2) {\n    if (!this.#routes)\n      throw Error(w);\n    this.#routes.push([e2, t2, n2]);\n  }\n  match(e2, t2) {\n    if (!this.#routes)\n      throw Error(`Fatal error`);\n    let n2 = this.#routers, r2 = this.#routes, i2 = n2.length, a2 = 0, o2;\n    for (;a2 < i2; a2++) {\n      let i3 = n2[a2];\n      try {\n        for (let e3 = 0, t3 = r2.length;e3 < t3; e3++)\n          i3.add(...r2[e3]);\n        o2 = i3.match(e2, t2);\n      } catch (e3) {\n        if (e3 instanceof T)\n          continue;\n        throw e3;\n      }\n      this.match = i3.match.bind(i3), this.#routers = [i3], this.#routes = undefined;\n      break;\n    }\n    if (a2 === i2)\n      throw Error(`Fatal error`);\n    return this.name = `SmartRouter + ${this.activeRouter.name}`, o2;\n  }\n  get activeRouter() {\n    if (this.#routes || this.#routers.length !== 1)\n      throw Error(`No active router has been determined yet.`);\n    return this.#routers[0];\n  }\n};\nvar W = Object.create(null);\nvar G = class {\n  #methods;\n  #children;\n  #patterns;\n  #order = 0;\n  #params = W;\n  constructor(e2, t2, n2) {\n    if (this.#children = n2 || Object.create(null), this.#methods = [], e2 && t2) {\n      let n3 = Object.create(null);\n      n3[e2] = { handler: t2, possibleKeys: [], score: 0 }, this.#methods = [n3];\n    }\n    this.#patterns = [];\n  }\n  insert(e2, t2, n2) {\n    this.#order = ++this.#order;\n    let r2 = this, a2 = t(t2), o2 = [];\n    for (let e3 = 0, t3 = a2.length;e3 < t3; e3++) {\n      let t4 = a2[e3], n3 = a2[e3 + 1], s2 = a(t4, n3), c2 = Array.isArray(s2) ? s2[0] : t4;\n      if (c2 in r2.#children) {\n        r2 = r2.#children[c2], s2 && o2.push(s2[1]);\n        continue;\n      }\n      r2.#children[c2] = new G, s2 && (r2.#patterns.push(s2), o2.push(s2[1])), r2 = r2.#children[c2];\n    }\n    return r2.#methods.push({ [e2]: { handler: n2, possibleKeys: o2.filter((e3, t3, n3) => n3.indexOf(e3) === t3), score: this.#order } }), r2;\n  }\n  #getHandlerSets(e2, t2, n2, r2) {\n    let i2 = [];\n    for (let a2 = 0, o2 = e2.#methods.length;a2 < o2; a2++) {\n      let o3 = e2.#methods[a2], s2 = o3[t2] || o3[C], c2 = {};\n      if (s2 !== undefined && (s2.params = Object.create(null), i2.push(s2), n2 !== W || r2 && r2 !== W))\n        for (let e3 = 0, t3 = s2.possibleKeys.length;e3 < t3; e3++) {\n          let t4 = s2.possibleKeys[e3], i3 = c2[s2.score];\n          s2.params[t4] = r2?.[t4] && !i3 ? r2[t4] : n2[t4] ?? r2?.[t4], c2[s2.score] = true;\n        }\n    }\n    return i2;\n  }\n  search(e2, t2) {\n    let n2 = [];\n    this.#params = W;\n    let r2 = [this], i2 = e(t2), a2 = [];\n    for (let t3 = 0, o2 = i2.length;t3 < o2; t3++) {\n      let s2 = i2[t3], c2 = t3 === o2 - 1, l2 = [];\n      for (let o3 = 0, u2 = r2.length;o3 < u2; o3++) {\n        let u3 = r2[o3], d2 = u3.#children[s2];\n        d2 && (d2.#params = u3.#params, c2 ? (d2.#children[`*`] && n2.push(...this.#getHandlerSets(d2.#children[`*`], e2, u3.#params)), n2.push(...this.#getHandlerSets(d2, e2, u3.#params))) : l2.push(d2));\n        for (let r3 = 0, o4 = u3.#patterns.length;r3 < o4; r3++) {\n          let o5 = u3.#patterns[r3], d3 = u3.#params === W ? {} : { ...u3.#params };\n          if (o5 === `*`) {\n            let t4 = u3.#children[`*`];\n            t4 && (n2.push(...this.#getHandlerSets(t4, e2, u3.#params)), t4.#params = d3, l2.push(t4));\n            continue;\n          }\n          let [f3, p3, m3] = o5;\n          if (!s2 && !(m3 instanceof RegExp))\n            continue;\n          let h3 = u3.#children[f3], g3 = i2.slice(t3).join(`/`);\n          if (m3 instanceof RegExp) {\n            let t4 = m3.exec(g3);\n            if (t4) {\n              if (d3[p3] = t4[0], n2.push(...this.#getHandlerSets(h3, e2, u3.#params, d3)), Object.keys(h3.#children).length) {\n                h3.#params = d3;\n                let e3 = t4[0].match(/\\//)?.length ?? 0;\n                (a2[e3] ||= []).push(h3);\n              }\n              continue;\n            }\n          }\n          (m3 === true || m3.test(s2)) && (d3[p3] = s2, c2 ? (n2.push(...this.#getHandlerSets(h3, e2, d3, u3.#params)), h3.#children[`*`] && n2.push(...this.#getHandlerSets(h3.#children[`*`], e2, d3, u3.#params))) : (h3.#params = d3, l2.push(h3)));\n        }\n      }\n      r2 = l2.concat(a2.shift() ?? []);\n    }\n    return n2.length > 1 && n2.sort((e3, t3) => e3.score - t3.score), [n2.map(({ handler: e3, params: t3 }) => [e3, t3])];\n  }\n};\nvar le = class {\n  name = `TrieRouter`;\n  #node;\n  constructor() {\n    this.#node = new G;\n  }\n  add(t2, n2, r2) {\n    let i2 = d(n2);\n    if (i2) {\n      for (let e2 = 0, n3 = i2.length;e2 < n3; e2++)\n        this.#node.insert(t2, i2[e2], r2);\n      return;\n    }\n    this.#node.insert(t2, n2, r2);\n  }\n  match(e2, t2) {\n    return this.#node.search(e2, t2);\n  }\n};\nvar K = class extends k {\n  constructor(e2 = {}) {\n    super(e2), this.router = e2.router ?? new U({ routers: [new H, new le] });\n  }\n};\nvar ue = (e2, t2, n2) => {\n  let r2 = e2.req.raw.headers.get(`Cookie`);\n  if (typeof t2 == `string`) {\n    if (!r2)\n      return;\n    let e3 = t2;\n    return n2 === `secure` ? e3 = `__Secure-` + t2 : n2 === `host` && (e3 = `__Host-` + t2), y(r2, e3)[e3];\n  }\n  return r2 ? y(r2) : {};\n};\nvar q = class extends Error {\n  res;\n  status;\n  constructor(e2 = 500, t2) {\n    super(t2?.message, { cause: t2?.cause }), this.res = t2?.res, this.status = e2;\n  }\n  getResponse() {\n    return this.res ? new Response(this.res.body, { status: this.status, headers: this.res.headers }) : new Response(this.message, { status: this.status });\n  }\n};\nvar de = (e2, t2) => new Response(e2, { headers: { "Content-Type": t2 } }).formData();\nvar fe = /^application\\/([a-z-\\.]+\\+)?json(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar pe = /^multipart\\/form-data(;\\s?boundary=[a-zA-Z0-9\'"()+_,\\-./:=?]+)?$/;\nvar me = /^application\\/x-www-form-urlencoded(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar J = (e2, t2) => async (n2, r2) => {\n  let i2 = {}, a2 = n2.req.header(`Content-Type`);\n  switch (e2) {\n    case `json`:\n      if (!a2 || !fe.test(a2))\n        break;\n      try {\n        i2 = await n2.req.json();\n      } catch {\n        throw new q(400, { message: `Malformed JSON in request body` });\n      }\n      break;\n    case `form`: {\n      if (!a2 || !(pe.test(a2) || me.test(a2)))\n        break;\n      let e3;\n      if (n2.req.bodyCache.formData)\n        e3 = await n2.req.bodyCache.formData;\n      else\n        try {\n          let t4 = await n2.req.arrayBuffer();\n          e3 = await de(t4, a2), n2.req.bodyCache.formData = e3;\n        } catch (e4) {\n          let t4 = `Malformed FormData request.`;\n          throw t4 += e4 instanceof Error ? ` ${e4.message}` : ` ${String(e4)}`, new q(400, { message: t4 });\n        }\n      let t3 = {};\n      e3.forEach((e4, n3) => {\n        n3.endsWith(`[]`) ? (t3[n3] ??= []).push(e4) : Array.isArray(t3[n3]) ? t3[n3].push(e4) : (n3 in t3) ? t3[n3] = [t3[n3], e4] : t3[n3] = e4;\n      }), i2 = t3;\n      break;\n    }\n    case `query`:\n      i2 = Object.fromEntries(Object.entries(n2.req.queries()).map(([e3, t3]) => t3.length === 1 ? [e3, t3[0]] : [e3, t3]));\n      break;\n    case `param`:\n      i2 = n2.req.param();\n      break;\n    case `header`:\n      i2 = n2.req.header();\n      break;\n    case `cookie`:\n      i2 = ue(n2);\n      break;\n  }\n  let o2 = await t2(i2, n2);\n  if (o2 instanceof Response)\n    return o2;\n  n2.req.addValidatedData(e2, o2), await r2();\n};\nvar Y = (e2, t2) => e2.json({ error: t2 }, 400);\nvar X = (e2) => {\n  let t2 = e2.req.param(`key`);\n  return !t2 || t2 === `` ? { key: t2, err: `Key is required` } : t2.length > 475 ? { key: t2, err: `Key is too long. Max length is 475 characters.` } : { key: t2 };\n};\nvar Z = () => new K;\nvar he = Z().get(`/:key`, async (e2) => {\n  let { key: t2, err: n2 } = X(e2);\n  if (n2)\n    return Y(e2, n2);\n  let r2 = await e2.env.store.get(t2);\n  return e2.json({ value: r2 }, 200);\n}).post(`/:key`, J(`json`, (e2, t2) => {\n  let n2 = e2.value;\n  return n2 ? typeof n2 == `string` ? n2.length > 20000 ? Y(t2, `Value is too long. Max length is 20,000 characters.`) : { value: n2 } : Y(t2, `Value must be a string`) : Y(t2, `Value is required`);\n}), async (e2) => {\n  let { key: t2, err: n2 } = X(e2);\n  if (n2)\n    return Y(e2, n2);\n  let { value: r2 } = e2.req.valid(`json`);\n  return await e2.env.store.set(t2, r2), e2.body(null, 204);\n}).delete(`/:key`, async (e2) => {\n  let { key: t2, err: n2 } = X(e2);\n  return n2 ? Y(e2, n2) : (await e2.env.store.delete(t2), e2.body(null, 204));\n}).get(`/`, async (e2) => {\n  let { cursor: t2, limit: n2, prefix: r2 } = e2.req.query(), { entries: i2, cursor: a2 } = await e2.env.store.list(r2, { cursor: t2 ? String(t2) : undefined, limit: n2 ? Number(n2) : 100 });\n  return e2.json({ entries: i2, cursor: a2 });\n});\nvar ge = (e2) => {\n  let t2 = e2.req.param(`key`);\n  return t2 ? t2.length > 475 ? { key: t2, err: `Key is too long. Max length is 475 characters.` } : { key: t2 } : { key: t2, err: `Key is required` };\n};\nvar Q = J(`param`, (e2) => ({ id: e2.id }));\nvar $ = Z().post(`/:key`, async (e2) => {\n  let { key: t2, err: n2 } = ge(e2);\n  return n2 ? Y(e2, n2) : e2.json(await e2.env.chat.upsert(t2), 200);\n}).get(`/:id`, Q, async (e2) => {\n  let { id: t2 } = e2.req.valid(`param`);\n  return e2.json(await e2.env.chat.get(t2), 200);\n}).get(`/:id/messages`, Q, async (e2) => {\n  let { id: t2 } = e2.req.valid(`param`);\n  return e2.json(await e2.env.chat.getMessages(t2), 200);\n}).post(`/:id/sendMessages`, J(`json`, (e2) => ({ id: e2.id, messages: e2.messages, options: e2.options })), async (e2) => {\n  let { id: t2, messages: n2, options: r2 } = e2.req.valid(`json`);\n  return t2 ? (await e2.env.chat.sendMessages(t2, n2, r2), e2.body(null, 204)) : Y(e2, `ID is required`);\n}).delete(`/:id/messages`, Q, J(`query`, (e2) => (typeof e2.message == `string` && (e2.message = [e2.message]), { messages: e2.message })), async (e2) => {\n  let { id: t2 } = e2.req.valid(`param`), { messages: n2 } = e2.req.valid(`query`);\n  return await e2.env.chat.deleteMessages(t2, n2), e2.body(null, 204);\n}).post(`/:id/start`, Q, async (e2) => {\n  let { id: t2 } = e2.req.valid(`param`);\n  return await e2.env.chat.start(t2), e2.body(null, 204);\n}).post(`/:id/stop`, Q, async (e2) => {\n  let { id: t2 } = e2.req.valid(`param`);\n  return await e2.env.chat.stop(t2), e2.body(null, 204);\n}).delete(`/:id`, Q, async (e2) => {\n  let { id: t2 } = e2.req.valid(`param`);\n  return await e2.env.chat.delete(t2), e2.body(null, 204);\n});\nvar _e = Z().post(`/v1/traces`, async (e2) => e2.env.otlp ? e2.env.otlp.traces(e2.req.raw) : e2.body(null, 204));\nvar ve = new K().onError((e2, t2) => t2.json({ error: e2 instanceof Error ? e2.message : `Unknown error` }, 500)).route(`/kv`, he).route(`/chat`, $).route(`/otlp`, _e);\n\n// ../../node_modules/@ai-sdk/provider/dist/index.mjs\nvar marker = "vercel.ai.error";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError2 extends Error {\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  static isInstance(error) {\n    return _AISDKError2.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\nvar name = "AI_APICallError";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\n_a2 = symbol2;\nvar name2 = "AI_EmptyResponseBodyError";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\n_a3 = symbol3;\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return "unknown error";\n  }\n  if (typeof error === "string") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\nvar name3 = "AI_InvalidArgumentError";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\nvar name4 = "AI_InvalidPromptError";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\n_a5 = symbol5;\nvar name5 = "AI_InvalidResponseDataError";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\n_a6 = symbol6;\nvar name6 = "AI_JSONParseError";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\nvar name7 = "AI_LoadAPIKeyError";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\n_a8 = symbol8;\nvar name8 = "AI_LoadSettingError";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\n_a9 = symbol9;\nvar name9 = "AI_NoContentGeneratedError";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\n_a10 = symbol10;\nvar name10 = "AI_NoSuchModelError";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\n_a11 = symbol11;\nvar name11 = "AI_TooManyEmbeddingValuesForCallError";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\n_a12 = symbol12;\nvar name12 = "AI_TypeValidationError";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError2 extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\nvar name13 = "AI_UnsupportedFunctionalityError";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\n_a14 = symbol14;\n\n// ../../node_modules/zod/dist/esm/v4/classic/external.js\nvar exports_external = {};\n__export(exports_external, {\n  xid: () => xid2,\n  void: () => _void2,\n  uuidv7: () => uuidv7,\n  uuidv6: () => uuidv6,\n  uuidv4: () => uuidv4,\n  uuid: () => uuid2,\n  url: () => url,\n  uppercase: () => _uppercase,\n  unknown: () => unknown,\n  union: () => union,\n  undefined: () => _undefined3,\n  ulid: () => ulid2,\n  uint64: () => uint64,\n  uint32: () => uint32,\n  tuple: () => tuple,\n  trim: () => _trim,\n  treeifyError: () => treeifyError,\n  transform: () => transform,\n  toUpperCase: () => _toUpperCase,\n  toLowerCase: () => _toLowerCase,\n  toJSONSchema: () => toJSONSchema,\n  templateLiteral: () => templateLiteral,\n  symbol: () => symbol15,\n  superRefine: () => superRefine,\n  success: () => success,\n  stringbool: () => stringbool,\n  string: () => string2,\n  strictObject: () => strictObject,\n  startsWith: () => _startsWith,\n  size: () => _size,\n  setErrorMap: () => setErrorMap,\n  set: () => set,\n  safeParseAsync: () => safeParseAsync2,\n  safeParse: () => safeParse2,\n  registry: () => registry,\n  regexes: () => exports_regexes,\n  regex: () => _regex,\n  refine: () => refine,\n  record: () => record,\n  readonly: () => readonly,\n  property: () => _property,\n  promise: () => promise,\n  prettifyError: () => prettifyError,\n  preprocess: () => preprocess,\n  prefault: () => prefault,\n  positive: () => _positive,\n  pipe: () => pipe,\n  partialRecord: () => partialRecord,\n  parseAsync: () => parseAsync2,\n  parse: () => parse3,\n  overwrite: () => _overwrite,\n  optional: () => optional,\n  object: () => object,\n  number: () => number2,\n  nullish: () => nullish2,\n  nullable: () => nullable,\n  null: () => _null3,\n  normalize: () => _normalize,\n  nonpositive: () => _nonpositive,\n  nonoptional: () => nonoptional,\n  nonnegative: () => _nonnegative,\n  never: () => never,\n  negative: () => _negative,\n  nativeEnum: () => nativeEnum,\n  nanoid: () => nanoid2,\n  nan: () => nan,\n  multipleOf: () => _multipleOf,\n  minSize: () => _minSize,\n  minLength: () => _minLength,\n  mime: () => _mime,\n  maxSize: () => _maxSize,\n  maxLength: () => _maxLength,\n  map: () => map,\n  lte: () => _lte,\n  lt: () => _lt,\n  lowercase: () => _lowercase,\n  looseObject: () => looseObject,\n  locales: () => exports_locales,\n  literal: () => literal,\n  length: () => _length,\n  lazy: () => lazy,\n  ksuid: () => ksuid2,\n  keyof: () => keyof,\n  jwt: () => jwt,\n  json: () => json,\n  iso: () => exports_iso,\n  ipv6: () => ipv62,\n  ipv4: () => ipv42,\n  intersection: () => intersection,\n  int64: () => int64,\n  int32: () => int32,\n  int: () => int,\n  instanceof: () => _instanceof,\n  includes: () => _includes,\n  guid: () => guid2,\n  gte: () => _gte,\n  gt: () => _gt,\n  globalRegistry: () => globalRegistry,\n  getErrorMap: () => getErrorMap,\n  function: () => _function,\n  formatError: () => formatError,\n  float64: () => float64,\n  float32: () => float32,\n  flattenError: () => flattenError,\n  file: () => file,\n  enum: () => _enum2,\n  endsWith: () => _endsWith,\n  emoji: () => emoji2,\n  email: () => email2,\n  e164: () => e1642,\n  discriminatedUnion: () => discriminatedUnion,\n  date: () => date3,\n  custom: () => custom,\n  cuid2: () => cuid22,\n  cuid: () => cuid3,\n  core: () => exports_core2,\n  config: () => config,\n  coerce: () => exports_coerce,\n  clone: () => clone,\n  cidrv6: () => cidrv62,\n  cidrv4: () => cidrv42,\n  check: () => check,\n  catch: () => _catch2,\n  boolean: () => boolean2,\n  bigint: () => bigint2,\n  base64url: () => base64url2,\n  base64: () => base642,\n  array: () => array,\n  any: () => any,\n  _default: () => _default2,\n  _ZodString: () => _ZodString,\n  ZodXID: () => ZodXID,\n  ZodVoid: () => ZodVoid,\n  ZodUnknown: () => ZodUnknown,\n  ZodUnion: () => ZodUnion,\n  ZodUndefined: () => ZodUndefined,\n  ZodUUID: () => ZodUUID,\n  ZodURL: () => ZodURL,\n  ZodULID: () => ZodULID,\n  ZodType: () => ZodType,\n  ZodTuple: () => ZodTuple,\n  ZodTransform: () => ZodTransform,\n  ZodTemplateLiteral: () => ZodTemplateLiteral,\n  ZodSymbol: () => ZodSymbol,\n  ZodSuccess: () => ZodSuccess,\n  ZodStringFormat: () => ZodStringFormat,\n  ZodString: () => ZodString,\n  ZodSet: () => ZodSet,\n  ZodRecord: () => ZodRecord,\n  ZodRealError: () => ZodRealError,\n  ZodReadonly: () => ZodReadonly,\n  ZodPromise: () => ZodPromise,\n  ZodPrefault: () => ZodPrefault,\n  ZodPipe: () => ZodPipe,\n  ZodOptional: () => ZodOptional,\n  ZodObject: () => ZodObject,\n  ZodNumberFormat: () => ZodNumberFormat,\n  ZodNumber: () => ZodNumber,\n  ZodNullable: () => ZodNullable,\n  ZodNull: () => ZodNull,\n  ZodNonOptional: () => ZodNonOptional,\n  ZodNever: () => ZodNever,\n  ZodNanoID: () => ZodNanoID,\n  ZodNaN: () => ZodNaN,\n  ZodMap: () => ZodMap,\n  ZodLiteral: () => ZodLiteral,\n  ZodLazy: () => ZodLazy,\n  ZodKSUID: () => ZodKSUID,\n  ZodJWT: () => ZodJWT,\n  ZodIssueCode: () => ZodIssueCode,\n  ZodIntersection: () => ZodIntersection,\n  ZodISOTime: () => ZodISOTime,\n  ZodISODuration: () => ZodISODuration,\n  ZodISODateTime: () => ZodISODateTime,\n  ZodISODate: () => ZodISODate,\n  ZodIPv6: () => ZodIPv6,\n  ZodIPv4: () => ZodIPv4,\n  ZodGUID: () => ZodGUID,\n  ZodFile: () => ZodFile,\n  ZodError: () => ZodError,\n  ZodEnum: () => ZodEnum,\n  ZodEmoji: () => ZodEmoji,\n  ZodEmail: () => ZodEmail,\n  ZodE164: () => ZodE164,\n  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,\n  ZodDefault: () => ZodDefault,\n  ZodDate: () => ZodDate,\n  ZodCustom: () => ZodCustom,\n  ZodCatch: () => ZodCatch,\n  ZodCUID2: () => ZodCUID2,\n  ZodCUID: () => ZodCUID,\n  ZodCIDRv6: () => ZodCIDRv6,\n  ZodCIDRv4: () => ZodCIDRv4,\n  ZodBoolean: () => ZodBoolean,\n  ZodBigIntFormat: () => ZodBigIntFormat,\n  ZodBigInt: () => ZodBigInt,\n  ZodBase64URL: () => ZodBase64URL,\n  ZodBase64: () => ZodBase64,\n  ZodArray: () => ZodArray,\n  ZodAny: () => ZodAny,\n  NEVER: () => NEVER,\n  $output: () => $output,\n  $input: () => $input,\n  $brand: () => $brand\n});\n\n// ../../node_modules/zod/dist/esm/v4/core/index.js\nvar exports_core2 = {};\n__export(exports_core2, {\n  version: () => version,\n  util: () => exports_util,\n  treeifyError: () => treeifyError,\n  toJSONSchema: () => toJSONSchema,\n  toDotPath: () => toDotPath,\n  safeParseAsync: () => safeParseAsync,\n  safeParse: () => safeParse,\n  registry: () => registry,\n  regexes: () => exports_regexes,\n  prettifyError: () => prettifyError,\n  parseAsync: () => parseAsync,\n  parse: () => parse,\n  locales: () => exports_locales,\n  isValidJWT: () => isValidJWT,\n  isValidBase64URL: () => isValidBase64URL,\n  isValidBase64: () => isValidBase64,\n  globalRegistry: () => globalRegistry,\n  globalConfig: () => globalConfig,\n  function: () => _function,\n  formatError: () => formatError,\n  flattenError: () => flattenError,\n  config: () => config,\n  clone: () => clone,\n  _xid: () => _xid,\n  _void: () => _void,\n  _uuidv7: () => _uuidv7,\n  _uuidv6: () => _uuidv6,\n  _uuidv4: () => _uuidv4,\n  _uuid: () => _uuid,\n  _url: () => _url,\n  _uppercase: () => _uppercase,\n  _unknown: () => _unknown,\n  _union: () => _union,\n  _undefined: () => _undefined2,\n  _ulid: () => _ulid,\n  _uint64: () => _uint64,\n  _uint32: () => _uint32,\n  _tuple: () => _tuple,\n  _trim: () => _trim,\n  _transform: () => _transform,\n  _toUpperCase: () => _toUpperCase,\n  _toLowerCase: () => _toLowerCase,\n  _templateLiteral: () => _templateLiteral,\n  _symbol: () => _symbol,\n  _success: () => _success,\n  _stringbool: () => _stringbool,\n  _string: () => _string,\n  _startsWith: () => _startsWith,\n  _size: () => _size,\n  _set: () => _set,\n  _safeParseAsync: () => _safeParseAsync,\n  _safeParse: () => _safeParse,\n  _regex: () => _regex,\n  _refine: () => _refine,\n  _record: () => _record,\n  _readonly: () => _readonly,\n  _property: () => _property,\n  _promise: () => _promise,\n  _positive: () => _positive,\n  _pipe: () => _pipe,\n  _parseAsync: () => _parseAsync,\n  _parse: () => _parse,\n  _overwrite: () => _overwrite,\n  _optional: () => _optional,\n  _number: () => _number,\n  _nullable: () => _nullable,\n  _null: () => _null2,\n  _normalize: () => _normalize,\n  _nonpositive: () => _nonpositive,\n  _nonoptional: () => _nonoptional,\n  _nonnegative: () => _nonnegative,\n  _never: () => _never,\n  _negative: () => _negative,\n  _nativeEnum: () => _nativeEnum,\n  _nanoid: () => _nanoid,\n  _nan: () => _nan,\n  _multipleOf: () => _multipleOf,\n  _minSize: () => _minSize,\n  _minLength: () => _minLength,\n  _min: () => _gte,\n  _mime: () => _mime,\n  _maxSize: () => _maxSize,\n  _maxLength: () => _maxLength,\n  _max: () => _lte,\n  _map: () => _map,\n  _lte: () => _lte,\n  _lt: () => _lt,\n  _lowercase: () => _lowercase,\n  _literal: () => _literal,\n  _length: () => _length,\n  _lazy: () => _lazy,\n  _ksuid: () => _ksuid,\n  _jwt: () => _jwt,\n  _isoTime: () => _isoTime,\n  _isoDuration: () => _isoDuration,\n  _isoDateTime: () => _isoDateTime,\n  _isoDate: () => _isoDate,\n  _ipv6: () => _ipv6,\n  _ipv4: () => _ipv4,\n  _intersection: () => _intersection,\n  _int64: () => _int64,\n  _int32: () => _int32,\n  _int: () => _int,\n  _includes: () => _includes,\n  _guid: () => _guid,\n  _gte: () => _gte,\n  _gt: () => _gt,\n  _float64: () => _float64,\n  _float32: () => _float32,\n  _file: () => _file,\n  _enum: () => _enum,\n  _endsWith: () => _endsWith,\n  _emoji: () => _emoji2,\n  _email: () => _email,\n  _e164: () => _e164,\n  _discriminatedUnion: () => _discriminatedUnion,\n  _default: () => _default,\n  _date: () => _date,\n  _custom: () => _custom,\n  _cuid2: () => _cuid2,\n  _cuid: () => _cuid,\n  _coercedString: () => _coercedString,\n  _coercedNumber: () => _coercedNumber,\n  _coercedDate: () => _coercedDate,\n  _coercedBoolean: () => _coercedBoolean,\n  _coercedBigint: () => _coercedBigint,\n  _cidrv6: () => _cidrv6,\n  _cidrv4: () => _cidrv4,\n  _catch: () => _catch,\n  _boolean: () => _boolean,\n  _bigint: () => _bigint,\n  _base64url: () => _base64url,\n  _base64: () => _base64,\n  _array: () => _array,\n  _any: () => _any,\n  JSONSchemaGenerator: () => JSONSchemaGenerator,\n  JSONSchema: () => exports_json_schema,\n  Doc: () => Doc,\n  $output: () => $output,\n  $input: () => $input,\n  $constructor: () => $constructor,\n  $brand: () => $brand,\n  $ZodXID: () => $ZodXID,\n  $ZodVoid: () => $ZodVoid,\n  $ZodUnknown: () => $ZodUnknown,\n  $ZodUnion: () => $ZodUnion,\n  $ZodUndefined: () => $ZodUndefined,\n  $ZodUUID: () => $ZodUUID,\n  $ZodURL: () => $ZodURL,\n  $ZodULID: () => $ZodULID,\n  $ZodType: () => $ZodType,\n  $ZodTuple: () => $ZodTuple,\n  $ZodTransform: () => $ZodTransform,\n  $ZodTemplateLiteral: () => $ZodTemplateLiteral,\n  $ZodSymbol: () => $ZodSymbol,\n  $ZodSuccess: () => $ZodSuccess,\n  $ZodStringFormat: () => $ZodStringFormat,\n  $ZodString: () => $ZodString,\n  $ZodSet: () => $ZodSet,\n  $ZodRegistry: () => $ZodRegistry,\n  $ZodRecord: () => $ZodRecord,\n  $ZodRealError: () => $ZodRealError,\n  $ZodReadonly: () => $ZodReadonly,\n  $ZodPromise: () => $ZodPromise,\n  $ZodPrefault: () => $ZodPrefault,\n  $ZodPipe: () => $ZodPipe,\n  $ZodOptional: () => $ZodOptional,\n  $ZodObject: () => $ZodObject,\n  $ZodNumberFormat: () => $ZodNumberFormat,\n  $ZodNumber: () => $ZodNumber,\n  $ZodNullable: () => $ZodNullable,\n  $ZodNull: () => $ZodNull,\n  $ZodNonOptional: () => $ZodNonOptional,\n  $ZodNever: () => $ZodNever,\n  $ZodNanoID: () => $ZodNanoID,\n  $ZodNaN: () => $ZodNaN,\n  $ZodMap: () => $ZodMap,\n  $ZodLiteral: () => $ZodLiteral,\n  $ZodLazy: () => $ZodLazy,\n  $ZodKSUID: () => $ZodKSUID,\n  $ZodJWT: () => $ZodJWT,\n  $ZodIntersection: () => $ZodIntersection,\n  $ZodISOTime: () => $ZodISOTime,\n  $ZodISODuration: () => $ZodISODuration,\n  $ZodISODateTime: () => $ZodISODateTime,\n  $ZodISODate: () => $ZodISODate,\n  $ZodIPv6: () => $ZodIPv6,\n  $ZodIPv4: () => $ZodIPv4,\n  $ZodGUID: () => $ZodGUID,\n  $ZodFunction: () => $ZodFunction,\n  $ZodFile: () => $ZodFile,\n  $ZodError: () => $ZodError,\n  $ZodEnum: () => $ZodEnum,\n  $ZodEmoji: () => $ZodEmoji,\n  $ZodEmail: () => $ZodEmail,\n  $ZodE164: () => $ZodE164,\n  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,\n  $ZodDefault: () => $ZodDefault,\n  $ZodDate: () => $ZodDate,\n  $ZodCustom: () => $ZodCustom,\n  $ZodCheckUpperCase: () => $ZodCheckUpperCase,\n  $ZodCheckStringFormat: () => $ZodCheckStringFormat,\n  $ZodCheckStartsWith: () => $ZodCheckStartsWith,\n  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,\n  $ZodCheckRegex: () => $ZodCheckRegex,\n  $ZodCheckProperty: () => $ZodCheckProperty,\n  $ZodCheckOverwrite: () => $ZodCheckOverwrite,\n  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,\n  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,\n  $ZodCheckMinSize: () => $ZodCheckMinSize,\n  $ZodCheckMinLength: () => $ZodCheckMinLength,\n  $ZodCheckMimeType: () => $ZodCheckMimeType,\n  $ZodCheckMaxSize: () => $ZodCheckMaxSize,\n  $ZodCheckMaxLength: () => $ZodCheckMaxLength,\n  $ZodCheckLowerCase: () => $ZodCheckLowerCase,\n  $ZodCheckLessThan: () => $ZodCheckLessThan,\n  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,\n  $ZodCheckIncludes: () => $ZodCheckIncludes,\n  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,\n  $ZodCheckEndsWith: () => $ZodCheckEndsWith,\n  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,\n  $ZodCheck: () => $ZodCheck,\n  $ZodCatch: () => $ZodCatch,\n  $ZodCUID2: () => $ZodCUID2,\n  $ZodCUID: () => $ZodCUID,\n  $ZodCIDRv6: () => $ZodCIDRv6,\n  $ZodCIDRv4: () => $ZodCIDRv4,\n  $ZodBoolean: () => $ZodBoolean,\n  $ZodBigIntFormat: () => $ZodBigIntFormat,\n  $ZodBigInt: () => $ZodBigInt,\n  $ZodBase64URL: () => $ZodBase64URL,\n  $ZodBase64: () => $ZodBase64,\n  $ZodAsyncError: () => $ZodAsyncError,\n  $ZodArray: () => $ZodArray,\n  $ZodAny: () => $ZodAny\n});\n\n// ../../node_modules/zod/dist/esm/v4/core/core.js\nfunction $constructor(name14, initializer, params) {\n  function init(inst, def) {\n    var _a15;\n    Object.defineProperty(inst, "_zod", {\n      value: inst._zod ?? {},\n      enumerable: false\n    });\n    (_a15 = inst._zod).traits ?? (_a15.traits = new Set);\n    inst._zod.traits.add(name14);\n    initializer(inst, def);\n    for (const k2 in _3.prototype) {\n      if (!(k2 in inst))\n        Object.defineProperty(inst, k2, { value: _3.prototype[k2].bind(inst) });\n    }\n    inst._zod.constr = _3;\n    inst._zod.def = def;\n  }\n  const Parent = params?.Parent ?? Object;\n\n  class Definition extends Parent {\n  }\n  Object.defineProperty(Definition, "name", { value: name14 });\n  function _3(def) {\n    var _a15;\n    const inst = params?.Parent ? new Definition : this;\n    init(inst, def);\n    (_a15 = inst._zod).deferred ?? (_a15.deferred = []);\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n  Object.defineProperty(_3, "init", { value: init });\n  Object.defineProperty(_3, Symbol.hasInstance, {\n    value: (inst) => {\n      if (params?.Parent && inst instanceof params.Parent)\n        return true;\n      return inst?._zod?.traits?.has(name14);\n    }\n  });\n  Object.defineProperty(_3, "name", { value: name14 });\n  return _3;\n}\nvar $brand = Symbol("zod_brand");\n\nclass $ZodAsyncError extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n}\nvar globalConfig = {};\nfunction config(newConfig) {\n  if (newConfig)\n    Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}\n// ../../node_modules/zod/dist/esm/v4/core/util.js\nvar exports_util = {};\n__export(exports_util, {\n  unwrapMessage: () => unwrapMessage,\n  stringifyPrimitive: () => stringifyPrimitive,\n  required: () => required,\n  randomString: () => randomString,\n  propertyKeyTypes: () => propertyKeyTypes,\n  promiseAllObject: () => promiseAllObject,\n  primitiveTypes: () => primitiveTypes,\n  prefixIssues: () => prefixIssues,\n  pick: () => pick,\n  partial: () => partial,\n  optionalKeys: () => optionalKeys,\n  omit: () => omit,\n  numKeys: () => numKeys,\n  nullish: () => nullish,\n  normalizeParams: () => normalizeParams,\n  merge: () => merge,\n  jsonStringifyReplacer: () => jsonStringifyReplacer,\n  joinValues: () => joinValues,\n  issue: () => issue,\n  isPlainObject: () => isPlainObject,\n  isObject: () => isObject,\n  getSizableOrigin: () => getSizableOrigin,\n  getParsedType: () => getParsedType,\n  getLengthableOrigin: () => getLengthableOrigin,\n  getEnumValues: () => getEnumValues,\n  getElementAtPath: () => getElementAtPath,\n  floatSafeRemainder: () => floatSafeRemainder,\n  finalizeIssue: () => finalizeIssue,\n  extend: () => extend,\n  escapeRegex: () => escapeRegex,\n  esc: () => esc,\n  defineLazy: () => defineLazy,\n  createTransparentProxy: () => createTransparentProxy,\n  clone: () => clone,\n  cleanRegex: () => cleanRegex,\n  cleanEnum: () => cleanEnum,\n  cached: () => cached,\n  assignProp: () => assignProp,\n  assertNotEqual: () => assertNotEqual,\n  assertNever: () => assertNever,\n  assertIs: () => assertIs,\n  assertEqual: () => assertEqual,\n  assert: () => assert,\n  allowsEval: () => allowsEval,\n  aborted: () => aborted,\n  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,\n  Class: () => Class,\n  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES\n});\nfunction assertEqual(val) {\n  return val;\n}\nfunction assertNotEqual(val) {\n  return val;\n}\nfunction assertIs(_arg) {}\nfunction assertNever(_x) {\n  throw new Error;\n}\nfunction assert(_3) {}\nfunction getEnumValues(entries) {\n  const numericValues = Object.values(entries).filter((v3) => typeof v3 === "number");\n  const values = Object.entries(entries).filter(([k2, _3]) => numericValues.indexOf(+k2) === -1).map(([_3, v3]) => v3);\n  return values;\n}\nfunction joinValues(array, separator = "|") {\n  return array.map((val) => stringifyPrimitive(val)).join(separator);\n}\nfunction jsonStringifyReplacer(_3, value) {\n  if (typeof value === "bigint")\n    return value.toString();\n  return value;\n}\nfunction cached(getter) {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, "value", { value });\n        return value;\n      }\n      throw new Error("cached value already set");\n    }\n  };\n}\nfunction nullish(input) {\n  return input === null || input === undefined;\n}\nfunction cleanRegex(source) {\n  const start = source.startsWith("^") ? 1 : 0;\n  const end = source.endsWith("$") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(".")[1] || "").length;\n  const stepDecCount = (step.toString().split(".")[1] || "").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));\n  return valInt % stepInt / 10 ** decCount;\n}\nfunction defineLazy(object, key, getter) {\n  const set = false;\n  Object.defineProperty(object, key, {\n    get() {\n      if (!set) {\n        const value = getter();\n        object[key] = value;\n        return value;\n      }\n      throw new Error("cached value already set");\n    },\n    set(v3) {\n      Object.defineProperty(object, key, {\n        value: v3\n      });\n    },\n    configurable: true\n  });\n}\nfunction assignProp(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction getElementAtPath(obj, path) {\n  if (!path)\n    return obj;\n  return path.reduce((acc, key) => acc?.[key], obj);\n}\nfunction promiseAllObject(promisesObj) {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map((key) => promisesObj[key]);\n  return Promise.all(promises).then((results) => {\n    const resolvedObj = {};\n    for (let i2 = 0;i2 < keys.length; i2++) {\n      resolvedObj[keys[i2]] = results[i2];\n    }\n    return resolvedObj;\n  });\n}\nfunction randomString(length = 10) {\n  const chars = "abcdefghijklmnopqrstuvwxyz";\n  let str = "";\n  for (let i2 = 0;i2 < length; i2++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\nfunction esc(str) {\n  return JSON.stringify(str);\n}\nfunction isObject(data) {\n  return typeof data === "object" && data !== null && !Array.isArray(data);\n}\nvar allowsEval = cached(() => {\n  try {\n    const F2 = Function;\n    new F2("");\n    return true;\n  } catch (_3) {\n    return false;\n  }\n});\nfunction isPlainObject(data) {\n  return typeof data === "object" && data !== null && (Object.getPrototypeOf(data) === Object.prototype || Object.getPrototypeOf(data) === null);\n}\nfunction numKeys(data) {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\nvar getParsedType = (data) => {\n  const t2 = typeof data;\n  switch (t2) {\n    case "undefined":\n      return "undefined";\n    case "string":\n      return "string";\n    case "number":\n      return Number.isNaN(data) ? "nan" : "number";\n    case "boolean":\n      return "boolean";\n    case "function":\n      return "function";\n    case "bigint":\n      return "bigint";\n    case "symbol":\n      return "symbol";\n    case "object":\n      if (Array.isArray(data)) {\n        return "array";\n      }\n      if (data === null) {\n        return "null";\n      }\n      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {\n        return "promise";\n      }\n      if (typeof Map !== "undefined" && data instanceof Map) {\n        return "map";\n      }\n      if (typeof Set !== "undefined" && data instanceof Set) {\n        return "set";\n      }\n      if (typeof Date !== "undefined" && data instanceof Date) {\n        return "date";\n      }\n      if (typeof File !== "undefined" && data instanceof File) {\n        return "file";\n      }\n      return "object";\n    default:\n      throw new Error(`Unknown data type: ${t2}`);\n  }\n};\nvar propertyKeyTypes = new Set(["string", "number", "symbol"]);\nvar primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);\nfunction escapeRegex(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction clone(inst, def, params) {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent)\n    cl._zod.parent = inst;\n  return cl;\n}\nfunction normalizeParams(_params) {\n  const params = _params;\n  if (!params)\n    return {};\n  if (typeof params === "string")\n    return { error: () => params };\n  if (params?.message !== undefined) {\n    if (params?.error !== undefined)\n      throw new Error("Cannot specify both `message` and `error` params");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === "string")\n    return { ...params, error: () => params.error };\n  return params;\n}\nfunction createTransparentProxy(getter) {\n  let target;\n  return new Proxy({}, {\n    get(_3, prop, receiver) {\n      target ?? (target = getter());\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_3, prop, value, receiver) {\n      target ?? (target = getter());\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_3, prop) {\n      target ?? (target = getter());\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_3, prop) {\n      target ?? (target = getter());\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_3) {\n      target ?? (target = getter());\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_3, prop) {\n      target ?? (target = getter());\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_3, prop, descriptor) {\n      target ?? (target = getter());\n      return Reflect.defineProperty(target, prop, descriptor);\n    }\n  });\n}\nfunction stringifyPrimitive(value) {\n  if (typeof value === "bigint")\n    return value.toString() + "n";\n  if (typeof value === "string")\n    return `"${value}"`;\n  return `${value}`;\n}\nfunction optionalKeys(shape) {\n  return Object.keys(shape).filter((k2) => {\n    return shape[k2]._zod.optin === "optional" && shape[k2]._zod.optout === "optional";\n  });\n}\nvar NUMBER_FORMAT_RANGES = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nvar BIGINT_FORMAT_RANGES = {\n  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],\n  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]\n};\nfunction pick(schema, mask) {\n  const newShape = {};\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: "${key}"`);\n    }\n    if (!mask[key])\n      continue;\n    newShape[key] = currDef.shape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction omit(schema, mask) {\n  const newShape = { ...schema._zod.def.shape };\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: "${key}"`);\n    }\n    if (!mask[key])\n      continue;\n    delete newShape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction extend(schema, shape) {\n  const def = {\n    ...schema._zod.def,\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, "shape", _shape);\n      return _shape;\n    },\n    checks: []\n  };\n  return clone(schema, def);\n}\nfunction merge(a2, b2) {\n  return clone(a2, {\n    ...a2._zod.def,\n    get shape() {\n      const _shape = { ...a2._zod.def.shape, ...b2._zod.def.shape };\n      assignProp(this, "shape", _shape);\n      return _shape;\n    },\n    catchall: b2._zod.def.catchall,\n    checks: []\n  });\n}\nfunction partial(Class, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = { ...oldShape };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in oldShape)) {\n        throw new Error(`Unrecognized key: "${key}"`);\n      }\n      if (!mask[key])\n        continue;\n      shape[key] = Class ? new Class({\n        type: "optional",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = Class ? new Class({\n        type: "optional",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    checks: []\n  });\n}\nfunction required(Class, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = { ...oldShape };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in shape)) {\n        throw new Error(`Unrecognized key: "${key}"`);\n      }\n      if (!mask[key])\n        continue;\n      shape[key] = new Class({\n        type: "nonoptional",\n        innerType: oldShape[key]\n      });\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = new Class({\n        type: "nonoptional",\n        innerType: oldShape[key]\n      });\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    checks: []\n  });\n}\nfunction aborted(x2, startIndex = 0) {\n  for (let i2 = startIndex;i2 < x2.issues.length; i2++) {\n    if (x2.issues[i2].continue !== true)\n      return true;\n  }\n  return false;\n}\nfunction prefixIssues(path, issues) {\n  return issues.map((iss) => {\n    var _a15;\n    (_a15 = iss).path ?? (_a15.path = []);\n    iss.path.unshift(path);\n    return iss;\n  });\n}\nfunction unwrapMessage(message) {\n  return typeof message === "string" ? message : message?.message;\n}\nfunction finalizeIssue(iss, ctx, config2) {\n  const full = { ...iss, path: iss.path ?? [] };\n  if (!iss.message) {\n    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";\n    full.message = message;\n  }\n  delete full.inst;\n  delete full.continue;\n  if (!ctx?.reportInput) {\n    delete full.input;\n  }\n  return full;\n}\nfunction getSizableOrigin(input) {\n  if (input instanceof Set)\n    return "set";\n  if (input instanceof Map)\n    return "map";\n  if (input instanceof File)\n    return "file";\n  return "unknown";\n}\nfunction getLengthableOrigin(input) {\n  if (Array.isArray(input))\n    return "array";\n  if (typeof input === "string")\n    return "string";\n  return "unknown";\n}\nfunction issue(...args) {\n  const [iss, input, inst] = args;\n  if (typeof iss === "string") {\n    return {\n      message: iss,\n      code: "custom",\n      input,\n      inst\n    };\n  }\n  return { ...iss };\n}\nfunction cleanEnum(obj) {\n  return Object.entries(obj).filter(([k2, _3]) => {\n    return Number.isNaN(Number.parseInt(k2, 10));\n  }).map((el) => el[1]);\n}\n\nclass Class {\n  constructor(..._args) {}\n}\n\n// ../../node_modules/zod/dist/esm/v4/core/errors.js\nvar initializer = (inst, def) => {\n  inst.name = "$ZodError";\n  Object.defineProperty(inst, "_zod", {\n    value: inst._zod,\n    enumerable: false\n  });\n  Object.defineProperty(inst, "issues", {\n    value: def,\n    enumerable: false\n  });\n  Object.defineProperty(inst, "message", {\n    get() {\n      return JSON.stringify(def, jsonStringifyReplacer, 2);\n    },\n    enumerable: true\n  });\n};\nvar $ZodError = $constructor("$ZodError", initializer);\nvar $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });\nfunction flattenError(error, mapper = (issue2) => issue2.message) {\n  const fieldErrors = {};\n  const formErrors = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n      fieldErrors[sub.path[0]].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return { formErrors, fieldErrors };\n}\nfunction formatError(error, _mapper) {\n  const mapper = _mapper || function(issue2) {\n    return issue2.message;\n  };\n  const fieldErrors = { _errors: [] };\n  const processError = (error2) => {\n    for (const issue2 of error2.issues) {\n      if (issue2.code === "invalid_union" && issue2.errors.length) {\n        issue2.errors.map((issues) => processError({ issues }));\n      } else if (issue2.code === "invalid_key") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.code === "invalid_element") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.path.length === 0) {\n        fieldErrors._errors.push(mapper(issue2));\n      } else {\n        let curr = fieldErrors;\n        let i2 = 0;\n        while (i2 < issue2.path.length) {\n          const el = issue2.path[i2];\n          const terminal = i2 === issue2.path.length - 1;\n          if (!terminal) {\n            curr[el] = curr[el] || { _errors: [] };\n          } else {\n            curr[el] = curr[el] || { _errors: [] };\n            curr[el]._errors.push(mapper(issue2));\n          }\n          curr = curr[el];\n          i2++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}\nfunction treeifyError(error, _mapper) {\n  const mapper = _mapper || function(issue2) {\n    return issue2.message;\n  };\n  const result = { errors: [] };\n  const processError = (error2, path = []) => {\n    var _a15, _b;\n    for (const issue2 of error2.issues) {\n      if (issue2.code === "invalid_union" && issue2.errors.length) {\n        issue2.errors.map((issues) => processError({ issues }, issue2.path));\n      } else if (issue2.code === "invalid_key") {\n        processError({ issues: issue2.issues }, issue2.path);\n      } else if (issue2.code === "invalid_element") {\n        processError({ issues: issue2.issues }, issue2.path);\n      } else {\n        const fullpath = [...path, ...issue2.path];\n        if (fullpath.length === 0) {\n          result.errors.push(mapper(issue2));\n          continue;\n        }\n        let curr = result;\n        let i2 = 0;\n        while (i2 < fullpath.length) {\n          const el = fullpath[i2];\n          const terminal = i2 === fullpath.length - 1;\n          if (typeof el === "string") {\n            curr.properties ?? (curr.properties = {});\n            (_a15 = curr.properties)[el] ?? (_a15[el] = { errors: [] });\n            curr = curr.properties[el];\n          } else {\n            curr.items ?? (curr.items = []);\n            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });\n            curr = curr.items[el];\n          }\n          if (terminal) {\n            curr.errors.push(mapper(issue2));\n          }\n          i2++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return result;\n}\nfunction toDotPath(path) {\n  const segs = [];\n  for (const seg of path) {\n    if (typeof seg === "number")\n      segs.push(`[${seg}]`);\n    else if (typeof seg === "symbol")\n      segs.push(`[${JSON.stringify(String(seg))}]`);\n    else if (/[^\\w$]/.test(seg))\n      segs.push(`[${JSON.stringify(seg)}]`);\n    else {\n      if (segs.length)\n        segs.push(".");\n      segs.push(seg);\n    }\n  }\n  return segs.join("");\n}\nfunction prettifyError(error) {\n  const lines = [];\n  const issues = [...error.issues].sort((a2, b2) => a2.path.length - b2.path.length);\n  for (const issue2 of issues) {\n    lines.push(` ${issue2.message}`);\n    if (issue2.path?.length)\n      lines.push(`   at ${toDotPath(issue2.path)}`);\n  }\n  return lines.join(`\n`);\n}\n\n// ../../node_modules/zod/dist/esm/v4/core/parse.js\nvar _parse = (_Err) => (schema, value, _ctx, _params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError;\n  }\n  if (result.issues.length) {\n    const e2 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    Error.captureStackTrace(e2, _params?.callee);\n    throw e2;\n  }\n  return result.value;\n};\nvar parse = /* @__PURE__ */ _parse($ZodRealError);\nvar _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  if (result.issues.length) {\n    const e2 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    Error.captureStackTrace(e2, params?.callee);\n    throw e2;\n  }\n  return result.value;\n};\nvar parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);\nvar _safeParse = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError;\n  }\n  return result.issues.length ? {\n    success: false,\n    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParse = /* @__PURE__ */ _safeParse($ZodRealError);\nvar _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  return result.issues.length ? {\n    success: false,\n    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);\n// ../../node_modules/zod/dist/esm/v4/core/regexes.js\nvar exports_regexes = {};\n__export(exports_regexes, {\n  xid: () => xid,\n  uuid7: () => uuid7,\n  uuid6: () => uuid6,\n  uuid4: () => uuid4,\n  uuid: () => uuid,\n  uppercase: () => uppercase,\n  unicodeEmail: () => unicodeEmail,\n  undefined: () => _undefined,\n  ulid: () => ulid,\n  time: () => time,\n  string: () => string,\n  rfc5322Email: () => rfc5322Email,\n  number: () => number,\n  null: () => _null,\n  nanoid: () => nanoid,\n  lowercase: () => lowercase,\n  ksuid: () => ksuid,\n  ipv6: () => ipv6,\n  ipv4: () => ipv4,\n  integer: () => integer,\n  html5Email: () => html5Email,\n  hostname: () => hostname,\n  guid: () => guid,\n  extendedDuration: () => extendedDuration,\n  emoji: () => emoji,\n  email: () => email,\n  e164: () => e164,\n  duration: () => duration,\n  domain: () => domain,\n  datetime: () => datetime,\n  date: () => date,\n  cuid2: () => cuid2,\n  cuid: () => cuid,\n  cidrv6: () => cidrv6,\n  cidrv4: () => cidrv4,\n  browserEmail: () => browserEmail,\n  boolean: () => boolean,\n  bigint: () => bigint,\n  base64url: () => base64url,\n  base64: () => base64,\n  _emoji: () => _emoji\n});\nvar cuid = /^[cC][^\\s-]{8,}$/;\nvar cuid2 = /^[0-9a-z]+$/;\nvar ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;\nvar xid = /^[0-9a-vA-V]{20}$/;\nvar ksuid = /^[A-Za-z0-9]{27}$/;\nvar nanoid = /^[a-zA-Z0-9_-]{21}$/;\nvar duration = /^P(?:(\\d+W)|(?!.*W)(?=\\d|T\\d)(\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+([.,]\\d+)?S)?)?)$/;\nvar extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;\nvar uuid = (version) => {\n  if (!version)\n    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;\n  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);\n};\nvar uuid4 = /* @__PURE__ */ uuid(4);\nvar uuid6 = /* @__PURE__ */ uuid(6);\nvar uuid7 = /* @__PURE__ */ uuid(7);\nvar email = /^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_\'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$/;\nvar html5Email = /^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nvar rfc5322Email = /^(([^<>()\\[\\]\\\\.,;:\\s@"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@"]+)*)|(".+"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\nvar unicodeEmail = /^[^\\s@"]{1,64}@[^\\s@]{1,255}$/u;\nvar browserEmail = /^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nvar _emoji = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nfunction emoji() {\n  return new RegExp(_emoji, "u");\n}\nvar ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;\nvar cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/([0-9]|[1-2][0-9]|3[0-2])$/;\nvar cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\nvar base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;\nvar base64url = /^[A-Za-z0-9_-]*$/;\nvar hostname = /^([a-zA-Z0-9-]+\\.)*[a-zA-Z0-9-]+$/;\nvar domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/;\nvar e164 = /^\\+(?:[0-9]){6,14}[0-9]$/;\nvar dateSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nvar date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);\nfunction timeSource(args) {\n  let regex = `([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d`;\n  if (args.precision) {\n    regex = `${regex}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    regex = `${regex}(\\\\.\\\\d+)?`;\n  }\n  return regex;\n}\nfunction time(args) {\n  return new RegExp(`^${timeSource(args)}$`);\n}\nfunction datetime(args) {\n  let regex = `${dateSource}T${timeSource(args)}`;\n  const opts = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset)\n    opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join("|")})`;\n  return new RegExp(`^${regex}$`);\n}\nvar string = (params) => {\n  const regex = params ? `[\\\\s\\\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\\\s\\\\S]*`;\n  return new RegExp(`^${regex}$`);\n};\nvar bigint = /^\\d+n?$/;\nvar integer = /^\\d+$/;\nvar number = /^-?\\d+(?:\\.\\d+)?/i;\nvar boolean = /true|false/i;\nvar _null = /null/i;\nvar _undefined = /undefined/i;\nvar lowercase = /^[^A-Z]*$/;\nvar uppercase = /^[^a-z]*$/;\n\n// ../../node_modules/zod/dist/esm/v4/core/checks.js\nvar $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {\n  var _a15;\n  inst._zod ?? (inst._zod = {});\n  inst._zod.def = def;\n  (_a15 = inst._zod).onattach ?? (_a15.onattach = []);\n});\nvar numericOriginMap = {\n  number: "number",\n  bigint: "bigint",\n  object: "date"\n};\nvar $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const origin = numericOriginMap[typeof def.value];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;\n    if (def.value < curr) {\n      if (def.inclusive)\n        bag.maximum = def.value;\n      else\n        bag.exclusiveMaximum = def.value;\n    }\n  });\n  inst._zod.check = (payload) => {\n    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {\n      return;\n    }\n    payload.issues.push({\n      origin,\n      code: "too_big",\n      maximum: def.value,\n      input: payload.value,\n      inclusive: def.inclusive,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const origin = numericOriginMap[typeof def.value];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;\n    if (def.value > curr) {\n      if (def.inclusive)\n        bag.minimum = def.value;\n      else\n        bag.exclusiveMinimum = def.value;\n    }\n  });\n  inst._zod.check = (payload) => {\n    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {\n      return;\n    }\n    payload.issues.push({\n      origin,\n      code: "too_small",\n      minimum: def.value,\n      input: payload.value,\n      inclusive: def.inclusive,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    var _a15;\n    (_a15 = inst2._zod.bag).multipleOf ?? (_a15.multipleOf = def.value);\n  });\n  inst._zod.check = (payload) => {\n    if (typeof payload.value !== typeof def.value)\n      throw new Error("Cannot mix number and bigint in multiple_of check.");\n    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;\n    if (isMultiple)\n      return;\n    payload.issues.push({\n      origin: typeof payload.value,\n      code: "not_multiple_of",\n      divisor: def.value,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  def.format = def.format || "float64";\n  const isInt = def.format?.includes("int");\n  const origin = isInt ? "int" : "number";\n  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    bag.minimum = minimum;\n    bag.maximum = maximum;\n    if (isInt)\n      bag.pattern = integer;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    if (isInt) {\n      if (!Number.isInteger(input)) {\n        payload.issues.push({\n          expected: origin,\n          format: def.format,\n          code: "invalid_type",\n          input,\n          inst\n        });\n        return;\n      }\n      if (!Number.isSafeInteger(input)) {\n        if (input > 0) {\n          payload.issues.push({\n            input,\n            code: "too_big",\n            maximum: Number.MAX_SAFE_INTEGER,\n            note: "Integers must be within the safe integer range.",\n            inst,\n            origin,\n            continue: !def.abort\n          });\n        } else {\n          payload.issues.push({\n            input,\n            code: "too_small",\n            minimum: Number.MIN_SAFE_INTEGER,\n            note: "Integers must be within the safe integer range.",\n            inst,\n            origin,\n            continue: !def.abort\n          });\n        }\n        return;\n      }\n    }\n    if (input < minimum) {\n      payload.issues.push({\n        origin: "number",\n        input,\n        code: "too_small",\n        minimum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n    if (input > maximum) {\n      payload.issues.push({\n        origin: "number",\n        input,\n        code: "too_big",\n        maximum,\n        inst\n      });\n    }\n  };\n});\nvar $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    bag.minimum = minimum;\n    bag.maximum = maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    if (input < minimum) {\n      payload.issues.push({\n        origin: "bigint",\n        input,\n        code: "too_small",\n        minimum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n    if (input > maximum) {\n      payload.issues.push({\n        origin: "bigint",\n        input,\n        code: "too_big",\n        maximum,\n        inst\n      });\n    }\n  };\n});\nvar $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.size !== undefined;\n  };\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr)\n      inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const size = input.size;\n    if (size <= def.maximum)\n      return;\n    payload.issues.push({\n      origin: getSizableOrigin(input),\n      code: "too_big",\n      maximum: def.maximum,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.size !== undefined;\n  };\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr)\n      inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const size = input.size;\n    if (size >= def.minimum)\n      return;\n    payload.issues.push({\n      origin: getSizableOrigin(input),\n      code: "too_small",\n      minimum: def.minimum,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.size !== undefined;\n  };\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.size;\n    bag.maximum = def.size;\n    bag.size = def.size;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const size = input.size;\n    if (size === def.size)\n      return;\n    const tooBig = size > def.size;\n    payload.issues.push({\n      origin: getSizableOrigin(input),\n      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== undefined;\n  };\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr)\n      inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length <= def.maximum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: "too_big",\n      maximum: def.maximum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== undefined;\n  };\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr)\n      inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length >= def.minimum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: "too_small",\n      minimum: def.minimum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== undefined;\n  };\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.length;\n    bag.maximum = def.length;\n    bag.length = def.length;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length === def.length)\n      return;\n    const origin = getLengthableOrigin(input);\n    const tooBig = length > def.length;\n    payload.issues.push({\n      origin,\n      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {\n  var _a15;\n  $ZodCheck.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    if (def.pattern) {\n      bag.patterns ?? (bag.patterns = new Set);\n      bag.patterns.add(def.pattern);\n    }\n  });\n  (_a15 = inst._zod).check ?? (_a15.check = (payload) => {\n    if (!def.pattern)\n      throw new Error("Not implemented.");\n    def.pattern.lastIndex = 0;\n    if (def.pattern.test(payload.value))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: def.format,\n      input: payload.value,\n      ...def.pattern ? { pattern: def.pattern.toString() } : {},\n      inst,\n      continue: !def.abort\n    });\n  });\n});\nvar $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {\n  $ZodCheckStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    def.pattern.lastIndex = 0;\n    if (def.pattern.test(payload.value))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "regex",\n      input: payload.value,\n      pattern: def.pattern.toString(),\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {\n  def.pattern ?? (def.pattern = lowercase);\n  $ZodCheckStringFormat.init(inst, def);\n});\nvar $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {\n  def.pattern ?? (def.pattern = uppercase);\n  $ZodCheckStringFormat.init(inst, def);\n});\nvar $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const escapedRegex = escapeRegex(def.includes);\n  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);\n  def.pattern = pattern;\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = new Set);\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = (payload) => {\n    if (payload.value.includes(def.includes, def.position))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "includes",\n      includes: def.includes,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);\n  def.pattern ?? (def.pattern = pattern);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = new Set);\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = (payload) => {\n    if (payload.value.startsWith(def.prefix))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "starts_with",\n      prefix: def.prefix,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);\n  def.pattern ?? (def.pattern = pattern);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = new Set);\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = (payload) => {\n    if (payload.value.endsWith(def.suffix))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "ends_with",\n      suffix: def.suffix,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nfunction handleCheckPropertyResult(result, payload, property) {\n  if (result.issues.length) {\n    payload.issues.push(...prefixIssues(property, result.issues));\n  }\n}\nvar $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = (payload) => {\n    const result = def.schema._zod.run({\n      value: payload.value[def.property],\n      issues: []\n    }, {});\n    if (result instanceof Promise) {\n      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));\n    }\n    handleCheckPropertyResult(result, payload, def.property);\n    return;\n  };\n});\nvar $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const mimeSet = new Set(def.mime);\n  inst._zod.onattach.push((inst2) => {\n    inst2._zod.bag.mime = def.mime;\n  });\n  inst._zod.check = (payload) => {\n    if (mimeSet.has(payload.value.type))\n      return;\n    payload.issues.push({\n      code: "invalid_value",\n      values: def.mime,\n      input: payload.value.type,\n      path: ["type"],\n      inst\n    });\n  };\n});\nvar $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = (payload) => {\n    payload.value = def.tx(payload.value);\n  };\n});\n\n// ../../node_modules/zod/dist/esm/v4/core/doc.js\nclass Doc {\n  constructor(args = []) {\n    this.content = [];\n    this.indent = 0;\n    if (this)\n      this.args = args;\n  }\n  indented(fn) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n  write(arg) {\n    if (typeof arg === "function") {\n      arg(this, { execution: "sync" });\n      arg(this, { execution: "async" });\n      return;\n    }\n    const content = arg;\n    const lines = content.split(`\n`).filter((x2) => x2);\n    const minIndent = Math.min(...lines.map((x2) => x2.length - x2.trimStart().length));\n    const dedented = lines.map((x2) => x2.slice(minIndent)).map((x2) => " ".repeat(this.indent * 2) + x2);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n  compile() {\n    const F2 = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x2) => `  ${x2}`)];\n    return new F2(...args, lines.join(`\n`));\n  }\n}\n\n// ../../node_modules/zod/dist/esm/v4/core/versions.js\nvar version = {\n  major: 4,\n  minor: 0,\n  patch: 0\n};\n\n// ../../node_modules/zod/dist/esm/v4/core/schemas.js\nvar $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {\n  var _a15;\n  inst ?? (inst = {});\n  inst._zod.id = def.type + "_" + randomString(10);\n  inst._zod.def = def;\n  inst._zod.bag = inst._zod.bag || {};\n  inst._zod.version = version;\n  const checks = [...inst._zod.def.checks ?? []];\n  if (inst._zod.traits.has("$ZodCheck")) {\n    checks.unshift(inst);\n  }\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n  if (checks.length === 0) {\n    (_a15 = inst._zod).deferred ?? (_a15.deferred = []);\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (payload, checks2, ctx) => {\n      let isAborted = aborted(payload);\n      let asyncResult;\n      for (const ch of checks2) {\n        if (ch._zod.when) {\n          const shouldRun = ch._zod.when(payload);\n          if (!shouldRun)\n            continue;\n        } else {\n          if (isAborted) {\n            continue;\n          }\n        }\n        const currLen = payload.issues.length;\n        const _3 = ch._zod.check(payload);\n        if (_3 instanceof Promise && ctx?.async === false) {\n          throw new $ZodAsyncError;\n        }\n        if (asyncResult || _3 instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _3;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen)\n              return;\n            if (!isAborted)\n              isAborted = aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen)\n            continue;\n          if (!isAborted)\n            isAborted = aborted(payload, currLen);\n        }\n      }\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n    inst._zod.run = (payload, ctx) => {\n      const result = inst._zod.parse(payload, ctx);\n      if (result instanceof Promise) {\n        if (ctx.async === false)\n          throw new $ZodAsyncError;\n        return result.then((result2) => runChecks(result2, checks, ctx));\n      }\n      return runChecks(result, checks, ctx);\n    };\n  }\n  inst["~standard"] = {\n    validate: (value) => {\n      try {\n        const r2 = safeParse(inst, value);\n        return r2.success ? { value: r2.data } : { issues: r2.error?.issues };\n      } catch (_3) {\n        return safeParseAsync(inst, value).then((r2) => r2.success ? { value: r2.data } : { issues: r2.error?.issues });\n      }\n    },\n    vendor: "zod",\n    version: 1\n  };\n});\nvar $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);\n  inst._zod.parse = (payload, _3) => {\n    if (def.coerce)\n      try {\n        payload.value = String(payload.value);\n      } catch (_4) {}\n    if (typeof payload.value === "string")\n      return payload;\n    payload.issues.push({\n      expected: "string",\n      code: "invalid_type",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {\n  $ZodCheckStringFormat.init(inst, def);\n  $ZodString.init(inst, def);\n});\nvar $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {\n  def.pattern ?? (def.pattern = guid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {\n  if (def.version) {\n    const versionMap = {\n      v1: 1,\n      v2: 2,\n      v3: 3,\n      v4: 4,\n      v5: 5,\n      v6: 6,\n      v7: 7,\n      v8: 8\n    };\n    const v3 = versionMap[def.version];\n    if (v3 === undefined)\n      throw new Error(`Invalid UUID version: "${def.version}"`);\n    def.pattern ?? (def.pattern = uuid(v3));\n  } else\n    def.pattern ?? (def.pattern = uuid());\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {\n  def.pattern ?? (def.pattern = email);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    try {\n      const url = new URL(payload.value);\n      if (def.hostname) {\n        def.hostname.lastIndex = 0;\n        if (!def.hostname.test(url.hostname)) {\n          payload.issues.push({\n            code: "invalid_format",\n            format: "url",\n            note: "Invalid hostname",\n            pattern: hostname.source,\n            input: payload.value,\n            inst\n          });\n        }\n      }\n      if (def.protocol) {\n        def.protocol.lastIndex = 0;\n        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {\n          payload.issues.push({\n            code: "invalid_format",\n            format: "url",\n            note: "Invalid protocol",\n            pattern: def.protocol.source,\n            input: payload.value,\n            inst\n          });\n        }\n      }\n      return;\n    } catch (_3) {\n      payload.issues.push({\n        code: "invalid_format",\n        format: "url",\n        input: payload.value,\n        inst\n      });\n    }\n  };\n});\nvar $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {\n  def.pattern ?? (def.pattern = emoji());\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {\n  def.pattern ?? (def.pattern = nanoid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {\n  def.pattern ?? (def.pattern = cuid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {\n  def.pattern ?? (def.pattern = cuid2);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {\n  def.pattern ?? (def.pattern = ulid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {\n  def.pattern ?? (def.pattern = xid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {\n  def.pattern ?? (def.pattern = ksuid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {\n  def.pattern ?? (def.pattern = datetime(def));\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {\n  def.pattern ?? (def.pattern = date);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {\n  def.pattern ?? (def.pattern = time(def));\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {\n  def.pattern ?? (def.pattern = duration);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {\n  def.pattern ?? (def.pattern = ipv4);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = `ipv4`;\n  });\n});\nvar $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {\n  def.pattern ?? (def.pattern = ipv6);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = `ipv6`;\n  });\n  inst._zod.check = (payload) => {\n    try {\n      new URL(`http://[${payload.value}]`);\n    } catch {\n      payload.issues.push({\n        code: "invalid_format",\n        format: "ipv6",\n        input: payload.value,\n        inst\n      });\n    }\n  };\n});\nvar $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {\n  def.pattern ?? (def.pattern = cidrv4);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {\n  def.pattern ?? (def.pattern = cidrv6);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    const [address, prefix] = payload.value.split("/");\n    try {\n      if (!prefix)\n        throw new Error;\n      const prefixNum = Number(prefix);\n      if (`${prefixNum}` !== prefix)\n        throw new Error;\n      if (prefixNum < 0 || prefixNum > 128)\n        throw new Error;\n      new URL(`http://[${address}]`);\n    } catch {\n      payload.issues.push({\n        code: "invalid_format",\n        format: "cidrv6",\n        input: payload.value,\n        inst\n      });\n    }\n  };\n});\nfunction isValidBase64(data) {\n  if (data === "")\n    return true;\n  if (data.length % 4 !== 0)\n    return false;\n  try {\n    atob(data);\n    return true;\n  } catch {\n    return false;\n  }\n}\nvar $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {\n  def.pattern ?? (def.pattern = base64);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    inst2._zod.bag.contentEncoding = "base64";\n  });\n  inst._zod.check = (payload) => {\n    if (isValidBase64(payload.value))\n      return;\n    payload.issues.push({\n      code: "invalid_format",\n      format: "base64",\n      input: payload.value,\n      inst\n    });\n  };\n});\nfunction isValidBase64URL(data) {\n  if (!base64url.test(data))\n    return false;\n  const base642 = data.replace(/[-_]/g, (c2) => c2 === "-" ? "+" : "/");\n  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");\n  return isValidBase64(padded);\n}\nvar $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {\n  def.pattern ?? (def.pattern = base64url);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    inst2._zod.bag.contentEncoding = "base64url";\n  });\n  inst._zod.check = (payload) => {\n    if (isValidBase64URL(payload.value))\n      return;\n    payload.issues.push({\n      code: "invalid_format",\n      format: "base64url",\n      input: payload.value,\n      inst\n    });\n  };\n});\nvar $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {\n  def.pattern ?? (def.pattern = e164);\n  $ZodStringFormat.init(inst, def);\n});\nfunction isValidJWT(token, algorithm = null) {\n  try {\n    const tokensParts = token.split(".");\n    if (tokensParts.length !== 3)\n      return false;\n    const [header] = tokensParts;\n    const parsedHeader = JSON.parse(atob(header));\n    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")\n      return false;\n    if (!parsedHeader.alg)\n      return false;\n    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))\n      return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nvar $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    if (isValidJWT(payload.value, def.alg))\n      return;\n    payload.issues.push({\n      code: "invalid_format",\n      format: "jwt",\n      input: payload.value,\n      inst\n    });\n  };\n});\nvar $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = inst._zod.bag.pattern ?? number;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce)\n      try {\n        payload.value = Number(payload.value);\n      } catch (_3) {}\n    const input = payload.value;\n    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {\n      return payload;\n    }\n    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;\n    payload.issues.push({\n      expected: "number",\n      code: "invalid_type",\n      input,\n      inst,\n      ...received ? { received } : {}\n    });\n    return payload;\n  };\n});\nvar $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {\n  $ZodCheckNumberFormat.init(inst, def);\n  $ZodNumber.init(inst, def);\n});\nvar $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = boolean;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce)\n      try {\n        payload.value = Boolean(payload.value);\n      } catch (_3) {}\n    const input = payload.value;\n    if (typeof input === "boolean")\n      return payload;\n    payload.issues.push({\n      expected: "boolean",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = bigint;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce)\n      try {\n        payload.value = BigInt(payload.value);\n      } catch (_3) {}\n    const { value: input } = payload;\n    if (typeof input === "bigint")\n      return payload;\n    payload.issues.push({\n      expected: "bigint",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {\n  $ZodCheckBigIntFormat.init(inst, def);\n  $ZodBigInt.init(inst, def);\n});\nvar $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const { value: input } = payload;\n    if (typeof input === "symbol")\n      return payload;\n    payload.issues.push({\n      expected: "symbol",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = _undefined;\n  inst._zod.values = new Set([undefined]);\n  inst._zod.parse = (payload, _ctx) => {\n    const { value: input } = payload;\n    if (typeof input === "undefined")\n      return payload;\n    payload.issues.push({\n      expected: "undefined",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = _null;\n  inst._zod.values = new Set([null]);\n  inst._zod.parse = (payload, _ctx) => {\n    const { value: input } = payload;\n    if (input === null)\n      return payload;\n    payload.issues.push({\n      expected: "null",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload) => payload;\n});\nvar $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload) => payload;\n});\nvar $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: "never",\n      code: "invalid_type",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const { value: input } = payload;\n    if (typeof input === "undefined")\n      return payload;\n    payload.issues.push({\n      expected: "void",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) {\n      try {\n        payload.value = new Date(payload.value);\n      } catch (_err) {}\n    }\n    const input = payload.value;\n    const isDate = input instanceof Date;\n    const isValidDate = isDate && !Number.isNaN(input.getTime());\n    if (isValidDate)\n      return payload;\n    payload.issues.push({\n      expected: "date",\n      code: "invalid_type",\n      input,\n      ...isDate ? { received: "Invalid Date" } : {},\n      inst\n    });\n    return payload;\n  };\n});\nfunction handleArrayResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: "array",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = Array(input.length);\n    const proms = [];\n    for (let i2 = 0;i2 < input.length; i2++) {\n      const item = input[i2];\n      const result = def.element._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));\n      } else {\n        handleArrayResult(result, payload, i2);\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nfunction handleObjectResult(result, final, key) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(key, result.issues));\n  }\n  final.value[key] = result.value;\n}\nfunction handleOptionalObjectResult(result, final, key, input) {\n  if (result.issues.length) {\n    if (input[key] === undefined) {\n      if (key in input) {\n        final.value[key] = undefined;\n      } else {\n        final.value[key] = result.value;\n      }\n    } else {\n      final.issues.push(...prefixIssues(key, result.issues));\n    }\n  } else if (result.value === undefined) {\n    if (key in input)\n      final.value[key] = undefined;\n  } else {\n    final.value[key] = result.value;\n  }\n}\nvar $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {\n  $ZodType.init(inst, def);\n  const _normalized = cached(() => {\n    const keys = Object.keys(def.shape);\n    for (const k2 of keys) {\n      if (!(def.shape[k2] instanceof $ZodType)) {\n        throw new Error(`Invalid element at key "${k2}": expected a Zod schema`);\n      }\n    }\n    const okeys = optionalKeys(def.shape);\n    return {\n      shape: def.shape,\n      keys,\n      keySet: new Set(keys),\n      numKeys: keys.length,\n      optionalKeys: new Set(okeys)\n    };\n  });\n  defineLazy(inst._zod, "propValues", () => {\n    const shape = def.shape;\n    const propValues = {};\n    for (const key in shape) {\n      const field = shape[key]._zod;\n      if (field.values) {\n        propValues[key] ?? (propValues[key] = new Set);\n        for (const v3 of field.values)\n          propValues[key].add(v3);\n      }\n    }\n    return propValues;\n  });\n  const generateFastpass = (shape) => {\n    const doc = new Doc(["shape", "payload", "ctx"]);\n    const { keys, optionalKeys: optionalKeys2 } = _normalized.value;\n    const parseStr = (key) => {\n      const k2 = esc(key);\n      return `shape[${k2}]._zod.run({ value: input[${k2}], issues: [] }, ctx)`;\n    };\n    doc.write(`const input = payload.value;`);\n    const ids = Object.create(null);\n    for (const key of keys) {\n      ids[key] = randomString(15);\n    }\n    doc.write(`const newResult = {}`);\n    for (const key of keys) {\n      if (optionalKeys2.has(key)) {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        const k2 = esc(key);\n        doc.write(`\n        if (${id}.issues.length) {\n          if (input[${k2}] === undefined) {\n            if (${k2} in input) {\n              newResult[${k2}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${id}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${k2}, ...iss.path] : [${k2}],\n              }))\n            );\n          }\n        } else if (${id}.value === undefined) {\n          if (${k2} in input) newResult[${k2}] = undefined;\n        } else {\n          newResult[${k2}] = ${id}.value;\n        }\n        `);\n      } else {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        doc.write(`\n          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]\n          })));`);\n        doc.write(`newResult[${esc(key)}] = ${id}.value`);\n      }\n    }\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload, ctx) => fn(shape, payload, ctx);\n  };\n  let fastpass;\n  const isObject2 = isObject;\n  const jit = !globalConfig.jitless;\n  const allowsEval2 = allowsEval;\n  const fastEnabled = jit && allowsEval2.value;\n  const { catchall } = def;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject2(input)) {\n      payload.issues.push({\n        expected: "object",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      if (!fastpass)\n        fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n    } else {\n      payload.value = {};\n      const shape = value.shape;\n      for (const key of value.keys) {\n        const el = shape[key];\n        const r2 = el._zod.run({ value: input[key], issues: [] }, ctx);\n        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";\n        if (r2 instanceof Promise) {\n          proms.push(r2.then((r3) => isOptional ? handleOptionalObjectResult(r3, payload, key, input) : handleObjectResult(r3, payload, key)));\n        } else {\n          if (isOptional) {\n            handleOptionalObjectResult(r2, payload, key, input);\n          } else {\n            handleObjectResult(r2, payload, key);\n          }\n        }\n      }\n    }\n    if (!catchall) {\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    const unrecognized = [];\n    const keySet = value.keySet;\n    const _catchall = catchall._zod;\n    const t2 = _catchall.def.type;\n    for (const key of Object.keys(input)) {\n      if (keySet.has(key))\n        continue;\n      if (t2 === "never") {\n        unrecognized.push(key);\n        continue;\n      }\n      const r2 = _catchall.run({ value: input[key], issues: [] }, ctx);\n      if (r2 instanceof Promise) {\n        proms.push(r2.then((r3) => handleObjectResult(r3, payload, key)));\n      } else {\n        handleObjectResult(r2, payload, key);\n      }\n    }\n    if (unrecognized.length) {\n      payload.issues.push({\n        code: "unrecognized_keys",\n        keys: unrecognized,\n        input,\n        inst\n      });\n    }\n    if (!proms.length)\n      return payload;\n    return Promise.all(proms).then(() => {\n      return payload;\n    });\n  };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n  final.issues.push({\n    code: "invalid_union",\n    input: final.value,\n    inst,\n    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  });\n  return final;\n}\nvar $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "values", () => {\n    if (def.options.every((o2) => o2._zod.values)) {\n      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n    }\n    return;\n  });\n  defineLazy(inst._zod, "pattern", () => {\n    if (def.options.every((o2) => o2._zod.pattern)) {\n      const patterns = def.options.map((o2) => o2._zod.pattern);\n      return new RegExp(`^(${patterns.map((p3) => cleanRegex(p3.source)).join("|")})$`);\n    }\n    return;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0)\n          return result;\n        results.push(result);\n      }\n    }\n    if (!async)\n      return handleUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then((results2) => {\n      return handleUnionResults(results2, payload, inst, ctx);\n    });\n  };\n});\nvar $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  const _super = inst._zod.parse;\n  defineLazy(inst._zod, "propValues", () => {\n    const propValues = {};\n    for (const option of def.options) {\n      const pv = option._zod.propValues;\n      if (!pv || Object.keys(pv).length === 0)\n        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);\n      for (const [k2, v3] of Object.entries(pv)) {\n        if (!propValues[k2])\n          propValues[k2] = new Set;\n        for (const val of v3) {\n          propValues[k2].add(val);\n        }\n      }\n    }\n    return propValues;\n  });\n  const disc = cached(() => {\n    const opts = def.options;\n    const map = new Map;\n    for (const o2 of opts) {\n      const values = o2._zod.propValues[def.discriminator];\n      if (!values || values.size === 0)\n        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o2)}"`);\n      for (const v3 of values) {\n        if (map.has(v3)) {\n          throw new Error(`Duplicate discriminator value "${String(v3)}"`);\n        }\n        map.set(v3, o2);\n      }\n    }\n    return map;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!isObject(input)) {\n      payload.issues.push({\n        code: "invalid_type",\n        expected: "object",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const opt = disc.value.get(input?.[def.discriminator]);\n    if (opt) {\n      return opt._zod.run(payload, ctx);\n    }\n    if (def.unionFallback) {\n      return _super(payload, ctx);\n    }\n    payload.issues.push({\n      code: "invalid_union",\n      errors: [],\n      note: "No matching discriminator",\n      input,\n      path: [def.discriminator],\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const { value: input } = payload;\n    const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n    const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n    const async = left instanceof Promise || right instanceof Promise;\n    if (async) {\n      return Promise.all([left, right]).then(([left2, right2]) => {\n        return handleIntersectionResults(payload, left2, right2);\n      });\n    }\n    return handleIntersectionResults(payload, left, right);\n  };\n});\nfunction mergeValues(a2, b2) {\n  if (a2 === b2) {\n    return { valid: true, data: a2 };\n  }\n  if (a2 instanceof Date && b2 instanceof Date && +a2 === +b2) {\n    return { valid: true, data: a2 };\n  }\n  if (isPlainObject(a2) && isPlainObject(b2)) {\n    const bKeys = Object.keys(b2);\n    const sharedKeys = Object.keys(a2).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a2, ...b2 };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a2[key], b2[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  }\n  if (Array.isArray(a2) && Array.isArray(b2)) {\n    if (a2.length !== b2.length) {\n      return { valid: false, mergeErrorPath: [] };\n    }\n    const newArray = [];\n    for (let index = 0;index < a2.length; index++) {\n      const itemA = a2[index];\n      const itemB = b2[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  }\n  return { valid: false, mergeErrorPath: [] };\n}\nfunction handleIntersectionResults(result, left, right) {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (aborted(result))\n    return result;\n  const merged = mergeValues(left.value, right.value);\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n  result.value = merged.data;\n  return result;\n}\nvar $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {\n  $ZodType.init(inst, def);\n  const items = def.items;\n  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: "tuple",\n        code: "invalid_type"\n      });\n      return payload;\n    }\n    payload.value = [];\n    const proms = [];\n    if (!def.rest) {\n      const tooBig = input.length > items.length;\n      const tooSmall = input.length < optStart - 1;\n      if (tooBig || tooSmall) {\n        payload.issues.push({\n          input,\n          inst,\n          origin: "array",\n          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }\n        });\n        return payload;\n      }\n    }\n    let i2 = -1;\n    for (const item of items) {\n      i2++;\n      if (i2 >= input.length) {\n        if (i2 >= optStart)\n          continue;\n      }\n      const result = item._zod.run({\n        value: input[i2],\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));\n      } else {\n        handleTupleResult(result, payload, i2);\n      }\n    }\n    if (def.rest) {\n      const rest = input.slice(items.length);\n      for (const el of rest) {\n        i2++;\n        const result = def.rest._zod.run({\n          value: el,\n          issues: []\n        }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));\n        } else {\n          handleTupleResult(result, payload, i2);\n        }\n      }\n    }\n    if (proms.length)\n      return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleTupleResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!isPlainObject(input)) {\n      payload.issues.push({\n        expected: "record",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (def.keyType._zod.values) {\n      const values = def.keyType._zod.values;\n      payload.value = {};\n      for (const key of values) {\n        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {\n          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n          if (result instanceof Promise) {\n            proms.push(result.then((result2) => {\n              if (result2.issues.length) {\n                payload.issues.push(...prefixIssues(key, result2.issues));\n              }\n              payload.value[key] = result2.value;\n            }));\n          } else {\n            if (result.issues.length) {\n              payload.issues.push(...prefixIssues(key, result.issues));\n            }\n            payload.value[key] = result.value;\n          }\n        }\n      }\n      let unrecognized;\n      for (const key in input) {\n        if (!values.has(key)) {\n          unrecognized = unrecognized ?? [];\n          unrecognized.push(key);\n        }\n      }\n      if (unrecognized && unrecognized.length > 0) {\n        payload.issues.push({\n          code: "unrecognized_keys",\n          input,\n          inst,\n          keys: unrecognized\n        });\n      }\n    } else {\n      payload.value = {};\n      for (const key of Reflect.ownKeys(input)) {\n        if (key === "__proto__")\n          continue;\n        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n        if (keyResult instanceof Promise) {\n          throw new Error("Async schemas not supported in object keys currently");\n        }\n        if (keyResult.issues.length) {\n          payload.issues.push({\n            origin: "record",\n            code: "invalid_key",\n            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),\n            input: key,\n            path: [key],\n            inst\n          });\n          payload.value[keyResult.value] = keyResult.value;\n          continue;\n        }\n        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then((result2) => {\n            if (result2.issues.length) {\n              payload.issues.push(...prefixIssues(key, result2.issues));\n            }\n            payload.value[keyResult.value] = result2.value;\n          }));\n        } else {\n          if (result.issues.length) {\n            payload.issues.push(...prefixIssues(key, result.issues));\n          }\n          payload.value[keyResult.value] = result.value;\n        }\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nvar $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Map)) {\n      payload.issues.push({\n        expected: "map",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    payload.value = new Map;\n    for (const [key, value] of input) {\n      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);\n      if (keyResult instanceof Promise || valueResult instanceof Promise) {\n        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {\n          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);\n        }));\n      } else {\n        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n      }\n    }\n    if (proms.length)\n      return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {\n  if (keyResult.issues.length) {\n    if (propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...prefixIssues(key, keyResult.issues));\n    } else {\n      final.issues.push({\n        origin: "map",\n        code: "invalid_key",\n        input,\n        inst,\n        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n      });\n    }\n  }\n  if (valueResult.issues.length) {\n    if (propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...prefixIssues(key, valueResult.issues));\n    } else {\n      final.issues.push({\n        origin: "map",\n        code: "invalid_element",\n        input,\n        inst,\n        key,\n        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n      });\n    }\n  }\n  final.value.set(keyResult.value, valueResult.value);\n}\nvar $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Set)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: "set",\n        code: "invalid_type"\n      });\n      return payload;\n    }\n    const proms = [];\n    payload.value = new Set;\n    for (const item of input) {\n      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleSetResult(result2, payload)));\n      } else\n        handleSetResult(result, payload);\n    }\n    if (proms.length)\n      return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleSetResult(result, final) {\n  if (result.issues.length) {\n    final.issues.push(...result.issues);\n  }\n  final.value.add(result.value);\n}\nvar $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {\n  $ZodType.init(inst, def);\n  const values = getEnumValues(def.entries);\n  inst._zod.values = new Set(values);\n  inst._zod.pattern = new RegExp(`^(${values.filter((k2) => propertyKeyTypes.has(typeof k2)).map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2.toString()).join("|")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: "invalid_value",\n      values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.values = new Set(def.values);\n  inst._zod.pattern = new RegExp(`^(${def.values.map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2 ? o2.toString() : String(o2)).join("|")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: "invalid_value",\n      values: def.values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input instanceof File)\n      return payload;\n    payload.issues.push({\n      expected: "file",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const _out = def.transform(payload.value, payload);\n    if (_ctx.async) {\n      const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    if (_out instanceof Promise) {\n      throw new $ZodAsyncError;\n    }\n    payload.value = _out;\n    return payload;\n  };\n});\nvar $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = "optional";\n  inst._zod.optout = "optional";\n  defineLazy(inst._zod, "values", () => {\n    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;\n  });\n  defineLazy(inst._zod, "pattern", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === undefined) {\n      return payload;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, "pattern", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;\n  });\n  defineLazy(inst._zod, "values", () => {\n    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === null)\n      return payload;\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = "optional";\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === undefined) {\n      payload.value = def.defaultValue;\n      return payload;\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleDefaultResult(result2, def));\n    }\n    return handleDefaultResult(result, def);\n  };\n});\nfunction handleDefaultResult(payload, def) {\n  if (payload.value === undefined) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\nvar $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = "optional";\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === undefined) {\n      payload.value = def.defaultValue;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "values", () => {\n    const v3 = def.innerType._zod.values;\n    return v3 ? new Set([...v3].filter((x2) => x2 !== undefined)) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleNonOptionalResult(result2, inst));\n    }\n    return handleNonOptionalResult(result, inst);\n  };\n});\nfunction handleNonOptionalResult(payload, inst) {\n  if (!payload.issues.length && payload.value === undefined) {\n    payload.issues.push({\n      code: "invalid_type",\n      expected: "nonoptional",\n      input: payload.value,\n      inst\n    });\n  }\n  return payload;\n}\nvar $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => {\n        payload.value = result2.issues.length === 0;\n        return payload;\n      });\n    }\n    payload.value = result.issues.length === 0;\n    return payload;\n  };\n});\nvar $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => {\n        payload.value = result2.value;\n        if (result2.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n            },\n            input: payload.value\n          });\n          payload.issues = [];\n        }\n        return payload;\n      });\n    }\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n        },\n        input: payload.value\n      });\n      payload.issues = [];\n    }\n    return payload;\n  };\n});\nvar $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: "nan",\n        code: "invalid_type"\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\nvar $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "values", () => def.in._zod.values);\n  defineLazy(inst._zod, "optin", () => def.in._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.out._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then((left2) => handlePipeResult(left2, def, ctx));\n    }\n    return handlePipeResult(left, def, ctx);\n  };\n});\nfunction handlePipeResult(left, def, ctx) {\n  if (aborted(left)) {\n    return left;\n  }\n  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\nvar $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);\n  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(handleReadonlyResult);\n    }\n    return handleReadonlyResult(result);\n  };\n});\nfunction handleReadonlyResult(payload) {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\nvar $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {\n  $ZodType.init(inst, def);\n  const regexParts = [];\n  for (const part of def.parts) {\n    if (part instanceof $ZodType) {\n      if (!part._zod.pattern) {\n        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);\n      }\n      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;\n      if (!source)\n        throw new Error(`Invalid template literal part: ${part._zod.traits}`);\n      const start = source.startsWith("^") ? 1 : 0;\n      const end = source.endsWith("$") ? source.length - 1 : source.length;\n      regexParts.push(source.slice(start, end));\n    } else if (part === null || primitiveTypes.has(typeof part)) {\n      regexParts.push(escapeRegex(`${part}`));\n    } else {\n      throw new Error(`Invalid template literal part: ${part}`);\n    }\n  }\n  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== "string") {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: "template_literal",\n        code: "invalid_type"\n      });\n      return payload;\n    }\n    inst._zod.pattern.lastIndex = 0;\n    if (!inst._zod.pattern.test(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        code: "invalid_format",\n        format: "template_literal",\n        pattern: inst._zod.pattern.source\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\nvar $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));\n  };\n});\nvar $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "innerType", () => def.getter());\n  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);\n  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);\n  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);\n  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const inner = inst._zod.innerType;\n    return inner._zod.run(payload, ctx);\n  };\n});\nvar $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _3) => {\n    return payload;\n  };\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const r2 = def.fn(input);\n    if (r2 instanceof Promise) {\n      return r2.then((r3) => handleRefineResult(r3, payload, input, inst));\n    }\n    handleRefineResult(r2, payload, input, inst);\n    return;\n  };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n  if (!result) {\n    const _iss = {\n      code: "custom",\n      input,\n      inst,\n      path: [...inst._zod.def.path ?? []],\n      continue: !inst._zod.def.abort\n    };\n    if (inst._zod.def.params)\n      _iss.params = inst._zod.def.params;\n    payload.issues.push(issue(_iss));\n  }\n}\n// ../../node_modules/zod/dist/esm/v4/locales/index.js\nvar exports_locales = {};\n__export(exports_locales, {\n  zhTW: () => zh_TW_default,\n  zhCN: () => zh_CN_default,\n  vi: () => vi_default,\n  ur: () => ur_default,\n  ua: () => ua_default,\n  tr: () => tr_default,\n  th: () => th_default,\n  ta: () => ta_default,\n  sv: () => sv_default,\n  sl: () => sl_default,\n  ru: () => ru_default,\n  pt: () => pt_default,\n  pl: () => pl_default,\n  ota: () => ota_default,\n  no: () => no_default,\n  nl: () => nl_default,\n  ms: () => ms_default,\n  mk: () => mk_default,\n  ko: () => ko_default,\n  kh: () => kh_default,\n  ja: () => ja_default,\n  it: () => it_default,\n  id: () => id_default,\n  hu: () => hu_default,\n  he: () => he_default,\n  frCA: () => fr_CA_default,\n  fr: () => fr_default,\n  fi: () => fi_default,\n  fa: () => fa_default,\n  es: () => es_default,\n  en: () => en_default,\n  de: () => de_default,\n  cs: () => cs_default,\n  ca: () => ca_default,\n  be: () => be_default,\n  az: () => az_default,\n  ar: () => ar_default\n});\n\n// ../../node_modules/zod/dist/esm/v4/locales/ar.js\nvar error = () => {\n  const Sizable = {\n    string: { unit: "", verb: " " },\n    file: { unit: "", verb: " " },\n    array: { unit: "", verb: " " },\n    set: { unit: "", verb: " " }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "number";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: " ",\n    url: "",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "   ISO",\n    date: "  ISO",\n    time: "  ISO",\n    duration: "  ISO",\n    ipv4: " IPv4",\n    ipv6: " IPv6",\n    cidrv4: "   IPv4",\n    cidrv6: "   IPv6",\n    base64: "  base64-encoded",\n    base64url: "  base64url-encoded",\n    json_string: "   JSON",\n    e164: "   E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `  :   ${issue2.expected}    ${parsedType(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `  :   ${stringifyPrimitive(issue2.values[0])}`;\n        return `  :     : ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `   :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return `  :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `  :     "${issue2.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `  :     "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `  :    "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `  :     ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue2.format}  `;\n      }\n      case "not_multiple_of":\n        return `  :      ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;\n      case "invalid_key":\n        return `    ${issue2.origin}`;\n      case "invalid_union":\n        return "  ";\n      case "invalid_element":\n        return `    ${issue2.origin}`;\n      default:\n        return "  ";\n    }\n  };\n};\nfunction ar_default() {\n  return {\n    localeError: error()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/az.js\nvar error2 = () => {\n  const Sizable = {\n    string: { unit: "simvol", verb: "olmaldr" },\n    file: { unit: "bayt", verb: "olmaldr" },\n    array: { unit: "element", verb: "olmaldr" },\n    set: { unit: "element", verb: "olmaldr" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "number";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "input",\n    email: "email address",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO datetime",\n    date: "ISO date",\n    time: "ISO time",\n    duration: "ISO duration",\n    ipv4: "IPv4 address",\n    ipv6: "IPv6 address",\n    cidrv4: "IPv4 range",\n    cidrv6: "IPv6 range",\n    base64: "base64-encoded string",\n    base64url: "base64url-encoded string",\n    json_string: "JSON string",\n    e164: "E.164 number",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Yanl dyr: gzlniln ${issue2.expected}, daxil olan ${parsedType(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Yanl dyr: gzlniln ${stringifyPrimitive(issue2.values[0])}`;\n        return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;\n        return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Yanl mtn: "${_issue.prefix}" il balamaldr`;\n        if (_issue.format === "ends_with")\n          return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;\n        if (_issue.format === "includes")\n          return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;\n        if (_issue.format === "regex")\n          return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;\n        return `Yanl ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Yanl dd: ${issue2.divisor} il bln biln olmaldr`;\n      case "unrecognized_keys":\n        return `Tannmayan aar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin} daxilind yanl aar`;\n      case "invalid_union":\n        return "Yanl dyr";\n      case "invalid_element":\n        return `${issue2.origin} daxilind yanl dyr`;\n      default:\n        return `Yanl dyr`;\n    }\n  };\n};\nfunction az_default() {\n  return {\n    localeError: error2()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/be.js\nfunction getBelarusianPlural(count, one, few, many) {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n  if (lastDigit === 1) {\n    return one;\n  }\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n  return many;\n}\nvar error3 = () => {\n  const Sizable = {\n    string: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    array: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    set: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    file: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: "email ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO   ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "   base64",\n    base64url: "   base64url",\n    json_string: "JSON ",\n    e164: " E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return ` :  ${issue2.expected},  ${parsedType(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` :  ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :    ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          const maxValue = Number(issue2.maximum);\n          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return ` : ,  ${issue2.origin ?? ""}  ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;\n        }\n        return ` : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          const minValue = Number(issue2.minimum);\n          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return ` : ,  ${issue2.origin}  ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;\n        }\n        return ` : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return ` :    "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return ` :    "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return ` :   "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` :    ${_issue.pattern}`;\n        return ` ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` :    ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return " ";\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction be_default() {\n  return {\n    localeError: error3()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/ca.js\nvar error4 = () => {\n  const Sizable = {\n    string: { unit: "carcters", verb: "contenir" },\n    file: { unit: "bytes", verb: "contenir" },\n    array: { unit: "elements", verb: "contenir" },\n    set: { unit: "elements", verb: "contenir" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "number";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "entrada",\n    email: "adrea electrnica",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "data i hora ISO",\n    date: "data ISO",\n    time: "hora ISO",\n    duration: "durada ISO",\n    ipv4: "adrea IPv4",\n    ipv6: "adrea IPv6",\n    cidrv4: "rang IPv4",\n    cidrv6: "rang IPv6",\n    base64: "cadena codificada en base64",\n    base64url: "cadena codificada en base64url",\n    json_string: "cadena JSON",\n    e164: "nmero E.164",\n    jwt: "JWT",\n    template_literal: "entrada"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Tipus invlid: s\'esperava ${issue2.expected}, s\'ha rebut ${parsedType(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Valor invlid: s\'esperava ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opci invlida: s\'esperava una de ${joinValues(issue2.values, " o ")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "com a mxim" : "menys de";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Massa gran: s\'esperava que ${issue2.origin ?? "el valor"} contingus ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;\n        return `Massa gran: s\'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? "com a mnim" : "ms de";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Massa petit: s\'esperava que ${issue2.origin} contingus ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Massa petit: s\'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Format invlid: ha de comenar amb "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Format invlid: ha d\'acabar amb "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Format invlid: ha d\'incloure "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;\n        return `Format invlid per a ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Nmero invlid: ha de ser mltiple de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Clau invlida a ${issue2.origin}`;\n      case "invalid_union":\n        return "Entrada invlida";\n      case "invalid_element":\n        return `Element invlid a ${issue2.origin}`;\n      default:\n        return `Entrada invlida`;\n    }\n  };\n};\nfunction ca_default() {\n  return {\n    localeError: error4()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/cs.js\nvar error5 = () => {\n  const Sizable = {\n    string: { unit: "znak", verb: "mt" },\n    file: { unit: "bajt", verb: "mt" },\n    array: { unit: "prvk", verb: "mt" },\n    set: { unit: "prvk", verb: "mt" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "slo";\n      }\n      case "string": {\n        return "etzec";\n      }\n      case "boolean": {\n        return "boolean";\n      }\n      case "bigint": {\n        return "bigint";\n      }\n      case "function": {\n        return "funkce";\n      }\n      case "symbol": {\n        return "symbol";\n      }\n      case "undefined": {\n        return "undefined";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "pole";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "regulrn vraz",\n    email: "e-mailov adresa",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "datum a as ve formtu ISO",\n    date: "datum ve formtu ISO",\n    time: "as ve formtu ISO",\n    duration: "doba trvn ISO",\n    ipv4: "IPv4 adresa",\n    ipv6: "IPv6 adresa",\n    cidrv4: "rozsah IPv4",\n    cidrv6: "rozsah IPv6",\n    base64: "etzec zakdovan ve formtu base64",\n    base64url: "etzec zakdovan ve formtu base64url",\n    json_string: "etzec ve formtu JSON",\n    e164: "slo E.164",\n    jwt: "JWT",\n    template_literal: "vstup"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Neplatn vstup: oekvno ${issue2.expected}, obdreno ${parsedType(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Neplatn vstup: oekvno ${stringifyPrimitive(issue2.values[0])}`;\n        return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk"}`;\n        }\n        return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk"}`;\n        }\n        return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Neplatn etzec: mus konit na "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;\n        return `Neplatn formt ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Neplatn slo: mus bt nsobkem ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Neznm kle: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Neplatn kl v ${issue2.origin}`;\n      case "invalid_union":\n        return "Neplatn vstup";\n      case "invalid_element":\n        return `Neplatn hodnota v ${issue2.origin}`;\n      default:\n        return `Neplatn vstup`;\n    }\n  };\n};\nfunction cs_default() {\n  return {\n    localeError: error5()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/de.js\nvar error6 = () => {\n  const Sizable = {\n    string: { unit: "Zeichen", verb: "zu haben" },\n    file: { unit: "Bytes", verb: "zu haben" },\n    array: { unit: "Elemente", verb: "zu haben" },\n    set: { unit: "Elemente", verb: "zu haben" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "Zahl";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "Array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "Eingabe",\n    email: "E-Mail-Adresse",\n    url: "URL",\n    emoji: "Emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO-Datum und -Uhrzeit",\n    date: "ISO-Datum",\n    time: "ISO-Uhrzeit",\n    duration: "ISO-Dauer",\n    ipv4: "IPv4-Adresse",\n    ipv6: "IPv6-Adresse",\n    cidrv4: "IPv4-Bereich",\n    cidrv6: "IPv6-Bereich",\n    base64: "Base64-codierter String",\n    base64url: "Base64-URL-codierter String",\n    json_string: "JSON-String",\n    e164: "E.164-Nummer",\n    jwt: "JWT",\n    template_literal: "Eingabe"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Ungltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ungltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;\n        return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;\n        }\n        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;\n        if (_issue.format === "ends_with")\n          return `Ungltiger String: muss mit "${_issue.suffix}" enden`;\n        if (_issue.format === "includes")\n          return `Ungltiger String: muss "${_issue.includes}" enthalten`;\n        if (_issue.format === "regex")\n          return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;\n        return `Ungltig: ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Ungltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Ungltiger Schlssel in ${issue2.origin}`;\n      case "invalid_union":\n        return "Ungltige Eingabe";\n      case "invalid_element":\n        return `Ungltiger Wert in ${issue2.origin}`;\n      default:\n        return `Ungltige Eingabe`;\n    }\n  };\n};\nfunction de_default() {\n  return {\n    localeError: error6()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/en.js\nvar parsedType = (data) => {\n  const t2 = typeof data;\n  switch (t2) {\n    case "number": {\n      return Number.isNaN(data) ? "NaN" : "number";\n    }\n    case "object": {\n      if (Array.isArray(data)) {\n        return "array";\n      }\n      if (data === null) {\n        return "null";\n      }\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t2;\n};\nvar error7 = () => {\n  const Sizable = {\n    string: { unit: "characters", verb: "to have" },\n    file: { unit: "bytes", verb: "to have" },\n    array: { unit: "items", verb: "to have" },\n    set: { unit: "items", verb: "to have" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const Nouns = {\n    regex: "input",\n    email: "email address",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO datetime",\n    date: "ISO date",\n    time: "ISO time",\n    duration: "ISO duration",\n    ipv4: "IPv4 address",\n    ipv6: "IPv6 address",\n    cidrv4: "IPv4 range",\n    cidrv6: "IPv6 range",\n    base64: "base64-encoded string",\n    base64url: "base64url-encoded string",\n    json_string: "JSON string",\n    e164: "E.164 number",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;\n        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;\n        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Invalid string: must start with "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Invalid string: must end with "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Invalid string: must include "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Invalid string: must match pattern ${_issue.pattern}`;\n        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Invalid number: must be a multiple of ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Invalid key in ${issue2.origin}`;\n      case "invalid_union":\n        return "Invalid input";\n      case "invalid_element":\n        return `Invalid value in ${issue2.origin}`;\n      default:\n        return `Invalid input`;\n    }\n  };\n};\nfunction en_default() {\n  return {\n    localeError: error7()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/es.js\nvar error8 = () => {\n  const Sizable = {\n    string: { unit: "caracteres", verb: "tener" },\n    file: { unit: "bytes", verb: "tener" },\n    array: { unit: "elementos", verb: "tener" },\n    set: { unit: "elementos", verb: "tener" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "nmero";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "arreglo";\n        }\n        if (data === null) {\n          return "nulo";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "entrada",\n    email: "direccin de correo electrnico",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "fecha y hora ISO",\n    date: "fecha ISO",\n    time: "hora ISO",\n    duration: "duracin ISO",\n    ipv4: "direccin IPv4",\n    ipv6: "direccin IPv6",\n    cidrv4: "rango IPv4",\n    cidrv6: "rango IPv6",\n    base64: "cadena codificada en base64",\n    base64url: "URL codificada en base64",\n    json_string: "cadena JSON",\n    e164: "nmero E.164",\n    jwt: "JWT",\n    template_literal: "entrada"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Entrada invlida: se esperaba ${issue2.expected}, recibido ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Entrada invlida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opcin invlida: se esperaba una de ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;\n        return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Demasiado pequeo: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Demasiado pequeo: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Cadena invlida: debe terminar en "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Cadena invlida: debe incluir "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;\n        return `Invlido ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Nmero invlido: debe ser mltiplo de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Llave invlida en ${issue2.origin}`;\n      case "invalid_union":\n        return "Entrada invlida";\n      case "invalid_element":\n        return `Valor invlido en ${issue2.origin}`;\n      default:\n        return `Entrada invlida`;\n    }\n  };\n};\nfunction es_default() {\n  return {\n    localeError: error8()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/fa.js\nvar error9 = () => {\n  const Sizable = {\n    string: { unit: "", verb: " " },\n    file: { unit: "", verb: " " },\n    array: { unit: "", verb: " " },\n    set: { unit: "", verb: " " }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: " ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "   ",\n    date: " ",\n    time: " ",\n    duration: "  ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64-encoded ",\n    base64url: "base64url-encoded ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return ` :  ${issue2.expected}  ${parsedType2(issue2.input)}  `;\n      case "invalid_value":\n        if (issue2.values.length === 1) {\n          return ` :  ${stringifyPrimitive(issue2.values[0])} `;\n        }\n        return ` :    ${joinValues(issue2.values, "|")} `;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;\n        }\n        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;\n        }\n        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` :   "${_issue.prefix}"  `;\n        }\n        if (_issue.format === "ends_with") {\n          return ` :   "${_issue.suffix}"  `;\n        }\n        if (_issue.format === "includes") {\n          return ` :   "${_issue.includes}" `;\n        }\n        if (_issue.format === "regex") {\n          return ` :    ${_issue.pattern}   `;\n        }\n        return `${Nouns[_issue.format] ?? issue2.format} `;\n      }\n      case "not_multiple_of":\n        return ` :   ${issue2.divisor} `;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""} : ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return ` `;\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction fa_default() {\n  return {\n    localeError: error9()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/fi.js\nvar error10 = () => {\n  const Sizable = {\n    string: { unit: "merkki", subject: "merkkijonon" },\n    file: { unit: "tavua", subject: "tiedoston" },\n    array: { unit: "alkiota", subject: "listan" },\n    set: { unit: "alkiota", subject: "joukon" },\n    number: { unit: "", subject: "luvun" },\n    bigint: { unit: "", subject: "suuren kokonaisluvun" },\n    int: { unit: "", subject: "kokonaisluvun" },\n    date: { unit: "", subject: "pivmrn" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "number";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "snnllinen lauseke",\n    email: "shkpostiosoite",\n    url: "URL-osoite",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO-aikaleima",\n    date: "ISO-pivmr",\n    time: "ISO-aika",\n    duration: "ISO-kesto",\n    ipv4: "IPv4-osoite",\n    ipv6: "IPv6-osoite",\n    cidrv4: "IPv4-alue",\n    cidrv6: "IPv6-alue",\n    base64: "base64-koodattu merkkijono",\n    base64url: "base64url-koodattu merkkijono",\n    json_string: "JSON-merkkijono",\n    e164: "E.164-luku",\n    jwt: "JWT",\n    template_literal: "templaattimerkkijono"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue2.values[0])}`;\n        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();\n        }\n        return `Liian suuri: arvon tytyy olla ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();\n        }\n        return `Liian pieni: arvon tytyy olla ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;\n        if (_issue.format === "regex") {\n          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;\n        }\n        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Virheellinen luku: tytyy olla luvun ${issue2.divisor} monikerta`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return "Virheellinen avain tietueessa";\n      case "invalid_union":\n        return "Virheellinen unioni";\n      case "invalid_element":\n        return "Virheellinen arvo joukossa";\n      default:\n        return `Virheellinen syte`;\n    }\n  };\n};\nfunction fi_default() {\n  return {\n    localeError: error10()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/fr.js\nvar error11 = () => {\n  const Sizable = {\n    string: { unit: "caractres", verb: "avoir" },\n    file: { unit: "octets", verb: "avoir" },\n    array: { unit: "lments", verb: "avoir" },\n    set: { unit: "lments", verb: "avoir" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "nombre";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "tableau";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "entre",\n    email: "adresse e-mail",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "date et heure ISO",\n    date: "date ISO",\n    time: "heure ISO",\n    duration: "dure ISO",\n    ipv4: "adresse IPv4",\n    ipv6: "adresse IPv6",\n    cidrv4: "plage IPv4",\n    cidrv6: "plage IPv6",\n    base64: "chane encode en base64",\n    base64url: "chane encode en base64url",\n    json_string: "chane JSON",\n    e164: "numro E.164",\n    jwt: "JWT",\n    template_literal: "entre"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Entre invalide : ${issue2.expected} attendu, ${parsedType2(issue2.input)} reu`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Entre invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;\n        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;\n        return `Trop grand : ${issue2.origin ?? "valeur"} doit tre ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Trop petit : ${issue2.origin} doit tre ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Chane invalide : doit commencer par "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Chane invalide : doit inclure "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue2.format} invalide`;\n      }\n      case "not_multiple_of":\n        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Cl invalide dans ${issue2.origin}`;\n      case "invalid_union":\n        return "Entre invalide";\n      case "invalid_element":\n        return `Valeur invalide dans ${issue2.origin}`;\n      default:\n        return `Entre invalide`;\n    }\n  };\n};\nfunction fr_default() {\n  return {\n    localeError: error11()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/fr-CA.js\nvar error12 = () => {\n  const Sizable = {\n    string: { unit: "caractres", verb: "avoir" },\n    file: { unit: "octets", verb: "avoir" },\n    array: { unit: "lments", verb: "avoir" },\n    set: { unit: "lments", verb: "avoir" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "number";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "entre",\n    email: "adresse courriel",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "date-heure ISO",\n    date: "date ISO",\n    time: "heure ISO",\n    duration: "dure ISO",\n    ipv4: "adresse IPv4",\n    ipv6: "adresse IPv6",\n    cidrv4: "plage IPv4",\n    cidrv6: "plage IPv6",\n    base64: "chane encode en base64",\n    base64url: "chane encode en base64url",\n    json_string: "chane JSON",\n    e164: "numro E.164",\n    jwt: "JWT",\n    template_literal: "entre"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Entre invalide : attendu ${issue2.expected}, reu ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Entre invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;\n        return `Option invalide : attendu l\'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;\n        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? "" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Chane invalide : doit commencer par "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Chane invalide : doit inclure "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue2.format} invalide`;\n      }\n      case "not_multiple_of":\n        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Cl invalide dans ${issue2.origin}`;\n      case "invalid_union":\n        return "Entre invalide";\n      case "invalid_element":\n        return `Valeur invalide dans ${issue2.origin}`;\n      default:\n        return `Entre invalide`;\n    }\n  };\n};\nfunction fr_CA_default() {\n  return {\n    localeError: error12()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/he.js\nvar error13 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "number";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: " ",\n    url: " ",\n    emoji: "\'",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "  ISO",\n    date: " ISO",\n    time: " ISO",\n    duration: "  ISO",\n    ipv4: " IPv4",\n    ipv6: " IPv6",\n    cidrv4: " IPv4",\n    cidrv6: " IPv6",\n    base64: "  64",\n    base64url: "  64  ",\n    json_string: " JSON",\n    e164: " E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `  :  ${issue2.expected},  ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `  :  ${stringifyPrimitive(issue2.values[0])}`;\n        return `  :     ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` : ${issue2.origin ?? "value"}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;\n        return ` : ${issue2.origin ?? "value"}   ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` : ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `  :   "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `  :    "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `  :   "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `  :    ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue2.format}  `;\n      }\n      case "not_multiple_of":\n        return `  :     ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""}  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return "  ";\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return `  `;\n    }\n  };\n};\nfunction he_default() {\n  return {\n    localeError: error13()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/hu.js\nvar error14 = () => {\n  const Sizable = {\n    string: { unit: "karakter", verb: "legyen" },\n    file: { unit: "byte", verb: "legyen" },\n    array: { unit: "elem", verb: "legyen" },\n    set: { unit: "elem", verb: "legyen" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "szm";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "tmb";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "bemenet",\n    email: "email cm",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO idblyeg",\n    date: "ISO dtum",\n    time: "ISO id",\n    duration: "ISO idintervallum",\n    ipv4: "IPv4 cm",\n    ipv6: "IPv6 cm",\n    cidrv4: "IPv4 tartomny",\n    cidrv6: "IPv6 tartomny",\n    base64: "base64-kdolt string",\n    base64url: "base64url-kdolt string",\n    json_string: "JSON string",\n    e164: "E.164 szm",\n    jwt: "JWT",\n    template_literal: "bemenet"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `rvnytelen bemenet: a vrt rtk ${issue2.expected}, a kapott rtk ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue2.values[0])}`;\n        return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Tl nagy: ${issue2.origin ?? "rtk"} mrete tl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;\n        return `Tl nagy: a bemeneti rtk ${issue2.origin ?? "rtk"} tl nagy: ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Tl kicsi: a bemeneti rtk ${issue2.origin} mrete tl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Tl kicsi: a bemeneti rtk ${issue2.origin} tl kicsi ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;\n        if (_issue.format === "ends_with")\n          return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;\n        if (_issue.format === "includes")\n          return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;\n        if (_issue.format === "regex")\n          return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;\n        return `rvnytelen ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `rvnytelen szm: ${issue2.divisor} tbbszrsnek kell lennie`;\n      case "unrecognized_keys":\n        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `rvnytelen kulcs ${issue2.origin}`;\n      case "invalid_union":\n        return "rvnytelen bemenet";\n      case "invalid_element":\n        return `rvnytelen rtk: ${issue2.origin}`;\n      default:\n        return `rvnytelen bemenet`;\n    }\n  };\n};\nfunction hu_default() {\n  return {\n    localeError: error14()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/id.js\nvar error15 = () => {\n  const Sizable = {\n    string: { unit: "karakter", verb: "memiliki" },\n    file: { unit: "byte", verb: "memiliki" },\n    array: { unit: "item", verb: "memiliki" },\n    set: { unit: "item", verb: "memiliki" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "number";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "input",\n    email: "alamat email",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "tanggal dan waktu format ISO",\n    date: "tanggal format ISO",\n    time: "jam format ISO",\n    duration: "durasi format ISO",\n    ipv4: "alamat IPv4",\n    ipv6: "alamat IPv6",\n    cidrv4: "rentang alamat IPv4",\n    cidrv6: "rentang alamat IPv6",\n    base64: "string dengan enkode base64",\n    base64url: "string dengan enkode base64url",\n    json_string: "string JSON",\n    e164: "angka E.164",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;\n        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;\n        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `String tidak valid: harus menyertakan "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;\n      }\n      case "not_multiple_of":\n        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Kunci tidak valid di ${issue2.origin}`;\n      case "invalid_union":\n        return "Input tidak valid";\n      case "invalid_element":\n        return `Nilai tidak valid di ${issue2.origin}`;\n      default:\n        return `Input tidak valid`;\n    }\n  };\n};\nfunction id_default() {\n  return {\n    localeError: error15()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/it.js\nvar error16 = () => {\n  const Sizable = {\n    string: { unit: "caratteri", verb: "avere" },\n    file: { unit: "byte", verb: "avere" },\n    array: { unit: "elementi", verb: "avere" },\n    set: { unit: "elementi", verb: "avere" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "numero";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "vettore";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "input",\n    email: "indirizzo email",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "data e ora ISO",\n    date: "data ISO",\n    time: "ora ISO",\n    duration: "durata ISO",\n    ipv4: "indirizzo IPv4",\n    ipv6: "indirizzo IPv6",\n    cidrv4: "intervallo IPv4",\n    cidrv6: "intervallo IPv6",\n    base64: "stringa codificata in base64",\n    base64url: "URL codificata in base64",\n    json_string: "stringa JSON",\n    e164: "numero E.164",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;\n        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Stringa non valida: deve includere "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;\n        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Chiave non valida in ${issue2.origin}`;\n      case "invalid_union":\n        return "Input non valido";\n      case "invalid_element":\n        return `Valore non valido in ${issue2.origin}`;\n      default:\n        return `Input non valido`;\n    }\n  };\n};\nfunction it_default() {\n  return {\n    localeError: error16()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/ja.js\nvar error17 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: "",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO",\n    date: "ISO",\n    time: "ISO",\n    duration: "ISO",\n    ipv4: "IPv4",\n    ipv6: "IPv6",\n    cidrv4: "IPv4",\n    cidrv6: "IPv6",\n    base64: "base64",\n    base64url: "base64url",\n    json_string: "JSON",\n    e164: "E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `: ${issue2.expected}${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `: ${stringifyPrimitive(issue2.values[0])}`;\n        return `: ${joinValues(issue2.values, "")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${sizing.unit ?? ""}${adj}`;\n        return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${adj}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `: ${issue2.origin}${issue2.minimum.toString()}${sizing.unit}${adj}`;\n        return `: ${issue2.origin}${issue2.minimum.toString()}${adj}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `: "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `: "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `: "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `: ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `: ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, "")}`;\n      case "invalid_key":\n        return `${issue2.origin}`;\n      case "invalid_union":\n        return "";\n      case "invalid_element":\n        return `${issue2.origin}`;\n      default:\n        return ``;\n    }\n  };\n};\nfunction ja_default() {\n  return {\n    localeError: error17()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/kh.js\nvar error18 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? " (NaN)" : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return " (Array)";\n        }\n        if (data === null) {\n          return " (null)";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: "",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "  ISO",\n    date: " ISO",\n    time: " ISO",\n    duration: " ISO",\n    ipv4: " IPv4",\n    ipv6: " IPv6",\n    cidrv4: " IPv4",\n    cidrv6: " IPv6",\n    base64: " base64",\n    base64url: " base64url",\n    json_string: " JSON",\n    e164: " E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `  ${issue2.expected}  ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `  ${stringifyPrimitive(issue2.values[0])}`;\n        return `  ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `  "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `  "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `  "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `  ${_issue.pattern}`;\n        return ` ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `  ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return ` ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return ` ${issue2.origin}`;\n      case "invalid_union":\n        return ``;\n      case "invalid_element":\n        return ` ${issue2.origin}`;\n      default:\n        return ``;\n    }\n  };\n};\nfunction kh_default() {\n  return {\n    localeError: error18()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/ko.js\nvar error19 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "to have" },\n    file: { unit: "", verb: "to have" },\n    array: { unit: "", verb: "to have" },\n    set: { unit: "", verb: "to have" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "number";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: " ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64  ",\n    base64url: "base64url  ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return ` :   ${issue2.expected},   ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` :  ${stringifyPrimitive(issue2.values[0])}  `;\n        return ` : ${joinValues(issue2.values, " ")}   `;\n      case "too_big": {\n        const adj = issue2.inclusive ? "" : "";\n        const suffix = adj === "" ? " " : " ";\n        const sizing = getSizing(issue2.origin);\n        const unit = sizing?.unit ?? "";\n        if (sizing)\n          return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;\n        return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()} ${adj}${suffix}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? "" : "";\n        const suffix = adj === "" ? " " : " ";\n        const sizing = getSizing(issue2.origin);\n        const unit = sizing?.unit ?? "";\n        if (sizing) {\n          return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;\n        }\n        return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()} ${adj}${suffix}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` : "${_issue.prefix}"()  `;\n        }\n        if (_issue.format === "ends_with")\n          return ` : "${_issue.suffix}"()  `;\n        if (_issue.format === "includes")\n          return ` : "${_issue.includes}"()  `;\n        if (_issue.format === "regex")\n          return ` :  ${_issue.pattern}   `;\n        return ` ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` : ${issue2.divisor}  `;\n      case "unrecognized_keys":\n        return `   : ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return ` : ${issue2.origin}`;\n      case "invalid_union":\n        return ` `;\n      case "invalid_element":\n        return ` : ${issue2.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction ko_default() {\n  return {\n    localeError: error19()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/mk.js\nvar error20 = () => {\n  const Sizable = {\n    string: { unit: "", verb: " " },\n    file: { unit: "", verb: " " },\n    array: { unit: "", verb: " " },\n    set: { unit: "", verb: " " }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: "  -",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO   ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64- ",\n    base64url: "base64url- ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return ` :   ${issue2.expected},  ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :    ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` :     "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return ` :     "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return ` :    "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` :      ${_issue.pattern}`;\n        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` :      ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? " " : " "}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return " ";\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction mk_default() {\n  return {\n    localeError: error20()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/ms.js\nvar error21 = () => {\n  const Sizable = {\n    string: { unit: "aksara", verb: "mempunyai" },\n    file: { unit: "bait", verb: "mempunyai" },\n    array: { unit: "elemen", verb: "mempunyai" },\n    set: { unit: "elemen", verb: "mempunyai" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "nombor";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "input",\n    email: "alamat e-mel",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "tarikh masa ISO",\n    date: "tarikh ISO",\n    time: "masa ISO",\n    duration: "tempoh ISO",\n    ipv4: "alamat IPv4",\n    ipv6: "alamat IPv6",\n    cidrv4: "julat IPv4",\n    cidrv6: "julat IPv6",\n    base64: "string dikodkan base64",\n    base64url: "string dikodkan base64url",\n    json_string: "string JSON",\n    e164: "nombor E.164",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;\n        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;\n        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;\n      }\n      case "not_multiple_of":\n        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Kunci tidak sah dalam ${issue2.origin}`;\n      case "invalid_union":\n        return "Input tidak sah";\n      case "invalid_element":\n        return `Nilai tidak sah dalam ${issue2.origin}`;\n      default:\n        return `Input tidak sah`;\n    }\n  };\n};\nfunction ms_default() {\n  return {\n    localeError: error21()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/nl.js\nvar error22 = () => {\n  const Sizable = {\n    string: { unit: "tekens" },\n    file: { unit: "bytes" },\n    array: { unit: "elementen" },\n    set: { unit: "elementen" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "getal";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "invoer",\n    email: "emailadres",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO datum en tijd",\n    date: "ISO datum",\n    time: "ISO tijd",\n    duration: "ISO duur",\n    ipv4: "IPv4-adres",\n    ipv6: "IPv6-adres",\n    cidrv4: "IPv4-bereik",\n    cidrv6: "IPv6-bereik",\n    base64: "base64-gecodeerde tekst",\n    base64url: "base64 URL-gecodeerde tekst",\n    json_string: "JSON string",\n    e164: "E.164-nummer",\n    jwt: "JWT",\n    template_literal: "invoer"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ongeldige optie: verwacht n van ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;\n        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;\n        }\n        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;\n        }\n        if (_issue.format === "ends_with")\n          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;\n        if (_issue.format === "includes")\n          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;\n        if (_issue.format === "regex")\n          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;\n        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;\n      case "unrecognized_keys":\n        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Ongeldige key in ${issue2.origin}`;\n      case "invalid_union":\n        return "Ongeldige invoer";\n      case "invalid_element":\n        return `Ongeldige waarde in ${issue2.origin}`;\n      default:\n        return `Ongeldige invoer`;\n    }\n  };\n};\nfunction nl_default() {\n  return {\n    localeError: error22()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/no.js\nvar error23 = () => {\n  const Sizable = {\n    string: { unit: "tegn", verb: " ha" },\n    file: { unit: "bytes", verb: " ha" },\n    array: { unit: "elementer", verb: " inneholde" },\n    set: { unit: "elementer", verb: " inneholde" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "tall";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "liste";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "input",\n    email: "e-postadresse",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO dato- og klokkeslett",\n    date: "ISO-dato",\n    time: "ISO-klokkeslett",\n    duration: "ISO-varighet",\n    ipv4: "IPv4-omrde",\n    ipv6: "IPv6-omrde",\n    cidrv4: "IPv4-spekter",\n    cidrv6: "IPv6-spekter",\n    base64: "base64-enkodet streng",\n    base64url: "base64url-enkodet streng",\n    json_string: "JSON-streng",\n    e164: "E.164-nummer",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;\n        return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Ugyldig streng: m starte med "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Ugyldig streng: m ende med "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Ugyldig streng: m inneholde "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;\n        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Ugyldig tall: m vre et multiplum av ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Ugyldig nkkel i ${issue2.origin}`;\n      case "invalid_union":\n        return "Ugyldig input";\n      case "invalid_element":\n        return `Ugyldig verdi i ${issue2.origin}`;\n      default:\n        return `Ugyldig input`;\n    }\n  };\n};\nfunction no_default() {\n  return {\n    localeError: error23()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/ota.js\nvar error24 = () => {\n  const Sizable = {\n    string: { unit: "harf", verb: "olmaldr" },\n    file: { unit: "bayt", verb: "olmaldr" },\n    array: { unit: "unsur", verb: "olmaldr" },\n    set: { unit: "unsur", verb: "olmaldr" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "numara";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "saf";\n        }\n        if (data === null) {\n          return "gayb";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "giren",\n    email: "epostagh",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO hengm",\n    date: "ISO tarihi",\n    time: "ISO zaman",\n    duration: "ISO mddeti",\n    ipv4: "IPv4 nin",\n    ipv6: "IPv6 nin",\n    cidrv4: "IPv4 menzili",\n    cidrv6: "IPv6 menzili",\n    base64: "base64-ifreli metin",\n    base64url: "base64url-ifreli metin",\n    json_string: "JSON metin",\n    e164: "E.164 says",\n    jwt: "JWT",\n    template_literal: "giren"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Fsit giren: umulan ${issue2.expected}, alnan ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Fsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;\n        return `Fsit tercih: mteberler ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;\n        return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalyd.`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalyd.`;\n        }\n        return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalyd.`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Fsit metin: "${_issue.prefix}" ile balamal.`;\n        if (_issue.format === "ends_with")\n          return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;\n        if (_issue.format === "includes")\n          return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;\n        if (_issue.format === "regex")\n          return `Fsit metin: ${_issue.pattern} nakna uymal.`;\n        return `Fsit ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Fsit say: ${issue2.divisor} kat olmalyd.`;\n      case "unrecognized_keys":\n        return `Tannmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin} iin tannmayan anahtar var.`;\n      case "invalid_union":\n        return "Giren tannamad.";\n      case "invalid_element":\n        return `${issue2.origin} iin tannmayan kymet var.`;\n      default:\n        return `Kymet tannamad.`;\n    }\n  };\n};\nfunction ota_default() {\n  return {\n    localeError: error24()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/pl.js\nvar error25 = () => {\n  const Sizable = {\n    string: { unit: "znakw", verb: "mie" },\n    file: { unit: "bajtw", verb: "mie" },\n    array: { unit: "elementw", verb: "mie" },\n    set: { unit: "elementw", verb: "mie" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "liczba";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "tablica";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "wyraenie",\n    email: "adres email",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "data i godzina w formacie ISO",\n    date: "data w formacie ISO",\n    time: "godzina w formacie ISO",\n    duration: "czas trwania ISO",\n    ipv4: "adres IPv4",\n    ipv6: "adres IPv6",\n    cidrv4: "zakres IPv4",\n    cidrv6: "zakres IPv6",\n    base64: "cig znakw zakodowany w formacie base64",\n    base64url: "cig znakw zakodowany w formacie base64url",\n    json_string: "cig znakw w formacie JSON",\n    e164: "liczba E.164",\n    jwt: "JWT",\n    template_literal: "wejcie"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Nieprawidowe dane wejciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;\n        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Za dua warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementw"}`;\n        }\n        return `Zbyt du(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Za maa warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementw"}`;\n        }\n        return `Zbyt ma(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;\n        return `Nieprawidow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Nieprawidowy klucz w ${issue2.origin}`;\n      case "invalid_union":\n        return "Nieprawidowe dane wejciowe";\n      case "invalid_element":\n        return `Nieprawidowa warto w ${issue2.origin}`;\n      default:\n        return `Nieprawidowe dane wejciowe`;\n    }\n  };\n};\nfunction pl_default() {\n  return {\n    localeError: error25()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/pt.js\nvar error26 = () => {\n  const Sizable = {\n    string: { unit: "caracteres", verb: "ter" },\n    file: { unit: "bytes", verb: "ter" },\n    array: { unit: "itens", verb: "ter" },\n    set: { unit: "itens", verb: "ter" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "nmero";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "nulo";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "padro",\n    email: "endereo de e-mail",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "data e hora ISO",\n    date: "data ISO",\n    time: "hora ISO",\n    duration: "durao ISO",\n    ipv4: "endereo IPv4",\n    ipv6: "endereo IPv6",\n    cidrv4: "faixa de IPv4",\n    cidrv6: "faixa de IPv6",\n    base64: "texto codificado em base64",\n    base64url: "URL codificada em base64",\n    json_string: "texto JSON",\n    e164: "nmero E.164",\n    jwt: "JWT",\n    template_literal: "entrada"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Tipo invlido: esperado ${issue2.expected}, recebido ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Entrada invlida: esperado ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opo invlida: esperada uma das ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;\n        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Texto invlido: deve comear com "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Texto invlido: deve terminar com "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Texto invlido: deve incluir "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue2.format} invlido`;\n      }\n      case "not_multiple_of":\n        return `Nmero invlido: deve ser mltiplo de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Chave invlida em ${issue2.origin}`;\n      case "invalid_union":\n        return "Entrada invlida";\n      case "invalid_element":\n        return `Valor invlido em ${issue2.origin}`;\n      default:\n        return `Campo invlido`;\n    }\n  };\n};\nfunction pt_default() {\n  return {\n    localeError: error26()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/ru.js\nfunction getRussianPlural(count, one, few, many) {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n  if (lastDigit === 1) {\n    return one;\n  }\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n  return many;\n}\nvar error27 = () => {\n  const Sizable = {\n    string: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    file: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    array: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    set: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: "email ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO   ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "   base64",\n    base64url: "   base64url",\n    json_string: "JSON ",\n    e164: " E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return ` :  ${issue2.expected},  ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` :  ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :    ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          const maxValue = Number(issue2.maximum);\n          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return `  : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${unit}`;\n        }\n        return `  : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          const minValue = Number(issue2.minimum);\n          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return `  : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${unit}`;\n        }\n        return `  : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return ` :    "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return ` :    "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return ` :   "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` :    ${_issue.pattern}`;\n        return ` ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` :    ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return "  ";\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return `  `;\n    }\n  };\n};\nfunction ru_default() {\n  return {\n    localeError: error27()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/sl.js\nvar error28 = () => {\n  const Sizable = {\n    string: { unit: "znakov", verb: "imeti" },\n    file: { unit: "bajtov", verb: "imeti" },\n    array: { unit: "elementov", verb: "imeti" },\n    set: { unit: "elementov", verb: "imeti" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "tevilo";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "tabela";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "vnos",\n    email: "e-potni naslov",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO datum in as",\n    date: "ISO datum",\n    time: "ISO as",\n    duration: "ISO trajanje",\n    ipv4: "IPv4 naslov",\n    ipv6: "IPv6 naslov",\n    cidrv4: "obseg IPv4",\n    cidrv6: "obseg IPv6",\n    base64: "base64 kodiran niz",\n    base64url: "base64url kodiran niz",\n    json_string: "JSON niz",\n    e164: "E.164 tevilka",\n    jwt: "JWT",\n    template_literal: "vnos"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Neveljaven vnos: priakovano ${issue2.expected}, prejeto ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue2.values[0])}`;\n        return `Neveljavna monost: priakovano eno izmed ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;\n        return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Premajhno: priakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Premajhno: priakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;\n        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Neveljavno tevilo: mora biti vekratnik ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Neprepoznan${issue2.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Neveljaven klju v ${issue2.origin}`;\n      case "invalid_union":\n        return "Neveljaven vnos";\n      case "invalid_element":\n        return `Neveljavna vrednost v ${issue2.origin}`;\n      default:\n        return "Neveljaven vnos";\n    }\n  };\n};\nfunction sl_default() {\n  return {\n    localeError: error28()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/sv.js\nvar error29 = () => {\n  const Sizable = {\n    string: { unit: "tecken", verb: "att ha" },\n    file: { unit: "bytes", verb: "att ha" },\n    array: { unit: "objekt", verb: "att innehlla" },\n    set: { unit: "objekt", verb: "att innehlla" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "antal";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "lista";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "reguljrt uttryck",\n    email: "e-postadress",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO-datum och tid",\n    date: "ISO-datum",\n    time: "ISO-tid",\n    duration: "ISO-varaktighet",\n    ipv4: "IPv4-intervall",\n    ipv6: "IPv6-intervall",\n    cidrv4: "IPv4-spektrum",\n    cidrv6: "IPv6-spektrum",\n    base64: "base64-kodad strng",\n    base64url: "base64url-kodad strng",\n    json_string: "JSON-strng",\n    e164: "E.164-nummer",\n    jwt: "JWT",\n    template_literal: "mall-literal"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Ogiltig inmatning: frvntat ${issue2.expected}, fick ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ogiltigt val: frvntade en av ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Fr stor(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;\n        }\n        return `Fr stor(t): frvntat ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Ogiltig strng: mste brja med "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Ogiltig strng: mste innehlla "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;\n        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Ogiltigt tal: mste vara en multipel av ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Ogiltig nyckel i ${issue2.origin ?? "vrdet"}`;\n      case "invalid_union":\n        return "Ogiltig input";\n      case "invalid_element":\n        return `Ogiltigt vrde i ${issue2.origin ?? "vrdet"}`;\n      default:\n        return `Ogiltig input`;\n    }\n  };\n};\nfunction sv_default() {\n  return {\n    localeError: error29()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/ta.js\nvar error30 = () => {\n  const Sizable = {\n    string: { unit: "", verb: " " },\n    file: { unit: "", verb: " " },\n    array: { unit: "", verb: " " },\n    set: { unit: "", verb: " " }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? " " : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "";\n        }\n        if (data === null) {\n          return "";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: " ",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO  ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO  ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64-encoded ",\n    base64url: "base64url-encoded ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return ` :  ${issue2.expected},  ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` :  ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :  ${joinValues(issue2.values, "|")}  `;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;\n        }\n        return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}   `;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;\n        }\n        return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()}   `;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return ` : "${_issue.prefix}"   `;\n        if (_issue.format === "ends_with")\n          return ` : "${_issue.suffix}"   `;\n        if (_issue.format === "includes")\n          return ` : "${_issue.includes}"   `;\n        if (_issue.format === "regex")\n          return ` : ${_issue.pattern}   `;\n        return ` ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` : ${issue2.divisor}    `;\n      case "unrecognized_keys":\n        return `  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin}   `;\n      case "invalid_union":\n        return " ";\n      case "invalid_element":\n        return `${issue2.origin}   `;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction ta_default() {\n  return {\n    localeError: error30()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/th.js\nvar error31 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType2 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? " (NaN)" : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return " (Array)";\n        }\n        if (data === null) {\n          return " (null)";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: "",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: " ISO",\n    date: " ISO",\n    time: " ISO",\n    duration: " ISO",\n    ipv4: " IPv4",\n    ipv6: " IPv6",\n    cidrv4: " IP  IPv4",\n    cidrv6: " IP  IPv6",\n    base64: " Base64",\n    base64url: " Base64  URL",\n    json_string: " JSON",\n    e164: " (E.164)",\n    jwt: " JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `:  ${issue2.expected}  ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `:  ${stringifyPrimitive(issue2.values[0])}`;\n        return `:  ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "" : "";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? "" : "";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `:  "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `:  "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `:  "${_issue.includes}" `;\n        if (_issue.format === "regex")\n          return `:  ${_issue.pattern}`;\n        return `: ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `:  ${issue2.divisor} `;\n      case "unrecognized_keys":\n        return `: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return ` ${issue2.origin}`;\n      case "invalid_union":\n        return ": ";\n      case "invalid_element":\n        return ` ${issue2.origin}`;\n      default:\n        return ``;\n    }\n  };\n};\nfunction th_default() {\n  return {\n    localeError: error31()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/tr.js\nvar parsedType2 = (data) => {\n  const t2 = typeof data;\n  switch (t2) {\n    case "number": {\n      return Number.isNaN(data) ? "NaN" : "number";\n    }\n    case "object": {\n      if (Array.isArray(data)) {\n        return "array";\n      }\n      if (data === null) {\n        return "null";\n      }\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t2;\n};\nvar error32 = () => {\n  const Sizable = {\n    string: { unit: "karakter", verb: "olmal" },\n    file: { unit: "bayt", verb: "olmal" },\n    array: { unit: "e", verb: "olmal" },\n    set: { unit: "e", verb: "olmal" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const Nouns = {\n    regex: "girdi",\n    email: "e-posta adresi",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO tarih ve saat",\n    date: "ISO tarih",\n    time: "ISO saat",\n    duration: "ISO sre",\n    ipv4: "IPv4 adresi",\n    ipv6: "IPv6 adresi",\n    cidrv4: "IPv4 aral",\n    cidrv6: "IPv6 aral",\n    base64: "base64 ile ifrelenmi metin",\n    base64url: "base64url ile ifrelenmi metin",\n    json_string: "JSON dizesi",\n    e164: "E.164 says",\n    jwt: "JWT",\n    template_literal: "ablon dizesi"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Geersiz deer: beklenen ${issue2.expected}, alnan ${parsedType2(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Geersiz deer: beklenen ${stringifyPrimitive(issue2.values[0])}`;\n        return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "e"}`;\n        return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Geersiz metin: "${_issue.prefix}" ile balamal`;\n        if (_issue.format === "ends_with")\n          return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;\n        if (_issue.format === "includes")\n          return `Geersiz metin: "${_issue.includes}" iermeli`;\n        if (_issue.format === "regex")\n          return `Geersiz metin: ${_issue.pattern} desenine uymal`;\n        return `Geersiz ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Geersiz say: ${issue2.divisor} ile tam blnebilmeli`;\n      case "unrecognized_keys":\n        return `Tannmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin} iinde geersiz anahtar`;\n      case "invalid_union":\n        return "Geersiz deer";\n      case "invalid_element":\n        return `${issue2.origin} iinde geersiz deer`;\n      default:\n        return `Geersiz deer`;\n    }\n  };\n};\nfunction tr_default() {\n  return {\n    localeError: error32()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/ua.js\nvar error33 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType3 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: " ",\n    email: "  ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "   ISO",\n    date: " ISO",\n    time: " ISO",\n    duration: " ISO",\n    ipv4: " IPv4",\n    ipv6: " IPv6",\n    cidrv4: " IPv4",\n    cidrv6: " IPv6",\n    base64: "   base64",\n    base64url: "   base64url",\n    json_string: " JSON",\n    e164: " E.164",\n    jwt: "JWT",\n    template_literal: " "\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `  :  ${issue2.expected},  ${parsedType3(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `  :  ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :    ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` : ,  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return ` : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ,  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return ` :    "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return ` :    "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return ` :   "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` :    ${_issue.pattern}`;\n        return ` ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` :    ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return "  ";\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return `  `;\n    }\n  };\n};\nfunction ua_default() {\n  return {\n    localeError: error33()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/ur.js\nvar error34 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType3 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "";\n        }\n        if (data === null) {\n          return "";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: " ",\n    email: "  ",\n    url: "  ",\n    emoji: "",\n    uuid: "   ",\n    uuidv4: "     4",\n    uuidv6: "     6",\n    nanoid: "  ",\n    guid: "   ",\n    cuid: "   ",\n    cuid2: "    2",\n    ulid: "   ",\n    xid: "  ",\n    ksuid: "    ",\n    datetime: "    ",\n    date: "   ",\n    time: "   ",\n    duration: "   ",\n    ipv4: "   4 ",\n    ipv6: "   6 ",\n    cidrv4: "   4 ",\n    cidrv6: "   6 ",\n    base64: " 64   ",\n    base64url: " 64      ",\n    json_string: "    ",\n    e164: " 164 ",\n    jwt: "  ",\n    template_literal: " "\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `  : ${issue2.expected}   ${parsedType3(issue2.input)}  `;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `  : ${stringifyPrimitive(issue2.values[0])}  `;\n        return ` : ${joinValues(issue2.values, "|")}     `;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;\n        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}   `;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;\n        }\n        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()}   `;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` : "${_issue.prefix}"    `;\n        }\n        if (_issue.format === "ends_with")\n          return ` : "${_issue.suffix}"    `;\n        if (_issue.format === "includes")\n          return ` : "${_issue.includes}"   `;\n        if (_issue.format === "regex")\n          return ` :  ${_issue.pattern}    `;\n        return ` ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` : ${issue2.divisor}    `;\n      case "unrecognized_keys":\n        return `   ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;\n      case "invalid_key":\n        return `${issue2.origin}   `;\n      case "invalid_union":\n        return "  ";\n      case "invalid_element":\n        return `${issue2.origin}   `;\n      default:\n        return `  `;\n    }\n  };\n};\nfunction ur_default() {\n  return {\n    localeError: error34()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/vi.js\nvar error35 = () => {\n  const Sizable = {\n    string: { unit: "k t", verb: "c" },\n    file: { unit: "byte", verb: "c" },\n    array: { unit: "phn t", verb: "c" },\n    set: { unit: "phn t", verb: "c" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType3 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "s";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "mng";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "u vo",\n    email: "a ch email",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ngy gi ISO",\n    date: "ngy ISO",\n    time: "gi ISO",\n    duration: "khong thi gian ISO",\n    ipv4: "a ch IPv4",\n    ipv6: "a ch IPv6",\n    cidrv4: "di IPv4",\n    cidrv6: "di IPv6",\n    base64: "chui m ha base64",\n    base64url: "chui m ha base64url",\n    json_string: "chui JSON",\n    e164: "s E.164",\n    jwt: "JWT",\n    template_literal: "u vo"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `u vo khng hp l: mong i ${issue2.expected}, nhn c ${parsedType3(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `u vo khng hp l: mong i ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phn t"}`;\n        return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Qu nh: mong i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Qu nh: mong i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Chui khng hp l: phi bao gm "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue2.format} khng hp l`;\n      }\n      case "not_multiple_of":\n        return `S khng hp l: phi l bi s ca ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Kha khng c nhn dng: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Kha khng hp l trong ${issue2.origin}`;\n      case "invalid_union":\n        return "u vo khng hp l";\n      case "invalid_element":\n        return `Gi tr khng hp l trong ${issue2.origin}`;\n      default:\n        return `u vo khng hp l`;\n    }\n  };\n};\nfunction vi_default() {\n  return {\n    localeError: error35()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/zh-CN.js\nvar error36 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType3 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "(NaN)" : "";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "";\n        }\n        if (data === null) {\n          return "(null)";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: "",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO",\n    date: "ISO",\n    time: "ISO",\n    duration: "ISO",\n    ipv4: "IPv4",\n    ipv6: "IPv6",\n    cidrv4: "IPv4",\n    cidrv6: "IPv6",\n    base64: "base64",\n    base64url: "base64url",\n    json_string: "JSON",\n    e164: "E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return ` ${issue2.expected} ${parsedType3(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` ${stringifyPrimitive(issue2.values[0])}`;\n        return ` ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return ` "${_issue.prefix}" `;\n        if (_issue.format === "ends_with")\n          return ` "${_issue.suffix}" `;\n        if (_issue.format === "includes")\n          return ` "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` ${_issue.pattern}`;\n        return `${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` ${issue2.divisor} `;\n      case "unrecognized_keys":\n        return `(key): ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin} (key)`;\n      case "invalid_union":\n        return "";\n      case "invalid_element":\n        return `${issue2.origin} (value)`;\n      default:\n        return ``;\n    }\n  };\n};\nfunction zh_CN_default() {\n  return {\n    localeError: error36()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/locales/zh-TW.js\nvar error37 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const parsedType3 = (data) => {\n    const t2 = typeof data;\n    switch (t2) {\n      case "number": {\n        return Number.isNaN(data) ? "NaN" : "number";\n      }\n      case "object": {\n        if (Array.isArray(data)) {\n          return "array";\n        }\n        if (data === null) {\n          return "null";\n        }\n        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n          return data.constructor.name;\n        }\n      }\n    }\n    return t2;\n  };\n  const Nouns = {\n    regex: "",\n    email: "",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64 ",\n    base64url: "base64url ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return ` ${issue2.expected} ${parsedType3(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` ${stringifyPrimitive(issue2.values[0])}`;\n        return ` ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` "${_issue.prefix}" `;\n        }\n        if (_issue.format === "ends_with")\n          return ` "${_issue.suffix}" `;\n        if (_issue.format === "includes")\n          return ` "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` ${_issue.pattern}`;\n        return ` ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` ${issue2.divisor} `;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""}${joinValues(issue2.keys, "")}`;\n      case "invalid_key":\n        return `${issue2.origin} `;\n      case "invalid_union":\n        return "";\n      case "invalid_element":\n        return `${issue2.origin} `;\n      default:\n        return ``;\n    }\n  };\n};\nfunction zh_TW_default() {\n  return {\n    localeError: error37()\n  };\n}\n// ../../node_modules/zod/dist/esm/v4/core/registries.js\nvar $output = Symbol("ZodOutput");\nvar $input = Symbol("ZodInput");\n\nclass $ZodRegistry {\n  constructor() {\n    this._map = new WeakMap;\n    this._idmap = new Map;\n  }\n  add(schema, ..._meta) {\n    const meta = _meta[0];\n    this._map.set(schema, meta);\n    if (meta && typeof meta === "object" && "id" in meta) {\n      if (this._idmap.has(meta.id)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id, schema);\n    }\n    return this;\n  }\n  remove(schema) {\n    this._map.delete(schema);\n    return this;\n  }\n  get(schema) {\n    const p3 = schema._zod.parent;\n    if (p3) {\n      const pm = { ...this.get(p3) ?? {} };\n      delete pm.id;\n      return { ...pm, ...this._map.get(schema) };\n    }\n    return this._map.get(schema);\n  }\n  has(schema) {\n    return this._map.has(schema);\n  }\n}\nfunction registry() {\n  return new $ZodRegistry;\n}\nvar globalRegistry = /* @__PURE__ */ registry();\n// ../../node_modules/zod/dist/esm/v4/core/api.js\nfunction _string(Class2, params) {\n  return new Class2({\n    type: "string",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedString(Class2, params) {\n  return new Class2({\n    type: "string",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _email(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "email",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _guid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "guid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _uuid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv4(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    version: "v4",\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv6(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    version: "v6",\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv7(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    version: "v7",\n    ...normalizeParams(params)\n  });\n}\nfunction _url(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "url",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _emoji2(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "emoji",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _nanoid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "nanoid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cuid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cuid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cuid2(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cuid2",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ulid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ulid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _xid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "xid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ksuid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ksuid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ipv4(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ipv4",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ipv6(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ipv6",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cidrv4(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cidrv4",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cidrv6(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cidrv6",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _base64(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "base64",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _base64url(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "base64url",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _e164(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "e164",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _jwt(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "jwt",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _isoDateTime(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "datetime",\n    check: "string_format",\n    offset: false,\n    local: false,\n    precision: null,\n    ...normalizeParams(params)\n  });\n}\nfunction _isoDate(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "date",\n    check: "string_format",\n    ...normalizeParams(params)\n  });\n}\nfunction _isoTime(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "time",\n    check: "string_format",\n    precision: null,\n    ...normalizeParams(params)\n  });\n}\nfunction _isoDuration(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "duration",\n    check: "string_format",\n    ...normalizeParams(params)\n  });\n}\nfunction _number(Class2, params) {\n  return new Class2({\n    type: "number",\n    checks: [],\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedNumber(Class2, params) {\n  return new Class2({\n    type: "number",\n    coerce: true,\n    checks: [],\n    ...normalizeParams(params)\n  });\n}\nfunction _int(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "safeint",\n    ...normalizeParams(params)\n  });\n}\nfunction _float32(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "float32",\n    ...normalizeParams(params)\n  });\n}\nfunction _float64(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "float64",\n    ...normalizeParams(params)\n  });\n}\nfunction _int32(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "int32",\n    ...normalizeParams(params)\n  });\n}\nfunction _uint32(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "uint32",\n    ...normalizeParams(params)\n  });\n}\nfunction _boolean(Class2, params) {\n  return new Class2({\n    type: "boolean",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedBoolean(Class2, params) {\n  return new Class2({\n    type: "boolean",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _bigint(Class2, params) {\n  return new Class2({\n    type: "bigint",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedBigint(Class2, params) {\n  return new Class2({\n    type: "bigint",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _int64(Class2, params) {\n  return new Class2({\n    type: "bigint",\n    check: "bigint_format",\n    abort: false,\n    format: "int64",\n    ...normalizeParams(params)\n  });\n}\nfunction _uint64(Class2, params) {\n  return new Class2({\n    type: "bigint",\n    check: "bigint_format",\n    abort: false,\n    format: "uint64",\n    ...normalizeParams(params)\n  });\n}\nfunction _symbol(Class2, params) {\n  return new Class2({\n    type: "symbol",\n    ...normalizeParams(params)\n  });\n}\nfunction _undefined2(Class2, params) {\n  return new Class2({\n    type: "undefined",\n    ...normalizeParams(params)\n  });\n}\nfunction _null2(Class2, params) {\n  return new Class2({\n    type: "null",\n    ...normalizeParams(params)\n  });\n}\nfunction _any(Class2) {\n  return new Class2({\n    type: "any"\n  });\n}\nfunction _unknown(Class2) {\n  return new Class2({\n    type: "unknown"\n  });\n}\nfunction _never(Class2, params) {\n  return new Class2({\n    type: "never",\n    ...normalizeParams(params)\n  });\n}\nfunction _void(Class2, params) {\n  return new Class2({\n    type: "void",\n    ...normalizeParams(params)\n  });\n}\nfunction _date(Class2, params) {\n  return new Class2({\n    type: "date",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedDate(Class2, params) {\n  return new Class2({\n    type: "date",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _nan(Class2, params) {\n  return new Class2({\n    type: "nan",\n    ...normalizeParams(params)\n  });\n}\nfunction _lt(value, params) {\n  return new $ZodCheckLessThan({\n    check: "less_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: false\n  });\n}\nfunction _lte(value, params) {\n  return new $ZodCheckLessThan({\n    check: "less_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: true\n  });\n}\nfunction _gt(value, params) {\n  return new $ZodCheckGreaterThan({\n    check: "greater_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: false\n  });\n}\nfunction _gte(value, params) {\n  return new $ZodCheckGreaterThan({\n    check: "greater_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: true\n  });\n}\nfunction _positive(params) {\n  return _gt(0, params);\n}\nfunction _negative(params) {\n  return _lt(0, params);\n}\nfunction _nonpositive(params) {\n  return _lte(0, params);\n}\nfunction _nonnegative(params) {\n  return _gte(0, params);\n}\nfunction _multipleOf(value, params) {\n  return new $ZodCheckMultipleOf({\n    check: "multiple_of",\n    ...normalizeParams(params),\n    value\n  });\n}\nfunction _maxSize(maximum, params) {\n  return new $ZodCheckMaxSize({\n    check: "max_size",\n    ...normalizeParams(params),\n    maximum\n  });\n}\nfunction _minSize(minimum, params) {\n  return new $ZodCheckMinSize({\n    check: "min_size",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _size(size, params) {\n  return new $ZodCheckSizeEquals({\n    check: "size_equals",\n    ...normalizeParams(params),\n    size\n  });\n}\nfunction _maxLength(maximum, params) {\n  const ch = new $ZodCheckMaxLength({\n    check: "max_length",\n    ...normalizeParams(params),\n    maximum\n  });\n  return ch;\n}\nfunction _minLength(minimum, params) {\n  return new $ZodCheckMinLength({\n    check: "min_length",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _length(length, params) {\n  return new $ZodCheckLengthEquals({\n    check: "length_equals",\n    ...normalizeParams(params),\n    length\n  });\n}\nfunction _regex(pattern, params) {\n  return new $ZodCheckRegex({\n    check: "string_format",\n    format: "regex",\n    ...normalizeParams(params),\n    pattern\n  });\n}\nfunction _lowercase(params) {\n  return new $ZodCheckLowerCase({\n    check: "string_format",\n    format: "lowercase",\n    ...normalizeParams(params)\n  });\n}\nfunction _uppercase(params) {\n  return new $ZodCheckUpperCase({\n    check: "string_format",\n    format: "uppercase",\n    ...normalizeParams(params)\n  });\n}\nfunction _includes(includes, params) {\n  return new $ZodCheckIncludes({\n    check: "string_format",\n    format: "includes",\n    ...normalizeParams(params),\n    includes\n  });\n}\nfunction _startsWith(prefix, params) {\n  return new $ZodCheckStartsWith({\n    check: "string_format",\n    format: "starts_with",\n    ...normalizeParams(params),\n    prefix\n  });\n}\nfunction _endsWith(suffix, params) {\n  return new $ZodCheckEndsWith({\n    check: "string_format",\n    format: "ends_with",\n    ...normalizeParams(params),\n    suffix\n  });\n}\nfunction _property(property, schema, params) {\n  return new $ZodCheckProperty({\n    check: "property",\n    property,\n    schema,\n    ...normalizeParams(params)\n  });\n}\nfunction _mime(types, params) {\n  return new $ZodCheckMimeType({\n    check: "mime_type",\n    mime: types,\n    ...normalizeParams(params)\n  });\n}\nfunction _overwrite(tx) {\n  return new $ZodCheckOverwrite({\n    check: "overwrite",\n    tx\n  });\n}\nfunction _normalize(form) {\n  return _overwrite((input) => input.normalize(form));\n}\nfunction _trim() {\n  return _overwrite((input) => input.trim());\n}\nfunction _toLowerCase() {\n  return _overwrite((input) => input.toLowerCase());\n}\nfunction _toUpperCase() {\n  return _overwrite((input) => input.toUpperCase());\n}\nfunction _array(Class2, element, params) {\n  return new Class2({\n    type: "array",\n    element,\n    ...normalizeParams(params)\n  });\n}\nfunction _union(Class2, options, params) {\n  return new Class2({\n    type: "union",\n    options,\n    ...normalizeParams(params)\n  });\n}\nfunction _discriminatedUnion(Class2, discriminator, options, params) {\n  return new Class2({\n    type: "union",\n    options,\n    discriminator,\n    ...normalizeParams(params)\n  });\n}\nfunction _intersection(Class2, left, right) {\n  return new Class2({\n    type: "intersection",\n    left,\n    right\n  });\n}\nfunction _tuple(Class2, items, _paramsOrRest, _params) {\n  const hasRest = _paramsOrRest instanceof $ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new Class2({\n    type: "tuple",\n    items,\n    rest,\n    ...normalizeParams(params)\n  });\n}\nfunction _record(Class2, keyType, valueType, params) {\n  return new Class2({\n    type: "record",\n    keyType,\n    valueType,\n    ...normalizeParams(params)\n  });\n}\nfunction _map(Class2, keyType, valueType, params) {\n  return new Class2({\n    type: "map",\n    keyType,\n    valueType,\n    ...normalizeParams(params)\n  });\n}\nfunction _set(Class2, valueType, params) {\n  return new Class2({\n    type: "set",\n    valueType,\n    ...normalizeParams(params)\n  });\n}\nfunction _enum(Class2, values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v3) => [v3, v3])) : values;\n  return new Class2({\n    type: "enum",\n    entries,\n    ...normalizeParams(params)\n  });\n}\nfunction _nativeEnum(Class2, entries, params) {\n  return new Class2({\n    type: "enum",\n    entries,\n    ...normalizeParams(params)\n  });\n}\nfunction _literal(Class2, value, params) {\n  return new Class2({\n    type: "literal",\n    values: Array.isArray(value) ? value : [value],\n    ...normalizeParams(params)\n  });\n}\nfunction _file(Class2, params) {\n  return new Class2({\n    type: "file",\n    ...normalizeParams(params)\n  });\n}\nfunction _transform(Class2, fn) {\n  return new Class2({\n    type: "transform",\n    transform: fn\n  });\n}\nfunction _optional(Class2, innerType) {\n  return new Class2({\n    type: "optional",\n    innerType\n  });\n}\nfunction _nullable(Class2, innerType) {\n  return new Class2({\n    type: "nullable",\n    innerType\n  });\n}\nfunction _default(Class2, innerType, defaultValue) {\n  return new Class2({\n    type: "default",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === "function" ? defaultValue() : defaultValue;\n    }\n  });\n}\nfunction _nonoptional(Class2, innerType, params) {\n  return new Class2({\n    type: "nonoptional",\n    innerType,\n    ...normalizeParams(params)\n  });\n}\nfunction _success(Class2, innerType) {\n  return new Class2({\n    type: "success",\n    innerType\n  });\n}\nfunction _catch(Class2, innerType, catchValue) {\n  return new Class2({\n    type: "catch",\n    innerType,\n    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue\n  });\n}\nfunction _pipe(Class2, in_, out) {\n  return new Class2({\n    type: "pipe",\n    in: in_,\n    out\n  });\n}\nfunction _readonly(Class2, innerType) {\n  return new Class2({\n    type: "readonly",\n    innerType\n  });\n}\nfunction _templateLiteral(Class2, parts, params) {\n  return new Class2({\n    type: "template_literal",\n    parts,\n    ...normalizeParams(params)\n  });\n}\nfunction _lazy(Class2, getter) {\n  return new Class2({\n    type: "lazy",\n    getter\n  });\n}\nfunction _promise(Class2, innerType) {\n  return new Class2({\n    type: "promise",\n    innerType\n  });\n}\nfunction _custom(Class2, fn, _params) {\n  const norm = normalizeParams(_params);\n  norm.abort ?? (norm.abort = true);\n  const schema = new Class2({\n    type: "custom",\n    check: "custom",\n    fn,\n    ...norm\n  });\n  return schema;\n}\nfunction _refine(Class2, fn, _params) {\n  const schema = new Class2({\n    type: "custom",\n    check: "custom",\n    fn,\n    ...normalizeParams(_params)\n  });\n  return schema;\n}\nfunction _stringbool(Classes, _params) {\n  const { case: _case, error: error38, truthy, falsy } = normalizeParams(_params);\n  const trueValues = new Set(truthy ?? ["true", "1", "yes", "on", "y", "enabled"]);\n  const falseValues = new Set(falsy ?? ["false", "0", "no", "off", "n", "disabled"]);\n  const _Pipe = Classes.Pipe ?? $ZodPipe;\n  const _Boolean = Classes.Boolean ?? $ZodBoolean;\n  const _Unknown = Classes.Unknown ?? $ZodUnknown;\n  const inst = new _Unknown({\n    type: "unknown",\n    checks: [\n      {\n        _zod: {\n          check: (ctx) => {\n            if (typeof ctx.value === "string") {\n              let data = ctx.value;\n              if (_case !== "sensitive")\n                data = data.toLowerCase();\n              if (trueValues.has(data)) {\n                ctx.value = true;\n              } else if (falseValues.has(data)) {\n                ctx.value = false;\n              } else {\n                ctx.issues.push({\n                  code: "invalid_value",\n                  expected: "stringbool",\n                  values: [...trueValues, ...falseValues],\n                  input: ctx.value,\n                  inst\n                });\n              }\n            } else {\n              ctx.issues.push({\n                code: "invalid_type",\n                expected: "string",\n                input: ctx.value\n              });\n            }\n          },\n          def: {\n            check: "custom"\n          },\n          onattach: []\n        }\n      }\n    ],\n    error: error38\n  });\n  return new _Pipe({\n    type: "pipe",\n    in: inst,\n    out: new _Boolean({\n      type: "boolean",\n      error: error38\n    }),\n    error: error38\n  });\n}\n\n// ../../node_modules/zod/dist/esm/v4/core/function.js\nclass $ZodFunction {\n  constructor(def) {\n    this._def = def;\n    this.def = def;\n  }\n  implement(func) {\n    if (typeof func !== "function") {\n      throw new Error("implement() must be called with a function");\n    }\n    const impl = (...args) => {\n      const parsedArgs = this._def.input ? parse(this._def.input, args, undefined, { callee: impl }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error("Invalid arguments schema: not an array or tuple schema.");\n      }\n      const output = func(...parsedArgs);\n      return this._def.output ? parse(this._def.output, output, undefined, { callee: impl }) : output;\n    };\n    return impl;\n  }\n  implementAsync(func) {\n    if (typeof func !== "function") {\n      throw new Error("implement() must be called with a function");\n    }\n    const impl = async (...args) => {\n      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, undefined, { callee: impl }) : args;\n      if (!Array.isArray(parsedArgs)) {\n        throw new Error("Invalid arguments schema: not an array or tuple schema.");\n      }\n      const output = await func(...parsedArgs);\n      return this._def.output ? parseAsync(this._def.output, output, undefined, { callee: impl }) : output;\n    };\n    return impl;\n  }\n  input(...args) {\n    const F2 = this.constructor;\n    if (Array.isArray(args[0])) {\n      return new F2({\n        type: "function",\n        input: new $ZodTuple({\n          type: "tuple",\n          items: args[0],\n          rest: args[1]\n        }),\n        output: this._def.output\n      });\n    }\n    return new F2({\n      type: "function",\n      input: args[0],\n      output: this._def.output\n    });\n  }\n  output(output) {\n    const F2 = this.constructor;\n    return new F2({\n      type: "function",\n      input: this._def.input,\n      output\n    });\n  }\n}\nfunction _function(params) {\n  return new $ZodFunction({\n    type: "function",\n    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),\n    output: params?.output ?? _unknown($ZodUnknown)\n  });\n}\n// ../../node_modules/zod/dist/esm/v4/core/to-json-schema.js\nclass JSONSchemaGenerator {\n  constructor(params) {\n    this.counter = 0;\n    this.metadataRegistry = params?.metadata ?? globalRegistry;\n    this.target = params?.target ?? "draft-2020-12";\n    this.unrepresentable = params?.unrepresentable ?? "throw";\n    this.override = params?.override ?? (() => {});\n    this.io = params?.io ?? "output";\n    this.seen = new Map;\n  }\n  process(schema, _params = { path: [], schemaPath: [] }) {\n    var _a15;\n    const def = schema._zod.def;\n    const formatMap = {\n      guid: "uuid",\n      url: "uri",\n      datetime: "date-time",\n      json_string: "json-string",\n      regex: ""\n    };\n    const seen = this.seen.get(schema);\n    if (seen) {\n      seen.count++;\n      const isCycle = _params.schemaPath.includes(schema);\n      if (isCycle) {\n        seen.cycle = _params.path;\n      }\n      return seen.schema;\n    }\n    const result = { schema: {}, count: 1, cycle: undefined };\n    this.seen.set(schema, result);\n    if (schema._zod.toJSONSchema) {\n      result.schema = schema._zod.toJSONSchema();\n    }\n    const params = {\n      ..._params,\n      schemaPath: [..._params.schemaPath, schema],\n      path: _params.path\n    };\n    const parent = schema._zod.parent;\n    if (parent) {\n      result.ref = parent;\n      this.process(parent, params);\n      this.seen.get(parent).isParent = true;\n    } else {\n      const _json = result.schema;\n      switch (def.type) {\n        case "string": {\n          const json = _json;\n          json.type = "string";\n          const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;\n          if (typeof minimum === "number")\n            json.minLength = minimum;\n          if (typeof maximum === "number")\n            json.maxLength = maximum;\n          if (format) {\n            json.format = formatMap[format] ?? format;\n            if (json.format === "")\n              delete json.format;\n          }\n          if (contentEncoding)\n            json.contentEncoding = contentEncoding;\n          if (patterns && patterns.size > 0) {\n            const regexes = [...patterns];\n            if (regexes.length === 1)\n              json.pattern = regexes[0].source;\n            else if (regexes.length > 1) {\n              result.schema.allOf = [\n                ...regexes.map((regex) => ({\n                  ...this.target === "draft-7" ? { type: "string" } : {},\n                  pattern: regex.source\n                }))\n              ];\n            }\n          }\n          break;\n        }\n        case "number": {\n          const json = _json;\n          const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n          if (typeof format === "string" && format.includes("int"))\n            json.type = "integer";\n          else\n            json.type = "number";\n          if (typeof exclusiveMinimum === "number")\n            json.exclusiveMinimum = exclusiveMinimum;\n          if (typeof minimum === "number") {\n            json.minimum = minimum;\n            if (typeof exclusiveMinimum === "number") {\n              if (exclusiveMinimum >= minimum)\n                delete json.minimum;\n              else\n                delete json.exclusiveMinimum;\n            }\n          }\n          if (typeof exclusiveMaximum === "number")\n            json.exclusiveMaximum = exclusiveMaximum;\n          if (typeof maximum === "number") {\n            json.maximum = maximum;\n            if (typeof exclusiveMaximum === "number") {\n              if (exclusiveMaximum <= maximum)\n                delete json.maximum;\n              else\n                delete json.exclusiveMaximum;\n            }\n          }\n          if (typeof multipleOf === "number")\n            json.multipleOf = multipleOf;\n          break;\n        }\n        case "boolean": {\n          const json = _json;\n          json.type = "boolean";\n          break;\n        }\n        case "bigint": {\n          if (this.unrepresentable === "throw") {\n            throw new Error("BigInt cannot be represented in JSON Schema");\n          }\n          break;\n        }\n        case "symbol": {\n          if (this.unrepresentable === "throw") {\n            throw new Error("Symbols cannot be represented in JSON Schema");\n          }\n          break;\n        }\n        case "undefined": {\n          const json = _json;\n          json.type = "null";\n          break;\n        }\n        case "null": {\n          _json.type = "null";\n          break;\n        }\n        case "any": {\n          break;\n        }\n        case "unknown": {\n          break;\n        }\n        case "never": {\n          _json.not = {};\n          break;\n        }\n        case "void": {\n          if (this.unrepresentable === "throw") {\n            throw new Error("Void cannot be represented in JSON Schema");\n          }\n          break;\n        }\n        case "date": {\n          if (this.unrepresentable === "throw") {\n            throw new Error("Date cannot be represented in JSON Schema");\n          }\n          break;\n        }\n        case "array": {\n          const json = _json;\n          const { minimum, maximum } = schema._zod.bag;\n          if (typeof minimum === "number")\n            json.minItems = minimum;\n          if (typeof maximum === "number")\n            json.maxItems = maximum;\n          json.type = "array";\n          json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });\n          break;\n        }\n        case "object": {\n          const json = _json;\n          json.type = "object";\n          json.properties = {};\n          const shape = def.shape;\n          for (const key in shape) {\n            json.properties[key] = this.process(shape[key], {\n              ...params,\n              path: [...params.path, "properties", key]\n            });\n          }\n          const allKeys = new Set(Object.keys(shape));\n          const requiredKeys = new Set([...allKeys].filter((key) => {\n            const v3 = def.shape[key]._zod;\n            if (this.io === "input") {\n              return v3.optin === undefined;\n            } else {\n              return v3.optout === undefined;\n            }\n          }));\n          if (requiredKeys.size > 0) {\n            json.required = Array.from(requiredKeys);\n          }\n          if (def.catchall?._zod.def.type === "never") {\n            json.additionalProperties = false;\n          } else if (!def.catchall) {\n            if (this.io === "output")\n              json.additionalProperties = false;\n          } else if (def.catchall) {\n            json.additionalProperties = this.process(def.catchall, {\n              ...params,\n              path: [...params.path, "additionalProperties"]\n            });\n          }\n          break;\n        }\n        case "union": {\n          const json = _json;\n          json.anyOf = def.options.map((x2, i2) => this.process(x2, {\n            ...params,\n            path: [...params.path, "anyOf", i2]\n          }));\n          break;\n        }\n        case "intersection": {\n          const json = _json;\n          const a2 = this.process(def.left, {\n            ...params,\n            path: [...params.path, "allOf", 0]\n          });\n          const b2 = this.process(def.right, {\n            ...params,\n            path: [...params.path, "allOf", 1]\n          });\n          const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;\n          const allOf = [\n            ...isSimpleIntersection(a2) ? a2.allOf : [a2],\n            ...isSimpleIntersection(b2) ? b2.allOf : [b2]\n          ];\n          json.allOf = allOf;\n          break;\n        }\n        case "tuple": {\n          const json = _json;\n          json.type = "array";\n          const prefixItems = def.items.map((x2, i2) => this.process(x2, { ...params, path: [...params.path, "prefixItems", i2] }));\n          if (this.target === "draft-2020-12") {\n            json.prefixItems = prefixItems;\n          } else {\n            json.items = prefixItems;\n          }\n          if (def.rest) {\n            const rest = this.process(def.rest, {\n              ...params,\n              path: [...params.path, "items"]\n            });\n            if (this.target === "draft-2020-12") {\n              json.items = rest;\n            } else {\n              json.additionalItems = rest;\n            }\n          }\n          if (def.rest) {\n            json.items = this.process(def.rest, {\n              ...params,\n              path: [...params.path, "items"]\n            });\n          }\n          const { minimum, maximum } = schema._zod.bag;\n          if (typeof minimum === "number")\n            json.minItems = minimum;\n          if (typeof maximum === "number")\n            json.maxItems = maximum;\n          break;\n        }\n        case "record": {\n          const json = _json;\n          json.type = "object";\n          json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });\n          json.additionalProperties = this.process(def.valueType, {\n            ...params,\n            path: [...params.path, "additionalProperties"]\n          });\n          break;\n        }\n        case "map": {\n          if (this.unrepresentable === "throw") {\n            throw new Error("Map cannot be represented in JSON Schema");\n          }\n          break;\n        }\n        case "set": {\n          if (this.unrepresentable === "throw") {\n            throw new Error("Set cannot be represented in JSON Schema");\n          }\n          break;\n        }\n        case "enum": {\n          const json = _json;\n          const values = getEnumValues(def.entries);\n          if (values.every((v3) => typeof v3 === "number"))\n            json.type = "number";\n          if (values.every((v3) => typeof v3 === "string"))\n            json.type = "string";\n          json.enum = values;\n          break;\n        }\n        case "literal": {\n          const json = _json;\n          const vals = [];\n          for (const val of def.values) {\n            if (val === undefined) {\n              if (this.unrepresentable === "throw") {\n                throw new Error("Literal `undefined` cannot be represented in JSON Schema");\n              } else {}\n            } else if (typeof val === "bigint") {\n              if (this.unrepresentable === "throw") {\n                throw new Error("BigInt literals cannot be represented in JSON Schema");\n              } else {\n                vals.push(Number(val));\n              }\n            } else {\n              vals.push(val);\n            }\n          }\n          if (vals.length === 0) {} else if (vals.length === 1) {\n            const val = vals[0];\n            json.type = val === null ? "null" : typeof val;\n            json.const = val;\n          } else {\n            if (vals.every((v3) => typeof v3 === "number"))\n              json.type = "number";\n            if (vals.every((v3) => typeof v3 === "string"))\n              json.type = "string";\n            if (vals.every((v3) => typeof v3 === "boolean"))\n              json.type = "string";\n            if (vals.every((v3) => v3 === null))\n              json.type = "null";\n            json.enum = vals;\n          }\n          break;\n        }\n        case "file": {\n          const json = _json;\n          const file = {\n            type: "string",\n            format: "binary",\n            contentEncoding: "binary"\n          };\n          const { minimum, maximum, mime } = schema._zod.bag;\n          if (minimum !== undefined)\n            file.minLength = minimum;\n          if (maximum !== undefined)\n            file.maxLength = maximum;\n          if (mime) {\n            if (mime.length === 1) {\n              file.contentMediaType = mime[0];\n              Object.assign(json, file);\n            } else {\n              json.anyOf = mime.map((m3) => {\n                const mFile = { ...file, contentMediaType: m3 };\n                return mFile;\n              });\n            }\n          } else {\n            Object.assign(json, file);\n          }\n          break;\n        }\n        case "transform": {\n          if (this.unrepresentable === "throw") {\n            throw new Error("Transforms cannot be represented in JSON Schema");\n          }\n          break;\n        }\n        case "nullable": {\n          const inner = this.process(def.innerType, params);\n          _json.anyOf = [inner, { type: "null" }];\n          break;\n        }\n        case "nonoptional": {\n          this.process(def.innerType, params);\n          result.ref = def.innerType;\n          break;\n        }\n        case "success": {\n          const json = _json;\n          json.type = "boolean";\n          break;\n        }\n        case "default": {\n          this.process(def.innerType, params);\n          result.ref = def.innerType;\n          _json.default = def.defaultValue;\n          break;\n        }\n        case "prefault": {\n          this.process(def.innerType, params);\n          result.ref = def.innerType;\n          if (this.io === "input")\n            _json._prefault = def.defaultValue;\n          break;\n        }\n        case "catch": {\n          this.process(def.innerType, params);\n          result.ref = def.innerType;\n          let catchValue;\n          try {\n            catchValue = def.catchValue(undefined);\n          } catch {\n            throw new Error("Dynamic catch values are not supported in JSON Schema");\n          }\n          _json.default = catchValue;\n          break;\n        }\n        case "nan": {\n          if (this.unrepresentable === "throw") {\n            throw new Error("NaN cannot be represented in JSON Schema");\n          }\n          break;\n        }\n        case "template_literal": {\n          const json = _json;\n          const pattern = schema._zod.pattern;\n          if (!pattern)\n            throw new Error("Pattern not found in template literal");\n          json.type = "string";\n          json.pattern = pattern.source;\n          break;\n        }\n        case "pipe": {\n          const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;\n          this.process(innerType, params);\n          result.ref = innerType;\n          break;\n        }\n        case "readonly": {\n          this.process(def.innerType, params);\n          result.ref = def.innerType;\n          _json.readOnly = true;\n          break;\n        }\n        case "promise": {\n          this.process(def.innerType, params);\n          result.ref = def.innerType;\n          break;\n        }\n        case "optional": {\n          this.process(def.innerType, params);\n          result.ref = def.innerType;\n          break;\n        }\n        case "lazy": {\n          const innerType = schema._zod.innerType;\n          this.process(innerType, params);\n          result.ref = innerType;\n          break;\n        }\n        case "custom": {\n          if (this.unrepresentable === "throw") {\n            throw new Error("Custom types cannot be represented in JSON Schema");\n          }\n          break;\n        }\n        default: {}\n      }\n    }\n    const meta = this.metadataRegistry.get(schema);\n    if (meta)\n      Object.assign(result.schema, meta);\n    if (this.io === "input" && isTransforming(schema)) {\n      delete result.schema.examples;\n      delete result.schema.default;\n    }\n    if (this.io === "input" && result.schema._prefault)\n      (_a15 = result.schema).default ?? (_a15.default = result.schema._prefault);\n    delete result.schema._prefault;\n    const _result = this.seen.get(schema);\n    return _result.schema;\n  }\n  emit(schema, _params) {\n    const params = {\n      cycles: _params?.cycles ?? "ref",\n      reused: _params?.reused ?? "inline",\n      external: _params?.external ?? undefined\n    };\n    const root = this.seen.get(schema);\n    if (!root)\n      throw new Error("Unprocessed schema. This is a bug in Zod.");\n    const makeURI = (entry) => {\n      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";\n      if (params.external) {\n        const externalId = params.external.registry.get(entry[0])?.id;\n        if (externalId)\n          return { ref: params.external.uri(externalId) };\n        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;\n        entry[1].defId = id;\n        return { defId: id, ref: `${params.external.uri("__shared")}#/${defsSegment}/${id}` };\n      }\n      if (entry[1] === root) {\n        return { ref: "#" };\n      }\n      const uriPrefix = `#`;\n      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n      return { defId, ref: defUriPrefix + defId };\n    };\n    const extractToDef = (entry) => {\n      if (entry[1].schema.$ref) {\n        return;\n      }\n      const seen = entry[1];\n      const { ref, defId } = makeURI(entry);\n      seen.def = { ...seen.schema };\n      if (defId)\n        seen.defId = defId;\n      const schema2 = seen.schema;\n      for (const key in schema2) {\n        delete schema2[key];\n      }\n      schema2.$ref = ref;\n    };\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (schema === entry[0]) {\n        extractToDef(entry);\n        continue;\n      }\n      if (params.external) {\n        const ext = params.external.registry.get(entry[0])?.id;\n        if (schema !== entry[0] && ext) {\n          extractToDef(entry);\n          continue;\n        }\n      }\n      const id = this.metadataRegistry.get(entry[0])?.id;\n      if (id) {\n        extractToDef(entry);\n        continue;\n      }\n      if (seen.cycle) {\n        if (params.cycles === "throw") {\n          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + \'\\n\\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.\');\n        } else if (params.cycles === "ref") {\n          extractToDef(entry);\n        }\n        continue;\n      }\n      if (seen.count > 1) {\n        if (params.reused === "ref") {\n          extractToDef(entry);\n          continue;\n        }\n      }\n    }\n    const flattenRef = (zodSchema, params2) => {\n      const seen = this.seen.get(zodSchema);\n      const schema2 = seen.def ?? seen.schema;\n      const _cached = { ...schema2 };\n      if (seen.ref === null) {\n        return;\n      }\n      const ref = seen.ref;\n      seen.ref = null;\n      if (ref) {\n        flattenRef(ref, params2);\n        const refSchema = this.seen.get(ref).schema;\n        if (refSchema.$ref && params2.target === "draft-7") {\n          schema2.allOf = schema2.allOf ?? [];\n          schema2.allOf.push(refSchema);\n        } else {\n          Object.assign(schema2, refSchema);\n          Object.assign(schema2, _cached);\n        }\n      }\n      if (!seen.isParent)\n        this.override({\n          zodSchema,\n          jsonSchema: schema2\n        });\n    };\n    for (const entry of [...this.seen.entries()].reverse()) {\n      flattenRef(entry[0], { target: this.target });\n    }\n    const result = {};\n    if (this.target === "draft-2020-12") {\n      result.$schema = "https://json-schema.org/draft/2020-12/schema";\n    } else if (this.target === "draft-7") {\n      result.$schema = "http://json-schema.org/draft-07/schema#";\n    } else {\n      console.warn(`Invalid target: ${this.target}`);\n    }\n    Object.assign(result, root.def);\n    const defs = params.external?.defs ?? {};\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (seen.def && seen.defId) {\n        defs[seen.defId] = seen.def;\n      }\n    }\n    if (!params.external && Object.keys(defs).length > 0) {\n      if (this.target === "draft-2020-12") {\n        result.$defs = defs;\n      } else {\n        result.definitions = defs;\n      }\n    }\n    try {\n      return JSON.parse(JSON.stringify(result));\n    } catch (_err) {\n      throw new Error("Error converting schema to JSON.");\n    }\n  }\n}\nfunction toJSONSchema(input, _params) {\n  if (input instanceof $ZodRegistry) {\n    const gen2 = new JSONSchemaGenerator(_params);\n    const defs = {};\n    for (const entry of input._idmap.entries()) {\n      const [_3, schema] = entry;\n      gen2.process(schema);\n    }\n    const schemas = {};\n    const external = {\n      registry: input,\n      uri: _params?.uri || ((id) => id),\n      defs\n    };\n    for (const entry of input._idmap.entries()) {\n      const [key, schema] = entry;\n      schemas[key] = gen2.emit(schema, {\n        ..._params,\n        external\n      });\n    }\n    if (Object.keys(defs).length > 0) {\n      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";\n      schemas.__shared = {\n        [defsSegment]: defs\n      };\n    }\n    return { schemas };\n  }\n  const gen = new JSONSchemaGenerator(_params);\n  gen.process(input);\n  return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n  const ctx = _ctx ?? { seen: new Set };\n  if (ctx.seen.has(_schema))\n    return false;\n  ctx.seen.add(_schema);\n  const schema = _schema;\n  const def = schema._zod.def;\n  switch (def.type) {\n    case "string":\n    case "number":\n    case "bigint":\n    case "boolean":\n    case "date":\n    case "symbol":\n    case "undefined":\n    case "null":\n    case "any":\n    case "unknown":\n    case "never":\n    case "void":\n    case "literal":\n    case "enum":\n    case "nan":\n    case "file":\n    case "template_literal":\n      return false;\n    case "array": {\n      return isTransforming(def.element, ctx);\n    }\n    case "object": {\n      for (const key in def.shape) {\n        if (isTransforming(def.shape[key], ctx))\n          return true;\n      }\n      return false;\n    }\n    case "union": {\n      for (const option of def.options) {\n        if (isTransforming(option, ctx))\n          return true;\n      }\n      return false;\n    }\n    case "intersection": {\n      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n    }\n    case "tuple": {\n      for (const item of def.items) {\n        if (isTransforming(item, ctx))\n          return true;\n      }\n      if (def.rest && isTransforming(def.rest, ctx))\n        return true;\n      return false;\n    }\n    case "record": {\n      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n    }\n    case "map": {\n      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n    }\n    case "set": {\n      return isTransforming(def.valueType, ctx);\n    }\n    case "promise":\n    case "optional":\n    case "nonoptional":\n    case "nullable":\n    case "readonly":\n      return isTransforming(def.innerType, ctx);\n    case "lazy":\n      return isTransforming(def.getter(), ctx);\n    case "default": {\n      return isTransforming(def.innerType, ctx);\n    }\n    case "prefault": {\n      return isTransforming(def.innerType, ctx);\n    }\n    case "custom": {\n      return false;\n    }\n    case "transform": {\n      return true;\n    }\n    case "pipe": {\n      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n    }\n    case "success": {\n      return false;\n    }\n    case "catch": {\n      return false;\n    }\n    default:\n  }\n  throw new Error(`Unknown schema type: ${def.type}`);\n}\n// ../../node_modules/zod/dist/esm/v4/core/json-schema.js\nvar exports_json_schema = {};\n// ../../node_modules/zod/dist/esm/v4/classic/iso.js\nvar exports_iso = {};\n__export(exports_iso, {\n  time: () => time2,\n  duration: () => duration2,\n  datetime: () => datetime2,\n  date: () => date2,\n  ZodISOTime: () => ZodISOTime,\n  ZodISODuration: () => ZodISODuration,\n  ZodISODateTime: () => ZodISODateTime,\n  ZodISODate: () => ZodISODate\n});\nvar ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {\n  $ZodISODateTime.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction datetime2(params) {\n  return _isoDateTime(ZodISODateTime, params);\n}\nvar ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {\n  $ZodISODate.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction date2(params) {\n  return _isoDate(ZodISODate, params);\n}\nvar ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {\n  $ZodISOTime.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction time2(params) {\n  return _isoTime(ZodISOTime, params);\n}\nvar ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {\n  $ZodISODuration.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction duration2(params) {\n  return _isoDuration(ZodISODuration, params);\n}\n\n// ../../node_modules/zod/dist/esm/v4/classic/errors.js\nvar initializer2 = (inst, issues) => {\n  $ZodError.init(inst, issues);\n  inst.name = "ZodError";\n  Object.defineProperties(inst, {\n    format: {\n      value: (mapper) => formatError(inst, mapper)\n    },\n    flatten: {\n      value: (mapper) => flattenError(inst, mapper)\n    },\n    addIssue: {\n      value: (issue2) => inst.issues.push(issue2)\n    },\n    addIssues: {\n      value: (issues2) => inst.issues.push(...issues2)\n    },\n    isEmpty: {\n      get() {\n        return inst.issues.length === 0;\n      }\n    }\n  });\n};\nvar ZodError = $constructor("ZodError", initializer2);\nvar ZodRealError = $constructor("ZodError", initializer2, {\n  Parent: Error\n});\n\n// ../../node_modules/zod/dist/esm/v4/classic/parse.js\nvar parse3 = /* @__PURE__ */ _parse(ZodRealError);\nvar parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);\nvar safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);\nvar safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);\n\n// ../../node_modules/zod/dist/esm/v4/classic/schemas.js\nvar ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst.def = def;\n  Object.defineProperty(inst, "_def", { value: def });\n  inst.check = (...checks2) => {\n    return inst.clone({\n      ...def,\n      checks: [\n        ...def.checks ?? [],\n        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)\n      ]\n    });\n  };\n  inst.clone = (def2, params) => clone(inst, def2, params);\n  inst.brand = () => inst;\n  inst.register = (reg, meta) => {\n    reg.add(inst, meta);\n    return inst;\n  };\n  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });\n  inst.safeParse = (data, params) => safeParse2(inst, data, params);\n  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });\n  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);\n  inst.spa = inst.safeParseAsync;\n  inst.refine = (check, params) => inst.check(refine(check, params));\n  inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n  inst.overwrite = (fn) => inst.check(_overwrite(fn));\n  inst.optional = () => optional(inst);\n  inst.nullable = () => nullable(inst);\n  inst.nullish = () => optional(nullable(inst));\n  inst.nonoptional = (params) => nonoptional(inst, params);\n  inst.array = () => array(inst);\n  inst.or = (arg) => union([inst, arg]);\n  inst.and = (arg) => intersection(inst, arg);\n  inst.transform = (tx) => pipe(inst, transform(tx));\n  inst.default = (def2) => _default2(inst, def2);\n  inst.prefault = (def2) => prefault(inst, def2);\n  inst.catch = (params) => _catch2(inst, params);\n  inst.pipe = (target) => pipe(inst, target);\n  inst.readonly = () => readonly(inst);\n  inst.describe = (description) => {\n    const cl = inst.clone();\n    globalRegistry.add(cl, { description });\n    return cl;\n  };\n  Object.defineProperty(inst, "description", {\n    get() {\n      return globalRegistry.get(inst)?.description;\n    },\n    configurable: true\n  });\n  inst.meta = (...args) => {\n    if (args.length === 0) {\n      return globalRegistry.get(inst);\n    }\n    const cl = inst.clone();\n    globalRegistry.add(cl, args[0]);\n    return cl;\n  };\n  inst.isOptional = () => inst.safeParse(undefined).success;\n  inst.isNullable = () => inst.safeParse(null).success;\n  return inst;\n});\nvar _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {\n  $ZodString.init(inst, def);\n  ZodType.init(inst, def);\n  const bag = inst._zod.bag;\n  inst.format = bag.format ?? null;\n  inst.minLength = bag.minimum ?? null;\n  inst.maxLength = bag.maximum ?? null;\n  inst.regex = (...args) => inst.check(_regex(...args));\n  inst.includes = (...args) => inst.check(_includes(...args));\n  inst.startsWith = (...args) => inst.check(_startsWith(...args));\n  inst.endsWith = (...args) => inst.check(_endsWith(...args));\n  inst.min = (...args) => inst.check(_minLength(...args));\n  inst.max = (...args) => inst.check(_maxLength(...args));\n  inst.length = (...args) => inst.check(_length(...args));\n  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));\n  inst.lowercase = (params) => inst.check(_lowercase(params));\n  inst.uppercase = (params) => inst.check(_uppercase(params));\n  inst.trim = () => inst.check(_trim());\n  inst.normalize = (...args) => inst.check(_normalize(...args));\n  inst.toLowerCase = () => inst.check(_toLowerCase());\n  inst.toUpperCase = () => inst.check(_toUpperCase());\n});\nvar ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {\n  $ZodString.init(inst, def);\n  _ZodString.init(inst, def);\n  inst.email = (params) => inst.check(_email(ZodEmail, params));\n  inst.url = (params) => inst.check(_url(ZodURL, params));\n  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));\n  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));\n  inst.guid = (params) => inst.check(_guid(ZodGUID, params));\n  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));\n  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));\n  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));\n  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));\n  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));\n  inst.guid = (params) => inst.check(_guid(ZodGUID, params));\n  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));\n  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));\n  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));\n  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));\n  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));\n  inst.xid = (params) => inst.check(_xid(ZodXID, params));\n  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));\n  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));\n  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));\n  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));\n  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));\n  inst.e164 = (params) => inst.check(_e164(ZodE164, params));\n  inst.datetime = (params) => inst.check(datetime2(params));\n  inst.date = (params) => inst.check(date2(params));\n  inst.time = (params) => inst.check(time2(params));\n  inst.duration = (params) => inst.check(duration2(params));\n});\nfunction string2(params) {\n  return _string(ZodString, params);\n}\nvar ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  _ZodString.init(inst, def);\n});\nvar ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {\n  $ZodEmail.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction email2(params) {\n  return _email(ZodEmail, params);\n}\nvar ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {\n  $ZodGUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction guid2(params) {\n  return _guid(ZodGUID, params);\n}\nvar ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {\n  $ZodUUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction uuid2(params) {\n  return _uuid(ZodUUID, params);\n}\nfunction uuidv4(params) {\n  return _uuidv4(ZodUUID, params);\n}\nfunction uuidv6(params) {\n  return _uuidv6(ZodUUID, params);\n}\nfunction uuidv7(params) {\n  return _uuidv7(ZodUUID, params);\n}\nvar ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {\n  $ZodURL.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction url(params) {\n  return _url(ZodURL, params);\n}\nvar ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {\n  $ZodEmoji.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction emoji2(params) {\n  return _emoji2(ZodEmoji, params);\n}\nvar ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {\n  $ZodNanoID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction nanoid2(params) {\n  return _nanoid(ZodNanoID, params);\n}\nvar ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {\n  $ZodCUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cuid3(params) {\n  return _cuid(ZodCUID, params);\n}\nvar ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {\n  $ZodCUID2.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cuid22(params) {\n  return _cuid2(ZodCUID2, params);\n}\nvar ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {\n  $ZodULID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ulid2(params) {\n  return _ulid(ZodULID, params);\n}\nvar ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {\n  $ZodXID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction xid2(params) {\n  return _xid(ZodXID, params);\n}\nvar ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {\n  $ZodKSUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ksuid2(params) {\n  return _ksuid(ZodKSUID, params);\n}\nvar ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {\n  $ZodIPv4.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ipv42(params) {\n  return _ipv4(ZodIPv4, params);\n}\nvar ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {\n  $ZodIPv6.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ipv62(params) {\n  return _ipv6(ZodIPv6, params);\n}\nvar ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {\n  $ZodCIDRv4.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cidrv42(params) {\n  return _cidrv4(ZodCIDRv4, params);\n}\nvar ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {\n  $ZodCIDRv6.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cidrv62(params) {\n  return _cidrv6(ZodCIDRv6, params);\n}\nvar ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {\n  $ZodBase64.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction base642(params) {\n  return _base64(ZodBase64, params);\n}\nvar ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {\n  $ZodBase64URL.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction base64url2(params) {\n  return _base64url(ZodBase64URL, params);\n}\nvar ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {\n  $ZodE164.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction e1642(params) {\n  return _e164(ZodE164, params);\n}\nvar ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {\n  $ZodJWT.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction jwt(params) {\n  return _jwt(ZodJWT, params);\n}\nvar ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {\n  $ZodNumber.init(inst, def);\n  ZodType.init(inst, def);\n  inst.gt = (value, params) => inst.check(_gt(value, params));\n  inst.gte = (value, params) => inst.check(_gte(value, params));\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.lt = (value, params) => inst.check(_lt(value, params));\n  inst.lte = (value, params) => inst.check(_lte(value, params));\n  inst.max = (value, params) => inst.check(_lte(value, params));\n  inst.int = (params) => inst.check(int(params));\n  inst.safe = (params) => inst.check(int(params));\n  inst.positive = (params) => inst.check(_gt(0, params));\n  inst.nonnegative = (params) => inst.check(_gte(0, params));\n  inst.negative = (params) => inst.check(_lt(0, params));\n  inst.nonpositive = (params) => inst.check(_lte(0, params));\n  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));\n  inst.step = (value, params) => inst.check(_multipleOf(value, params));\n  inst.finite = () => inst;\n  const bag = inst._zod.bag;\n  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;\n  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;\n  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);\n  inst.isFinite = true;\n  inst.format = bag.format ?? null;\n});\nfunction number2(params) {\n  return _number(ZodNumber, params);\n}\nvar ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {\n  $ZodNumberFormat.init(inst, def);\n  ZodNumber.init(inst, def);\n});\nfunction int(params) {\n  return _int(ZodNumberFormat, params);\n}\nfunction float32(params) {\n  return _float32(ZodNumberFormat, params);\n}\nfunction float64(params) {\n  return _float64(ZodNumberFormat, params);\n}\nfunction int32(params) {\n  return _int32(ZodNumberFormat, params);\n}\nfunction uint32(params) {\n  return _uint32(ZodNumberFormat, params);\n}\nvar ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {\n  $ZodBoolean.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction boolean2(params) {\n  return _boolean(ZodBoolean, params);\n}\nvar ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {\n  $ZodBigInt.init(inst, def);\n  ZodType.init(inst, def);\n  inst.gte = (value, params) => inst.check(_gte(value, params));\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.gt = (value, params) => inst.check(_gt(value, params));\n  inst.gte = (value, params) => inst.check(_gte(value, params));\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.lt = (value, params) => inst.check(_lt(value, params));\n  inst.lte = (value, params) => inst.check(_lte(value, params));\n  inst.max = (value, params) => inst.check(_lte(value, params));\n  inst.positive = (params) => inst.check(_gt(BigInt(0), params));\n  inst.negative = (params) => inst.check(_lt(BigInt(0), params));\n  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));\n  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));\n  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));\n  const bag = inst._zod.bag;\n  inst.minValue = bag.minimum ?? null;\n  inst.maxValue = bag.maximum ?? null;\n  inst.format = bag.format ?? null;\n});\nfunction bigint2(params) {\n  return _bigint(ZodBigInt, params);\n}\nvar ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {\n  $ZodBigIntFormat.init(inst, def);\n  ZodBigInt.init(inst, def);\n});\nfunction int64(params) {\n  return _int64(ZodBigIntFormat, params);\n}\nfunction uint64(params) {\n  return _uint64(ZodBigIntFormat, params);\n}\nvar ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {\n  $ZodSymbol.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction symbol15(params) {\n  return _symbol(ZodSymbol, params);\n}\nvar ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {\n  $ZodUndefined.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction _undefined3(params) {\n  return _undefined2(ZodUndefined, params);\n}\nvar ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {\n  $ZodNull.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction _null3(params) {\n  return _null2(ZodNull, params);\n}\nvar ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {\n  $ZodAny.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction any() {\n  return _any(ZodAny);\n}\nvar ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {\n  $ZodUnknown.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction unknown() {\n  return _unknown(ZodUnknown);\n}\nvar ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {\n  $ZodNever.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction never(params) {\n  return _never(ZodNever, params);\n}\nvar ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {\n  $ZodVoid.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction _void2(params) {\n  return _void(ZodVoid, params);\n}\nvar ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {\n  $ZodDate.init(inst, def);\n  ZodType.init(inst, def);\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.max = (value, params) => inst.check(_lte(value, params));\n  const c2 = inst._zod.bag;\n  inst.minDate = c2.minimum ? new Date(c2.minimum) : null;\n  inst.maxDate = c2.maximum ? new Date(c2.maximum) : null;\n});\nfunction date3(params) {\n  return _date(ZodDate, params);\n}\nvar ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {\n  $ZodArray.init(inst, def);\n  ZodType.init(inst, def);\n  inst.element = def.element;\n  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));\n  inst.nonempty = (params) => inst.check(_minLength(1, params));\n  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));\n  inst.length = (len, params) => inst.check(_length(len, params));\n  inst.unwrap = () => inst.element;\n});\nfunction array(element, params) {\n  return _array(ZodArray, element, params);\n}\nfunction keyof(schema) {\n  const shape = schema._zod.def.shape;\n  return literal(Object.keys(shape));\n}\nvar ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {\n  $ZodObject.init(inst, def);\n  ZodType.init(inst, def);\n  exports_util.defineLazy(inst, "shape", () => {\n    return Object.fromEntries(Object.entries(inst._zod.def.shape));\n  });\n  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));\n  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });\n  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });\n  inst.extend = (incoming) => {\n    return exports_util.extend(inst, incoming);\n  };\n  inst.merge = (other) => exports_util.merge(inst, other);\n  inst.pick = (mask) => exports_util.pick(inst, mask);\n  inst.omit = (mask) => exports_util.omit(inst, mask);\n  inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);\n  inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);\n});\nfunction object(shape, params) {\n  const def = {\n    type: "object",\n    get shape() {\n      exports_util.assignProp(this, "shape", { ...shape });\n      return this.shape;\n    },\n    ...exports_util.normalizeParams(params)\n  };\n  return new ZodObject(def);\n}\nfunction strictObject(shape, params) {\n  return new ZodObject({\n    type: "object",\n    get shape() {\n      exports_util.assignProp(this, "shape", { ...shape });\n      return this.shape;\n    },\n    catchall: never(),\n    ...exports_util.normalizeParams(params)\n  });\n}\nfunction looseObject(shape, params) {\n  return new ZodObject({\n    type: "object",\n    get shape() {\n      exports_util.assignProp(this, "shape", { ...shape });\n      return this.shape;\n    },\n    catchall: unknown(),\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  ZodType.init(inst, def);\n  inst.options = def.options;\n});\nfunction union(options, params) {\n  return new ZodUnion({\n    type: "union",\n    options,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {\n  ZodUnion.init(inst, def);\n  $ZodDiscriminatedUnion.init(inst, def);\n});\nfunction discriminatedUnion(discriminator, options, params) {\n  return new ZodDiscriminatedUnion({\n    type: "union",\n    options,\n    discriminator,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {\n  $ZodIntersection.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction intersection(left, right) {\n  return new ZodIntersection({\n    type: "intersection",\n    left,\n    right\n  });\n}\nvar ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {\n  $ZodTuple.init(inst, def);\n  ZodType.init(inst, def);\n  inst.rest = (rest) => inst.clone({\n    ...inst._zod.def,\n    rest\n  });\n});\nfunction tuple(items, _paramsOrRest, _params) {\n  const hasRest = _paramsOrRest instanceof $ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new ZodTuple({\n    type: "tuple",\n    items,\n    rest,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {\n  $ZodRecord.init(inst, def);\n  ZodType.init(inst, def);\n  inst.keyType = def.keyType;\n  inst.valueType = def.valueType;\n});\nfunction record(keyType, valueType, params) {\n  return new ZodRecord({\n    type: "record",\n    keyType,\n    valueType,\n    ...exports_util.normalizeParams(params)\n  });\n}\nfunction partialRecord(keyType, valueType, params) {\n  return new ZodRecord({\n    type: "record",\n    keyType: union([keyType, never()]),\n    valueType,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {\n  $ZodMap.init(inst, def);\n  ZodType.init(inst, def);\n  inst.keyType = def.keyType;\n  inst.valueType = def.valueType;\n});\nfunction map(keyType, valueType, params) {\n  return new ZodMap({\n    type: "map",\n    keyType,\n    valueType,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {\n  $ZodSet.init(inst, def);\n  ZodType.init(inst, def);\n  inst.min = (...args) => inst.check(_minSize(...args));\n  inst.nonempty = (params) => inst.check(_minSize(1, params));\n  inst.max = (...args) => inst.check(_maxSize(...args));\n  inst.size = (...args) => inst.check(_size(...args));\n});\nfunction set(valueType, params) {\n  return new ZodSet({\n    type: "set",\n    valueType,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {\n  $ZodEnum.init(inst, def);\n  ZodType.init(inst, def);\n  inst.enum = def.entries;\n  inst.options = Object.values(def.entries);\n  const keys = new Set(Object.keys(def.entries));\n  inst.extract = (values, params) => {\n    const newEntries = {};\n    for (const value of values) {\n      if (keys.has(value)) {\n        newEntries[value] = def.entries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...exports_util.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n  inst.exclude = (values, params) => {\n    const newEntries = { ...def.entries };\n    for (const value of values) {\n      if (keys.has(value)) {\n        delete newEntries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...exports_util.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n});\nfunction _enum2(values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v3) => [v3, v3])) : values;\n  return new ZodEnum({\n    type: "enum",\n    entries,\n    ...exports_util.normalizeParams(params)\n  });\n}\nfunction nativeEnum(entries, params) {\n  return new ZodEnum({\n    type: "enum",\n    entries,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {\n  $ZodLiteral.init(inst, def);\n  ZodType.init(inst, def);\n  inst.values = new Set(def.values);\n  Object.defineProperty(inst, "value", {\n    get() {\n      if (def.values.length > 1) {\n        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");\n      }\n      return def.values[0];\n    }\n  });\n});\nfunction literal(value, params) {\n  return new ZodLiteral({\n    type: "literal",\n    values: Array.isArray(value) ? value : [value],\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {\n  $ZodFile.init(inst, def);\n  ZodType.init(inst, def);\n  inst.min = (size, params) => inst.check(_minSize(size, params));\n  inst.max = (size, params) => inst.check(_maxSize(size, params));\n  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));\n});\nfunction file(params) {\n  return _file(ZodFile, params);\n}\nvar ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {\n  $ZodTransform.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === "string") {\n        payload.issues.push(exports_util.issue(issue2, payload.value, def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = "custom");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = inst);\n        _issue.continue ?? (_issue.continue = true);\n        payload.issues.push(exports_util.issue(_issue));\n      }\n    };\n    const output = def.transform(payload.value, payload);\n    if (output instanceof Promise) {\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    payload.value = output;\n    return payload;\n  };\n});\nfunction transform(fn) {\n  return new ZodTransform({\n    type: "transform",\n    transform: fn\n  });\n}\nvar ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {\n  $ZodOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction optional(innerType) {\n  return new ZodOptional({\n    type: "optional",\n    innerType\n  });\n}\nvar ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {\n  $ZodNullable.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nullable(innerType) {\n  return new ZodNullable({\n    type: "nullable",\n    innerType\n  });\n}\nfunction nullish2(innerType) {\n  return optional(nullable(innerType));\n}\nvar ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {\n  $ZodDefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeDefault = inst.unwrap;\n});\nfunction _default2(innerType, defaultValue) {\n  return new ZodDefault({\n    type: "default",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === "function" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {\n  $ZodPrefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction prefault(innerType, defaultValue) {\n  return new ZodPrefault({\n    type: "prefault",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === "function" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {\n  $ZodNonOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nonoptional(innerType, params) {\n  return new ZodNonOptional({\n    type: "nonoptional",\n    innerType,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {\n  $ZodSuccess.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction success(innerType) {\n  return new ZodSuccess({\n    type: "success",\n    innerType\n  });\n}\nvar ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {\n  $ZodCatch.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeCatch = inst.unwrap;\n});\nfunction _catch2(innerType, catchValue) {\n  return new ZodCatch({\n    type: "catch",\n    innerType,\n    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue\n  });\n}\nvar ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {\n  $ZodNaN.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction nan(params) {\n  return _nan(ZodNaN, params);\n}\nvar ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {\n  $ZodPipe.init(inst, def);\n  ZodType.init(inst, def);\n  inst.in = def.in;\n  inst.out = def.out;\n});\nfunction pipe(in_, out) {\n  return new ZodPipe({\n    type: "pipe",\n    in: in_,\n    out\n  });\n}\nvar ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {\n  $ZodReadonly.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction readonly(innerType) {\n  return new ZodReadonly({\n    type: "readonly",\n    innerType\n  });\n}\nvar ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {\n  $ZodTemplateLiteral.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction templateLiteral(parts, params) {\n  return new ZodTemplateLiteral({\n    type: "template_literal",\n    parts,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {\n  $ZodLazy.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.getter();\n});\nfunction lazy(getter) {\n  return new ZodLazy({\n    type: "lazy",\n    getter\n  });\n}\nvar ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {\n  $ZodPromise.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction promise(innerType) {\n  return new ZodPromise({\n    type: "promise",\n    innerType\n  });\n}\nvar ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {\n  $ZodCustom.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction check(fn, params) {\n  const ch = new $ZodCheck({\n    check: "custom",\n    ...exports_util.normalizeParams(params)\n  });\n  ch._zod.check = fn;\n  return ch;\n}\nfunction custom(fn, _params) {\n  return _custom(ZodCustom, fn ?? (() => true), _params);\n}\nfunction refine(fn, _params = {}) {\n  return _refine(ZodCustom, fn, _params);\n}\nfunction superRefine(fn, params) {\n  const ch = check((payload) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === "string") {\n        payload.issues.push(exports_util.issue(issue2, payload.value, ch._zod.def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = "custom");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = ch);\n        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);\n        payload.issues.push(exports_util.issue(_issue));\n      }\n    };\n    return fn(payload.value, payload);\n  }, params);\n  return ch;\n}\nfunction _instanceof(cls, params = {\n  error: `Input not instance of ${cls.name}`\n}) {\n  const inst = new ZodCustom({\n    type: "custom",\n    check: "custom",\n    fn: (data) => data instanceof cls,\n    abort: true,\n    ...exports_util.normalizeParams(params)\n  });\n  inst._zod.bag.Class = cls;\n  return inst;\n}\nvar stringbool = (...args) => _stringbool({\n  Pipe: ZodPipe,\n  Boolean: ZodBoolean,\n  Unknown: ZodUnknown\n}, ...args);\nfunction json(params) {\n  const jsonSchema = lazy(() => {\n    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);\n  });\n  return jsonSchema;\n}\nfunction preprocess(fn, schema) {\n  return pipe(transform(fn), schema);\n}\n// ../../node_modules/zod/dist/esm/v4/classic/compat.js\nvar ZodIssueCode = {\n  invalid_type: "invalid_type",\n  too_big: "too_big",\n  too_small: "too_small",\n  invalid_format: "invalid_format",\n  not_multiple_of: "not_multiple_of",\n  unrecognized_keys: "unrecognized_keys",\n  invalid_union: "invalid_union",\n  invalid_key: "invalid_key",\n  invalid_element: "invalid_element",\n  invalid_value: "invalid_value",\n  custom: "custom"\n};\nvar INVALID = Object.freeze({\n  status: "aborted"\n});\nvar NEVER = INVALID;\nfunction setErrorMap(map2) {\n  config({\n    customError: map2\n  });\n}\nfunction getErrorMap() {\n  return config().customError;\n}\n// ../../node_modules/zod/dist/esm/v4/classic/coerce.js\nvar exports_coerce = {};\n__export(exports_coerce, {\n  string: () => string3,\n  number: () => number3,\n  date: () => date4,\n  boolean: () => boolean3,\n  bigint: () => bigint3\n});\nfunction string3(params) {\n  return _coercedString(ZodString, params);\n}\nfunction number3(params) {\n  return _coercedNumber(ZodNumber, params);\n}\nfunction boolean3(params) {\n  return _coercedBoolean(ZodBoolean, params);\n}\nfunction bigint3(params) {\n  return _coercedBigint(ZodBigInt, params);\n}\nfunction date4(params) {\n  return _coercedDate(ZodDate, params);\n}\n\n// ../../node_modules/zod/dist/esm/v4/classic/external.js\nconfig(en_default());\n// ../../node_modules/zod/dist/esm/v4/classic/index.js\nvar classic_default = exports_external;\n\n// ../../node_modules/zod/dist/esm/v4/index.js\nvar v4_default = classic_default;\n\n// ../../node_modules/zod/dist/esm/v3/helpers/util.js\nvar util;\n(function(util2) {\n  util2.assertEqual = (_3) => {};\n  function assertIs2(_arg) {}\n  util2.assertIs = assertIs2;\n  function assertNever2(_x) {\n    throw new Error;\n  }\n  util2.assertNever = assertNever2;\n  util2.arrayToEnum = (items) => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util2.getValidEnumValues = (obj) => {\n    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");\n    const filtered = {};\n    for (const k2 of validKeys) {\n      filtered[k2] = obj[k2];\n    }\n    return util2.objectValues(filtered);\n  };\n  util2.objectValues = (obj) => {\n    return util2.objectKeys(obj).map(function(e2) {\n      return obj[e2];\n    });\n  };\n  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {\n    const keys = [];\n    for (const key in object2) {\n      if (Object.prototype.hasOwnProperty.call(object2, key)) {\n        keys.push(key);\n      }\n    }\n    return keys;\n  };\n  util2.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item))\n        return item;\n    }\n    return;\n  };\n  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;\n  function joinValues2(array2, separator = " | ") {\n    return array2.map((val) => typeof val === "string" ? `\'${val}\'` : val).join(separator);\n  }\n  util2.joinValues = joinValues2;\n  util2.jsonStringifyReplacer = (_3, value) => {\n    if (typeof value === "bigint") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\n  "string",\n  "nan",\n  "number",\n  "integer",\n  "float",\n  "boolean",\n  "date",\n  "bigint",\n  "symbol",\n  "function",\n  "undefined",\n  "null",\n  "array",\n  "object",\n  "unknown",\n  "promise",\n  "void",\n  "never",\n  "map",\n  "set"\n]);\nvar getParsedType2 = (data) => {\n  const t2 = typeof data;\n  switch (t2) {\n    case "undefined":\n      return ZodParsedType.undefined;\n    case "string":\n      return ZodParsedType.string;\n    case "number":\n      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case "boolean":\n      return ZodParsedType.boolean;\n    case "function":\n      return ZodParsedType.function;\n    case "bigint":\n      return ZodParsedType.bigint;\n    case "symbol":\n      return ZodParsedType.symbol;\n    case "object":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== "undefined" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== "undefined" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== "undefined" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};\n\n// ../../node_modules/zod/dist/esm/v3/ZodError.js\nvar ZodIssueCode2 = util.arrayToEnum([\n  "invalid_type",\n  "invalid_literal",\n  "custom",\n  "invalid_union",\n  "invalid_union_discriminator",\n  "invalid_enum_value",\n  "unrecognized_keys",\n  "invalid_arguments",\n  "invalid_return_type",\n  "invalid_date",\n  "invalid_string",\n  "too_small",\n  "too_big",\n  "invalid_intersection_types",\n  "not_multiple_of",\n  "not_finite"\n]);\nclass ZodError2 extends Error {\n  get errors() {\n    return this.issues;\n  }\n  constructor(issues) {\n    super();\n    this.issues = [];\n    this.addIssue = (sub) => {\n      this.issues = [...this.issues, sub];\n    };\n    this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.name = "ZodError";\n    this.issues = issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function(issue2) {\n      return issue2.message;\n    };\n    const fieldErrors = { _errors: [] };\n    const processError = (error38) => {\n      for (const issue2 of error38.issues) {\n        if (issue2.code === "invalid_union") {\n          issue2.unionErrors.map(processError);\n        } else if (issue2.code === "invalid_return_type") {\n          processError(issue2.returnTypeError);\n        } else if (issue2.code === "invalid_arguments") {\n          processError(issue2.argumentsError);\n        } else if (issue2.path.length === 0) {\n          fieldErrors._errors.push(mapper(issue2));\n        } else {\n          let curr = fieldErrors;\n          let i2 = 0;\n          while (i2 < issue2.path.length) {\n            const el = issue2.path[i2];\n            const terminal = i2 === issue2.path.length - 1;\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue2));\n            }\n            curr = curr[el];\n            i2++;\n          }\n        }\n      }\n    };\n    processError(this);\n    return fieldErrors;\n  }\n  static assert(value) {\n    if (!(value instanceof ZodError2)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = (issue2) => issue2.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n        fieldErrors[sub.path[0]].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n}\nZodError2.create = (issues) => {\n  const error38 = new ZodError2(issues);\n  return error38;\n};\n\n// ../../node_modules/zod/dist/esm/v3/locales/en.js\nvar errorMap = (issue2, _ctx) => {\n  let message;\n  switch (issue2.code) {\n    case ZodIssueCode2.invalid_type:\n      if (issue2.received === ZodParsedType.undefined) {\n        message = "Required";\n      } else {\n        message = `Expected ${issue2.expected}, received ${issue2.received}`;\n      }\n      break;\n    case ZodIssueCode2.invalid_literal:\n      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode2.unrecognized_keys:\n      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;\n      break;\n    case ZodIssueCode2.invalid_union:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode2.invalid_union_discriminator:\n      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;\n      break;\n    case ZodIssueCode2.invalid_enum_value:\n      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received \'${issue2.received}\'`;\n      break;\n    case ZodIssueCode2.invalid_arguments:\n      message = `Invalid function arguments`;\n      break;\n    case ZodIssueCode2.invalid_return_type:\n      message = `Invalid function return type`;\n      break;\n    case ZodIssueCode2.invalid_date:\n      message = `Invalid date`;\n      break;\n    case ZodIssueCode2.invalid_string:\n      if (typeof issue2.validation === "object") {\n        if ("includes" in issue2.validation) {\n          message = `Invalid input: must include "${issue2.validation.includes}"`;\n          if (typeof issue2.validation.position === "number") {\n            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;\n          }\n        } else if ("startsWith" in issue2.validation) {\n          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;\n        } else if ("endsWith" in issue2.validation) {\n          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;\n        } else {\n          util.assertNever(issue2.validation);\n        }\n      } else if (issue2.validation !== "regex") {\n        message = `Invalid ${issue2.validation}`;\n      } else {\n        message = "Invalid";\n      }\n      break;\n    case ZodIssueCode2.too_small:\n      if (issue2.type === "array")\n        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;\n      else if (issue2.type === "string")\n        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;\n      else if (issue2.type === "number")\n        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;\n      else if (issue2.type === "date")\n        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;\n      else\n        message = "Invalid input";\n      break;\n    case ZodIssueCode2.too_big:\n      if (issue2.type === "array")\n        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;\n      else if (issue2.type === "string")\n        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;\n      else if (issue2.type === "number")\n        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;\n      else if (issue2.type === "bigint")\n        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;\n      else if (issue2.type === "date")\n        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;\n      else\n        message = "Invalid input";\n      break;\n    case ZodIssueCode2.custom:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode2.invalid_intersection_types:\n      message = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode2.not_multiple_of:\n      message = `Number must be a multiple of ${issue2.multipleOf}`;\n      break;\n    case ZodIssueCode2.not_finite:\n      message = "Number must be finite";\n      break;\n    default:\n      message = _ctx.defaultError;\n      util.assertNever(issue2);\n  }\n  return { message };\n};\nvar en_default2 = errorMap;\n\n// ../../node_modules/zod/dist/esm/v3/errors.js\nvar overrideErrorMap = en_default2;\nfunction getErrorMap2() {\n  return overrideErrorMap;\n}\n\n// ../../node_modules/zod/dist/esm/v3/helpers/parseUtil.js\nvar makeIssue = (params) => {\n  const { data, path, errorMaps, issueData } = params;\n  const fullPath = [...path, ...issueData.path || []];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  if (issueData.message !== undefined) {\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message\n    };\n  }\n  let errorMessage = "";\n  const maps = errorMaps.filter((m3) => !!m3).slice().reverse();\n  for (const map2 of maps) {\n    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage\n  };\n};\nfunction addIssueToContext(ctx, issueData) {\n  const overrideMap = getErrorMap2();\n  const issue2 = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      ctx.schemaErrorMap,\n      overrideMap,\n      overrideMap === en_default2 ? undefined : en_default2\n    ].filter((x2) => !!x2)\n  });\n  ctx.common.issues.push(issue2);\n}\n\nclass ParseStatus {\n  constructor() {\n    this.value = "valid";\n  }\n  dirty() {\n    if (this.value === "valid")\n      this.value = "dirty";\n  }\n  abort() {\n    if (this.value !== "aborted")\n      this.value = "aborted";\n  }\n  static mergeArray(status, results) {\n    const arrayValue = [];\n    for (const s2 of results) {\n      if (s2.status === "aborted")\n        return INVALID2;\n      if (s2.status === "dirty")\n        status.dirty();\n      arrayValue.push(s2.value);\n    }\n    return { status: status.value, value: arrayValue };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value\n      });\n    }\n    return ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === "aborted")\n        return INVALID2;\n      if (value.status === "aborted")\n        return INVALID2;\n      if (key.status === "dirty")\n        status.dirty();\n      if (value.status === "dirty")\n        status.dirty();\n      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return { status: status.value, value: finalObject };\n  }\n}\nvar INVALID2 = Object.freeze({\n  status: "aborted"\n});\nvar DIRTY = (value) => ({ status: "dirty", value });\nvar OK = (value) => ({ status: "valid", value });\nvar isAborted = (x2) => x2.status === "aborted";\nvar isDirty = (x2) => x2.status === "dirty";\nvar isValid = (x2) => x2.status === "valid";\nvar isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;\n\n// ../../node_modules/zod/dist/esm/v3/helpers/errorUtil.js\nvar errorUtil;\n(function(errorUtil2) {\n  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};\n  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n\n// ../../node_modules/zod/dist/esm/v3/types.js\nclass ParseInputLazyPath {\n  constructor(parent, value, path, key) {\n    this._cachedPath = [];\n    this.parent = parent;\n    this.data = value;\n    this._path = path;\n    this._key = key;\n  }\n  get path() {\n    if (!this._cachedPath.length) {\n      if (Array.isArray(this._key)) {\n        this._cachedPath.push(...this._path, ...this._key);\n      } else {\n        this._cachedPath.push(...this._path, this._key);\n      }\n    }\n    return this._cachedPath;\n  }\n}\nvar handleResult = (ctx, result) => {\n  if (isValid(result)) {\n    return { success: true, data: result.value };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error("Validation failed but no issues detected.");\n    }\n    return {\n      success: false,\n      get error() {\n        if (this._error)\n          return this._error;\n        const error38 = new ZodError2(ctx.common.issues);\n        this._error = error38;\n        return this._error;\n      }\n    };\n  }\n};\nfunction processCreateParams(params) {\n  if (!params)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = (iss, ctx) => {\n    const { message } = params;\n    if (iss.code === "invalid_enum_value") {\n      return { message: message ?? ctx.defaultError };\n    }\n    if (typeof ctx.data === "undefined") {\n      return { message: message ?? required_error ?? ctx.defaultError };\n    }\n    if (iss.code !== "invalid_type")\n      return { message: ctx.defaultError };\n    return { message: message ?? invalid_type_error ?? ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\n\nclass ZodType2 {\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType2(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType2(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus,\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType2(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error("Synchronous parse encountered promise.");\n    }\n    return result;\n  }\n  _parseAsync(input) {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n  parse(data, params) {\n    const result = this.safeParse(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  safeParse(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: params?.async ?? false,\n        contextualErrorMap: params?.errorMap\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType2(data)\n    };\n    const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n    return handleResult(ctx, result);\n  }\n  "~validate"(data) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: !!this["~standard"].async\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType2(data)\n    };\n    if (!this["~standard"].async) {\n      try {\n        const result = this._parseSync({ data, path: [], parent: ctx });\n        return isValid(result) ? {\n          value: result.value\n        } : {\n          issues: ctx.common.issues\n        };\n      } catch (err) {\n        if (err?.message?.toLowerCase()?.includes("encountered")) {\n          this["~standard"].async = true;\n        }\n        ctx.common = {\n          issues: [],\n          async: true\n        };\n      }\n    }\n    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {\n      value: result.value\n    } : {\n      issues: ctx.common.issues\n    });\n  }\n  async parseAsync(data, params) {\n    const result = await this.safeParseAsync(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  async safeParseAsync(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params?.errorMap,\n        async: true\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType2(data)\n    };\n    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n  refine(check2, message) {\n    const getIssueProperties = (val) => {\n      if (typeof message === "string" || typeof message === "undefined") {\n        return { message };\n      } else if (typeof message === "function") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check2(val);\n      const setError = () => ctx.addIssue({\n        code: ZodIssueCode2.custom,\n        ...getIssueProperties(val)\n      });\n      if (typeof Promise !== "undefined" && result instanceof Promise) {\n        return result.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  refinement(check2, refinementData) {\n    return this._refinement((val, ctx) => {\n      if (!check2(val)) {\n        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: "refinement", refinement }\n    });\n  }\n  superRefine(refinement) {\n    return this._refinement(refinement);\n  }\n  constructor(def) {\n    this.spa = this.safeParseAsync;\n    this._def = def;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.brand = this.brand.bind(this);\n    this.default = this.default.bind(this);\n    this.catch = this.catch.bind(this);\n    this.describe = this.describe.bind(this);\n    this.pipe = this.pipe.bind(this);\n    this.readonly = this.readonly.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n    this["~standard"] = {\n      version: 1,\n      vendor: "zod",\n      validate: (data) => this["~validate"](data)\n    };\n  }\n  optional() {\n    return ZodOptional2.create(this, this._def);\n  }\n  nullable() {\n    return ZodNullable2.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return ZodArray2.create(this);\n  }\n  promise() {\n    return ZodPromise2.create(this, this._def);\n  }\n  or(option) {\n    return ZodUnion2.create([this, option], this._def);\n  }\n  and(incoming) {\n    return ZodIntersection2.create(this, incoming, this._def);\n  }\n  transform(transform2) {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: "transform", transform: transform2 }\n    });\n  }\n  default(def) {\n    const defaultValueFunc = typeof def === "function" ? def : () => def;\n    return new ZodDefault2({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def)\n    });\n  }\n  catch(def) {\n    const catchValueFunc = typeof def === "function" ? def : () => def;\n    return new ZodCatch2({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  pipe(target) {\n    return ZodPipeline.create(this, target);\n  }\n  readonly() {\n    return ZodReadonly2.create(this);\n  }\n  isOptional() {\n    return this.safeParse(undefined).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n}\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar cuid2Regex = /^[0-9a-z]+$/;\nvar ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\nvar uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar nanoidRegex = /^[a-z0-9_-]{21}$/i;\nvar jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nvar durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_\'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nvar emojiRegex;\nvar ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\nvar ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nvar ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\nvar base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\nvar base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\nvar dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nvar dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n  let secondsRegexSource = `[0-5]\\\\d`;\n  if (args.precision) {\n    secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n  }\n  const secondsQuantifier = args.precision ? "+" : "?";\n  return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n  return new RegExp(`^${timeRegexSource(args)}$`);\n}\nfunction datetimeRegex(args) {\n  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n  const opts = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset)\n    opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join("|")})`;\n  return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version2) {\n  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nfunction isValidJWT2(jwt2, alg) {\n  if (!jwtRegex.test(jwt2))\n    return false;\n  try {\n    const [header] = jwt2.split(".");\n    const base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");\n    const decoded = JSON.parse(atob(base643));\n    if (typeof decoded !== "object" || decoded === null)\n      return false;\n    if ("typ" in decoded && decoded?.typ !== "JWT")\n      return false;\n    if (!decoded.alg)\n      return false;\n    if (alg && decoded.alg !== alg)\n      return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction isValidCidr(ip, version2) {\n  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {\n    return true;\n  }\n  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {\n    return true;\n  }\n  return false;\n}\n\nclass ZodString2 extends ZodType2 {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx2.parsedType\n      });\n      return INVALID2;\n    }\n    const status = new ParseStatus;\n    let ctx = undefined;\n    for (const check2 of this._def.checks) {\n      if (check2.kind === "min") {\n        if (input.data.length < check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_small,\n            minimum: check2.value,\n            type: "string",\n            inclusive: true,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "max") {\n        if (input.data.length > check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_big,\n            maximum: check2.value,\n            type: "string",\n            inclusive: true,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "length") {\n        const tooBig = input.data.length > check2.value;\n        const tooSmall = input.data.length < check2.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode2.too_big,\n              maximum: check2.value,\n              type: "string",\n              inclusive: true,\n              exact: true,\n              message: check2.message\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode2.too_small,\n              minimum: check2.value,\n              type: "string",\n              inclusive: true,\n              exact: true,\n              message: check2.message\n            });\n          }\n          status.dirty();\n        }\n      } else if (check2.kind === "email") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "email",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "emoji") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, "u");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "emoji",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "uuid") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "uuid",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "nanoid") {\n        if (!nanoidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "nanoid",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "cuid") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "cuid",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "cuid2") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "cuid2",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "ulid") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "ulid",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "url") {\n        try {\n          new URL(input.data);\n        } catch {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "url",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "regex") {\n        check2.regex.lastIndex = 0;\n        const testResult = check2.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "regex",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "trim") {\n        input.data = input.data.trim();\n      } else if (check2.kind === "includes") {\n        if (!input.data.includes(check2.value, check2.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: { includes: check2.value, position: check2.position },\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "toLowerCase") {\n        input.data = input.data.toLowerCase();\n      } else if (check2.kind === "toUpperCase") {\n        input.data = input.data.toUpperCase();\n      } else if (check2.kind === "startsWith") {\n        if (!input.data.startsWith(check2.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: { startsWith: check2.value },\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "endsWith") {\n        if (!input.data.endsWith(check2.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: { endsWith: check2.value },\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "datetime") {\n        const regex = datetimeRegex(check2);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: "datetime",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "date") {\n        const regex = dateRegex;\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: "date",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "time") {\n        const regex = timeRegex(check2);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: "time",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "duration") {\n        if (!durationRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "duration",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "ip") {\n        if (!isValidIP(input.data, check2.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "ip",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "jwt") {\n        if (!isValidJWT2(input.data, check2.alg)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "jwt",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "cidr") {\n        if (!isValidCidr(input.data, check2.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "cidr",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "base64") {\n        if (!base64Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "base64",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "base64url") {\n        if (!base64urlRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "base64url",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _regex(regex, validation, message) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode2.invalid_string,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  _addCheck(check2) {\n    return new ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  email(message) {\n    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });\n  }\n  url(message) {\n    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });\n  }\n  emoji(message) {\n    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });\n  }\n  uuid(message) {\n    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });\n  }\n  nanoid(message) {\n    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });\n  }\n  cuid(message) {\n    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });\n  }\n  cuid2(message) {\n    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });\n  }\n  ulid(message) {\n    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });\n  }\n  base64(message) {\n    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });\n  }\n  base64url(message) {\n    return this._addCheck({\n      kind: "base64url",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  jwt(options) {\n    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });\n  }\n  ip(options) {\n    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });\n  }\n  cidr(options) {\n    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });\n  }\n  datetime(options) {\n    if (typeof options === "string") {\n      return this._addCheck({\n        kind: "datetime",\n        precision: null,\n        offset: false,\n        local: false,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: "datetime",\n      precision: typeof options?.precision === "undefined" ? null : options?.precision,\n      offset: options?.offset ?? false,\n      local: options?.local ?? false,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  date(message) {\n    return this._addCheck({ kind: "date", message });\n  }\n  time(options) {\n    if (typeof options === "string") {\n      return this._addCheck({\n        kind: "time",\n        precision: null,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: "time",\n      precision: typeof options?.precision === "undefined" ? null : options?.precision,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  duration(message) {\n    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });\n  }\n  regex(regex, message) {\n    return this._addCheck({\n      kind: "regex",\n      regex,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  includes(value, options) {\n    return this._addCheck({\n      kind: "includes",\n      value,\n      position: options?.position,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  startsWith(value, message) {\n    return this._addCheck({\n      kind: "startsWith",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  endsWith(value, message) {\n    return this._addCheck({\n      kind: "endsWith",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  min(minLength, message) {\n    return this._addCheck({\n      kind: "min",\n      value: minLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  max(maxLength, message) {\n    return this._addCheck({\n      kind: "max",\n      value: maxLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  length(len, message) {\n    return this._addCheck({\n      kind: "length",\n      value: len,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  nonempty(message) {\n    return this.min(1, errorUtil.errToObj(message));\n  }\n  trim() {\n    return new ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, { kind: "trim" }]\n    });\n  }\n  toLowerCase() {\n    return new ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, { kind: "toLowerCase" }]\n    });\n  }\n  toUpperCase() {\n    return new ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, { kind: "toUpperCase" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((ch) => ch.kind === "datetime");\n  }\n  get isDate() {\n    return !!this._def.checks.find((ch) => ch.kind === "date");\n  }\n  get isTime() {\n    return !!this._def.checks.find((ch) => ch.kind === "time");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((ch) => ch.kind === "duration");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === "email");\n  }\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === "url");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((ch) => ch.kind === "emoji");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === "uuid");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((ch) => ch.kind === "nanoid");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === "cuid");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((ch) => ch.kind === "cuid2");\n  }\n  get isULID() {\n    return !!this._def.checks.find((ch) => ch.kind === "ulid");\n  }\n  get isIP() {\n    return !!this._def.checks.find((ch) => ch.kind === "ip");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find((ch) => ch.kind === "cidr");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((ch) => ch.kind === "base64");\n  }\n  get isBase64url() {\n    return !!this._def.checks.find((ch) => ch.kind === "base64url");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxLength() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n}\nZodString2.create = (params) => {\n  return new ZodString2({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodString,\n    coerce: params?.coerce ?? false,\n    ...processCreateParams(params)\n  });\n};\nfunction floatSafeRemainder2(val, step) {\n  const valDecCount = (val.toString().split(".")[1] || "").length;\n  const stepDecCount = (step.toString().split(".")[1] || "").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));\n  return valInt % stepInt / 10 ** decCount;\n}\n\nclass ZodNumber2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n    this.step = this.multipleOf;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      });\n      return INVALID2;\n    }\n    let ctx = undefined;\n    const status = new ParseStatus;\n    for (const check2 of this._def.checks) {\n      if (check2.kind === "int") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_type,\n            expected: "integer",\n            received: "float",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "min") {\n        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_small,\n            minimum: check2.value,\n            type: "number",\n            inclusive: check2.inclusive,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "max") {\n        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_big,\n            maximum: check2.value,\n            type: "number",\n            inclusive: check2.inclusive,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "multipleOf") {\n        if (floatSafeRemainder2(input.data, check2.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.not_multiple_of,\n            multipleOf: check2.value,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "finite") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.not_finite,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message) {\n    return this.setLimit("min", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit("min", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit("max", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit("max", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new ZodNumber2({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check2) {\n    return new ZodNumber2({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  int(message) {\n    return this._addCheck({\n      kind: "int",\n      message: errorUtil.toString(message)\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: "min",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: "max",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: "max",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: "min",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: "multipleOf",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  finite(message) {\n    return this._addCheck({\n      kind: "finite",\n      message: errorUtil.toString(message)\n    });\n  }\n  safe(message) {\n    return this._addCheck({\n      kind: "min",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    })._addCheck({\n      kind: "max",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));\n  }\n  get isFinite() {\n    let max = null;\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {\n        return true;\n      } else if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      } else if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return Number.isFinite(min) && Number.isFinite(max);\n  }\n}\nZodNumber2.create = (params) => {\n  return new ZodNumber2({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodNumber,\n    coerce: params?.coerce || false,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodBigInt2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      try {\n        input.data = BigInt(input.data);\n      } catch {\n        return this._getInvalidInput(input);\n      }\n    }\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.bigint) {\n      return this._getInvalidInput(input);\n    }\n    let ctx = undefined;\n    const status = new ParseStatus;\n    for (const check2 of this._def.checks) {\n      if (check2.kind === "min") {\n        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_small,\n            type: "bigint",\n            minimum: check2.value,\n            inclusive: check2.inclusive,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "max") {\n        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_big,\n            type: "bigint",\n            maximum: check2.value,\n            inclusive: check2.inclusive,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "multipleOf") {\n        if (input.data % check2.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.not_multiple_of,\n            multipleOf: check2.value,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _getInvalidInput(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode2.invalid_type,\n      expected: ZodParsedType.bigint,\n      received: ctx.parsedType\n    });\n    return INVALID2;\n  }\n  gte(value, message) {\n    return this.setLimit("min", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit("min", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit("max", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit("max", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new ZodBigInt2({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check2) {\n    return new ZodBigInt2({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: "min",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: "max",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: "max",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: "min",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: "multipleOf",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n}\nZodBigInt2.create = (params) => {\n  return new ZodBigInt2({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodBigInt,\n    coerce: params?.coerce ?? false,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodBoolean2 extends ZodType2 {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    return OK(input.data);\n  }\n}\nZodBoolean2.create = (params) => {\n  return new ZodBoolean2({\n    typeName: ZodFirstPartyTypeKind.ZodBoolean,\n    coerce: params?.coerce || false,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodDate2 extends ZodType2 {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      });\n      return INVALID2;\n    }\n    if (Number.isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode2.invalid_date\n      });\n      return INVALID2;\n    }\n    const status = new ParseStatus;\n    let ctx = undefined;\n    for (const check2 of this._def.checks) {\n      if (check2.kind === "min") {\n        if (input.data.getTime() < check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_small,\n            message: check2.message,\n            inclusive: true,\n            exact: false,\n            minimum: check2.value,\n            type: "date"\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "max") {\n        if (input.data.getTime() > check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_big,\n            message: check2.message,\n            inclusive: true,\n            exact: false,\n            maximum: check2.value,\n            type: "date"\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check2) {\n    return new ZodDate2({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  min(minDate, message) {\n    return this._addCheck({\n      kind: "min",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  max(maxDate, message) {\n    return this._addCheck({\n      kind: "max",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max != null ? new Date(max) : null;\n  }\n}\nZodDate2.create = (params) => {\n  return new ZodDate2({\n    checks: [],\n    coerce: params?.coerce || false,\n    typeName: ZodFirstPartyTypeKind.ZodDate,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodSymbol2 extends ZodType2 {\n  _parse(input) {\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    return OK(input.data);\n  }\n}\nZodSymbol2.create = (params) => {\n  return new ZodSymbol2({\n    typeName: ZodFirstPartyTypeKind.ZodSymbol,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodUndefined2 extends ZodType2 {\n  _parse(input) {\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    return OK(input.data);\n  }\n}\nZodUndefined2.create = (params) => {\n  return new ZodUndefined2({\n    typeName: ZodFirstPartyTypeKind.ZodUndefined,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNull2 extends ZodType2 {\n  _parse(input) {\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    return OK(input.data);\n  }\n}\nZodNull2.create = (params) => {\n  return new ZodNull2({\n    typeName: ZodFirstPartyTypeKind.ZodNull,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodAny2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this._any = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n}\nZodAny2.create = (params) => {\n  return new ZodAny2({\n    typeName: ZodFirstPartyTypeKind.ZodAny,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodUnknown2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this._unknown = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n}\nZodUnknown2.create = (params) => {\n  return new ZodUnknown2({\n    typeName: ZodFirstPartyTypeKind.ZodUnknown,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNever2 extends ZodType2 {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode2.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    });\n    return INVALID2;\n  }\n}\nZodNever2.create = (params) => {\n  return new ZodNever2({\n    typeName: ZodFirstPartyTypeKind.ZodNever,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodVoid2 extends ZodType2 {\n  _parse(input) {\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    return OK(input.data);\n  }\n}\nZodVoid2.create = (params) => {\n  return new ZodVoid2({\n    typeName: ZodFirstPartyTypeKind.ZodVoid,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodArray2 extends ZodType2 {\n  _parse(input) {\n    const { ctx, status } = this._processInputParams(input);\n    const def = this._def;\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,\n          minimum: tooSmall ? def.exactLength.value : undefined,\n          maximum: tooBig ? def.exactLength.value : undefined,\n          type: "array",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode2.too_small,\n          minimum: def.minLength.value,\n          type: "array",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode2.too_big,\n          maximum: def.maxLength.value,\n          type: "array",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.all([...ctx.data].map((item, i2) => {\n        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));\n      })).then((result2) => {\n        return ParseStatus.mergeArray(status, result2);\n      });\n    }\n    const result = [...ctx.data].map((item, i2) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));\n    });\n    return ParseStatus.mergeArray(status, result);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message) {\n    return new ZodArray2({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxLength, message) {\n    return new ZodArray2({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) }\n    });\n  }\n  length(len, message) {\n    return new ZodArray2({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message) }\n    });\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n}\nZodArray2.create = (schema, params) => {\n  return new ZodArray2({\n    type: schema,\n    minLength: null,\n    maxLength: null,\n    exactLength: null,\n    typeName: ZodFirstPartyTypeKind.ZodArray,\n    ...processCreateParams(params)\n  });\n};\nfunction deepPartialify(schema) {\n  if (schema instanceof ZodObject2) {\n    const newShape = {};\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional2.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject2({\n      ...schema._def,\n      shape: () => newShape\n    });\n  } else if (schema instanceof ZodArray2) {\n    return new ZodArray2({\n      ...schema._def,\n      type: deepPartialify(schema.element)\n    });\n  } else if (schema instanceof ZodOptional2) {\n    return ZodOptional2.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable2) {\n    return ZodNullable2.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple2) {\n    return ZodTuple2.create(schema.items.map((item) => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}\n\nclass ZodObject2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this._cached = null;\n    this.nonstrict = this.passthrough;\n    this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const shape = this._def.shape();\n    const keys = util.objectKeys(shape);\n    this._cached = { shape, keys };\n    return this._cached;\n  }\n  _parse(input) {\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      });\n      return INVALID2;\n    }\n    const { status, ctx } = this._processInputParams(input);\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key];\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: "valid", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever2) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === "passthrough") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: "valid", value: key },\n            value: { status: "valid", value: ctx.data[key] }\n          });\n        }\n      } else if (unknownKeys === "strict") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.unrecognized_keys,\n            keys: extraKeys\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === "strip") {} else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: "valid", value: key },\n          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.resolve().then(async () => {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          syncPairs.push({\n            key,\n            value,\n            alwaysSet: pair.alwaysSet\n          });\n        }\n        return syncPairs;\n      }).then((syncPairs) => {\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n      });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message) {\n    errorUtil.errToObj;\n    return new ZodObject2({\n      ...this._def,\n      unknownKeys: "strict",\n      ...message !== undefined ? {\n        errorMap: (issue2, ctx) => {\n          const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;\n          if (issue2.code === "unrecognized_keys")\n            return {\n              message: errorUtil.errToObj(message).message ?? defaultError\n            };\n          return {\n            message: defaultError\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new ZodObject2({\n      ...this._def,\n      unknownKeys: "strip"\n    });\n  }\n  passthrough() {\n    return new ZodObject2({\n      ...this._def,\n      unknownKeys: "passthrough"\n    });\n  }\n  extend(augmentation) {\n    return new ZodObject2({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation\n      })\n    });\n  }\n  merge(merging) {\n    const merged = new ZodObject2({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape()\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject\n    });\n    return merged;\n  }\n  setKey(key, schema) {\n    return this.augment({ [key]: schema });\n  }\n  catchall(index) {\n    return new ZodObject2({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(mask)) {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n    return new ZodObject2({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n    return new ZodObject2({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      const fieldSchema = this.shape[key];\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    }\n    return new ZodObject2({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n        while (newField instanceof ZodOptional2) {\n          newField = newField._def.innerType;\n        }\n        newShape[key] = newField;\n      }\n    }\n    return new ZodObject2({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n}\nZodObject2.create = (shape, params) => {\n  return new ZodObject2({\n    shape: () => shape,\n    unknownKeys: "strip",\n    catchall: ZodNever2.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject2.strictCreate = (shape, params) => {\n  return new ZodObject2({\n    shape: () => shape,\n    unknownKeys: "strict",\n    catchall: ZodNever2.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject2.lazycreate = (shape, params) => {\n  return new ZodObject2({\n    shape,\n    unknownKeys: "strip",\n    catchall: ZodNever2.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodUnion2 extends ZodType2 {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n    function handleResults(results) {\n      for (const result of results) {\n        if (result.result.status === "valid") {\n          return result.result;\n        }\n      }\n      for (const result of results) {\n        if (result.result.status === "dirty") {\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n      const unionErrors = results.map((result) => new ZodError2(result.ctx.common.issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_union,\n        unionErrors\n      });\n      return INVALID2;\n    }\n    if (ctx.common.async) {\n      return Promise.all(options.map(async (option) => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    } else {\n      let dirty = undefined;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result.status === "valid") {\n          return result;\n        } else if (result.status === "dirty" && !dirty) {\n          dirty = { result, ctx: childCtx };\n        }\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n      const unionErrors = issues.map((issues2) => new ZodError2(issues2));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_union,\n        unionErrors\n      });\n      return INVALID2;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n}\nZodUnion2.create = (types, params) => {\n  return new ZodUnion2({\n    options: types,\n    typeName: ZodFirstPartyTypeKind.ZodUnion,\n    ...processCreateParams(params)\n  });\n};\nvar getDiscriminator = (type) => {\n  if (type instanceof ZodLazy2) {\n    return getDiscriminator(type.schema);\n  } else if (type instanceof ZodEffects) {\n    return getDiscriminator(type.innerType());\n  } else if (type instanceof ZodLiteral2) {\n    return [type.value];\n  } else if (type instanceof ZodEnum2) {\n    return type.options;\n  } else if (type instanceof ZodNativeEnum) {\n    return util.objectValues(type.enum);\n  } else if (type instanceof ZodDefault2) {\n    return getDiscriminator(type._def.innerType);\n  } else if (type instanceof ZodUndefined2) {\n    return [undefined];\n  } else if (type instanceof ZodNull2) {\n    return [null];\n  } else if (type instanceof ZodOptional2) {\n    return [undefined, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodNullable2) {\n    return [null, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodBranded) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodReadonly2) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodCatch2) {\n    return getDiscriminator(type._def.innerType);\n  } else {\n    return [];\n  }\n};\n\nclass ZodDiscriminatedUnion2 extends ZodType2 {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    const discriminator = this.discriminator;\n    const discriminatorValue = ctx.data[discriminator];\n    const option = this.optionsMap.get(discriminatorValue);\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator]\n      });\n      return INVALID2;\n    }\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  static create(discriminator, options, params) {\n    const optionsMap = new Map;\n    for (const type of options) {\n      const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n      if (!discriminatorValues.length) {\n        throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n        optionsMap.set(value, type);\n      }\n    }\n    return new ZodDiscriminatedUnion2({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params)\n    });\n  }\n}\nfunction mergeValues2(a2, b2) {\n  const aType = getParsedType2(a2);\n  const bType = getParsedType2(b2);\n  if (a2 === b2) {\n    return { valid: true, data: a2 };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b2);\n    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a2, ...b2 };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues2(a2[key], b2[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a2.length !== b2.length) {\n      return { valid: false };\n    }\n    const newArray = [];\n    for (let index = 0;index < a2.length; index++) {\n      const itemA = a2[index];\n      const itemB = b2[index];\n      const sharedValue = mergeValues2(itemA, itemB);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {\n    return { valid: true, data: a2 };\n  } else {\n    return { valid: false };\n  }\n}\n\nclass ZodIntersection2 extends ZodType2 {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID2;\n      }\n      const merged = mergeValues2(parsedLeft.value, parsedRight.value);\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode2.invalid_intersection_types\n        });\n        return INVALID2;\n      }\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n      return { status: status.value, value: merged.data };\n    };\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        })\n      ]).then(([left, right]) => handleParsed(left, right));\n    } else {\n      return handleParsed(this._def.left._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }));\n    }\n  }\n}\nZodIntersection2.create = (left, right, params) => {\n  return new ZodIntersection2({\n    left,\n    right,\n    typeName: ZodFirstPartyTypeKind.ZodIntersection,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodTuple2 extends ZodType2 {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: "array"\n      });\n      return INVALID2;\n    }\n    const rest = this._def.rest;\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: "array"\n      });\n      status.dirty();\n    }\n    const items = [...ctx.data].map((item, itemIndex) => {\n      const schema = this._def.items[itemIndex] || this._def.rest;\n      if (!schema)\n        return null;\n      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n    }).filter((x2) => !!x2);\n    if (ctx.common.async) {\n      return Promise.all(items).then((results) => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items);\n    }\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new ZodTuple2({\n      ...this._def,\n      rest\n    });\n  }\n}\nZodTuple2.create = (schemas3, params) => {\n  if (!Array.isArray(schemas3)) {\n    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");\n  }\n  return new ZodTuple2({\n    items: schemas3,\n    typeName: ZodFirstPartyTypeKind.ZodTuple,\n    rest: null,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodRecord2 extends ZodType2 {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    const pairs = [];\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    if (second instanceof ZodType2) {\n      return new ZodRecord2({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third)\n      });\n    }\n    return new ZodRecord2({\n      keyType: ZodString2.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n}\n\nclass ZodMap2 extends ZodType2 {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))\n      };\n    });\n    if (ctx.common.async) {\n      const finalMap = new Map;\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === "aborted" || value.status === "aborted") {\n            return INVALID2;\n          }\n          if (key.status === "dirty" || value.status === "dirty") {\n            status.dirty();\n          }\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = new Map;\n      for (const pair of pairs) {\n        const key = pair.key;\n        const value = pair.value;\n        if (key.status === "aborted" || value.status === "aborted") {\n          return INVALID2;\n        }\n        if (key.status === "dirty" || value.status === "dirty") {\n          status.dirty();\n        }\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n}\nZodMap2.create = (keyType, valueType, params) => {\n  return new ZodMap2({\n    valueType,\n    keyType,\n    typeName: ZodFirstPartyTypeKind.ZodMap,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodSet2 extends ZodType2 {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    const def = this._def;\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode2.too_small,\n          minimum: def.minSize.value,\n          type: "set",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode2.too_big,\n          maximum: def.maxSize.value,\n          type: "set",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message\n        });\n        status.dirty();\n      }\n    }\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = new Set;\n      for (const element of elements2) {\n        if (element.status === "aborted")\n          return INVALID2;\n        if (element.status === "dirty")\n          status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements2) => finalizeSet(elements2));\n    } else {\n      return finalizeSet(elements);\n    }\n  }\n  min(minSize, message) {\n    return new ZodSet2({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxSize, message) {\n    return new ZodSet2({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) }\n    });\n  }\n  size(size, message) {\n    return this.min(size, message).max(size, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n}\nZodSet2.create = (valueType, params) => {\n  return new ZodSet2({\n    valueType,\n    minSize: null,\n    maxSize: null,\n    typeName: ZodFirstPartyTypeKind.ZodSet,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodFunction extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this.validate = this.implement;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    function makeArgsIssue(args, error38) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x2) => !!x2),\n        issueData: {\n          code: ZodIssueCode2.invalid_arguments,\n          argumentsError: error38\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error38) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x2) => !!x2),\n        issueData: {\n          code: ZodIssueCode2.invalid_return_type,\n          returnTypeError: error38\n        }\n      });\n    }\n    const params = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n    if (this._def.returns instanceof ZodPromise2) {\n      const me2 = this;\n      return OK(async function(...args) {\n        const error38 = new ZodError2([]);\n        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {\n          error38.addIssue(makeArgsIssue(args, e2));\n          throw error38;\n        });\n        const result = await Reflect.apply(fn, this, parsedArgs);\n        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {\n          error38.addIssue(makeReturnsIssue(result, e2));\n          throw error38;\n        });\n        return parsedReturns;\n      });\n    } else {\n      const me2 = this;\n      return OK(function(...args) {\n        const parsedArgs = me2._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError2([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = Reflect.apply(fn, this, parsedArgs.data);\n        const parsedReturns = me2._def.returns.safeParse(result, params);\n        if (!parsedReturns.success) {\n          throw new ZodError2([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new ZodFunction({\n      ...this._def,\n      args: ZodTuple2.create(items).rest(ZodUnknown2.create())\n    });\n  }\n  returns(returnType) {\n    return new ZodFunction({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  strictImplement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  static create(args, returns, params) {\n    return new ZodFunction({\n      args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),\n      returns: returns || ZodUnknown2.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params)\n    });\n  }\n}\n\nclass ZodLazy2 extends ZodType2 {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n}\nZodLazy2.create = (getter, params) => {\n  return new ZodLazy2({\n    getter,\n    typeName: ZodFirstPartyTypeKind.ZodLazy,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodLiteral2 extends ZodType2 {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode2.invalid_literal,\n        expected: this._def.value\n      });\n      return INVALID2;\n    }\n    return { status: "valid", value: input.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n}\nZodLiteral2.create = (value, params) => {\n  return new ZodLiteral2({\n    value,\n    typeName: ZodFirstPartyTypeKind.ZodLiteral,\n    ...processCreateParams(params)\n  });\n};\nfunction createZodEnum(values, params) {\n  return new ZodEnum2({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params)\n  });\n}\n\nclass ZodEnum2 extends ZodType2 {\n  _parse(input) {\n    if (typeof input.data !== "string") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode2.invalid_type\n      });\n      return INVALID2;\n    }\n    if (!this._cache) {\n      this._cache = new Set(this._def.values);\n    }\n    if (!this._cache.has(input.data)) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode2.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID2;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  extract(values, newDef = this._def) {\n    return ZodEnum2.create(values, {\n      ...this._def,\n      ...newDef\n    });\n  }\n  exclude(values, newDef = this._def) {\n    return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)), {\n      ...this._def,\n      ...newDef\n    });\n  }\n}\nZodEnum2.create = createZodEnum;\n\nclass ZodNativeEnum extends ZodType2 {\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode2.invalid_type\n      });\n      return INVALID2;\n    }\n    if (!this._cache) {\n      this._cache = new Set(util.getValidEnumValues(this._def.values));\n    }\n    if (!this._cache.has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode2.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID2;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n}\nZodNativeEnum.create = (values, params) => {\n  return new ZodNativeEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodPromise2 extends ZodType2 {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then((data) => {\n      return this._def.type.parseAsync(data, {\n        path: ctx.path,\n        errorMap: ctx.common.contextualErrorMap\n      });\n    }));\n  }\n}\nZodPromise2.create = (schema, params) => {\n  return new ZodPromise2({\n    type: schema,\n    typeName: ZodFirstPartyTypeKind.ZodPromise,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodEffects extends ZodType2 {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const effect = this._def.effect || null;\n    const checkCtx = {\n      addIssue: (arg) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n    if (effect.type === "preprocess") {\n      const processed = effect.transform(ctx.data, checkCtx);\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then(async (processed2) => {\n          if (status.value === "aborted")\n            return INVALID2;\n          const result = await this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n          if (result.status === "aborted")\n            return INVALID2;\n          if (result.status === "dirty")\n            return DIRTY(result.value);\n          if (status.value === "dirty")\n            return DIRTY(result.value);\n          return result;\n        });\n      } else {\n        if (status.value === "aborted")\n          return INVALID2;\n        const result = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (result.status === "aborted")\n          return INVALID2;\n        if (result.status === "dirty")\n          return DIRTY(result.value);\n        if (status.value === "dirty")\n          return DIRTY(result.value);\n        return result;\n      }\n    }\n    if (effect.type === "refinement") {\n      const executeRefinement = (acc) => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");\n        }\n        return acc;\n      };\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inner.status === "aborted")\n          return INVALID2;\n        if (inner.status === "dirty")\n          status.dirty();\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === "aborted")\n            return INVALID2;\n          if (inner.status === "dirty")\n            status.dirty();\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n    if (effect.type === "transform") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base))\n          return INVALID2;\n        const result = effect.transform(base.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n        }\n        return { status: status.value, value: result };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n          if (!isValid(base))\n            return INVALID2;\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n            status: status.value,\n            value: result\n          }));\n        });\n      }\n    }\n    util.assertNever(effect);\n  }\n}\nZodEffects.create = (schema, effect, params) => {\n  return new ZodEffects({\n    schema,\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    effect,\n    ...processCreateParams(params)\n  });\n};\nZodEffects.createWithPreprocess = (preprocess2, schema, params) => {\n  return new ZodEffects({\n    schema,\n    effect: { type: "preprocess", transform: preprocess2 },\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    ...processCreateParams(params)\n  });\n};\nclass ZodOptional2 extends ZodType2 {\n  _parse(input) {\n    const parsedType3 = this._getType(input);\n    if (parsedType3 === ZodParsedType.undefined) {\n      return OK(undefined);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nZodOptional2.create = (type, params) => {\n  return new ZodOptional2({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNullable2 extends ZodType2 {\n  _parse(input) {\n    const parsedType3 = this._getType(input);\n    if (parsedType3 === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nZodNullable2.create = (type, params) => {\n  return new ZodNullable2({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodNullable,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodDefault2 extends ZodType2 {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n}\nZodDefault2.create = (type, params) => {\n  return new ZodDefault2({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodDefault,\n    defaultValue: typeof params.default === "function" ? params.default : () => params.default,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodCatch2 extends ZodType2 {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const newCtx = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: []\n      }\n    };\n    const result = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx\n      }\n    });\n    if (isAsync(result)) {\n      return result.then((result2) => {\n        return {\n          status: "valid",\n          value: result2.status === "valid" ? result2.value : this._def.catchValue({\n            get error() {\n              return new ZodError2(newCtx.common.issues);\n            },\n            input: newCtx.data\n          })\n        };\n      });\n    } else {\n      return {\n        status: "valid",\n        value: result.status === "valid" ? result.value : this._def.catchValue({\n          get error() {\n            return new ZodError2(newCtx.common.issues);\n          },\n          input: newCtx.data\n        })\n      };\n    }\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n}\nZodCatch2.create = (type, params) => {\n  return new ZodCatch2({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodCatch,\n    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNaN2 extends ZodType2 {\n  _parse(input) {\n    const parsedType3 = this._getType(input);\n    if (parsedType3 !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      });\n      return INVALID2;\n    }\n    return { status: "valid", value: input.data };\n  }\n}\nZodNaN2.create = (params) => {\n  return new ZodNaN2({\n    typeName: ZodFirstPartyTypeKind.ZodNaN,\n    ...processCreateParams(params)\n  });\n};\nvar BRAND = Symbol("zod_brand");\n\nclass ZodBranded extends ZodType2 {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n}\n\nclass ZodPipeline extends ZodType2 {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inResult.status === "aborted")\n          return INVALID2;\n        if (inResult.status === "dirty") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n      if (inResult.status === "aborted")\n        return INVALID2;\n      if (inResult.status === "dirty") {\n        status.dirty();\n        return {\n          status: "dirty",\n          value: inResult.value\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n  }\n  static create(a2, b2) {\n    return new ZodPipeline({\n      in: a2,\n      out: b2,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline\n    });\n  }\n}\n\nclass ZodReadonly2 extends ZodType2 {\n  _parse(input) {\n    const result = this._def.innerType._parse(input);\n    const freeze = (data) => {\n      if (isValid(data)) {\n        data.value = Object.freeze(data.value);\n      }\n      return data;\n    };\n    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nZodReadonly2.create = (type, params) => {\n  return new ZodReadonly2({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodReadonly,\n    ...processCreateParams(params)\n  });\n};\nvar late = {\n  object: ZodObject2.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";\n  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";\n  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";\n  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";\n  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";\n  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";\n  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";\n  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";\n  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";\n  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";\n  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";\n  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";\n  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";\n  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";\n  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";\n  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";\n  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";\n  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";\n  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";\n  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";\n  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";\n  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";\n  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";\n  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";\n  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";\n  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";\n  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";\n  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";\n  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";\n  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";\n  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";\n  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";\n  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";\n  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";\n  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";\n  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar stringType = ZodString2.create;\nvar numberType = ZodNumber2.create;\nvar nanType = ZodNaN2.create;\nvar bigIntType = ZodBigInt2.create;\nvar booleanType = ZodBoolean2.create;\nvar dateType = ZodDate2.create;\nvar symbolType = ZodSymbol2.create;\nvar undefinedType = ZodUndefined2.create;\nvar nullType = ZodNull2.create;\nvar anyType = ZodAny2.create;\nvar unknownType = ZodUnknown2.create;\nvar neverType = ZodNever2.create;\nvar voidType = ZodVoid2.create;\nvar arrayType = ZodArray2.create;\nvar objectType = ZodObject2.create;\nvar strictObjectType = ZodObject2.strictCreate;\nvar unionType = ZodUnion2.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion2.create;\nvar intersectionType = ZodIntersection2.create;\nvar tupleType = ZodTuple2.create;\nvar recordType = ZodRecord2.create;\nvar mapType = ZodMap2.create;\nvar setType = ZodSet2.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy2.create;\nvar literalType = ZodLiteral2.create;\nvar enumType = ZodEnum2.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise2.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional2.create;\nvar nullableType = ZodNullable2.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar pipelineType = ZodPipeline.create;\n// ../../node_modules/@ai-sdk/provider-utils/dist/index.mjs\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",\n  separator = "-"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i2 = 0;i2 < size; i2++) {\n      chars[i2] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join("");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: "separator",\n      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\nfunction getErrorMessage2(error38) {\n  if (error38 == null) {\n    return "unknown error";\n  }\n  if (typeof error38 === "string") {\n    return error38;\n  }\n  if (error38 instanceof Error) {\n    return error38.message;\n  }\n  return JSON.stringify(error38);\n}\nvar suspectProtoRx = /"__proto__"\\s*:/;\nvar suspectConstructorRx = /"constructor"\\s*:/;\nfunction _parse2(text) {\n  const obj = JSON.parse(text);\n  if (obj === null || typeof obj !== "object") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {\n        throw new SyntaxError("Object contains forbidden prototype property");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {\n        throw new SyntaxError("Object contains forbidden prototype property");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === "object") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text) {\n  const { stackTraceLimit } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse2(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nvar validatorSymbol = Symbol.for("vercel.ai.validator");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : standardSchemaValidator(value);\n}\nfunction standardSchemaValidator(standardSchema) {\n  return validator(async (value) => {\n    const result = await standardSchema["~standard"].validate(value);\n    return result.issues == null ? { success: true, value: result.value } : {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\nasync function validateTypes({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes({ value, schema });\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const result = await validator2.validate(value);\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n      rawValue: value\n    };\n  } catch (error38) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error38 }),\n      rawValue: value\n    };\n  }\n}\nasync function safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    return await safeValidateTypes({ value, schema });\n  } catch (error38) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error38) ? error38 : new JSONParseError({ text, cause: error38 }),\n      rawValue: undefined\n    };\n  }\n}\nvar getRelativePath = (pathA, pathB) => {\n  let i2 = 0;\n  for (;i2 < pathA.length && i2 < pathB.length; i2++) {\n    if (pathA[i2] !== pathB[i2])\n      break;\n  }\n  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");\n};\nvar ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");\nvar defaultOptions = {\n  name: undefined,\n  $refStrategy: "root",\n  basePath: ["#"],\n  effectStrategy: "input",\n  pipeStrategy: "all",\n  dateStrategy: "format:date-time",\n  mapStrategy: "entries",\n  removeAdditionalStrategy: "passthrough",\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: "definitions",\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  patternStrategy: "escape",\n  applyRegexFlags: false,\n  emailStrategy: "format:email",\n  base64Strategy: "contentEncoding:base64",\n  nameStrategy: "ref"\n};\nvar getDefaultOptions = (options) => typeof options === "string" ? {\n  ...defaultOptions,\n  name: options\n} : {\n  ...defaultOptions,\n  ...options\n};\nfunction parseAnyDef() {\n  return {};\n}\nfunction parseArrayDef(def, refs) {\n  var _a15, _b, _c;\n  const res = {\n    type: "array"\n  };\n  if (((_a15 = def.type) == null ? undefined : _a15._def) && ((_c = (_b = def.type) == null ? undefined : _b._def) == null ? undefined : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "items"]\n    });\n  }\n  if (def.minLength) {\n    res.minItems = def.minLength.value;\n  }\n  if (def.maxLength) {\n    res.maxItems = def.maxLength.value;\n  }\n  if (def.exactLength) {\n    res.minItems = def.exactLength.value;\n    res.maxItems = def.exactLength.value;\n  }\n  return res;\n}\nfunction parseBigintDef(def) {\n  const res = {\n    type: "integer",\n    format: "int64"\n  };\n  if (!def.checks)\n    return res;\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case "min":\n        if (check2.inclusive) {\n          res.minimum = check2.value;\n        } else {\n          res.exclusiveMinimum = check2.value;\n        }\n        break;\n      case "max":\n        if (check2.inclusive) {\n          res.maximum = check2.value;\n        } else {\n          res.exclusiveMaximum = check2.value;\n        }\n        break;\n      case "multipleOf":\n        res.multipleOf = check2.value;\n        break;\n    }\n  }\n  return res;\n}\nfunction parseBooleanDef() {\n  return { type: "boolean" };\n}\nfunction parseBrandedDef(_def, refs) {\n  return parseDef(_def.type._def, refs);\n}\nvar parseCatchDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\nfunction parseDateDef(def, refs, overrideDateStrategy) {\n  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item))\n    };\n  }\n  switch (strategy) {\n    case "string":\n    case "format:date-time":\n      return {\n        type: "string",\n        format: "date-time"\n      };\n    case "format:date":\n      return {\n        type: "string",\n        format: "date"\n      };\n    case "integer":\n      return integerDateParser(def);\n  }\n}\nvar integerDateParser = (def) => {\n  const res = {\n    type: "integer",\n    format: "unix-time"\n  };\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case "min":\n        res.minimum = check2.value;\n        break;\n      case "max":\n        res.maximum = check2.value;\n        break;\n    }\n  }\n  return res;\n};\nfunction parseDefaultDef(_def, refs) {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue()\n  };\n}\nfunction parseEffectsDef(_def, refs) {\n  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();\n}\nfunction parseEnumDef(def) {\n  return {\n    type: "string",\n    enum: Array.from(def.values)\n  };\n}\nvar isJsonSchema7AllOfType = (type) => {\n  if ("type" in type && type.type === "string")\n    return false;\n  return "allOf" in type;\n};\nfunction parseIntersectionDef(def, refs) {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "allOf", "0"]\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "allOf", "1"]\n    })\n  ].filter((x2) => !!x2);\n  const mergedAllOf = [];\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n    } else {\n      let nestedSchema = schema;\n      if ("additionalProperties" in schema && schema.additionalProperties === false) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? { allOf: mergedAllOf } : undefined;\n}\nfunction parseLiteralDef(def) {\n  const parsedType3 = typeof def.value;\n  if (parsedType3 !== "bigint" && parsedType3 !== "number" && parsedType3 !== "boolean" && parsedType3 !== "string") {\n    return {\n      type: Array.isArray(def.value) ? "array" : "object"\n    };\n  }\n  return {\n    type: parsedType3 === "bigint" ? "integer" : parsedType3,\n    const: def.value\n  };\n}\nvar emojiRegex2 = undefined;\nvar zodPatterns = {\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_\'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  emoji: () => {\n    if (emojiRegex2 === undefined) {\n      emojiRegex2 = RegExp("^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$", "u");\n    }\n    return emojiRegex2;\n  },\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/\n};\nfunction parseStringDef(def, refs) {\n  const res = {\n    type: "string"\n  };\n  if (def.checks) {\n    for (const check2 of def.checks) {\n      switch (check2.kind) {\n        case "min":\n          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;\n          break;\n        case "max":\n          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;\n          break;\n        case "email":\n          switch (refs.emailStrategy) {\n            case "format:email":\n              addFormat(res, "email", check2.message, refs);\n              break;\n            case "format:idn-email":\n              addFormat(res, "idn-email", check2.message, refs);\n              break;\n            case "pattern:zod":\n              addPattern(res, zodPatterns.email, check2.message, refs);\n              break;\n          }\n          break;\n        case "url":\n          addFormat(res, "uri", check2.message, refs);\n          break;\n        case "uuid":\n          addFormat(res, "uuid", check2.message, refs);\n          break;\n        case "regex":\n          addPattern(res, check2.regex, check2.message, refs);\n          break;\n        case "cuid":\n          addPattern(res, zodPatterns.cuid, check2.message, refs);\n          break;\n        case "cuid2":\n          addPattern(res, zodPatterns.cuid2, check2.message, refs);\n          break;\n        case "startsWith":\n          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`), check2.message, refs);\n          break;\n        case "endsWith":\n          addPattern(res, RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`), check2.message, refs);\n          break;\n        case "datetime":\n          addFormat(res, "date-time", check2.message, refs);\n          break;\n        case "date":\n          addFormat(res, "date", check2.message, refs);\n          break;\n        case "time":\n          addFormat(res, "time", check2.message, refs);\n          break;\n        case "duration":\n          addFormat(res, "duration", check2.message, refs);\n          break;\n        case "length":\n          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;\n          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;\n          break;\n        case "includes": {\n          addPattern(res, RegExp(escapeLiteralCheckValue(check2.value, refs)), check2.message, refs);\n          break;\n        }\n        case "ip": {\n          if (check2.version !== "v6") {\n            addFormat(res, "ipv4", check2.message, refs);\n          }\n          if (check2.version !== "v4") {\n            addFormat(res, "ipv6", check2.message, refs);\n          }\n          break;\n        }\n        case "base64url":\n          addPattern(res, zodPatterns.base64url, check2.message, refs);\n          break;\n        case "jwt":\n          addPattern(res, zodPatterns.jwt, check2.message, refs);\n          break;\n        case "cidr": {\n          if (check2.version !== "v6") {\n            addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);\n          }\n          if (check2.version !== "v4") {\n            addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);\n          }\n          break;\n        }\n        case "emoji":\n          addPattern(res, zodPatterns.emoji(), check2.message, refs);\n          break;\n        case "ulid": {\n          addPattern(res, zodPatterns.ulid, check2.message, refs);\n          break;\n        }\n        case "base64": {\n          switch (refs.base64Strategy) {\n            case "format:binary": {\n              addFormat(res, "binary", check2.message, refs);\n              break;\n            }\n            case "contentEncoding:base64": {\n              res.contentEncoding = "base64";\n              break;\n            }\n            case "pattern:zod": {\n              addPattern(res, zodPatterns.base64, check2.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case "nanoid": {\n          addPattern(res, zodPatterns.nanoid, check2.message, refs);\n        }\n        case "toLowerCase":\n        case "toUpperCase":\n        case "trim":\n          break;\n        default:\n      }\n    }\n  }\n  return res;\n}\nfunction escapeLiteralCheckValue(literal2, refs) {\n  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal2) : literal2;\n}\nvar ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");\nfunction escapeNonAlphaNumeric(source) {\n  let result = "";\n  for (let i2 = 0;i2 < source.length; i2++) {\n    if (!ALPHA_NUMERIC.has(source[i2])) {\n      result += "\\\\";\n    }\n    result += source[i2];\n  }\n  return result;\n}\nfunction addFormat(schema, value, message, refs) {\n  var _a15;\n  if (schema.format || ((_a15 = schema.anyOf) == null ? undefined : _a15.some((x2) => x2.format))) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format\n      });\n      delete schema.format;\n    }\n    schema.anyOf.push({\n      format: value,\n      ...message && refs.errorMessages && { errorMessage: { format: message } }\n    });\n  } else {\n    schema.format = value;\n  }\n}\nfunction addPattern(schema, regex, message, refs) {\n  var _a15;\n  if (schema.pattern || ((_a15 = schema.allOf) == null ? undefined : _a15.some((x2) => x2.pattern))) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern\n      });\n      delete schema.pattern;\n    }\n    schema.allOf.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...message && refs.errorMessages && { errorMessage: { pattern: message } }\n    });\n  } else {\n    schema.pattern = stringifyRegExpWithFlags(regex, refs);\n  }\n}\nfunction stringifyRegExpWithFlags(regex, refs) {\n  var _a15;\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n  const flags = {\n    i: regex.flags.includes("i"),\n    m: regex.flags.includes("m"),\n    s: regex.flags.includes("s")\n  };\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = "";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i2 = 0;i2 < source.length; i2++) {\n    if (isEscaped) {\n      pattern += source[i2];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i2].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i2];\n            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i2 + 1] === "-" && ((_a15 = source[i2 + 2]) == null ? undefined : _a15.match(/[a-z]/))) {\n            pattern += source[i2];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i2]}${source[i2].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i2].match(/[a-z]/)) {\n        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i2] === "^") {\n        pattern += `(^|(?<=[\\r\n]))`;\n        continue;\n      } else if (source[i2] === "$") {\n        pattern += `($|(?=[\\r\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i2] === ".") {\n      pattern += inCharGroup ? `${source[i2]}\\r\n` : `[${source[i2]}\\r\n]`;\n      continue;\n    }\n    pattern += source[i2];\n    if (source[i2] === "\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i2] === "]") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i2] === "[") {\n      inCharGroup = true;\n    }\n  }\n  try {\n    new RegExp(pattern);\n  } catch (e2) {\n    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);\n    return regex.source;\n  }\n  return pattern;\n}\nfunction parseRecordDef(def, refs) {\n  var _a15, _b, _c, _d, _e2, _f;\n  const schema = {\n    type: "object",\n    additionalProperties: (_a15 = parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "additionalProperties"]\n    })) != null ? _a15 : refs.allowedAdditionalProperties\n  };\n  if (((_b = def.keyType) == null ? undefined : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? undefined : _c.length)) {\n    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  } else if (((_d = def.keyType) == null ? undefined : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values\n      }\n    };\n  } else if (((_e2 = def.keyType) == null ? undefined : _e2._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? undefined : _f.length)) {\n    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  }\n  return schema;\n}\nfunction parseMapDef(def, refs) {\n  if (refs.mapStrategy === "record") {\n    return parseRecordDef(def, refs);\n  }\n  const keys = parseDef(def.keyType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "items", "items", "0"]\n  }) || parseAnyDef();\n  const values = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "items", "items", "1"]\n  }) || parseAnyDef();\n  return {\n    type: "array",\n    maxItems: 125,\n    items: {\n      type: "array",\n      items: [keys, values],\n      minItems: 2,\n      maxItems: 2\n    }\n  };\n}\nfunction parseNativeEnumDef(def) {\n  const object2 = def.values;\n  const actualKeys = Object.keys(def.values).filter((key) => {\n    return typeof object2[object2[key]] !== "number";\n  });\n  const actualValues = actualKeys.map((key) => object2[key]);\n  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n  return {\n    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],\n    enum: actualValues\n  };\n}\nfunction parseNeverDef() {\n  return { not: parseAnyDef() };\n}\nfunction parseNullDef() {\n  return {\n    type: "null"\n  };\n}\nvar primitiveMappings = {\n  ZodString: "string",\n  ZodNumber: "number",\n  ZodBigInt: "integer",\n  ZodBoolean: "boolean",\n  ZodNull: "null"\n};\nfunction parseUnionDef(def, refs) {\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  if (options.every((x2) => (x2._def.typeName in primitiveMappings) && (!x2._def.checks || !x2._def.checks.length))) {\n    const types = options.reduce((types2, x2) => {\n      const type = primitiveMappings[x2._def.typeName];\n      return type && !types2.includes(type) ? [...types2, type] : types2;\n    }, []);\n    return {\n      type: types.length > 1 ? types : types[0]\n    };\n  } else if (options.every((x2) => x2._def.typeName === "ZodLiteral" && !x2.description)) {\n    const types = options.reduce((acc, x2) => {\n      const type = typeof x2._def.value;\n      switch (type) {\n        case "string":\n        case "number":\n        case "boolean":\n          return [...acc, type];\n        case "bigint":\n          return [...acc, "integer"];\n        case "object":\n          if (x2._def.value === null)\n            return [...acc, "null"];\n        case "symbol":\n        case "undefined":\n        case "function":\n        default:\n          return acc;\n      }\n    }, []);\n    if (types.length === options.length) {\n      const uniqueTypes = types.filter((x2, i2, a2) => a2.indexOf(x2) === i2);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce((acc, x2) => {\n          return acc.includes(x2._def.value) ? acc : [...acc, x2._def.value];\n        }, [])\n      };\n    }\n  } else if (options.every((x2) => x2._def.typeName === "ZodEnum")) {\n    return {\n      type: "string",\n      enum: options.reduce((acc, x2) => [\n        ...acc,\n        ...x2._def.values.filter((x22) => !acc.includes(x22))\n      ], [])\n    };\n  }\n  return asAnyOf(def, refs);\n}\nvar asAnyOf = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x2, i2) => parseDef(x2._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "anyOf", `${i2}`]\n  })).filter((x2) => !!x2 && (!refs.strictUnions || typeof x2 === "object" && Object.keys(x2).length > 0));\n  return anyOf.length ? { anyOf } : undefined;\n};\nfunction parseNullableDef(def, refs) {\n  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n    return {\n      type: [\n        primitiveMappings[def.innerType._def.typeName],\n        "null"\n      ]\n    };\n  }\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "anyOf", "0"]\n  });\n  return base && { anyOf: [base, { type: "null" }] };\n}\nfunction parseNumberDef(def) {\n  const res = {\n    type: "number"\n  };\n  if (!def.checks)\n    return res;\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case "int":\n        res.type = "integer";\n        break;\n      case "min":\n        if (check2.inclusive) {\n          res.minimum = check2.value;\n        } else {\n          res.exclusiveMinimum = check2.value;\n        }\n        break;\n      case "max":\n        if (check2.inclusive) {\n          res.maximum = check2.value;\n        } else {\n          res.exclusiveMaximum = check2.value;\n        }\n        break;\n      case "multipleOf":\n        res.multipleOf = check2.value;\n        break;\n    }\n  }\n  return res;\n}\nfunction parseObjectDef(def, refs) {\n  const result = {\n    type: "object",\n    properties: {}\n  };\n  const required2 = [];\n  const shape = def.shape();\n  for (const propName in shape) {\n    let propDef = shape[propName];\n    if (propDef === undefined || propDef._def === undefined) {\n      continue;\n    }\n    const propOptional = safeIsOptional(propDef);\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "properties", propName],\n      propertyPath: [...refs.currentPath, "properties", propName]\n    });\n    if (parsedDef === undefined) {\n      continue;\n    }\n    result.properties[propName] = parsedDef;\n    if (!propOptional) {\n      required2.push(propName);\n    }\n  }\n  if (required2.length) {\n    result.required = required2;\n  }\n  const additionalProperties = decideAdditionalProperties(def, refs);\n  if (additionalProperties !== undefined) {\n    result.additionalProperties = additionalProperties;\n  }\n  return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n  if (def.catchall._def.typeName !== "ZodNever") {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "additionalProperties"]\n    });\n  }\n  switch (def.unknownKeys) {\n    case "passthrough":\n      return refs.allowedAdditionalProperties;\n    case "strict":\n      return refs.rejectedAdditionalProperties;\n    case "strip":\n      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;\n  }\n}\nfunction safeIsOptional(schema) {\n  try {\n    return schema.isOptional();\n  } catch (e2) {\n    return true;\n  }\n}\nvar parseOptionalDef = (def, refs) => {\n  var _a15;\n  if (refs.currentPath.toString() === ((_a15 = refs.propertyPath) == null ? undefined : _a15.toString())) {\n    return parseDef(def.innerType._def, refs);\n  }\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "anyOf", "1"]\n  });\n  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();\n};\nvar parsePipelineDef = (def, refs) => {\n  if (refs.pipeStrategy === "input") {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === "output") {\n    return parseDef(def.out._def, refs);\n  }\n  const a2 = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "allOf", "0"]\n  });\n  const b2 = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"]\n  });\n  return {\n    allOf: [a2, b2].filter((x2) => x2 !== undefined)\n  };\n};\nfunction parsePromiseDef(def, refs) {\n  return parseDef(def.type._def, refs);\n}\nfunction parseSetDef(def, refs) {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "items"]\n  });\n  const schema = {\n    type: "array",\n    uniqueItems: true,\n    items\n  };\n  if (def.minSize) {\n    schema.minItems = def.minSize.value;\n  }\n  if (def.maxSize) {\n    schema.maxItems = def.maxSize.value;\n  }\n  return schema;\n}\nfunction parseTupleDef(def, refs) {\n  if (def.rest) {\n    return {\n      type: "array",\n      minItems: def.items.length,\n      items: def.items.map((x2, i2) => parseDef(x2._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, "items", `${i2}`]\n      })).reduce((acc, x2) => x2 === undefined ? acc : [...acc, x2], []),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, "additionalItems"]\n      })\n    };\n  } else {\n    return {\n      type: "array",\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items.map((x2, i2) => parseDef(x2._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, "items", `${i2}`]\n      })).reduce((acc, x2) => x2 === undefined ? acc : [...acc, x2], [])\n    };\n  }\n}\nfunction parseUndefinedDef() {\n  return {\n    not: parseAnyDef()\n  };\n}\nfunction parseUnknownDef() {\n  return parseAnyDef();\n}\nvar parseReadonlyDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\nvar selectParser = (def, typeName, refs) => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def);\n    case ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def);\n    case ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef();\n    case ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef();\n    case ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUnion:\n    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def);\n    case ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLazy:\n      return () => def.getter()._def;\n    case ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNaN:\n    case ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef();\n    case ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef();\n    case ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef();\n    case ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodFunction:\n    case ZodFirstPartyTypeKind.ZodVoid:\n    case ZodFirstPartyTypeKind.ZodSymbol:\n      return;\n    default:\n      return /* @__PURE__ */ ((_3) => {\n        return;\n      })(typeName);\n  }\n};\nfunction parseDef(def, refs, forceResolution = false) {\n  var _a15;\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = (_a15 = refs.override) == null ? undefined : _a15.call(refs, def, refs, seenItem, forceResolution);\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== undefined) {\n      return seenSchema;\n    }\n  }\n  const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n  const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema2) {\n    addMeta(def, refs, jsonSchema2);\n  }\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);\n    newItem.jsonSchema = jsonSchema2;\n    return postProcessResult;\n  }\n  newItem.jsonSchema = jsonSchema2;\n  return jsonSchema2;\n}\nvar get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case "root":\n      return { $ref: item.path.join("/") };\n    case "relative":\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case "none":\n    case "seen": {\n      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);\n        return parseAnyDef();\n      }\n      return refs.$refStrategy === "seen" ? parseAnyDef() : undefined;\n    }\n  }\n};\nvar addMeta = (def, refs, jsonSchema2) => {\n  if (def.description) {\n    jsonSchema2.description = def.description;\n  }\n  return jsonSchema2;\n};\nvar getRefs = (options) => {\n  const _options = getDefaultOptions(options);\n  const currentPath = _options.name !== undefined ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;\n  return {\n    ..._options,\n    currentPath,\n    propertyPath: undefined,\n    seen: new Map(Object.entries(_options.definitions).map(([name14, def]) => [\n      def._def,\n      {\n        def: def._def,\n        path: [..._options.basePath, _options.definitionPath, name14],\n        jsonSchema: undefined\n      }\n    ]))\n  };\n};\nvar zodToJsonSchema = (schema, options) => {\n  var _a15;\n  const refs = getRefs(options);\n  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name22, schema2]) => {\n    var _a22;\n    return {\n      ...acc,\n      [name22]: (_a22 = parseDef(schema2._def, {\n        ...refs,\n        currentPath: [...refs.basePath, refs.definitionPath, name22]\n      }, true)) != null ? _a22 : parseAnyDef()\n    };\n  }, {}) : undefined;\n  const name14 = typeof options === "string" ? options : (options == null ? undefined : options.nameStrategy) === "title" ? undefined : options == null ? undefined : options.name;\n  const main = (_a15 = parseDef(schema._def, name14 === undefined ? refs : {\n    ...refs,\n    currentPath: [...refs.basePath, refs.definitionPath, name14]\n  }, false)) != null ? _a15 : parseAnyDef();\n  const title = typeof options === "object" && options.name !== undefined && options.nameStrategy === "title" ? options.name : undefined;\n  if (title !== undefined) {\n    main.title = title;\n  }\n  const combined = name14 === undefined ? definitions ? {\n    ...main,\n    [refs.definitionPath]: definitions\n  } : main : {\n    $ref: [\n      ...refs.$refStrategy === "relative" ? [] : refs.basePath,\n      refs.definitionPath,\n      name14\n    ].join("/"),\n    [refs.definitionPath]: {\n      ...definitions,\n      [name14]: main\n    }\n  };\n  combined.$schema = "http://json-schema.org/draft-07/schema#";\n  return combined;\n};\nvar zod_to_json_schema_default = zodToJsonSchema;\nfunction zod3Schema(zodSchema2, options) {\n  var _a15;\n  const useReferences = (_a15 = options == null ? undefined : options.useReferences) != null ? _a15 : false;\n  return jsonSchema(zod_to_json_schema_default(zodSchema2, {\n    $refStrategy: useReferences ? "root" : "none"\n  }), {\n    validate: async (value) => {\n      const result = await zodSchema2.safeParseAsync(value);\n      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n    }\n  });\n}\nfunction zod4Schema(zodSchema2, options) {\n  var _a15;\n  const useReferences = (_a15 = options == null ? undefined : options.useReferences) != null ? _a15 : false;\n  const z4JSONSchema = toJSONSchema(zodSchema2, {\n    target: "draft-7",\n    io: "output",\n    reused: useReferences ? "ref" : "inline"\n  });\n  return jsonSchema(z4JSONSchema, {\n    validate: async (value) => {\n      const result = await safeParseAsync2(zodSchema2, value);\n      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n    }\n  });\n}\nfunction isZod4Schema(zodSchema2) {\n  return "_zod" in zodSchema2;\n}\nfunction zodSchema(zodSchema2, options) {\n  if (isZod4Schema(zodSchema2)) {\n    return zod4Schema(zodSchema2, options);\n  } else {\n    return zod3Schema(zodSchema2, options);\n  }\n}\nvar schemaSymbol = Symbol.for("vercel.ai.schema");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: undefined,\n    [validatorSymbol]: true,\n    jsonSchema: jsonSchema2,\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;\n}\nfunction asSchema(schema) {\n  return schema == null ? jsonSchema({\n    properties: {},\n    additionalProperties: false\n  }) : isSchema(schema) ? schema : zodSchema(schema);\n}\n\n// ../../node_modules/ai/dist/index.mjs\nvar __defProp2 = Object.defineProperty;\nvar __export2 = (target, all) => {\n  for (var name17 in all)\n    __defProp2(target, name17, { get: all[name17], enumerable: true });\n};\nvar name14 = "AI_NoOutputSpecifiedError";\nvar marker15 = `vercel.ai.error.${name14}`;\nvar symbol17 = Symbol.for(marker15);\nvar _a15;\n_a15 = symbol17;\nvar name22 = "AI_InvalidArgumentError";\nvar marker22 = `vercel.ai.error.${name22}`;\nvar symbol22 = Symbol.for(marker22);\nvar _a22;\n_a22 = symbol22;\nvar name32 = "AI_InvalidStreamPartError";\nvar marker32 = `vercel.ai.error.${name32}`;\nvar symbol32 = Symbol.for(marker32);\nvar _a32;\n_a32 = symbol32;\nvar name42 = "AI_InvalidToolInputError";\nvar marker42 = `vercel.ai.error.${name42}`;\nvar symbol42 = Symbol.for(marker42);\nvar _a42;\n_a42 = symbol42;\nvar name52 = "AI_MCPClientError";\nvar marker52 = `vercel.ai.error.${name52}`;\nvar symbol52 = Symbol.for(marker52);\nvar _a52;\n_a52 = symbol52;\nvar name62 = "AI_NoImageGeneratedError";\nvar marker62 = `vercel.ai.error.${name62}`;\nvar symbol62 = Symbol.for(marker62);\nvar _a62;\n_a62 = symbol62;\nvar name72 = "AI_NoObjectGeneratedError";\nvar marker72 = `vercel.ai.error.${name72}`;\nvar symbol72 = Symbol.for(marker72);\nvar _a72;\nvar NoObjectGeneratedError = class extends AISDKError {\n  constructor({\n    message = "No object generated.",\n    cause,\n    text: text2,\n    response,\n    usage,\n    finishReason\n  }) {\n    super({ name: name72, message, cause });\n    this[_a72] = true;\n    this.text = text2;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n  static isInstance(error38) {\n    return AISDKError.hasMarker(error38, marker72);\n  }\n};\n_a72 = symbol72;\nvar name82 = "AI_NoOutputGeneratedError";\nvar marker82 = `vercel.ai.error.${name82}`;\nvar symbol82 = Symbol.for(marker82);\nvar _a82;\n_a82 = symbol82;\nvar name92 = "AI_NoSuchToolError";\nvar marker92 = `vercel.ai.error.${name92}`;\nvar symbol92 = Symbol.for(marker92);\nvar _a92;\n_a92 = symbol92;\nvar name102 = "AI_ToolCallRepairError";\nvar marker102 = `vercel.ai.error.${name102}`;\nvar symbol102 = Symbol.for(marker102);\nvar _a102;\n_a102 = symbol102;\nvar name112 = "AI_InvalidDataContentError";\nvar marker112 = `vercel.ai.error.${name112}`;\nvar symbol112 = Symbol.for(marker112);\nvar _a112;\n_a112 = symbol112;\nvar name122 = "AI_InvalidMessageRoleError";\nvar marker122 = `vercel.ai.error.${name122}`;\nvar symbol122 = Symbol.for(marker122);\nvar _a122;\n_a122 = symbol122;\nvar name132 = "AI_MessageConversionError";\nvar marker132 = `vercel.ai.error.${name132}`;\nvar symbol132 = Symbol.for(marker132);\nvar _a132;\nvar MessageConversionError = class extends AISDKError {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name132, message });\n    this[_a132] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error38) {\n    return AISDKError.hasMarker(error38, marker132);\n  }\n};\n_a132 = symbol132;\nvar name142 = "AI_DownloadError";\nvar marker142 = `vercel.ai.error.${name142}`;\nvar symbol142 = Symbol.for(marker142);\nvar _a142;\n_a142 = symbol142;\nvar name15 = "AI_RetryError";\nvar marker152 = `vercel.ai.error.${name15}`;\nvar symbol152 = Symbol.for(marker152);\nvar _a152;\n_a152 = symbol152;\nvar dataContentSchema = exports_external.union([\n  exports_external.string(),\n  exports_external.instanceof(Uint8Array),\n  exports_external.instanceof(ArrayBuffer),\n  exports_external.custom((value) => {\n    var _a17, _b;\n    return (_b = (_a17 = globalThis.Buffer) == null ? undefined : _a17.isBuffer(value)) != null ? _b : false;\n  }, { message: "Must be a Buffer" })\n]);\nvar jsonValueSchema = exports_external.lazy(() => exports_external.union([\n  exports_external.null(),\n  exports_external.string(),\n  exports_external.number(),\n  exports_external.boolean(),\n  exports_external.record(exports_external.string(), jsonValueSchema),\n  exports_external.array(jsonValueSchema)\n]));\nvar providerMetadataSchema = exports_external.record(exports_external.string(), exports_external.record(exports_external.string(), jsonValueSchema));\nvar textPartSchema = exports_external.object({\n  type: exports_external.literal("text"),\n  text: exports_external.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = exports_external.object({\n  type: exports_external.literal("image"),\n  image: exports_external.union([dataContentSchema, exports_external.instanceof(URL)]),\n  mediaType: exports_external.string().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = exports_external.object({\n  type: exports_external.literal("file"),\n  data: exports_external.union([dataContentSchema, exports_external.instanceof(URL)]),\n  filename: exports_external.string().optional(),\n  mediaType: exports_external.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = exports_external.object({\n  type: exports_external.literal("reasoning"),\n  text: exports_external.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = exports_external.object({\n  type: exports_external.literal("tool-call"),\n  toolCallId: exports_external.string(),\n  toolName: exports_external.string(),\n  input: exports_external.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  providerExecuted: exports_external.boolean().optional()\n});\nvar outputSchema = exports_external.discriminatedUnion("type", [\n  exports_external.object({\n    type: exports_external.literal("text"),\n    value: exports_external.string()\n  }),\n  exports_external.object({\n    type: exports_external.literal("json"),\n    value: jsonValueSchema\n  }),\n  exports_external.object({\n    type: exports_external.literal("error-text"),\n    value: exports_external.string()\n  }),\n  exports_external.object({\n    type: exports_external.literal("error-json"),\n    value: jsonValueSchema\n  }),\n  exports_external.object({\n    type: exports_external.literal("content"),\n    value: exports_external.array(exports_external.union([\n      exports_external.object({\n        type: exports_external.literal("text"),\n        text: exports_external.string()\n      }),\n      exports_external.object({\n        type: exports_external.literal("media"),\n        data: exports_external.string(),\n        mediaType: exports_external.string()\n      })\n    ]))\n  })\n]);\nvar toolResultPartSchema = exports_external.object({\n  type: exports_external.literal("tool-result"),\n  toolCallId: exports_external.string(),\n  toolName: exports_external.string(),\n  output: outputSchema,\n  providerOptions: providerMetadataSchema.optional()\n});\nvar systemModelMessageSchema = exports_external.object({\n  role: exports_external.literal("system"),\n  content: exports_external.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar userModelMessageSchema = exports_external.object({\n  role: exports_external.literal("user"),\n  content: exports_external.union([\n    exports_external.string(),\n    exports_external.array(exports_external.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar assistantModelMessageSchema = exports_external.object({\n  role: exports_external.literal("assistant"),\n  content: exports_external.union([\n    exports_external.string(),\n    exports_external.array(exports_external.union([\n      textPartSchema,\n      filePartSchema,\n      reasoningPartSchema,\n      toolCallPartSchema,\n      toolResultPartSchema\n    ]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolModelMessageSchema = exports_external.object({\n  role: exports_external.literal("tool"),\n  content: exports_external.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar modelMessageSchema = exports_external.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema\n]);\nfunction createToolModelOutput({\n  output,\n  tool: tool3,\n  errorMode\n}) {\n  if (errorMode === "text") {\n    return { type: "error-text", value: getErrorMessage(output) };\n  } else if (errorMode === "json") {\n    return { type: "error-json", value: toJSONValue(output) };\n  }\n  if (tool3 == null ? undefined : tool3.toModelOutput) {\n    return tool3.toModelOutput(output);\n  }\n  return typeof output === "string" ? { type: "text", value: output } : { type: "json", value: toJSONValue(output) };\n}\nfunction toJSONValue(value) {\n  return value === undefined ? null : value;\n}\nvar originalGenerateId = createIdGenerator({\n  prefix: "aitxt",\n  size: 24\n});\nvar JsonToSseTransformStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(part, controller) {\n        controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n      },\n      flush(controller) {\n        controller.enqueue(`data: [DONE]\n\n`);\n      }\n    });\n  }\n};\nvar uiMessageChunkSchema = exports_external.union([\n  exports_external.strictObject({\n    type: exports_external.literal("text-start"),\n    id: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("text-delta"),\n    id: exports_external.string(),\n    delta: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("text-end"),\n    id: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("error"),\n    errorText: exports_external.string()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-input-start"),\n    toolCallId: exports_external.string(),\n    toolName: exports_external.string(),\n    providerExecuted: exports_external.boolean().optional(),\n    dynamic: exports_external.boolean().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-input-delta"),\n    toolCallId: exports_external.string(),\n    inputTextDelta: exports_external.string()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-input-available"),\n    toolCallId: exports_external.string(),\n    toolName: exports_external.string(),\n    input: exports_external.unknown(),\n    providerExecuted: exports_external.boolean().optional(),\n    providerMetadata: providerMetadataSchema.optional(),\n    dynamic: exports_external.boolean().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-input-error"),\n    toolCallId: exports_external.string(),\n    toolName: exports_external.string(),\n    input: exports_external.unknown(),\n    providerExecuted: exports_external.boolean().optional(),\n    providerMetadata: providerMetadataSchema.optional(),\n    dynamic: exports_external.boolean().optional(),\n    errorText: exports_external.string()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-output-available"),\n    toolCallId: exports_external.string(),\n    output: exports_external.unknown(),\n    providerExecuted: exports_external.boolean().optional(),\n    dynamic: exports_external.boolean().optional(),\n    preliminary: exports_external.boolean().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-output-error"),\n    toolCallId: exports_external.string(),\n    errorText: exports_external.string(),\n    providerExecuted: exports_external.boolean().optional(),\n    dynamic: exports_external.boolean().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("reasoning"),\n    text: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("reasoning-start"),\n    id: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("reasoning-delta"),\n    id: exports_external.string(),\n    delta: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("reasoning-end"),\n    id: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("reasoning-part-finish")\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("source-url"),\n    sourceId: exports_external.string(),\n    url: exports_external.string(),\n    title: exports_external.string().optional(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("source-document"),\n    sourceId: exports_external.string(),\n    mediaType: exports_external.string(),\n    title: exports_external.string(),\n    filename: exports_external.string().optional(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("file"),\n    url: exports_external.string(),\n    mediaType: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.string().startsWith("data-"),\n    id: exports_external.string().optional(),\n    data: exports_external.unknown(),\n    transient: exports_external.boolean().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("start-step")\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("finish-step")\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("start"),\n    messageId: exports_external.string().optional(),\n    messageMetadata: exports_external.unknown().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("finish"),\n    messageMetadata: exports_external.unknown().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("abort")\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("message-metadata"),\n    messageMetadata: exports_external.unknown()\n  })\n]);\nfunction isDataUIMessageChunk(chunk) {\n  return chunk.type.startsWith("data-");\n}\nfunction mergeObjects(base, overrides) {\n  if (base === undefined && overrides === undefined) {\n    return;\n  }\n  if (base === undefined) {\n    return overrides;\n  }\n  if (overrides === undefined) {\n    return base;\n  }\n  const result = { ...base };\n  for (const key in overrides) {\n    if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n      const overridesValue = overrides[key];\n      if (overridesValue === undefined)\n        continue;\n      const baseValue = key in base ? base[key] : undefined;\n      const isSourceObject = overridesValue !== null && typeof overridesValue === "object" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n      const isTargetObject = baseValue !== null && baseValue !== undefined && typeof baseValue === "object" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n      if (isSourceObject && isTargetObject) {\n        result[key] = mergeObjects(baseValue, overridesValue);\n      } else {\n        result[key] = overridesValue;\n      }\n    }\n  }\n  return result;\n}\nfunction fixJson(input) {\n  const stack = ["ROOT"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i2, swapState) {\n    {\n      switch (char) {\n        case \'"\': {\n          lastValidIndex = i2;\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_STRING");\n          break;\n        }\n        case "f":\n        case "t":\n        case "n": {\n          lastValidIndex = i2;\n          literalStart = i2;\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_LITERAL");\n          break;\n        }\n        case "-": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_NUMBER");\n          break;\n        }\n        case "0":\n        case "1":\n        case "2":\n        case "3":\n        case "4":\n        case "5":\n        case "6":\n        case "7":\n        case "8":\n        case "9": {\n          lastValidIndex = i2;\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_NUMBER");\n          break;\n        }\n        case "{": {\n          lastValidIndex = i2;\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_OBJECT_START");\n          break;\n        }\n        case "[": {\n          lastValidIndex = i2;\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_ARRAY_START");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i2) {\n    switch (char) {\n      case ",": {\n        stack.pop();\n        stack.push("INSIDE_OBJECT_AFTER_COMMA");\n        break;\n      }\n      case "}": {\n        lastValidIndex = i2;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i2) {\n    switch (char) {\n      case ",": {\n        stack.pop();\n        stack.push("INSIDE_ARRAY_AFTER_COMMA");\n        break;\n      }\n      case "]": {\n        lastValidIndex = i2;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i2 = 0;i2 < input.length; i2++) {\n    const char = input[i2];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case "ROOT":\n        processValueStart(char, i2, "FINISH");\n        break;\n      case "INSIDE_OBJECT_START": {\n        switch (char) {\n          case \'"\': {\n            stack.pop();\n            stack.push("INSIDE_OBJECT_KEY");\n            break;\n          }\n          case "}": {\n            lastValidIndex = i2;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_OBJECT_AFTER_COMMA": {\n        switch (char) {\n          case \'"\': {\n            stack.pop();\n            stack.push("INSIDE_OBJECT_KEY");\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_OBJECT_KEY": {\n        switch (char) {\n          case \'"\': {\n            stack.pop();\n            stack.push("INSIDE_OBJECT_AFTER_KEY");\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_OBJECT_AFTER_KEY": {\n        switch (char) {\n          case ":": {\n            stack.pop();\n            stack.push("INSIDE_OBJECT_BEFORE_VALUE");\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_OBJECT_BEFORE_VALUE": {\n        processValueStart(char, i2, "INSIDE_OBJECT_AFTER_VALUE");\n        break;\n      }\n      case "INSIDE_OBJECT_AFTER_VALUE": {\n        processAfterObjectValue(char, i2);\n        break;\n      }\n      case "INSIDE_STRING": {\n        switch (char) {\n          case \'"\': {\n            stack.pop();\n            lastValidIndex = i2;\n            break;\n          }\n          case "\\\\": {\n            stack.push("INSIDE_STRING_ESCAPE");\n            break;\n          }\n          default: {\n            lastValidIndex = i2;\n          }\n        }\n        break;\n      }\n      case "INSIDE_ARRAY_START": {\n        switch (char) {\n          case "]": {\n            lastValidIndex = i2;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i2;\n            processValueStart(char, i2, "INSIDE_ARRAY_AFTER_VALUE");\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_ARRAY_AFTER_VALUE": {\n        switch (char) {\n          case ",": {\n            stack.pop();\n            stack.push("INSIDE_ARRAY_AFTER_COMMA");\n            break;\n          }\n          case "]": {\n            lastValidIndex = i2;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i2;\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_ARRAY_AFTER_COMMA": {\n        processValueStart(char, i2, "INSIDE_ARRAY_AFTER_VALUE");\n        break;\n      }\n      case "INSIDE_STRING_ESCAPE": {\n        stack.pop();\n        lastValidIndex = i2;\n        break;\n      }\n      case "INSIDE_NUMBER": {\n        switch (char) {\n          case "0":\n          case "1":\n          case "2":\n          case "3":\n          case "4":\n          case "5":\n          case "6":\n          case "7":\n          case "8":\n          case "9": {\n            lastValidIndex = i2;\n            break;\n          }\n          case "e":\n          case "E":\n          case "-":\n          case ".": {\n            break;\n          }\n          case ",": {\n            stack.pop();\n            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {\n              processAfterArrayValue(char, i2);\n            }\n            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {\n              processAfterObjectValue(char, i2);\n            }\n            break;\n          }\n          case "}": {\n            stack.pop();\n            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {\n              processAfterObjectValue(char, i2);\n            }\n            break;\n          }\n          case "]": {\n            stack.pop();\n            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {\n              processAfterArrayValue(char, i2);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_LITERAL": {\n        const partialLiteral = input.substring(literalStart, i2 + 1);\n        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {\n            processAfterObjectValue(char, i2);\n          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {\n            processAfterArrayValue(char, i2);\n          }\n        } else {\n          lastValidIndex = i2;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i2 = stack.length - 1;i2 >= 0; i2--) {\n    const state = stack[i2];\n    switch (state) {\n      case "INSIDE_STRING": {\n        result += \'"\';\n        break;\n      }\n      case "INSIDE_OBJECT_KEY":\n      case "INSIDE_OBJECT_AFTER_KEY":\n      case "INSIDE_OBJECT_AFTER_COMMA":\n      case "INSIDE_OBJECT_START":\n      case "INSIDE_OBJECT_BEFORE_VALUE":\n      case "INSIDE_OBJECT_AFTER_VALUE": {\n        result += "}";\n        break;\n      }\n      case "INSIDE_ARRAY_START":\n      case "INSIDE_ARRAY_AFTER_COMMA":\n      case "INSIDE_ARRAY_AFTER_VALUE": {\n        result += "]";\n        break;\n      }\n      case "INSIDE_LITERAL": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if ("true".startsWith(partialLiteral)) {\n          result += "true".slice(partialLiteral.length);\n        } else if ("false".startsWith(partialLiteral)) {\n          result += "false".slice(partialLiteral.length);\n        } else if ("null".startsWith(partialLiteral)) {\n          result += "null".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\nasync function parsePartialJson(jsonText) {\n  if (jsonText === undefined) {\n    return { value: undefined, state: "undefined-input" };\n  }\n  let result = await safeParseJSON({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: "successful-parse" };\n  }\n  result = await safeParseJSON({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: "repaired-parse" };\n  }\n  return { value: undefined, state: "failed-parse" };\n}\nfunction isToolUIPart(part) {\n  return part.type.startsWith("tool-");\n}\nfunction isDynamicToolUIPart(part) {\n  return part.type === "dynamic-tool";\n}\nfunction isToolOrDynamicToolUIPart(part) {\n  return isToolUIPart(part) || isDynamicToolUIPart(part);\n}\nfunction getToolName(part) {\n  return part.type.split("-").slice(1).join("-");\n}\nfunction createStreamingUIMessageState({\n  lastMessage,\n  messageId\n}) {\n  return {\n    message: (lastMessage == null ? undefined : lastMessage.role) === "assistant" ? lastMessage : {\n      id: messageId,\n      metadata: undefined,\n      role: "assistant",\n      parts: []\n    },\n    activeTextParts: {},\n    activeReasoningParts: {},\n    partialToolCalls: {}\n  };\n}\nfunction processUIMessageStream({\n  stream,\n  messageMetadataSchema,\n  dataPartSchemas,\n  runUpdateMessageJob,\n  onError,\n  onToolCall,\n  onData\n}) {\n  return stream.pipeThrough(new TransformStream({\n    async transform(chunk, controller) {\n      await runUpdateMessageJob(async ({ state, write }) => {\n        var _a17, _b, _c, _d;\n        function getToolInvocation(toolCallId) {\n          const toolInvocations = state.message.parts.filter(isToolUIPart);\n          const toolInvocation = toolInvocations.find((invocation) => invocation.toolCallId === toolCallId);\n          if (toolInvocation == null) {\n            throw new Error("tool-output-error must be preceded by a tool-input-available");\n          }\n          return toolInvocation;\n        }\n        function getDynamicToolInvocation(toolCallId) {\n          const toolInvocations = state.message.parts.filter((part) => part.type === "dynamic-tool");\n          const toolInvocation = toolInvocations.find((invocation) => invocation.toolCallId === toolCallId);\n          if (toolInvocation == null) {\n            throw new Error("tool-output-error must be preceded by a tool-input-available");\n          }\n          return toolInvocation;\n        }\n        function updateToolPart(options) {\n          var _a18;\n          const part = state.message.parts.find((part2) => isToolUIPart(part2) && part2.toolCallId === options.toolCallId);\n          const anyOptions = options;\n          const anyPart = part;\n          if (part != null) {\n            part.state = options.state;\n            anyPart.input = anyOptions.input;\n            anyPart.output = anyOptions.output;\n            anyPart.errorText = anyOptions.errorText;\n            anyPart.rawInput = anyOptions.rawInput;\n            anyPart.preliminary = anyOptions.preliminary;\n            anyPart.providerExecuted = (_a18 = anyOptions.providerExecuted) != null ? _a18 : part.providerExecuted;\n            if (anyOptions.providerMetadata != null && part.state === "input-available") {\n              part.callProviderMetadata = anyOptions.providerMetadata;\n            }\n          } else {\n            state.message.parts.push({\n              type: `tool-${options.toolName}`,\n              toolCallId: options.toolCallId,\n              state: options.state,\n              input: anyOptions.input,\n              output: anyOptions.output,\n              rawInput: anyOptions.rawInput,\n              errorText: anyOptions.errorText,\n              providerExecuted: anyOptions.providerExecuted,\n              preliminary: anyOptions.preliminary,\n              ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n            });\n          }\n        }\n        function updateDynamicToolPart(options) {\n          var _a18;\n          const part = state.message.parts.find((part2) => part2.type === "dynamic-tool" && part2.toolCallId === options.toolCallId);\n          const anyOptions = options;\n          const anyPart = part;\n          if (part != null) {\n            part.state = options.state;\n            anyPart.toolName = options.toolName;\n            anyPart.input = anyOptions.input;\n            anyPart.output = anyOptions.output;\n            anyPart.errorText = anyOptions.errorText;\n            anyPart.rawInput = (_a18 = anyOptions.rawInput) != null ? _a18 : anyPart.rawInput;\n            anyPart.preliminary = anyOptions.preliminary;\n            if (anyOptions.providerMetadata != null && part.state === "input-available") {\n              part.callProviderMetadata = anyOptions.providerMetadata;\n            }\n          } else {\n            state.message.parts.push({\n              type: "dynamic-tool",\n              toolName: options.toolName,\n              toolCallId: options.toolCallId,\n              state: options.state,\n              input: anyOptions.input,\n              output: anyOptions.output,\n              errorText: anyOptions.errorText,\n              preliminary: anyOptions.preliminary,\n              ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n            });\n          }\n        }\n        async function updateMessageMetadata(metadata) {\n          if (metadata != null) {\n            const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n            if (messageMetadataSchema != null) {\n              await validateTypes({\n                value: mergedMetadata,\n                schema: messageMetadataSchema\n              });\n            }\n            state.message.metadata = mergedMetadata;\n          }\n        }\n        switch (chunk.type) {\n          case "text-start": {\n            const textPart = {\n              type: "text",\n              text: "",\n              providerMetadata: chunk.providerMetadata,\n              state: "streaming"\n            };\n            state.activeTextParts[chunk.id] = textPart;\n            state.message.parts.push(textPart);\n            write();\n            break;\n          }\n          case "text-delta": {\n            const textPart = state.activeTextParts[chunk.id];\n            textPart.text += chunk.delta;\n            textPart.providerMetadata = (_a17 = chunk.providerMetadata) != null ? _a17 : textPart.providerMetadata;\n            write();\n            break;\n          }\n          case "text-end": {\n            const textPart = state.activeTextParts[chunk.id];\n            textPart.state = "done";\n            textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;\n            delete state.activeTextParts[chunk.id];\n            write();\n            break;\n          }\n          case "reasoning-start": {\n            const reasoningPart = {\n              type: "reasoning",\n              text: "",\n              providerMetadata: chunk.providerMetadata,\n              state: "streaming"\n            };\n            state.activeReasoningParts[chunk.id] = reasoningPart;\n            state.message.parts.push(reasoningPart);\n            write();\n            break;\n          }\n          case "reasoning-delta": {\n            const reasoningPart = state.activeReasoningParts[chunk.id];\n            reasoningPart.text += chunk.delta;\n            reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;\n            write();\n            break;\n          }\n          case "reasoning-end": {\n            const reasoningPart = state.activeReasoningParts[chunk.id];\n            reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;\n            reasoningPart.state = "done";\n            delete state.activeReasoningParts[chunk.id];\n            write();\n            break;\n          }\n          case "file": {\n            state.message.parts.push({\n              type: "file",\n              mediaType: chunk.mediaType,\n              url: chunk.url\n            });\n            write();\n            break;\n          }\n          case "source-url": {\n            state.message.parts.push({\n              type: "source-url",\n              sourceId: chunk.sourceId,\n              url: chunk.url,\n              title: chunk.title,\n              providerMetadata: chunk.providerMetadata\n            });\n            write();\n            break;\n          }\n          case "source-document": {\n            state.message.parts.push({\n              type: "source-document",\n              sourceId: chunk.sourceId,\n              mediaType: chunk.mediaType,\n              title: chunk.title,\n              filename: chunk.filename,\n              providerMetadata: chunk.providerMetadata\n            });\n            write();\n            break;\n          }\n          case "tool-input-start": {\n            const toolInvocations = state.message.parts.filter(isToolUIPart);\n            state.partialToolCalls[chunk.toolCallId] = {\n              text: "",\n              toolName: chunk.toolName,\n              index: toolInvocations.length,\n              dynamic: chunk.dynamic\n            };\n            if (chunk.dynamic) {\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "input-streaming",\n                input: undefined\n              });\n            } else {\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "input-streaming",\n                input: undefined,\n                providerExecuted: chunk.providerExecuted\n              });\n            }\n            write();\n            break;\n          }\n          case "tool-input-delta": {\n            const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n            partialToolCall.text += chunk.inputTextDelta;\n            const { value: partialArgs } = await parsePartialJson(partialToolCall.text);\n            if (partialToolCall.dynamic) {\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: partialToolCall.toolName,\n                state: "input-streaming",\n                input: partialArgs\n              });\n            } else {\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: partialToolCall.toolName,\n                state: "input-streaming",\n                input: partialArgs\n              });\n            }\n            write();\n            break;\n          }\n          case "tool-input-available": {\n            if (chunk.dynamic) {\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "input-available",\n                input: chunk.input,\n                providerMetadata: chunk.providerMetadata\n              });\n            } else {\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "input-available",\n                input: chunk.input,\n                providerExecuted: chunk.providerExecuted,\n                providerMetadata: chunk.providerMetadata\n              });\n            }\n            write();\n            if (onToolCall && !chunk.providerExecuted) {\n              await onToolCall({\n                toolCall: chunk\n              });\n            }\n            break;\n          }\n          case "tool-input-error": {\n            if (chunk.dynamic) {\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "output-error",\n                input: chunk.input,\n                errorText: chunk.errorText,\n                providerMetadata: chunk.providerMetadata\n              });\n            } else {\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "output-error",\n                input: undefined,\n                rawInput: chunk.input,\n                errorText: chunk.errorText,\n                providerExecuted: chunk.providerExecuted,\n                providerMetadata: chunk.providerMetadata\n              });\n            }\n            write();\n            break;\n          }\n          case "tool-output-available": {\n            if (chunk.dynamic) {\n              const toolInvocation = getDynamicToolInvocation(chunk.toolCallId);\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: toolInvocation.toolName,\n                state: "output-available",\n                input: toolInvocation.input,\n                output: chunk.output,\n                preliminary: chunk.preliminary\n              });\n            } else {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: getToolName(toolInvocation),\n                state: "output-available",\n                input: toolInvocation.input,\n                output: chunk.output,\n                providerExecuted: chunk.providerExecuted,\n                preliminary: chunk.preliminary\n              });\n            }\n            write();\n            break;\n          }\n          case "tool-output-error": {\n            if (chunk.dynamic) {\n              const toolInvocation = getDynamicToolInvocation(chunk.toolCallId);\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: toolInvocation.toolName,\n                state: "output-error",\n                input: toolInvocation.input,\n                errorText: chunk.errorText\n              });\n            } else {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: getToolName(toolInvocation),\n                state: "output-error",\n                input: toolInvocation.input,\n                rawInput: toolInvocation.rawInput,\n                errorText: chunk.errorText\n              });\n            }\n            write();\n            break;\n          }\n          case "start-step": {\n            state.message.parts.push({ type: "step-start" });\n            break;\n          }\n          case "finish-step": {\n            state.activeTextParts = {};\n            state.activeReasoningParts = {};\n            break;\n          }\n          case "start": {\n            if (chunk.messageId != null) {\n              state.message.id = chunk.messageId;\n            }\n            await updateMessageMetadata(chunk.messageMetadata);\n            if (chunk.messageId != null || chunk.messageMetadata != null) {\n              write();\n            }\n            break;\n          }\n          case "finish": {\n            await updateMessageMetadata(chunk.messageMetadata);\n            if (chunk.messageMetadata != null) {\n              write();\n            }\n            break;\n          }\n          case "message-metadata": {\n            await updateMessageMetadata(chunk.messageMetadata);\n            if (chunk.messageMetadata != null) {\n              write();\n            }\n            break;\n          }\n          case "error": {\n            onError == null || onError(new Error(chunk.errorText));\n            break;\n          }\n          default: {\n            if (isDataUIMessageChunk(chunk)) {\n              if ((dataPartSchemas == null ? undefined : dataPartSchemas[chunk.type]) != null) {\n                await validateTypes({\n                  value: chunk.data,\n                  schema: dataPartSchemas[chunk.type]\n                });\n              }\n              const dataChunk = chunk;\n              if (dataChunk.transient) {\n                onData == null || onData(dataChunk);\n                break;\n              }\n              const existingUIPart = dataChunk.id != null ? state.message.parts.find((chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id) : undefined;\n              if (existingUIPart != null) {\n                existingUIPart.data = dataChunk.data;\n              } else {\n                state.message.parts.push(dataChunk);\n              }\n              onData == null || onData(dataChunk);\n              write();\n            }\n          }\n        }\n        controller.enqueue(chunk);\n      });\n    }\n  }));\n}\nfunction handleUIMessageStreamFinish({\n  messageId,\n  originalMessages = [],\n  onFinish,\n  onError,\n  stream\n}) {\n  let lastMessage = originalMessages == null ? undefined : originalMessages[originalMessages.length - 1];\n  if ((lastMessage == null ? undefined : lastMessage.role) !== "assistant") {\n    lastMessage = undefined;\n  } else {\n    messageId = lastMessage.id;\n  }\n  let isAborted2 = false;\n  const idInjectedStream = stream.pipeThrough(new TransformStream({\n    transform(chunk, controller) {\n      if (chunk.type === "start") {\n        const startChunk = chunk;\n        if (startChunk.messageId == null && messageId != null) {\n          startChunk.messageId = messageId;\n        }\n      }\n      if (chunk.type === "abort") {\n        isAborted2 = true;\n      }\n      controller.enqueue(chunk);\n    }\n  }));\n  if (onFinish == null) {\n    return idInjectedStream;\n  }\n  const state = createStreamingUIMessageState({\n    lastMessage: lastMessage ? structuredClone(lastMessage) : undefined,\n    messageId: messageId != null ? messageId : ""\n  });\n  const runUpdateMessageJob = async (job) => {\n    await job({ state, write: () => {} });\n  };\n  let finishCalled = false;\n  const callOnFinish = async () => {\n    if (finishCalled || !onFinish) {\n      return;\n    }\n    finishCalled = true;\n    const isContinuation = state.message.id === (lastMessage == null ? undefined : lastMessage.id);\n    await onFinish({\n      isAborted: isAborted2,\n      isContinuation,\n      responseMessage: state.message,\n      messages: [\n        ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,\n        state.message\n      ]\n    });\n  };\n  return processUIMessageStream({\n    stream: idInjectedStream,\n    runUpdateMessageJob,\n    onError\n  }).pipeThrough(new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk);\n    },\n    async cancel() {\n      await callOnFinish();\n    },\n    async flush() {\n      await callOnFinish();\n    }\n  }));\n}\nvar originalGenerateId2 = createIdGenerator({\n  prefix: "aitxt",\n  size: 24\n});\nfunction convertToModelMessages(messages, options) {\n  const modelMessages = [];\n  if (options == null ? undefined : options.ignoreIncompleteToolCalls) {\n    messages = messages.map((message) => ({\n      ...message,\n      parts: message.parts.filter((part) => !isToolOrDynamicToolUIPart(part) || part.state !== "input-streaming" && part.state !== "input-available")\n    }));\n  }\n  for (const message of messages) {\n    switch (message.role) {\n      case "system": {\n        const textParts = message.parts.filter((part) => part.type === "text");\n        const providerMetadata = textParts.reduce((acc, part) => {\n          if (part.providerMetadata != null) {\n            return { ...acc, ...part.providerMetadata };\n          }\n          return acc;\n        }, {});\n        modelMessages.push({\n          role: "system",\n          content: textParts.map((part) => part.text).join(""),\n          ...Object.keys(providerMetadata).length > 0 ? { providerOptions: providerMetadata } : {}\n        });\n        break;\n      }\n      case "user": {\n        modelMessages.push({\n          role: "user",\n          content: message.parts.filter((part) => part.type === "text" || part.type === "file").map((part) => {\n            switch (part.type) {\n              case "text":\n                return {\n                  type: "text",\n                  text: part.text,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                };\n              case "file":\n                return {\n                  type: "file",\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                };\n              default:\n                return part;\n            }\n          })\n        });\n        break;\n      }\n      case "assistant": {\n        if (message.parts != null) {\n          let processBlock2 = function() {\n            var _a17, _b;\n            if (block.length === 0) {\n              return;\n            }\n            const content = [];\n            for (const part of block) {\n              if (part.type === "text") {\n                content.push({\n                  type: "text",\n                  text: part.text,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                });\n              } else if (part.type === "file") {\n                content.push({\n                  type: "file",\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url\n                });\n              } else if (part.type === "reasoning") {\n                content.push({\n                  type: "reasoning",\n                  text: part.text,\n                  providerOptions: part.providerMetadata\n                });\n              } else if (part.type === "dynamic-tool") {\n                const toolName = part.toolName;\n                if (part.state !== "input-streaming") {\n                  content.push({\n                    type: "tool-call",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.input,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                }\n              } else if (isToolUIPart(part)) {\n                const toolName = getToolName(part);\n                if (part.state !== "input-streaming") {\n                  content.push({\n                    type: "tool-call",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.state === "output-error" ? (_a17 = part.input) != null ? _a17 : part.rawInput : part.input,\n                    providerExecuted: part.providerExecuted,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                  if (part.providerExecuted === true && (part.state === "output-available" || part.state === "output-error")) {\n                    content.push({\n                      type: "tool-result",\n                      toolCallId: part.toolCallId,\n                      toolName,\n                      output: createToolModelOutput({\n                        output: part.state === "output-error" ? part.errorText : part.output,\n                        tool: (_b = options == null ? undefined : options.tools) == null ? undefined : _b[toolName],\n                        errorMode: part.state === "output-error" ? "json" : "none"\n                      })\n                    });\n                  }\n                }\n              } else {\n                const _exhaustiveCheck = part;\n                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n              }\n            }\n            modelMessages.push({\n              role: "assistant",\n              content\n            });\n            const toolParts = block.filter((part) => isToolUIPart(part) && part.providerExecuted !== true || part.type === "dynamic-tool");\n            if (toolParts.length > 0) {\n              modelMessages.push({\n                role: "tool",\n                content: toolParts.map((toolPart) => {\n                  var _a18;\n                  switch (toolPart.state) {\n                    case "output-error":\n                    case "output-available": {\n                      const toolName = toolPart.type === "dynamic-tool" ? toolPart.toolName : getToolName(toolPart);\n                      return {\n                        type: "tool-result",\n                        toolCallId: toolPart.toolCallId,\n                        toolName,\n                        output: createToolModelOutput({\n                          output: toolPart.state === "output-error" ? toolPart.errorText : toolPart.output,\n                          tool: (_a18 = options == null ? undefined : options.tools) == null ? undefined : _a18[toolName],\n                          errorMode: toolPart.state === "output-error" ? "text" : "none"\n                        })\n                      };\n                    }\n                    default: {\n                      return null;\n                    }\n                  }\n                }).filter((output) => output != null)\n              });\n            }\n            block = [];\n          };\n          var processBlock = processBlock2;\n          let block = [];\n          for (const part of message.parts) {\n            if (part.type === "text" || part.type === "reasoning" || part.type === "file" || part.type === "dynamic-tool" || isToolUIPart(part)) {\n              block.push(part);\n            } else if (part.type === "step-start") {\n              processBlock2();\n            }\n          }\n          processBlock2();\n          break;\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = message.role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return modelMessages;\n}\nvar originalGenerateId3 = createIdGenerator({ prefix: "aiobj", size: 24 });\nvar originalGenerateId4 = createIdGenerator({ prefix: "aiobj", size: 24 });\nvar output_exports = {};\n__export2(output_exports, {\n  object: () => object2,\n  text: () => text\n});\nvar text = () => ({\n  type: "text",\n  responseFormat: { type: "text" },\n  async parsePartial({ text: text2 }) {\n    return { partial: text2 };\n  },\n  async parseOutput({ text: text2 }) {\n    return text2;\n  }\n});\nvar object2 = ({\n  schema: inputSchema\n}) => {\n  const schema = asSchema(inputSchema);\n  return {\n    type: "object",\n    responseFormat: {\n      type: "json",\n      schema: schema.jsonSchema\n    },\n    async parsePartial({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case "failed-parse":\n        case "undefined-input":\n          return;\n        case "repaired-parse":\n        case "successful-parse":\n          return {\n            partial: result.value\n          };\n        default: {\n          const _exhaustiveCheck = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    async parseOutput({ text: text2 }, context) {\n      const parseResult = await safeParseJSON({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: "No object generated: could not parse the response.",\n          cause: parseResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      const validationResult = await safeValidateTypes({\n        value: parseResult.value,\n        schema\n      });\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: "No object generated: response did not match schema.",\n          cause: validationResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      return validationResult.value;\n    }\n  };\n};\nvar name16 = "AI_NoSuchProviderError";\nvar marker16 = `vercel.ai.error.${name16}`;\nvar symbol16 = Symbol.for(marker16);\nvar _a16;\n_a16 = symbol16;\nvar ClientOrServerImplementationSchema = exports_external.looseObject({\n  name: exports_external.string(),\n  version: exports_external.string()\n});\nvar BaseParamsSchema = exports_external.looseObject({\n  _meta: exports_external.optional(exports_external.object({}).loose())\n});\nvar ResultSchema = BaseParamsSchema;\nvar RequestSchema = exports_external.object({\n  method: exports_external.string(),\n  params: exports_external.optional(BaseParamsSchema)\n});\nvar ServerCapabilitiesSchema = exports_external.looseObject({\n  experimental: exports_external.optional(exports_external.object({}).loose()),\n  logging: exports_external.optional(exports_external.object({}).loose()),\n  prompts: exports_external.optional(exports_external.looseObject({\n    listChanged: exports_external.optional(exports_external.boolean())\n  })),\n  resources: exports_external.optional(exports_external.looseObject({\n    subscribe: exports_external.optional(exports_external.boolean()),\n    listChanged: exports_external.optional(exports_external.boolean())\n  })),\n  tools: exports_external.optional(exports_external.looseObject({\n    listChanged: exports_external.optional(exports_external.boolean())\n  }))\n});\nvar InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: exports_external.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: exports_external.optional(exports_external.string())\n});\nvar PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: exports_external.optional(exports_external.string())\n});\nvar ToolSchema = exports_external.object({\n  name: exports_external.string(),\n  description: exports_external.optional(exports_external.string()),\n  inputSchema: exports_external.object({\n    type: exports_external.literal("object"),\n    properties: exports_external.optional(exports_external.object({}).loose())\n  }).loose()\n}).loose();\nvar ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: exports_external.array(ToolSchema)\n});\nvar TextContentSchema = exports_external.object({\n  type: exports_external.literal("text"),\n  text: exports_external.string()\n}).loose();\nvar ImageContentSchema = exports_external.object({\n  type: exports_external.literal("image"),\n  data: exports_external.base64(),\n  mimeType: exports_external.string()\n}).loose();\nvar ResourceContentsSchema = exports_external.object({\n  uri: exports_external.string(),\n  mimeType: exports_external.optional(exports_external.string())\n}).loose();\nvar TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: exports_external.string()\n});\nvar BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: exports_external.base64()\n});\nvar EmbeddedResourceSchema = exports_external.object({\n  type: exports_external.literal("resource"),\n  resource: exports_external.union([TextResourceContentsSchema, BlobResourceContentsSchema])\n}).loose();\nvar CallToolResultSchema = ResultSchema.extend({\n  content: exports_external.array(exports_external.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])),\n  isError: exports_external.boolean().default(false).optional()\n}).or(ResultSchema.extend({\n  toolResult: exports_external.unknown()\n}));\nvar JSONRPC_VERSION = "2.0";\nvar JSONRPCRequestSchema = exports_external.object({\n  jsonrpc: exports_external.literal(JSONRPC_VERSION),\n  id: exports_external.union([exports_external.string(), exports_external.number().int()])\n}).merge(RequestSchema).strict();\nvar JSONRPCResponseSchema = exports_external.object({\n  jsonrpc: exports_external.literal(JSONRPC_VERSION),\n  id: exports_external.union([exports_external.string(), exports_external.number().int()]),\n  result: ResultSchema\n}).strict();\nvar JSONRPCErrorSchema = exports_external.object({\n  jsonrpc: exports_external.literal(JSONRPC_VERSION),\n  id: exports_external.union([exports_external.string(), exports_external.number().int()]),\n  error: exports_external.object({\n    code: exports_external.number().int(),\n    message: exports_external.string(),\n    data: exports_external.optional(exports_external.unknown())\n  })\n}).strict();\nvar JSONRPCNotificationSchema = exports_external.object({\n  jsonrpc: exports_external.literal(JSONRPC_VERSION)\n}).merge(exports_external.object({\n  method: exports_external.string(),\n  params: exports_external.optional(BaseParamsSchema)\n})).strict();\nvar JSONRPCMessageSchema = exports_external.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema\n]);\nvar textUIPartSchema = exports_external.object({\n  type: exports_external.literal("text"),\n  text: exports_external.string(),\n  state: exports_external.enum(["streaming", "done"]).optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar reasoningUIPartSchema = exports_external.object({\n  type: exports_external.literal("reasoning"),\n  text: exports_external.string(),\n  state: exports_external.enum(["streaming", "done"]).optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar sourceUrlUIPartSchema = exports_external.object({\n  type: exports_external.literal("source-url"),\n  sourceId: exports_external.string(),\n  url: exports_external.string(),\n  title: exports_external.string().optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar sourceDocumentUIPartSchema = exports_external.object({\n  type: exports_external.literal("source-document"),\n  sourceId: exports_external.string(),\n  mediaType: exports_external.string(),\n  title: exports_external.string(),\n  filename: exports_external.string().optional(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar fileUIPartSchema = exports_external.object({\n  type: exports_external.literal("file"),\n  mediaType: exports_external.string(),\n  filename: exports_external.string().optional(),\n  url: exports_external.string(),\n  providerMetadata: providerMetadataSchema.optional()\n});\nvar stepStartUIPartSchema = exports_external.object({\n  type: exports_external.literal("step-start")\n});\nvar dataUIPartSchema = exports_external.object({\n  type: exports_external.string().startsWith("data-"),\n  id: exports_external.string().optional(),\n  data: exports_external.unknown()\n});\nvar dynamicToolUIPartSchemas = [\n  exports_external.object({\n    type: exports_external.literal("dynamic-tool"),\n    toolName: exports_external.string(),\n    toolCallId: exports_external.string(),\n    state: exports_external.literal("input-streaming"),\n    input: exports_external.unknown().optional(),\n    output: exports_external.never().optional(),\n    errorText: exports_external.never().optional()\n  }),\n  exports_external.object({\n    type: exports_external.literal("dynamic-tool"),\n    toolName: exports_external.string(),\n    toolCallId: exports_external.string(),\n    state: exports_external.literal("input-available"),\n    input: exports_external.unknown(),\n    output: exports_external.never().optional(),\n    errorText: exports_external.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.object({\n    type: exports_external.literal("dynamic-tool"),\n    toolName: exports_external.string(),\n    toolCallId: exports_external.string(),\n    state: exports_external.literal("output-available"),\n    input: exports_external.unknown(),\n    output: exports_external.unknown(),\n    errorText: exports_external.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional(),\n    preliminary: exports_external.boolean().optional()\n  }),\n  exports_external.object({\n    type: exports_external.literal("dynamic-tool"),\n    toolName: exports_external.string(),\n    toolCallId: exports_external.string(),\n    state: exports_external.literal("output-error"),\n    input: exports_external.unknown(),\n    output: exports_external.never().optional(),\n    errorText: exports_external.string(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  })\n];\nvar toolUIPartSchemas = [\n  exports_external.object({\n    type: exports_external.string().startsWith("tool-"),\n    toolCallId: exports_external.string(),\n    state: exports_external.literal("input-streaming"),\n    input: exports_external.unknown().optional(),\n    output: exports_external.never().optional(),\n    errorText: exports_external.never().optional()\n  }),\n  exports_external.object({\n    type: exports_external.string().startsWith("tool-"),\n    toolCallId: exports_external.string(),\n    state: exports_external.literal("input-available"),\n    input: exports_external.unknown(),\n    output: exports_external.never().optional(),\n    errorText: exports_external.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.object({\n    type: exports_external.string().startsWith("tool-"),\n    toolCallId: exports_external.string(),\n    state: exports_external.literal("output-available"),\n    input: exports_external.unknown(),\n    output: exports_external.unknown(),\n    errorText: exports_external.never().optional(),\n    callProviderMetadata: providerMetadataSchema.optional(),\n    preliminary: exports_external.boolean().optional()\n  }),\n  exports_external.object({\n    type: exports_external.string().startsWith("tool-"),\n    toolCallId: exports_external.string(),\n    state: exports_external.literal("output-error"),\n    input: exports_external.unknown(),\n    output: exports_external.never().optional(),\n    errorText: exports_external.string(),\n    callProviderMetadata: providerMetadataSchema.optional()\n  })\n];\nvar uiMessageSchema = exports_external.object({\n  id: exports_external.string(),\n  role: exports_external.enum(["system", "user", "assistant"]),\n  metadata: exports_external.unknown().optional(),\n  parts: exports_external.array(exports_external.union([\n    textUIPartSchema,\n    reasoningUIPartSchema,\n    sourceUrlUIPartSchema,\n    sourceDocumentUIPartSchema,\n    fileUIPartSchema,\n    stepStartUIPartSchema,\n    dataUIPartSchema,\n    ...dynamicToolUIPartSchemas,\n    ...toolUIPartSchemas\n  ]))\n});\nfunction createUIMessageStream({\n  execute,\n  onError = getErrorMessage2,\n  originalMessages,\n  onFinish,\n  generateId: generateId3 = generateId\n}) {\n  let controller;\n  const ongoingStreamPromises = [];\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    }\n  });\n  function safeEnqueue(data) {\n    try {\n      controller.enqueue(data);\n    } catch (error38) {}\n  }\n  try {\n    const result = execute({\n      writer: {\n        write(part) {\n          safeEnqueue(part);\n        },\n        merge(streamArg) {\n          ongoingStreamPromises.push((async () => {\n            const reader = streamArg.getReader();\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done)\n                break;\n              safeEnqueue(value);\n            }\n          })().catch((error38) => {\n            safeEnqueue({\n              type: "error",\n              errorText: onError(error38)\n            });\n          }));\n        },\n        onError\n      }\n    });\n    if (result) {\n      ongoingStreamPromises.push(result.catch((error38) => {\n        safeEnqueue({\n          type: "error",\n          errorText: onError(error38)\n        });\n      }));\n    }\n  } catch (error38) {\n    safeEnqueue({\n      type: "error",\n      errorText: onError(error38)\n    });\n  }\n  const waitForStreams = new Promise(async (resolve2) => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve2();\n  });\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error38) {}\n  });\n  return handleUIMessageStreamFinish({\n    stream,\n    messageId: generateId3(),\n    originalMessages,\n    onFinish,\n    onError\n  });\n}\n\n// ../../node_modules/blink/dist/browser/index.browser-D8y5NucV.js\nfunction i2(e2) {\n  return typeof e2 == `object` && !!e2 && typeof e2[Symbol.asyncIterator] == `function`;\n}\nvar a2 = class extends Error {\n  constructor(e2, t2) {\n    super(e2), this.response = t2;\n  }\n};\nvar s2 = Object.freeze({ withContext(e2, t2) {\n  let n2 = {};\n  for (let r2 of Object.keys(e2))\n    n2[r2] = e2[r2].withContext(t2);\n  return n2;\n}, with(e2, t2) {\n  let n2 = {};\n  for (let r2 of Object.keys(e2))\n    n2[r2] = e2[r2].withContext(t2);\n  return n2;\n}, async withApproval(o2) {\n  let s3 = {};\n  for (let [e2, t2] of Object.entries(o2.tools)) {\n    let n2 = t2.execute;\n    s3[e2] = { ...t2, execute: async (e3, r2) => t2.autoApprove && n2 && await t2.autoApprove(e3) ? n2(e3, r2) : { type: `tool-approval`, outcome: `pending` } };\n  }\n  let l2 = o2.messages[o2.messages.length - 1];\n  if (!l2?.parts)\n    return s3;\n  let u2 = [];\n  for (let e2 of l2.parts) {\n    if (!isToolUIPart(e2))\n      continue;\n    let t2 = getToolName(e2), i3 = o2.tools[t2];\n    i3 && e2.state === `output-available` && i3.execute && c2(e2.output) && e2.output.outcome === `approved` && u2.push({ toolName: getToolName(e2), tool: i3, input: e2.input, toolCallId: e2.toolCallId });\n  }\n  if (u2.length > 0) {\n    let n2 = createUIMessageStream({ execute: async ({ writer: t2 }) => {\n      t2.write({ type: `start-step` }), await Promise.all(u2.map(async (n3) => {\n        if (!n3.tool.execute)\n          throw Error(`Tool does not support execute.`);\n        t2.write({ type: `tool-input-available`, toolCallId: n3.toolCallId, toolName: n3.toolName, input: n3.input });\n        try {\n          let r2 = await n3.tool.execute(n3.input, { toolCallId: n3.toolCallId, messages: convertToModelMessages(o2.messages, { tools: o2.tools }), abortSignal: o2.abortSignal });\n          if (i2(r2))\n            for await (let e2 of r2)\n              t2.write({ type: `tool-output-available`, toolCallId: n3.toolCallId, output: e2, preliminary: true });\n          t2.write({ type: `tool-output-available`, toolCallId: n3.toolCallId, output: r2 });\n        } catch (e2) {\n          t2.write({ type: `tool-output-error`, toolCallId: n3.toolCallId, errorText: e2 instanceof Error ? e2.message : String(e2) });\n        }\n      })), t2.write({ type: `finish` });\n    } });\n    throw new a2(`Executing tools`, n2);\n  }\n  return s3;\n}, prefix(e2, t2) {\n  let n2 = {};\n  for (let [r2, i3] of Object.entries(e2))\n    n2[`${t2}${r2}`] = i3;\n  return n2;\n} });\nfunction c2(e2) {\n  return typeof e2 == `object` && !!e2 && `type` in e2 && e2.type === `tool-approval`;\n}\n\n// ../../node_modules/blink/dist/browser/agent/client/index.js\nvar a3 = class extends Error {\n  constructor(e2, t2) {\n    super(e2), this.name = `ParseError`, this.type = t2.type, this.field = t2.field, this.value = t2.value, this.line = t2.line;\n  }\n};\nfunction o2(e2) {}\nfunction s3(e2) {\n  if (typeof e2 == `function`)\n    throw TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");\n  let { onEvent: t2 = o2, onError: n2 = o2, onRetry: r2 = o2, onComment: i3 } = e2, s4 = ``, l2 = true, u3, d2 = ``, f3 = ``;\n  function p3(e3) {\n    let t3 = l2 ? e3.replace(/^\\xEF\\xBB\\xBF/, ``) : e3, [n3, r3] = c3(`${s4}${t3}`);\n    for (let e4 of n3)\n      m3(e4);\n    s4 = r3, l2 = false;\n  }\n  function m3(e3) {\n    if (e3 === ``) {\n      g3();\n      return;\n    }\n    if (e3.startsWith(`:`)) {\n      i3 && i3(e3.slice(e3.startsWith(`: `) ? 2 : 1));\n      return;\n    }\n    let t3 = e3.indexOf(`:`);\n    if (t3 !== -1) {\n      let n3 = e3.slice(0, t3), r3 = e3[t3 + 1] === ` ` ? 2 : 1, i4 = e3.slice(t3 + r3);\n      h3(n3, i4, e3);\n      return;\n    }\n    h3(e3, ``, e3);\n  }\n  function h3(e3, t3, i4) {\n    switch (e3) {\n      case `event`:\n        f3 = t3;\n        break;\n      case `data`:\n        d2 = `${d2}${t3}\n`;\n        break;\n      case `id`:\n        u3 = t3.includes(`\\x00`) ? undefined : t3;\n        break;\n      case `retry`:\n        /^\\d+$/.test(t3) ? r2(parseInt(t3, 10)) : n2(new a3(`Invalid \\`retry\\` value: "${t3}"`, { type: `invalid-retry`, value: t3, line: i4 }));\n        break;\n      default:\n        n2(new a3(`Unknown field "${e3.length > 20 ? `${e3.slice(0, 20)}` : e3}"`, { type: `unknown-field`, field: e3, value: t3, line: i4 }));\n        break;\n    }\n  }\n  function g3() {\n    d2.length > 0 && t2({ id: u3, event: f3 || undefined, data: d2.endsWith(`\n`) ? d2.slice(0, -1) : d2 }), u3 = undefined, d2 = ``, f3 = ``;\n  }\n  function _3(e3 = {}) {\n    s4 && e3.consume && m3(s4), l2 = true, u3 = undefined, d2 = ``, f3 = ``, s4 = ``;\n  }\n  return { feed: p3, reset: _3 };\n}\nfunction c3(e2) {\n  let t2 = [], n2 = ``, r2 = 0;\n  for (;r2 < e2.length; ) {\n    let i3 = e2.indexOf(`\\r`, r2), a4 = e2.indexOf(`\n`, r2), o3 = -1;\n    if (i3 !== -1 && a4 !== -1 ? o3 = Math.min(i3, a4) : i3 === -1 ? a4 !== -1 && (o3 = a4) : o3 = i3 === e2.length - 1 ? -1 : i3, o3 === -1) {\n      n2 = e2.slice(r2);\n      break;\n    } else {\n      let n3 = e2.slice(r2, o3);\n      t2.push(n3), r2 = o3 + 1, e2[r2 - 1] === `\\r` && e2[r2] === `\n` && r2++;\n    }\n  }\n  return [t2, n2];\n}\nvar l2 = class extends TransformStream {\n  constructor({ onError: e2, onRetry: t2, onComment: n2 } = {}) {\n    let r2;\n    super({ start(i3) {\n      r2 = s3({ onEvent: (e3) => {\n        i3.enqueue(e3);\n      }, onError(t3) {\n        e2 === `terminate` ? i3.error(t3) : typeof e2 == `function` && e2(t3);\n      }, onRetry: t2, onComment: n2 });\n    }, transform(e3) {\n      r2.feed(e3);\n    } });\n  }\n};\nvar b2 = `vercel.ai.error`;\nvar x3 = Symbol.for(b2);\nvar S2;\nvar C2 = class e2 extends Error {\n  constructor({ name: e3, message: t2, cause: n2 }) {\n    super(t2), this[S2] = true, this.name = e3, this.cause = n2;\n  }\n  static isInstance(t2) {\n    return e2.hasMarker(t2, b2);\n  }\n  static hasMarker(e3, t2) {\n    let n2 = Symbol.for(t2);\n    return typeof e3 == `object` && !!e3 && n2 in e3 && typeof e3[n2] == `boolean` && e3[n2] === true;\n  }\n};\nS2 = x3;\nvar w2 = C2;\nvar ee2 = `AI_APICallError`;\nvar te2 = `vercel.ai.error.${ee2}`;\nvar ne2 = Symbol.for(te2);\nvar re2;\nvar T2 = class extends w2 {\n  constructor({ message: e3, url: t2, requestBodyValues: n2, statusCode: r2, responseHeaders: i3, responseBody: a4, cause: o3, isRetryable: s4 = r2 != null && (r2 === 408 || r2 === 409 || r2 === 429 || r2 >= 500), data: c4 }) {\n    super({ name: ee2, message: e3, cause: o3 }), this[re2] = true, this.url = t2, this.requestBodyValues = n2, this.statusCode = r2, this.responseHeaders = i3, this.responseBody = a4, this.isRetryable = s4, this.data = c4;\n  }\n  static isInstance(e3) {\n    return w2.hasMarker(e3, te2);\n  }\n};\nre2 = ne2;\nvar ie2 = `AI_EmptyResponseBodyError`;\nvar ae2 = `vercel.ai.error.${ie2}`;\nvar oe2 = Symbol.for(ae2);\nvar se2;\nvar ce2 = class extends w2 {\n  constructor({ message: e3 = `Empty response body` } = {}) {\n    super({ name: ie2, message: e3 }), this[se2] = true;\n  }\n  static isInstance(e3) {\n    return w2.hasMarker(e3, ae2);\n  }\n};\nse2 = oe2;\nfunction le2(e3) {\n  return e3 == null ? `unknown error` : typeof e3 == `string` ? e3 : e3 instanceof Error ? e3.message : JSON.stringify(e3);\n}\nvar ue2 = `AI_InvalidArgumentError`;\nvar de2 = `vercel.ai.error.${ue2}`;\nvar fe2 = Symbol.for(de2);\nvar pe2;\nvar me2 = class extends w2 {\n  constructor({ message: e3, cause: t2, argument: n2 }) {\n    super({ name: ue2, message: e3, cause: t2 }), this[pe2] = true, this.argument = n2;\n  }\n  static isInstance(e3) {\n    return w2.hasMarker(e3, de2);\n  }\n};\npe2 = fe2;\nvar he2 = `AI_InvalidPromptError`;\nvar ge2 = `vercel.ai.error.${he2}`;\nvar _e2 = Symbol.for(ge2);\nvar ve2;\nvar ye = class extends w2 {\n  constructor({ prompt: e3, message: t2, cause: n2 }) {\n    super({ name: he2, message: `Invalid prompt: ${t2}`, cause: n2 }), this[ve2] = true, this.prompt = e3;\n  }\n  static isInstance(e3) {\n    return w2.hasMarker(e3, ge2);\n  }\n};\nve2 = _e2;\nvar be = `AI_InvalidResponseDataError`;\nvar xe = `vercel.ai.error.${be}`;\nvar Se = Symbol.for(xe);\nvar Ce;\nvar E2 = class extends w2 {\n  constructor({ data: e3, message: t2 = `Invalid response data: ${JSON.stringify(e3)}.` }) {\n    super({ name: be, message: t2 }), this[Ce] = true, this.data = e3;\n  }\n  static isInstance(e3) {\n    return w2.hasMarker(e3, xe);\n  }\n};\nCe = Se;\nvar we = `AI_JSONParseError`;\nvar Te = `vercel.ai.error.${we}`;\nvar Ee = Symbol.for(Te);\nvar De;\nvar D2 = class extends w2 {\n  constructor({ text: e3, cause: t2 }) {\n    super({ name: we, message: `JSON parsing failed: Text: ${e3}.\nError message: ${le2(t2)}`, cause: t2 }), this[De] = true, this.text = e3;\n  }\n  static isInstance(e3) {\n    return w2.hasMarker(e3, Te);\n  }\n};\nDe = Ee;\nvar Oe = `AI_LoadAPIKeyError`;\nvar ke = `vercel.ai.error.${Oe}`;\nvar Ae = Symbol.for(ke);\nvar je;\nvar O2 = class extends w2 {\n  constructor({ message: e3 }) {\n    super({ name: Oe, message: e3 }), this[je] = true;\n  }\n  static isInstance(e3) {\n    return w2.hasMarker(e3, ke);\n  }\n};\nje = Ae;\nvar Me = `AI_NoSuchModelError`;\nvar Ne = `vercel.ai.error.${Me}`;\nvar Pe = Symbol.for(Ne);\nvar Fe;\nvar k2 = class extends w2 {\n  constructor({ errorName: e3 = Me, modelId: t2, modelType: n2, message: r2 = `No such ${n2}: ${t2}` }) {\n    super({ name: e3, message: r2 }), this[Fe] = true, this.modelId = t2, this.modelType = n2;\n  }\n  static isInstance(e3) {\n    return w2.hasMarker(e3, Ne);\n  }\n};\nFe = Pe;\nvar Ie = `AI_TooManyEmbeddingValuesForCallError`;\nvar Le = `vercel.ai.error.${Ie}`;\nvar Re = Symbol.for(Le);\nvar ze;\nvar Be = class extends w2 {\n  constructor(e3) {\n    super({ name: Ie, message: `Too many values for a single embedding call. The ${e3.provider} model "${e3.modelId}" can only embed up to ${e3.maxEmbeddingsPerCall} values per call, but ${e3.values.length} values were provided.` }), this[ze] = true, this.provider = e3.provider, this.modelId = e3.modelId, this.maxEmbeddingsPerCall = e3.maxEmbeddingsPerCall, this.values = e3.values;\n  }\n  static isInstance(e3) {\n    return w2.hasMarker(e3, Le);\n  }\n};\nze = Re;\nvar Ve = `AI_TypeValidationError`;\nvar He = `vercel.ai.error.${Ve}`;\nvar Ue = Symbol.for(He);\nvar We;\nvar Ge = class e3 extends w2 {\n  constructor({ value: e4, cause: t2 }) {\n    super({ name: Ve, message: `Type validation failed: Value: ${JSON.stringify(e4)}.\nError message: ${le2(t2)}`, cause: t2 }), this[We] = true, this.value = e4;\n  }\n  static isInstance(e4) {\n    return w2.hasMarker(e4, He);\n  }\n  static wrap({ value: t2, cause: n2 }) {\n    return e3.isInstance(n2) && n2.value === t2 ? n2 : new e3({ value: t2, cause: n2 });\n  }\n};\nWe = Ue;\nvar A2 = Ge;\nvar Ke = `AI_UnsupportedFunctionalityError`;\nvar qe = `vercel.ai.error.${Ke}`;\nvar Je = Symbol.for(qe);\nvar Ye;\nvar j2 = class extends w2 {\n  constructor({ functionality: e4, message: t2 = `\'${e4}\' functionality not supported.` }) {\n    super({ name: Ke, message: t2 }), this[Ye] = true, this.functionality = e4;\n  }\n  static isInstance(e4) {\n    return w2.hasMarker(e4, qe);\n  }\n};\nYe = Je;\nfunction M2(...e4) {\n  return e4.reduce((e5, t2) => ({ ...e5, ...t2 ?? {} }), {});\n}\nfunction N2(e4) {\n  return Object.fromEntries([...e4.headers]);\n}\nfunction Xe(e4 = globalThis) {\n  return e4.window ? `runtime/browser` : e4.navigator?.userAgent ? `runtime/${e4.navigator.userAgent.toLowerCase()}` : e4.process?.versions?.node ? `runtime/node.js/${e4.process.version.substring(0)}` : e4.EdgeRuntime ? `runtime/vercel-edge` : `runtime/unknown`;\n}\nfunction Ze(e4) {\n  return Object.fromEntries(Object.entries(e4).filter(([e5, t2]) => t2 != null));\n}\nfunction P2(e4, ...t2) {\n  let n2 = Ze(e4 ?? {}), r2 = new Headers(n2), i3 = r2.get(`user-agent`) || ``;\n  return r2.set(`user-agent`, [i3, ...t2].filter(Boolean).join(` `)), Object.fromEntries(r2);\n}\nvar F2 = (({ prefix: e4, size: t2 = 16, alphabet: n2 = `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`, separator: r2 = `-` } = {}) => {\n  let i3 = () => {\n    let e5 = n2.length, r3 = Array(t2);\n    for (let i4 = 0;i4 < t2; i4++)\n      r3[i4] = n2[Math.random() * e5 | 0];\n    return r3.join(``);\n  };\n  if (e4 == null)\n    return i3;\n  if (n2.includes(r2))\n    throw new me2({ argument: `separator`, message: `The separator "${r2}" must not be part of the alphabet "${n2}".` });\n  return () => `${e4}${r2}${i3()}`;\n})();\nfunction Qe(e4) {\n  return (e4 instanceof Error || e4 instanceof DOMException) && (e4.name === `AbortError` || e4.name === `ResponseAborted` || e4.name === `TimeoutError`);\n}\nvar $e = [`fetch failed`, `failed to fetch`];\nfunction et({ error: e4, url: t2, requestBodyValues: n2 }) {\n  if (Qe(e4))\n    return e4;\n  if (e4 instanceof TypeError && $e.includes(e4.message.toLowerCase())) {\n    let r2 = e4.cause;\n    if (r2 != null)\n      return new T2({ message: `Cannot connect to API: ${r2.message}`, cause: r2, url: t2, requestBodyValues: n2, isRetryable: true });\n  }\n  return e4;\n}\nvar tt = `3.0.10`;\nfunction I2({ apiKey: e4, environmentVariableName: t2, apiKeyParameterName: n2 = `apiKey`, description: r2 }) {\n  if (typeof e4 == `string`)\n    return e4;\n  if (e4 != null)\n    throw new O2({ message: `${r2} API key must be a string.` });\n  if (typeof process > `u`)\n    throw new O2({ message: `${r2} API key is missing. Pass it using the \'${n2}\' parameter. Environment variables is not supported in this environment.` });\n  if (e4 = process.env[t2], e4 == null)\n    throw new O2({ message: `${r2} API key is missing. Pass it using the \'${n2}\' parameter or the ${t2} environment variable.` });\n  if (typeof e4 != `string`)\n    throw new O2({ message: `${r2} API key must be a string. The value of the ${t2} environment variable is not a string.` });\n  return e4;\n}\nfunction nt({ settingValue: e4, environmentVariableName: t2 }) {\n  if (typeof e4 == `string` || !(e4 != null || typeof process > `u`) && (e4 = process.env[t2], !(e4 == null || typeof e4 != `string`)))\n    return e4;\n}\nfunction rt(e4) {\n  let [t2, n2 = ``] = e4.toLowerCase().split(`/`);\n  return { mpeg: `mp3`, "x-wav": `wav`, opus: `ogg`, mp4: `m4a`, "x-m4a": `m4a` }[n2] ?? n2;\n}\nvar it = /"__proto__"\\s*:/;\nvar at = /"constructor"\\s*:/;\nfunction ot(e4) {\n  let t2 = JSON.parse(e4);\n  return typeof t2 != `object` || !t2 || it.test(e4) === false && at.test(e4) === false ? t2 : st(t2);\n}\nfunction st(e4) {\n  let t2 = [e4];\n  for (;t2.length; ) {\n    let e5 = t2;\n    t2 = [];\n    for (let n2 of e5) {\n      if (Object.prototype.hasOwnProperty.call(n2, `__proto__`) || Object.prototype.hasOwnProperty.call(n2, `constructor`) && Object.prototype.hasOwnProperty.call(n2.constructor, `prototype`))\n        throw SyntaxError(`Object contains forbidden prototype property`);\n      for (let e6 in n2) {\n        let r2 = n2[e6];\n        r2 && typeof r2 == `object` && t2.push(r2);\n      }\n    }\n  }\n  return e4;\n}\nfunction ct(e4) {\n  let { stackTraceLimit: t2 } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return ot(e4);\n  } finally {\n    Error.stackTraceLimit = t2;\n  }\n}\nvar lt = Symbol.for(`vercel.ai.validator`);\nfunction ut(e4) {\n  return { [lt]: true, validate: e4 };\n}\nfunction dt(e4) {\n  return typeof e4 == `object` && !!e4 && lt in e4 && e4[lt] === true && `validate` in e4;\n}\nfunction ft(e4) {\n  return dt(e4) ? e4 : pt(e4);\n}\nfunction pt(e4) {\n  return ut(async (t2) => {\n    let n2 = await e4[`~standard`].validate(t2);\n    return n2.issues == null ? { success: true, value: n2.value } : { success: false, error: new A2({ value: t2, cause: n2.issues }) };\n  });\n}\nasync function mt({ value: e4, schema: t2 }) {\n  let n2 = await ht({ value: e4, schema: t2 });\n  if (!n2.success)\n    throw A2.wrap({ value: e4, cause: n2.error });\n  return n2.value;\n}\nasync function ht({ value: e4, schema: t2 }) {\n  let n2 = ft(t2);\n  try {\n    if (n2.validate == null)\n      return { success: true, value: e4, rawValue: e4 };\n    let t3 = await n2.validate(e4);\n    return t3.success ? { success: true, value: t3.value, rawValue: e4 } : { success: false, error: A2.wrap({ value: e4, cause: t3.error }), rawValue: e4 };\n  } catch (t3) {\n    return { success: false, error: A2.wrap({ value: e4, cause: t3 }), rawValue: e4 };\n  }\n}\nasync function gt({ text: e4, schema: t2 }) {\n  try {\n    let n2 = ct(e4);\n    return t2 == null ? n2 : mt({ value: n2, schema: t2 });\n  } catch (t3) {\n    throw D2.isInstance(t3) || A2.isInstance(t3) ? t3 : new D2({ text: e4, cause: t3 });\n  }\n}\nasync function _t({ text: e4, schema: t2 }) {\n  try {\n    let n2 = ct(e4);\n    return t2 == null ? { success: true, value: n2, rawValue: n2 } : await ht({ value: n2, schema: t2 });\n  } catch (t3) {\n    return { success: false, error: D2.isInstance(t3) ? t3 : new D2({ text: e4, cause: t3 }), rawValue: undefined };\n  }\n}\nfunction vt(e4) {\n  try {\n    return ct(e4), true;\n  } catch {\n    return false;\n  }\n}\nfunction yt({ stream: e4, schema: t2 }) {\n  return e4.pipeThrough(new TextDecoderStream).pipeThrough(new l2).pipeThrough(new TransformStream({ async transform({ data: e5 }, n2) {\n    e5 !== `[DONE]` && n2.enqueue(await _t({ text: e5, schema: t2 }));\n  } }));\n}\nasync function L2({ provider: e4, providerOptions: t2, schema: n2 }) {\n  if (t2?.[e4] == null)\n    return;\n  let r2 = await ht({ value: t2[e4], schema: n2 });\n  if (!r2.success)\n    throw new me2({ argument: `providerOptions`, message: `invalid ${e4} provider options`, cause: r2.error });\n  return r2.value;\n}\nvar bt = () => globalThis.fetch;\nvar R2 = async ({ url: e4, headers: t2, body: n2, failedResponseHandler: r2, successfulResponseHandler: i3, abortSignal: a4, fetch: o3 }) => St({ url: e4, headers: { "Content-Type": `application/json`, ...t2 }, body: { content: JSON.stringify(n2), values: n2 }, failedResponseHandler: r2, successfulResponseHandler: i3, abortSignal: a4, fetch: o3 });\nvar xt = async ({ url: e4, headers: t2, formData: n2, failedResponseHandler: r2, successfulResponseHandler: i3, abortSignal: a4, fetch: o3 }) => St({ url: e4, headers: t2, body: { content: n2, values: Object.fromEntries(n2.entries()) }, failedResponseHandler: r2, successfulResponseHandler: i3, abortSignal: a4, fetch: o3 });\nvar St = async ({ url: e4, headers: t2 = {}, body: n2, successfulResponseHandler: r2, failedResponseHandler: i3, abortSignal: a4, fetch: o3 = bt() }) => {\n  try {\n    let s4 = await o3(e4, { method: `POST`, headers: P2(t2, `ai-sdk/provider-utils/${tt}`, Xe()), body: n2.content, signal: a4 }), c4 = N2(s4);\n    if (!s4.ok) {\n      let t3;\n      try {\n        t3 = await i3({ response: s4, url: e4, requestBodyValues: n2.values });\n      } catch (t4) {\n        throw Qe(t4) || T2.isInstance(t4) ? t4 : new T2({ message: `Failed to process error response`, cause: t4, statusCode: s4.status, url: e4, responseHeaders: c4, requestBodyValues: n2.values });\n      }\n      throw t3.value;\n    }\n    try {\n      return await r2({ response: s4, url: e4, requestBodyValues: n2.values });\n    } catch (t3) {\n      throw t3 instanceof Error && (Qe(t3) || T2.isInstance(t3)) ? t3 : new T2({ message: `Failed to process successful response`, cause: t3, statusCode: s4.status, url: e4, responseHeaders: c4, requestBodyValues: n2.values });\n    }\n  } catch (t3) {\n    throw et({ error: t3, url: e4, requestBodyValues: n2.values });\n  }\n};\nfunction Ct(e4) {\n  return e4;\n}\nfunction z2({ id: e4, name: t2, inputSchema: n2 }) {\n  return ({ execute: r2, outputSchema: i3, toModelOutput: a4, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4, ...l3 }) => Ct({ type: `provider-defined`, id: e4, name: t2, args: l3, inputSchema: n2, outputSchema: i3, execute: r2, toModelOutput: a4, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4 });\n}\nfunction B2({ id: e4, name: t2, inputSchema: n2, outputSchema: r2 }) {\n  return ({ execute: i3, toModelOutput: a4, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4, ...l3 }) => Ct({ type: `provider-defined`, id: e4, name: t2, args: l3, inputSchema: n2, outputSchema: r2, execute: i3, toModelOutput: a4, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4 });\n}\nasync function V2(e4) {\n  return typeof e4 == `function` && (e4 = e4()), Promise.resolve(e4);\n}\nvar H2 = ({ errorSchema: e4, errorToMessage: t2, isRetryable: n2 }) => async ({ response: r2, url: i3, requestBodyValues: a4 }) => {\n  let o3 = await r2.text(), s4 = N2(r2);\n  if (o3.trim() === ``)\n    return { responseHeaders: s4, value: new T2({ message: r2.statusText, url: i3, requestBodyValues: a4, statusCode: r2.status, responseHeaders: s4, responseBody: o3, isRetryable: n2?.(r2) }) };\n  try {\n    let c4 = await gt({ text: o3, schema: e4 });\n    return { responseHeaders: s4, value: new T2({ message: t2(c4), url: i3, requestBodyValues: a4, statusCode: r2.status, responseHeaders: s4, responseBody: o3, data: c4, isRetryable: n2?.(r2, c4) }) };\n  } catch {\n    return { responseHeaders: s4, value: new T2({ message: r2.statusText, url: i3, requestBodyValues: a4, statusCode: r2.status, responseHeaders: s4, responseBody: o3, isRetryable: n2?.(r2) }) };\n  }\n};\nvar U2 = (e4) => async ({ response: t2 }) => {\n  let n2 = N2(t2);\n  if (t2.body == null)\n    throw new ce2({});\n  return { responseHeaders: n2, value: yt({ stream: t2.body, schema: e4 }) };\n};\nvar W2 = (e4) => async ({ response: t2, url: n2, requestBodyValues: r2 }) => {\n  let i3 = await t2.text(), a4 = await _t({ text: i3, schema: e4 }), o3 = N2(t2);\n  if (!a4.success)\n    throw new T2({ message: `Invalid JSON response`, cause: a4.error, statusCode: t2.status, responseHeaders: o3, responseBody: i3, url: n2, requestBodyValues: r2 });\n  return { responseHeaders: o3, value: a4.value, rawValue: a4.rawValue };\n};\nvar wt = () => async ({ response: e4, url: t2, requestBodyValues: n2 }) => {\n  let r2 = N2(e4);\n  if (!e4.body)\n    throw new T2({ message: `Response body is empty`, url: t2, requestBodyValues: n2, statusCode: e4.status, responseHeaders: r2, responseBody: undefined });\n  try {\n    let t3 = await e4.arrayBuffer();\n    return { responseHeaders: r2, value: new Uint8Array(t3) };\n  } catch (i3) {\n    throw new T2({ message: `Failed to read response as array buffer`, url: t2, requestBodyValues: n2, statusCode: e4.status, responseHeaders: r2, responseBody: undefined, cause: i3 });\n  }\n};\nvar { btoa: Tt, atob: Et } = globalThis;\nfunction Dt(e4) {\n  let t2 = e4.replace(/-/g, `+`).replace(/_/g, `/`), n2 = Et(t2);\n  return Uint8Array.from(n2, (e5) => e5.codePointAt(0));\n}\nfunction Ot(e4) {\n  let t2 = ``;\n  for (let n2 = 0;n2 < e4.length; n2++)\n    t2 += String.fromCodePoint(e4[n2]);\n  return Tt(t2);\n}\nfunction G2(e4) {\n  return e4 instanceof Uint8Array ? Ot(e4) : e4;\n}\nfunction K2(e4) {\n  return e4?.replace(/\\/$/, ``);\n}\nvar kt = `2.0.23`;\nvar At = exports_external.object({ type: exports_external.literal(`error`), error: exports_external.object({ type: exports_external.string(), message: exports_external.string() }) });\nvar jt = H2({ errorSchema: At, errorToMessage: (e4) => e4.error.message });\nvar Mt = exports_external.object({ citations: exports_external.object({ enabled: exports_external.boolean() }).optional(), title: exports_external.string().optional(), context: exports_external.string().optional() });\nvar Nt = exports_external.object({ sendReasoning: exports_external.boolean().optional(), thinking: exports_external.object({ type: exports_external.union([exports_external.literal(`enabled`), exports_external.literal(`disabled`)]), budgetTokens: exports_external.number().optional() }).optional(), disableParallelToolUse: exports_external.boolean().optional(), cacheControl: exports_external.object({ type: exports_external.literal(`ephemeral`), ttl: exports_external.union([exports_external.literal(`5m`), exports_external.literal(`1h`)]).optional() }).optional() });\nfunction q2(e4) {\n  let t2 = e4?.anthropic;\n  return t2?.cacheControl ?? t2?.cache_control;\n}\nvar Pt = exports_external.object({ maxCharacters: exports_external.number().optional() });\nvar Ft = z2({ id: `anthropic.text_editor_20250728`, name: `str_replace_based_edit_tool`, inputSchema: exports_external.object({ command: exports_external.enum([`view`, `create`, `str_replace`, `insert`]), path: exports_external.string(), file_text: exports_external.string().optional(), insert_line: exports_external.number().int().optional(), new_str: exports_external.string().optional(), old_str: exports_external.string().optional(), view_range: exports_external.array(exports_external.number().int()).optional() }) });\nvar It = (e4 = {}) => Ft(e4);\nvar Lt = exports_external.object({ maxUses: exports_external.number().optional(), allowedDomains: exports_external.array(exports_external.string()).optional(), blockedDomains: exports_external.array(exports_external.string()).optional(), userLocation: exports_external.object({ type: exports_external.literal(`approximate`), city: exports_external.string().optional(), region: exports_external.string().optional(), country: exports_external.string().optional(), timezone: exports_external.string().optional() }).optional() });\nvar Rt = exports_external.array(exports_external.object({ url: exports_external.string(), title: exports_external.string(), pageAge: exports_external.string().nullable(), encryptedContent: exports_external.string(), type: exports_external.literal(`web_search_result`) }));\nvar zt = B2({ id: `anthropic.web_search_20250305`, name: `web_search`, inputSchema: exports_external.object({ query: exports_external.string() }), outputSchema: Rt });\nvar Bt = (e4 = {}) => zt(e4);\nvar Vt = exports_external.object({ maxUses: exports_external.number().optional(), allowedDomains: exports_external.array(exports_external.string()).optional(), blockedDomains: exports_external.array(exports_external.string()).optional(), citations: exports_external.object({ enabled: exports_external.boolean() }).optional(), maxContentTokens: exports_external.number().optional() });\nvar Ht = exports_external.object({ type: exports_external.literal(`web_fetch_result`), url: exports_external.string(), content: exports_external.object({ type: exports_external.literal(`document`), title: exports_external.string(), citations: exports_external.object({ enabled: exports_external.boolean() }).optional(), source: exports_external.union([exports_external.object({ type: exports_external.literal(`base64`), mediaType: exports_external.literal(`application/pdf`), data: exports_external.string() }), exports_external.object({ type: exports_external.literal(`text`), mediaType: exports_external.literal(`text/plain`), data: exports_external.string() })]) }), retrievedAt: exports_external.string().nullable() });\nvar Ut = B2({ id: `anthropic.web_fetch_20250910`, name: `web_fetch`, inputSchema: exports_external.object({ url: exports_external.string() }), outputSchema: Ht });\nvar Wt = (e4 = {}) => Ut(e4);\nfunction Gt({ tools: e4, toolChoice: t2, disableParallelToolUse: n2 }) {\n  e4 = e4?.length ? e4 : undefined;\n  let r2 = [], i3 = new Set;\n  if (e4 == null)\n    return { tools: undefined, toolChoice: undefined, toolWarnings: r2, betas: i3 };\n  let a4 = [];\n  for (let t3 of e4)\n    switch (t3.type) {\n      case `function`: {\n        let e5 = q2(t3.providerOptions);\n        a4.push({ name: t3.name, description: t3.description, input_schema: t3.inputSchema, cache_control: e5 });\n        break;\n      }\n      case `provider-defined`:\n        switch (t3.id) {\n          case `anthropic.code_execution_20250522`:\n            i3.add(`code-execution-2025-05-22`), a4.push({ type: `code_execution_20250522`, name: `code_execution` });\n            break;\n          case `anthropic.computer_20250124`:\n            i3.add(`computer-use-2025-01-24`), a4.push({ name: `computer`, type: `computer_20250124`, display_width_px: t3.args.displayWidthPx, display_height_px: t3.args.displayHeightPx, display_number: t3.args.displayNumber });\n            break;\n          case `anthropic.computer_20241022`:\n            i3.add(`computer-use-2024-10-22`), a4.push({ name: `computer`, type: `computer_20241022`, display_width_px: t3.args.displayWidthPx, display_height_px: t3.args.displayHeightPx, display_number: t3.args.displayNumber });\n            break;\n          case `anthropic.text_editor_20250124`:\n            i3.add(`computer-use-2025-01-24`), a4.push({ name: `str_replace_editor`, type: `text_editor_20250124` });\n            break;\n          case `anthropic.text_editor_20241022`:\n            i3.add(`computer-use-2024-10-22`), a4.push({ name: `str_replace_editor`, type: `text_editor_20241022` });\n            break;\n          case `anthropic.text_editor_20250429`:\n            i3.add(`computer-use-2025-01-24`), a4.push({ name: `str_replace_based_edit_tool`, type: `text_editor_20250429` });\n            break;\n          case `anthropic.text_editor_20250728`: {\n            let e5 = Pt.parse(t3.args);\n            a4.push({ name: `str_replace_based_edit_tool`, type: `text_editor_20250728`, max_characters: e5.maxCharacters });\n            break;\n          }\n          case `anthropic.bash_20250124`:\n            i3.add(`computer-use-2025-01-24`), a4.push({ name: `bash`, type: `bash_20250124` });\n            break;\n          case `anthropic.bash_20241022`:\n            i3.add(`computer-use-2024-10-22`), a4.push({ name: `bash`, type: `bash_20241022` });\n            break;\n          case `anthropic.web_fetch_20250910`: {\n            i3.add(`web-fetch-2025-09-10`);\n            let e5 = Vt.parse(t3.args);\n            a4.push({ type: `web_fetch_20250910`, name: `web_fetch`, max_uses: e5.maxUses, allowed_domains: e5.allowedDomains, blocked_domains: e5.blockedDomains, citations: e5.citations, max_content_tokens: e5.maxContentTokens });\n            break;\n          }\n          case `anthropic.web_search_20250305`: {\n            let e5 = Lt.parse(t3.args);\n            a4.push({ type: `web_search_20250305`, name: `web_search`, max_uses: e5.maxUses, allowed_domains: e5.allowedDomains, blocked_domains: e5.blockedDomains, user_location: e5.userLocation });\n            break;\n          }\n          default:\n            r2.push({ type: `unsupported-tool`, tool: t3 });\n            break;\n        }\n        break;\n      default:\n        r2.push({ type: `unsupported-tool`, tool: t3 });\n        break;\n    }\n  if (t2 == null)\n    return { tools: a4, toolChoice: n2 ? { type: `auto`, disable_parallel_tool_use: n2 } : undefined, toolWarnings: r2, betas: i3 };\n  let o3 = t2.type;\n  switch (o3) {\n    case `auto`:\n      return { tools: a4, toolChoice: { type: `auto`, disable_parallel_tool_use: n2 }, toolWarnings: r2, betas: i3 };\n    case `required`:\n      return { tools: a4, toolChoice: { type: `any`, disable_parallel_tool_use: n2 }, toolWarnings: r2, betas: i3 };\n    case `none`:\n      return { tools: undefined, toolChoice: undefined, toolWarnings: r2, betas: i3 };\n    case `tool`:\n      return { tools: a4, toolChoice: { type: `tool`, name: t2.toolName, disable_parallel_tool_use: n2 }, toolWarnings: r2, betas: i3 };\n    default:\n      throw new j2({ functionality: `tool choice type: ${o3}` });\n  }\n}\nvar Kt = exports_external.object({ type: exports_external.literal(`code_execution_result`), stdout: exports_external.string(), stderr: exports_external.string(), return_code: exports_external.number() });\nvar qt = B2({ id: `anthropic.code_execution_20250522`, name: `code_execution`, inputSchema: exports_external.object({ code: exports_external.string() }), outputSchema: Kt });\nvar Jt = (e4 = {}) => qt(e4);\nfunction Yt(e4) {\n  if (typeof e4 == `string`)\n    return Buffer.from(e4, `base64`).toString(`utf-8`);\n  if (e4 instanceof Uint8Array)\n    return new TextDecoder().decode(e4);\n  throw e4 instanceof URL ? new j2({ functionality: `URL-based text documents are not supported for citations` }) : new j2({ functionality: `unsupported data type for text documents: ${typeof e4}` });\n}\nasync function Xt({ prompt: e4, sendReasoning: t2, warnings: n2 }) {\n  let r2 = new Set, i3 = Zt(e4), a4, o3 = [];\n  async function s4(e5) {\n    return (await L2({ provider: `anthropic`, providerOptions: e5, schema: Mt }))?.citations?.enabled ?? false;\n  }\n  async function c4(e5) {\n    let t3 = await L2({ provider: `anthropic`, providerOptions: e5, schema: Mt });\n    return { title: t3?.title, context: t3?.context };\n  }\n  for (let e5 = 0;e5 < i3.length; e5++) {\n    let l3 = i3[e5], u3 = e5 === i3.length - 1, d2 = l3.type;\n    switch (d2) {\n      case `system`:\n        if (a4 != null)\n          throw new j2({ functionality: `Multiple system messages that are separated by user/assistant messages` });\n        a4 = l3.messages.map(({ content: e6, providerOptions: t3 }) => ({ type: `text`, text: e6, cache_control: q2(t3) }));\n        break;\n      case `user`: {\n        let e6 = [];\n        for (let t3 of l3.messages) {\n          let { role: n3, content: i4 } = t3;\n          switch (n3) {\n            case `user`:\n              for (let n4 = 0;n4 < i4.length; n4++) {\n                let a5 = i4[n4], o4 = n4 === i4.length - 1, l4 = q2(a5.providerOptions) ?? (o4 ? q2(t3.providerOptions) : undefined);\n                switch (a5.type) {\n                  case `text`:\n                    e6.push({ type: `text`, text: a5.text, cache_control: l4 });\n                    break;\n                  case `file`:\n                    if (a5.mediaType.startsWith(`image/`))\n                      e6.push({ type: `image`, source: a5.data instanceof URL ? { type: `url`, url: a5.data.toString() } : { type: `base64`, media_type: a5.mediaType === `image/*` ? `image/jpeg` : a5.mediaType, data: G2(a5.data) }, cache_control: l4 });\n                    else if (a5.mediaType === `application/pdf`) {\n                      r2.add(`pdfs-2024-09-25`);\n                      let t4 = await s4(a5.providerOptions), n5 = await c4(a5.providerOptions);\n                      e6.push({ type: `document`, source: a5.data instanceof URL ? { type: `url`, url: a5.data.toString() } : { type: `base64`, media_type: `application/pdf`, data: G2(a5.data) }, title: n5.title ?? a5.filename, ...n5.context && { context: n5.context }, ...t4 && { citations: { enabled: true } }, cache_control: l4 });\n                    } else if (a5.mediaType === `text/plain`) {\n                      let t4 = await s4(a5.providerOptions), n5 = await c4(a5.providerOptions);\n                      e6.push({ type: `document`, source: a5.data instanceof URL ? { type: `url`, url: a5.data.toString() } : { type: `text`, media_type: `text/plain`, data: Yt(a5.data) }, title: n5.title ?? a5.filename, ...n5.context && { context: n5.context }, ...t4 && { citations: { enabled: true } }, cache_control: l4 });\n                    } else\n                      throw new j2({ functionality: `media type: ${a5.mediaType}` });\n                    break;\n                }\n              }\n              break;\n            case `tool`:\n              for (let n4 = 0;n4 < i4.length; n4++) {\n                let r3 = i4[n4], a5 = n4 === i4.length - 1, o4 = q2(r3.providerOptions) ?? (a5 ? q2(t3.providerOptions) : undefined), s5 = r3.output, c5;\n                switch (s5.type) {\n                  case `content`:\n                    c5 = s5.value.map((e7) => {\n                      switch (e7.type) {\n                        case `text`:\n                          return { type: `text`, text: e7.text, cache_control: undefined };\n                        case `media`:\n                          if (e7.mediaType.startsWith(`image/`))\n                            return { type: `image`, source: { type: `base64`, media_type: e7.mediaType, data: e7.data }, cache_control: undefined };\n                          throw new j2({ functionality: `media type: ${e7.mediaType}` });\n                      }\n                    });\n                    break;\n                  case `text`:\n                  case `error-text`:\n                    c5 = s5.value;\n                    break;\n                  case `json`:\n                  case `error-json`:\n                  default:\n                    c5 = JSON.stringify(s5.value);\n                    break;\n                }\n                e6.push({ type: `tool_result`, tool_use_id: r3.toolCallId, content: c5, is_error: s5.type === `error-text` || s5.type === `error-json` ? true : undefined, cache_control: o4 });\n              }\n              break;\n            default: {\n              let e7 = n3;\n              throw Error(`Unsupported role: ${e7}`);\n            }\n          }\n        }\n        o3.push({ role: `user`, content: e6 });\n        break;\n      }\n      case `assistant`: {\n        let e6 = [];\n        for (let r3 = 0;r3 < l3.messages.length; r3++) {\n          let i4 = l3.messages[r3], a5 = r3 === l3.messages.length - 1, { content: o4 } = i4;\n          for (let r4 = 0;r4 < o4.length; r4++) {\n            let s5 = o4[r4], c5 = r4 === o4.length - 1, l4 = q2(s5.providerOptions) ?? (c5 ? q2(i4.providerOptions) : undefined);\n            switch (s5.type) {\n              case `text`:\n                e6.push({ type: `text`, text: u3 && a5 && c5 ? s5.text.trim() : s5.text, cache_control: l4 });\n                break;\n              case `reasoning`:\n                if (t2) {\n                  let t3 = await L2({ provider: `anthropic`, providerOptions: s5.providerOptions, schema: on });\n                  t3 == null ? n2.push({ type: `other`, message: `unsupported reasoning metadata` }) : t3.signature == null ? t3.redactedData == null ? n2.push({ type: `other`, message: `unsupported reasoning metadata` }) : e6.push({ type: `redacted_thinking`, data: t3.redactedData, cache_control: l4 }) : e6.push({ type: `thinking`, thinking: s5.text, signature: t3.signature, cache_control: l4 });\n                } else\n                  n2.push({ type: `other`, message: `sending reasoning content is disabled for this model` });\n                break;\n              case `tool-call`:\n                if (s5.providerExecuted) {\n                  s5.toolName === `code_execution` || s5.toolName === `web_fetch` || s5.toolName === `web_search` ? e6.push({ type: `server_tool_use`, id: s5.toolCallId, name: s5.toolName, input: s5.input, cache_control: l4 }) : n2.push({ type: `other`, message: `provider executed tool call for tool ${s5.toolName} is not supported` });\n                  break;\n                }\n                e6.push({ type: `tool_use`, id: s5.toolCallId, name: s5.toolName, input: s5.input, cache_control: l4 });\n                break;\n              case `tool-result`:\n                if (s5.toolName === `code_execution`) {\n                  let t3 = s5.output;\n                  if (t3.type !== `json`) {\n                    n2.push({ type: `other`, message: `provider executed tool result output type ${t3.type} for tool ${s5.toolName} is not supported` });\n                    break;\n                  }\n                  let r5 = Kt.parse(t3.value);\n                  e6.push({ type: `code_execution_tool_result`, tool_use_id: s5.toolCallId, content: { type: r5.type, stdout: r5.stdout, stderr: r5.stderr, return_code: r5.return_code }, cache_control: l4 });\n                  break;\n                }\n                if (s5.toolName === `web_fetch`) {\n                  let t3 = s5.output;\n                  if (t3.type !== `json`) {\n                    n2.push({ type: `other`, message: `provider executed tool result output type ${t3.type} for tool ${s5.toolName} is not supported` });\n                    break;\n                  }\n                  let r5 = Ht.parse(t3.value);\n                  e6.push({ type: `web_fetch_tool_result`, tool_use_id: s5.toolCallId, content: { type: `web_fetch_result`, url: r5.url, retrieved_at: r5.retrievedAt, content: { type: `document`, title: r5.content.title, citations: r5.content.citations, source: { type: r5.content.source.type, media_type: r5.content.source.mediaType, data: r5.content.source.data } } }, cache_control: l4 });\n                  break;\n                }\n                if (s5.toolName === `web_search`) {\n                  let t3 = s5.output;\n                  if (t3.type !== `json`) {\n                    n2.push({ type: `other`, message: `provider executed tool result output type ${t3.type} for tool ${s5.toolName} is not supported` });\n                    break;\n                  }\n                  let r5 = Rt.parse(t3.value);\n                  e6.push({ type: `web_search_tool_result`, tool_use_id: s5.toolCallId, content: r5.map((e7) => ({ url: e7.url, title: e7.title, page_age: e7.pageAge, encrypted_content: e7.encryptedContent, type: e7.type })), cache_control: l4 });\n                  break;\n                }\n                n2.push({ type: `other`, message: `provider executed tool result for tool ${s5.toolName} is not supported` });\n                break;\n            }\n          }\n        }\n        o3.push({ role: `assistant`, content: e6 });\n        break;\n      }\n      default: {\n        let e6 = d2;\n        throw Error(`content type: ${e6}`);\n      }\n    }\n  }\n  return { prompt: { system: a4, messages: o3 }, betas: r2 };\n}\nfunction Zt(e4) {\n  let t2 = [], n2;\n  for (let r2 of e4) {\n    let { role: e5 } = r2;\n    switch (e5) {\n      case `system`:\n        n2?.type !== `system` && (n2 = { type: `system`, messages: [] }, t2.push(n2)), n2.messages.push(r2);\n        break;\n      case `assistant`:\n        n2?.type !== `assistant` && (n2 = { type: `assistant`, messages: [] }, t2.push(n2)), n2.messages.push(r2);\n        break;\n      case `user`:\n        n2?.type !== `user` && (n2 = { type: `user`, messages: [] }, t2.push(n2)), n2.messages.push(r2);\n        break;\n      case `tool`:\n        n2?.type !== `user` && (n2 = { type: `user`, messages: [] }, t2.push(n2)), n2.messages.push(r2);\n        break;\n      default: {\n        let t3 = e5;\n        throw Error(`Unsupported role: ${t3}`);\n      }\n    }\n  }\n  return t2;\n}\nfunction Qt({ finishReason: e4, isJsonResponseFromTool: t2 }) {\n  switch (e4) {\n    case `pause_turn`:\n    case `end_turn`:\n    case `stop_sequence`:\n      return `stop`;\n    case `refusal`:\n      return `content-filter`;\n    case `tool_use`:\n      return t2 ? `stop` : `tool-calls`;\n    case `max_tokens`:\n      return `length`;\n    default:\n      return `unknown`;\n  }\n}\nvar J2 = { webSearchResult: exports_external.object({ type: exports_external.literal(`web_search_result_location`), cited_text: exports_external.string(), url: exports_external.string(), title: exports_external.string(), encrypted_index: exports_external.string() }), pageLocation: exports_external.object({ type: exports_external.literal(`page_location`), cited_text: exports_external.string(), document_index: exports_external.number(), document_title: exports_external.string().nullable(), start_page_number: exports_external.number(), end_page_number: exports_external.number() }), charLocation: exports_external.object({ type: exports_external.literal(`char_location`), cited_text: exports_external.string(), document_index: exports_external.number(), document_title: exports_external.string().nullable(), start_char_index: exports_external.number(), end_char_index: exports_external.number() }) };\nvar $t = exports_external.discriminatedUnion(`type`, [J2.webSearchResult, J2.pageLocation, J2.charLocation]);\nexports_external.discriminatedUnion(`type`, [J2.pageLocation, J2.charLocation]);\nfunction en(e4, t2, n2, r2) {\n  if (e4.type === `page_location` || e4.type === `char_location`) {\n    let i3 = tn(e4, t2, n2);\n    i3 && r2(i3);\n  }\n}\nfunction tn(e4, t2, n2) {\n  let r2 = t2[e4.document_index];\n  if (!r2)\n    return null;\n  let i3 = e4.type === `page_location` ? { citedText: e4.cited_text, startPageNumber: e4.start_page_number, endPageNumber: e4.end_page_number } : { citedText: e4.cited_text, startCharIndex: e4.start_char_index, endCharIndex: e4.end_char_index };\n  return { type: `source`, sourceType: `document`, id: n2(), mediaType: r2.mediaType, title: e4.document_title ?? r2.title, filename: r2.filename, providerMetadata: { anthropic: i3 } };\n}\nvar nn = class {\n  constructor(e4, t2) {\n    this.specificationVersion = `v2`, this.modelId = e4, this.config = t2, this.generateId = t2.generateId ?? F2;\n  }\n  supportsUrl(e4) {\n    return e4.protocol === `https:`;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get supportedUrls() {\n    var e4;\n    return (e4 = this.config).supportedUrls?.call(e4) ?? {};\n  }\n  async getArgs({ prompt: e4, maxOutputTokens: t2 = 4096, temperature: n2, topP: r2, topK: i3, frequencyPenalty: a4, presencePenalty: o3, stopSequences: s4, responseFormat: c4, seed: l3, tools: u3, toolChoice: d2, providerOptions: f3 }) {\n    let p3 = [];\n    a4 != null && p3.push({ type: `unsupported-setting`, setting: `frequencyPenalty` }), o3 != null && p3.push({ type: `unsupported-setting`, setting: `presencePenalty` }), l3 != null && p3.push({ type: `unsupported-setting`, setting: `seed` }), c4?.type === `json` && (c4.schema == null ? p3.push({ type: `unsupported-setting`, setting: `responseFormat`, details: `JSON response format requires a schema. The response format is ignored.` }) : u3 != null && p3.push({ type: `unsupported-setting`, setting: `tools`, details: `JSON response format does not support tools. The provided tools are ignored.` }));\n    let m3 = c4?.type === `json` && c4.schema != null ? { type: `function`, name: `json`, description: `Respond with a JSON object.`, inputSchema: c4.schema } : undefined, h3 = await L2({ provider: `anthropic`, providerOptions: f3, schema: Nt }), { prompt: g3, betas: _3 } = await Xt({ prompt: e4, sendReasoning: h3?.sendReasoning ?? true, warnings: p3 }), v3 = h3?.thinking?.type === `enabled`, y3 = h3?.thinking?.budgetTokens, b3 = { model: this.modelId, max_tokens: t2, temperature: n2, top_k: i3, top_p: r2, stop_sequences: s4, ...v3 && { thinking: { type: `enabled`, budget_tokens: y3 } }, system: g3.system, messages: g3.messages };\n    if (v3) {\n      if (y3 == null)\n        throw new j2({ functionality: `thinking requires a budget` });\n      b3.temperature != null && (b3.temperature = undefined, p3.push({ type: `unsupported-setting`, setting: `temperature`, details: `temperature is not supported when thinking is enabled` })), i3 != null && (b3.top_k = undefined, p3.push({ type: `unsupported-setting`, setting: `topK`, details: `topK is not supported when thinking is enabled` })), r2 != null && (b3.top_p = undefined, p3.push({ type: `unsupported-setting`, setting: `topP`, details: `topP is not supported when thinking is enabled` })), b3.max_tokens = t2 + y3;\n    }\n    let { tools: x4, toolChoice: S3, toolWarnings: C3, betas: w3 } = Gt(m3 == null ? { tools: u3 ?? [], toolChoice: d2, disableParallelToolUse: h3?.disableParallelToolUse } : { tools: [m3], toolChoice: { type: `tool`, toolName: m3.name }, disableParallelToolUse: true });\n    return { args: { ...b3, tools: x4, tool_choice: S3 }, warnings: [...p3, ...C3], betas: new Set([..._3, ...w3]), usesJsonResponseTool: m3 != null };\n  }\n  async getHeaders({ betas: e4, headers: t2 }) {\n    return M2(await V2(this.config.headers), e4.size > 0 ? { "anthropic-beta": Array.from(e4).join(`,`) } : {}, t2);\n  }\n  buildRequestUrl(e4) {\n    var t2;\n    return (t2 = this.config).buildRequestUrl?.call(t2, this.config.baseURL, e4) ?? `${this.config.baseURL}/messages`;\n  }\n  transformRequestBody(e4) {\n    var t2;\n    return (t2 = this.config).transformRequestBody?.call(t2, e4) ?? e4;\n  }\n  extractCitationDocuments(e4) {\n    return e4.filter((e5) => e5.role === `user`).flatMap((e5) => e5.content).filter((e5) => e5.type !== `file` || e5.mediaType !== `application/pdf` && e5.mediaType !== `text/plain` ? false : e5.providerOptions?.anthropic?.citations?.enabled ?? false).map((e5) => {\n      let t2 = e5;\n      return { title: t2.filename ?? `Untitled Document`, filename: t2.filename, mediaType: t2.mediaType };\n    });\n  }\n  async doGenerate(e4) {\n    let { args: t2, warnings: n2, betas: r2, usesJsonResponseTool: i3 } = await this.getArgs(e4), a4 = this.extractCitationDocuments(e4.prompt), { responseHeaders: o3, value: s4, rawValue: c4 } = await R2({ url: this.buildRequestUrl(false), headers: await this.getHeaders({ betas: r2, headers: e4.headers }), body: this.transformRequestBody(t2), failedResponseHandler: jt, successfulResponseHandler: W2(rn), abortSignal: e4.abortSignal, fetch: this.config.fetch }), l3 = [];\n    for (let e5 of s4.content)\n      switch (e5.type) {\n        case `text`:\n          if (!i3 && (l3.push({ type: `text`, text: e5.text }), e5.citations))\n            for (let t3 of e5.citations)\n              en(t3, a4, this.generateId, (e6) => l3.push(e6));\n          break;\n        case `thinking`:\n          l3.push({ type: `reasoning`, text: e5.thinking, providerMetadata: { anthropic: { signature: e5.signature } } });\n          break;\n        case `redacted_thinking`:\n          l3.push({ type: `reasoning`, text: ``, providerMetadata: { anthropic: { redactedData: e5.data } } });\n          break;\n        case `tool_use`:\n          l3.push(i3 ? { type: `text`, text: JSON.stringify(e5.input) } : { type: `tool-call`, toolCallId: e5.id, toolName: e5.name, input: JSON.stringify(e5.input) });\n          break;\n        case `server_tool_use`:\n          (e5.name === `web_search` || e5.name === `code_execution` || e5.name === `web_fetch`) && l3.push({ type: `tool-call`, toolCallId: e5.id, toolName: e5.name, input: JSON.stringify(e5.input), providerExecuted: true });\n          break;\n        case `web_fetch_tool_result`:\n          e5.content.type === `web_fetch_result` ? l3.push({ type: `tool-result`, toolCallId: e5.tool_use_id, toolName: `web_fetch`, result: { type: `web_fetch_result`, url: e5.content.url, retrievedAt: e5.content.retrieved_at, content: { type: e5.content.content.type, title: e5.content.content.title, citations: e5.content.content.citations, source: { type: e5.content.content.source.type, mediaType: e5.content.content.source.media_type, data: e5.content.content.source.data } } }, providerExecuted: true }) : e5.content.type === `web_fetch_tool_result_error` && l3.push({ type: `tool-result`, toolCallId: e5.tool_use_id, toolName: `web_fetch`, isError: true, result: { type: `web_fetch_tool_result_error`, errorCode: e5.content.error_code }, providerExecuted: true });\n          break;\n        case `web_search_tool_result`:\n          if (Array.isArray(e5.content)) {\n            l3.push({ type: `tool-result`, toolCallId: e5.tool_use_id, toolName: `web_search`, result: e5.content.map((e6) => ({ url: e6.url, title: e6.title, pageAge: e6.page_age ?? null, encryptedContent: e6.encrypted_content, type: e6.type })), providerExecuted: true });\n            for (let t3 of e5.content)\n              l3.push({ type: `source`, sourceType: `url`, id: this.generateId(), url: t3.url, title: t3.title, providerMetadata: { anthropic: { pageAge: t3.page_age ?? null } } });\n          } else\n            l3.push({ type: `tool-result`, toolCallId: e5.tool_use_id, toolName: `web_search`, isError: true, result: { type: `web_search_tool_result_error`, errorCode: e5.content.error_code }, providerExecuted: true });\n          break;\n        case `code_execution_tool_result`:\n          e5.content.type === `code_execution_result` ? l3.push({ type: `tool-result`, toolCallId: e5.tool_use_id, toolName: `code_execution`, result: { type: e5.content.type, stdout: e5.content.stdout, stderr: e5.content.stderr, return_code: e5.content.return_code }, providerExecuted: true }) : e5.content.type === `code_execution_tool_result_error` && l3.push({ type: `tool-result`, toolCallId: e5.tool_use_id, toolName: `code_execution`, isError: true, result: { type: `code_execution_tool_result_error`, errorCode: e5.content.error_code }, providerExecuted: true });\n          break;\n      }\n    return { content: l3, finishReason: Qt({ finishReason: s4.stop_reason, isJsonResponseFromTool: i3 }), usage: { inputTokens: s4.usage.input_tokens, outputTokens: s4.usage.output_tokens, totalTokens: s4.usage.input_tokens + s4.usage.output_tokens, cachedInputTokens: s4.usage.cache_read_input_tokens ?? undefined }, request: { body: t2 }, response: { id: s4.id ?? undefined, modelId: s4.model ?? undefined, headers: o3, body: c4 }, warnings: n2, providerMetadata: { anthropic: { usage: s4.usage, cacheCreationInputTokens: s4.usage.cache_creation_input_tokens ?? null, stopSequence: s4.stop_sequence ?? null } } };\n  }\n  async doStream(e4) {\n    let { args: t2, warnings: n2, betas: r2, usesJsonResponseTool: i3 } = await this.getArgs(e4), a4 = this.extractCitationDocuments(e4.prompt), o3 = { ...t2, stream: true }, { responseHeaders: s4, value: c4 } = await R2({ url: this.buildRequestUrl(true), headers: await this.getHeaders({ betas: r2, headers: e4.headers }), body: this.transformRequestBody(o3), failedResponseHandler: jt, successfulResponseHandler: U2(an), abortSignal: e4.abortSignal, fetch: this.config.fetch }), l3 = `unknown`, u3 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, d2 = {}, f3, p3 = null, m3 = null, h3, g3 = this.generateId;\n    return { stream: c4.pipeThrough(new TransformStream({ start(e5) {\n      e5.enqueue({ type: `stream-start`, warnings: n2 });\n    }, transform(t3, n3) {\n      if (e4.includeRawChunks && n3.enqueue({ type: `raw`, rawValue: t3.rawValue }), !t3.success) {\n        n3.enqueue({ type: `error`, error: t3.error });\n        return;\n      }\n      let r3 = t3.value;\n      switch (r3.type) {\n        case `ping`:\n          return;\n        case `content_block_start`: {\n          let e5 = r3.content_block.type;\n          switch (h3 = e5, e5) {\n            case `text`:\n              d2[r3.index] = { type: `text` }, n3.enqueue({ type: `text-start`, id: String(r3.index) });\n              return;\n            case `thinking`:\n              d2[r3.index] = { type: `reasoning` }, n3.enqueue({ type: `reasoning-start`, id: String(r3.index) });\n              return;\n            case `redacted_thinking`:\n              d2[r3.index] = { type: `reasoning` }, n3.enqueue({ type: `reasoning-start`, id: String(r3.index), providerMetadata: { anthropic: { redactedData: r3.content_block.data } } });\n              return;\n            case `tool_use`:\n              d2[r3.index] = i3 ? { type: `text` } : { type: `tool-call`, toolCallId: r3.content_block.id, toolName: r3.content_block.name, input: `` }, n3.enqueue(i3 ? { type: `text-start`, id: String(r3.index) } : { type: `tool-input-start`, id: r3.content_block.id, toolName: r3.content_block.name });\n              return;\n            case `server_tool_use`:\n              (r3.content_block.name === `web_fetch` || r3.content_block.name === `web_search` || r3.content_block.name === `code_execution`) && (d2[r3.index] = { type: `tool-call`, toolCallId: r3.content_block.id, toolName: r3.content_block.name, input: ``, providerExecuted: true }, n3.enqueue({ type: `tool-input-start`, id: r3.content_block.id, toolName: r3.content_block.name, providerExecuted: true }));\n              return;\n            case `web_fetch_tool_result`: {\n              let e6 = r3.content_block;\n              e6.content.type === `web_fetch_result` ? n3.enqueue({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `web_fetch`, result: { type: `web_fetch_result`, url: e6.content.url, retrievedAt: e6.content.retrieved_at, content: { type: e6.content.content.type, title: e6.content.content.title, citations: e6.content.content.citations, source: { type: e6.content.content.source.type, mediaType: e6.content.content.source.media_type, data: e6.content.content.source.data } } } }) : e6.content.type === `web_fetch_tool_result_error` && n3.enqueue({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `web_fetch`, isError: true, result: { type: `web_fetch_tool_result_error`, errorCode: e6.content.error_code }, providerExecuted: true });\n              return;\n            }\n            case `web_search_tool_result`: {\n              let e6 = r3.content_block;\n              if (Array.isArray(e6.content)) {\n                n3.enqueue({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `web_search`, result: e6.content.map((e7) => ({ url: e7.url, title: e7.title, pageAge: e7.page_age ?? null, encryptedContent: e7.encrypted_content, type: e7.type })), providerExecuted: true });\n                for (let t4 of e6.content)\n                  n3.enqueue({ type: `source`, sourceType: `url`, id: g3(), url: t4.url, title: t4.title, providerMetadata: { anthropic: { pageAge: t4.page_age ?? null } } });\n              } else\n                n3.enqueue({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `web_search`, isError: true, result: { type: `web_search_tool_result_error`, errorCode: e6.content.error_code }, providerExecuted: true });\n              return;\n            }\n            case `code_execution_tool_result`: {\n              let e6 = r3.content_block;\n              e6.content.type === `code_execution_result` ? n3.enqueue({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `code_execution`, result: { type: e6.content.type, stdout: e6.content.stdout, stderr: e6.content.stderr, return_code: e6.content.return_code }, providerExecuted: true }) : e6.content.type === `code_execution_tool_result_error` && n3.enqueue({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `code_execution`, isError: true, result: { type: `code_execution_tool_result_error`, errorCode: e6.content.error_code }, providerExecuted: true });\n              return;\n            }\n            default: {\n              let t4 = e5;\n              throw Error(`Unsupported content block type: ${t4}`);\n            }\n          }\n        }\n        case `content_block_stop`:\n          if (d2[r3.index] != null) {\n            let e5 = d2[r3.index];\n            switch (e5.type) {\n              case `text`:\n                n3.enqueue({ type: `text-end`, id: String(r3.index) });\n                break;\n              case `reasoning`:\n                n3.enqueue({ type: `reasoning-end`, id: String(r3.index) });\n                break;\n              case `tool-call`:\n                i3 || (n3.enqueue({ type: `tool-input-end`, id: e5.toolCallId }), n3.enqueue(e5));\n                break;\n            }\n            delete d2[r3.index];\n          }\n          h3 = undefined;\n          return;\n        case `content_block_delta`: {\n          let e5 = r3.delta.type;\n          switch (e5) {\n            case `text_delta`:\n              if (i3)\n                return;\n              n3.enqueue({ type: `text-delta`, id: String(r3.index), delta: r3.delta.text });\n              return;\n            case `thinking_delta`:\n              n3.enqueue({ type: `reasoning-delta`, id: String(r3.index), delta: r3.delta.thinking });\n              return;\n            case `signature_delta`:\n              h3 === `thinking` && n3.enqueue({ type: `reasoning-delta`, id: String(r3.index), delta: ``, providerMetadata: { anthropic: { signature: r3.delta.signature } } });\n              return;\n            case `input_json_delta`: {\n              let e6 = d2[r3.index], t4 = r3.delta.partial_json;\n              if (i3) {\n                if (e6?.type !== `text`)\n                  return;\n                n3.enqueue({ type: `text-delta`, id: String(r3.index), delta: t4 });\n              } else {\n                if (e6?.type !== `tool-call`)\n                  return;\n                n3.enqueue({ type: `tool-input-delta`, id: e6.toolCallId, delta: t4 }), e6.input += t4;\n              }\n              return;\n            }\n            case `citations_delta`: {\n              let e6 = r3.delta.citation;\n              en(e6, a4, g3, (e7) => n3.enqueue(e7));\n              return;\n            }\n            default: {\n              let t4 = e5;\n              throw Error(`Unsupported delta type: ${t4}`);\n            }\n          }\n        }\n        case `message_start`:\n          u3.inputTokens = r3.message.usage.input_tokens, u3.cachedInputTokens = r3.message.usage.cache_read_input_tokens ?? undefined, f3 = { ...r3.message.usage }, p3 = r3.message.usage.cache_creation_input_tokens ?? null, n3.enqueue({ type: `response-metadata`, id: r3.message.id ?? undefined, modelId: r3.message.model ?? undefined });\n          return;\n        case `message_delta`:\n          u3.outputTokens = r3.usage.output_tokens, u3.totalTokens = (u3.inputTokens ?? 0) + (r3.usage.output_tokens ?? 0), l3 = Qt({ finishReason: r3.delta.stop_reason, isJsonResponseFromTool: i3 }), m3 = r3.delta.stop_sequence ?? null, f3 = { ...f3, ...r3.usage };\n          return;\n        case `message_stop`:\n          n3.enqueue({ type: `finish`, finishReason: l3, usage: u3, providerMetadata: { anthropic: { usage: f3 ?? null, cacheCreationInputTokens: p3, stopSequence: m3 } } });\n          return;\n        case `error`:\n          n3.enqueue({ type: `error`, error: r3.error });\n          return;\n        default: {\n          let e5 = r3;\n          throw Error(`Unsupported chunk type: ${e5}`);\n        }\n      }\n    } })), request: { body: o3 }, response: { headers: s4 } };\n  }\n};\nvar rn = exports_external.object({ type: exports_external.literal(`message`), id: exports_external.string().nullish(), model: exports_external.string().nullish(), content: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`text`), text: exports_external.string(), citations: exports_external.array($t).optional() }), exports_external.object({ type: exports_external.literal(`thinking`), thinking: exports_external.string(), signature: exports_external.string() }), exports_external.object({ type: exports_external.literal(`redacted_thinking`), data: exports_external.string() }), exports_external.object({ type: exports_external.literal(`tool_use`), id: exports_external.string(), name: exports_external.string(), input: exports_external.unknown() }), exports_external.object({ type: exports_external.literal(`server_tool_use`), id: exports_external.string(), name: exports_external.string(), input: exports_external.record(exports_external.string(), exports_external.unknown()).nullish() }), exports_external.object({ type: exports_external.literal(`web_fetch_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.object({ type: exports_external.literal(`web_fetch_result`), url: exports_external.string(), retrieved_at: exports_external.string(), content: exports_external.object({ type: exports_external.literal(`document`), title: exports_external.string().nullable(), citations: exports_external.object({ enabled: exports_external.boolean() }).optional(), source: exports_external.object({ type: exports_external.literal(`text`), media_type: exports_external.string(), data: exports_external.string() }) }) }), exports_external.object({ type: exports_external.literal(`web_fetch_tool_result_error`), error_code: exports_external.string() })]) }), exports_external.object({ type: exports_external.literal(`web_search_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.array(exports_external.object({ type: exports_external.literal(`web_search_result`), url: exports_external.string(), title: exports_external.string(), encrypted_content: exports_external.string(), page_age: exports_external.string().nullish() })), exports_external.object({ type: exports_external.literal(`web_search_tool_result_error`), error_code: exports_external.string() })]) }), exports_external.object({ type: exports_external.literal(`code_execution_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.object({ type: exports_external.literal(`code_execution_result`), stdout: exports_external.string(), stderr: exports_external.string(), return_code: exports_external.number() }), exports_external.object({ type: exports_external.literal(`code_execution_tool_result_error`), error_code: exports_external.string() })]) })])), stop_reason: exports_external.string().nullish(), stop_sequence: exports_external.string().nullish(), usage: exports_external.looseObject({ input_tokens: exports_external.number(), output_tokens: exports_external.number(), cache_creation_input_tokens: exports_external.number().nullish(), cache_read_input_tokens: exports_external.number().nullish() }) });\nvar an = exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`message_start`), message: exports_external.object({ id: exports_external.string().nullish(), model: exports_external.string().nullish(), usage: exports_external.looseObject({ input_tokens: exports_external.number(), cache_creation_input_tokens: exports_external.number().nullish(), cache_read_input_tokens: exports_external.number().nullish() }) }) }), exports_external.object({ type: exports_external.literal(`content_block_start`), index: exports_external.number(), content_block: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`text`), text: exports_external.string() }), exports_external.object({ type: exports_external.literal(`thinking`), thinking: exports_external.string() }), exports_external.object({ type: exports_external.literal(`tool_use`), id: exports_external.string(), name: exports_external.string() }), exports_external.object({ type: exports_external.literal(`redacted_thinking`), data: exports_external.string() }), exports_external.object({ type: exports_external.literal(`server_tool_use`), id: exports_external.string(), name: exports_external.string(), input: exports_external.record(exports_external.string(), exports_external.unknown()).nullish() }), exports_external.object({ type: exports_external.literal(`web_fetch_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.object({ type: exports_external.literal(`web_fetch_result`), url: exports_external.string(), retrieved_at: exports_external.string(), content: exports_external.object({ type: exports_external.literal(`document`), title: exports_external.string().nullable(), citations: exports_external.object({ enabled: exports_external.boolean() }).optional(), source: exports_external.object({ type: exports_external.literal(`text`), media_type: exports_external.string(), data: exports_external.string() }) }) }), exports_external.object({ type: exports_external.literal(`web_fetch_tool_result_error`), error_code: exports_external.string() })]) }), exports_external.object({ type: exports_external.literal(`web_search_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.array(exports_external.object({ type: exports_external.literal(`web_search_result`), url: exports_external.string(), title: exports_external.string(), encrypted_content: exports_external.string(), page_age: exports_external.string().nullish() })), exports_external.object({ type: exports_external.literal(`web_search_tool_result_error`), error_code: exports_external.string() })]) }), exports_external.object({ type: exports_external.literal(`code_execution_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.object({ type: exports_external.literal(`code_execution_result`), stdout: exports_external.string(), stderr: exports_external.string(), return_code: exports_external.number() }), exports_external.object({ type: exports_external.literal(`code_execution_tool_result_error`), error_code: exports_external.string() })]) })]) }), exports_external.object({ type: exports_external.literal(`content_block_delta`), index: exports_external.number(), delta: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`input_json_delta`), partial_json: exports_external.string() }), exports_external.object({ type: exports_external.literal(`text_delta`), text: exports_external.string() }), exports_external.object({ type: exports_external.literal(`thinking_delta`), thinking: exports_external.string() }), exports_external.object({ type: exports_external.literal(`signature_delta`), signature: exports_external.string() }), exports_external.object({ type: exports_external.literal(`citations_delta`), citation: $t })]) }), exports_external.object({ type: exports_external.literal(`content_block_stop`), index: exports_external.number() }), exports_external.object({ type: exports_external.literal(`error`), error: exports_external.object({ type: exports_external.string(), message: exports_external.string() }) }), exports_external.object({ type: exports_external.literal(`message_delta`), delta: exports_external.object({ stop_reason: exports_external.string().nullish(), stop_sequence: exports_external.string().nullish() }), usage: exports_external.looseObject({ output_tokens: exports_external.number(), cache_creation_input_tokens: exports_external.number().nullish() }) }), exports_external.object({ type: exports_external.literal(`message_stop`) }), exports_external.object({ type: exports_external.literal(`ping`) })]);\nvar on = exports_external.object({ signature: exports_external.string().optional(), redactedData: exports_external.string().optional() });\nvar sn = z2({ id: `anthropic.bash_20241022`, name: `bash`, inputSchema: v4_default.object({ command: v4_default.string(), restart: v4_default.boolean().optional() }) });\nvar cn = z2({ id: `anthropic.bash_20250124`, name: `bash`, inputSchema: v4_default.object({ command: v4_default.string(), restart: v4_default.boolean().optional() }) });\nvar ln = z2({ id: `anthropic.computer_20241022`, name: `computer`, inputSchema: exports_external.object({ action: exports_external.enum([`key`, `type`, `mouse_move`, `left_click`, `left_click_drag`, `right_click`, `middle_click`, `double_click`, `screenshot`, `cursor_position`]), coordinate: exports_external.array(exports_external.number().int()).optional(), text: exports_external.string().optional() }) });\nvar un = z2({ id: `anthropic.computer_20250124`, name: `computer`, inputSchema: exports_external.object({ action: exports_external.enum([`key`, `hold_key`, `type`, `cursor_position`, `mouse_move`, `left_mouse_down`, `left_mouse_up`, `left_click`, `left_click_drag`, `right_click`, `middle_click`, `double_click`, `triple_click`, `scroll`, `wait`, `screenshot`]), coordinate: exports_external.tuple([exports_external.number().int(), exports_external.number().int()]).optional(), duration: exports_external.number().optional(), scroll_amount: exports_external.number().optional(), scroll_direction: exports_external.enum([`up`, `down`, `left`, `right`]).optional(), start_coordinate: exports_external.tuple([exports_external.number().int(), exports_external.number().int()]).optional(), text: exports_external.string().optional() }) });\nvar dn = z2({ id: `anthropic.text_editor_20241022`, name: `str_replace_editor`, inputSchema: exports_external.object({ command: exports_external.enum([`view`, `create`, `str_replace`, `insert`, `undo_edit`]), path: exports_external.string(), file_text: exports_external.string().optional(), insert_line: exports_external.number().int().optional(), new_str: exports_external.string().optional(), old_str: exports_external.string().optional(), view_range: exports_external.array(exports_external.number().int()).optional() }) });\nvar fn = z2({ id: `anthropic.text_editor_20250124`, name: `str_replace_editor`, inputSchema: exports_external.object({ command: exports_external.enum([`view`, `create`, `str_replace`, `insert`, `undo_edit`]), path: exports_external.string(), file_text: exports_external.string().optional(), insert_line: exports_external.number().int().optional(), new_str: exports_external.string().optional(), old_str: exports_external.string().optional(), view_range: exports_external.array(exports_external.number().int()).optional() }) });\nvar pn = z2({ id: `anthropic.text_editor_20250429`, name: `str_replace_based_edit_tool`, inputSchema: exports_external.object({ command: exports_external.enum([`view`, `create`, `str_replace`, `insert`]), path: exports_external.string(), file_text: exports_external.string().optional(), insert_line: exports_external.number().int().optional(), new_str: exports_external.string().optional(), old_str: exports_external.string().optional(), view_range: exports_external.array(exports_external.number().int()).optional() }) });\nvar mn = { bash_20241022: sn, bash_20250124: cn, codeExecution_20250522: Jt, computer_20241022: ln, computer_20250124: un, textEditor_20241022: dn, textEditor_20250124: fn, textEditor_20250429: pn, textEditor_20250728: It, webFetch_20250910: Wt, webSearch_20250305: Bt };\nfunction hn(e4 = {}) {\n  let t2 = K2(e4.baseURL) ?? `https://api.anthropic.com/v1`, n2 = () => P2({ "anthropic-version": `2023-06-01`, "x-api-key": I2({ apiKey: e4.apiKey, environmentVariableName: `ANTHROPIC_API_KEY`, description: `Anthropic` }), ...e4.headers }, `ai-sdk/anthropic/${kt}`), r2 = (r3) => new nn(r3, { provider: `anthropic.messages`, baseURL: t2, headers: n2, fetch: e4.fetch, generateId: e4.generateId ?? F2, supportedUrls: () => ({ "image/*": [/^https?:\\/\\/.*$/] }) }), i3 = function(e5) {\n    if (new.target)\n      throw Error(`The Anthropic model function cannot be called with the new keyword.`);\n    return r2(e5);\n  };\n  return i3.languageModel = r2, i3.chat = r2, i3.messages = r2, i3.textEmbeddingModel = (e5) => {\n    throw new k2({ modelId: e5, modelType: `textEmbeddingModel` });\n  }, i3.imageModel = (e5) => {\n    throw new k2({ modelId: e5, modelType: `imageModel` });\n  }, i3.tools = mn, i3;\n}\nhn();\nvar gn = `2.0.17`;\nvar _n = exports_external.object({ error: exports_external.object({ code: exports_external.number().nullable(), message: exports_external.string(), status: exports_external.string() }) });\nvar Y2 = H2({ errorSchema: _n, errorToMessage: (e4) => e4.error.message });\nvar vn = exports_external.object({ outputDimensionality: exports_external.number().optional(), taskType: exports_external.enum([`SEMANTIC_SIMILARITY`, `CLASSIFICATION`, `CLUSTERING`, `RETRIEVAL_DOCUMENT`, `RETRIEVAL_QUERY`, `QUESTION_ANSWERING`, `FACT_VERIFICATION`, `CODE_RETRIEVAL_QUERY`]).optional() });\nvar yn = class {\n  constructor(e4, t2) {\n    this.specificationVersion = `v2`, this.maxEmbeddingsPerCall = 2048, this.supportsParallelCalls = true, this.modelId = e4, this.config = t2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doEmbed({ values: e4, headers: t2, abortSignal: n2, providerOptions: r2 }) {\n    let i3 = await L2({ provider: `google`, providerOptions: r2, schema: vn });\n    if (e4.length > this.maxEmbeddingsPerCall)\n      throw new Be({ provider: this.provider, modelId: this.modelId, maxEmbeddingsPerCall: this.maxEmbeddingsPerCall, values: e4 });\n    let a4 = M2(await V2(this.config.headers), t2);\n    if (e4.length === 1) {\n      let { responseHeaders: t3, value: r3, rawValue: o4 } = await R2({ url: `${this.config.baseURL}/models/${this.modelId}:embedContent`, headers: a4, body: { model: `models/${this.modelId}`, content: { parts: [{ text: e4[0] }] }, outputDimensionality: i3?.outputDimensionality, taskType: i3?.taskType }, failedResponseHandler: Y2, successfulResponseHandler: W2(xn), abortSignal: n2, fetch: this.config.fetch });\n      return { embeddings: [r3.embedding.values], usage: undefined, response: { headers: t3, body: o4 } };\n    }\n    let { responseHeaders: o3, value: s4, rawValue: c4 } = await R2({ url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`, headers: a4, body: { requests: e4.map((e5) => ({ model: `models/${this.modelId}`, content: { role: `user`, parts: [{ text: e5 }] }, outputDimensionality: i3?.outputDimensionality, taskType: i3?.taskType })) }, failedResponseHandler: Y2, successfulResponseHandler: W2(bn), abortSignal: n2, fetch: this.config.fetch });\n    return { embeddings: s4.embeddings.map((e5) => e5.values), usage: undefined, response: { headers: o3, body: c4 } };\n  }\n};\nvar bn = exports_external.object({ embeddings: exports_external.array(exports_external.object({ values: exports_external.array(exports_external.number()) })) });\nvar xn = exports_external.object({ embedding: exports_external.object({ values: exports_external.array(exports_external.number()) }) });\nfunction X2(e4) {\n  if (e4 == null || Sn(e4))\n    return;\n  if (typeof e4 == `boolean`)\n    return { type: `boolean`, properties: {} };\n  let { type: t2, description: n2, required: r2, properties: i3, items: a4, allOf: o3, anyOf: s4, oneOf: c4, format: l3, const: u3, minLength: d2, enum: f3 } = e4, p3 = {};\n  if (n2 && (p3.description = n2), r2 && (p3.required = r2), l3 && (p3.format = l3), u3 !== undefined && (p3.enum = [u3]), t2 && (Array.isArray(t2) ? t2.includes(`null`) ? (p3.type = t2.filter((e5) => e5 !== `null`)[0], p3.nullable = true) : p3.type = t2 : t2 === `null` ? p3.type = `null` : p3.type = t2), f3 !== undefined && (p3.enum = f3), i3 != null && (p3.properties = Object.entries(i3).reduce((e5, [t3, n3]) => (e5[t3] = X2(n3), e5), {})), a4 && (p3.items = Array.isArray(a4) ? a4.map(X2) : X2(a4)), o3 && (p3.allOf = o3.map(X2)), s4)\n    if (s4.some((e5) => typeof e5 == `object` && e5?.type === `null`)) {\n      let e5 = s4.filter((e6) => !(typeof e6 == `object` && e6?.type === `null`));\n      if (e5.length === 1) {\n        let t3 = X2(e5[0]);\n        typeof t3 == `object` && (p3.nullable = true, Object.assign(p3, t3));\n      } else\n        p3.anyOf = e5.map(X2), p3.nullable = true;\n    } else\n      p3.anyOf = s4.map(X2);\n  return c4 && (p3.oneOf = c4.map(X2)), d2 !== undefined && (p3.minLength = d2), p3;\n}\nfunction Sn(e4) {\n  return typeof e4 == `object` && !!e4 && e4.type === `object` && (e4.properties == null || Object.keys(e4.properties).length === 0) && !e4.additionalProperties;\n}\nfunction Cn(e4, t2) {\n  let n2 = [], r2 = [], i3 = true, a4 = t2?.isGemmaModel ?? false;\n  for (let { role: t3, content: a5 } of e4)\n    switch (t3) {\n      case `system`:\n        if (!i3)\n          throw new j2({ functionality: `system messages are only supported at the beginning of the conversation` });\n        n2.push({ text: a5 });\n        break;\n      case `user`: {\n        i3 = false;\n        let e5 = [];\n        for (let t4 of a5)\n          switch (t4.type) {\n            case `text`:\n              e5.push({ text: t4.text });\n              break;\n            case `file`: {\n              let n3 = t4.mediaType === `image/*` ? `image/jpeg` : t4.mediaType;\n              e5.push(t4.data instanceof URL ? { fileData: { mimeType: n3, fileUri: t4.data.toString() } } : { inlineData: { mimeType: n3, data: G2(t4.data) } });\n              break;\n            }\n          }\n        r2.push({ role: `user`, parts: e5 });\n        break;\n      }\n      case `assistant`:\n        i3 = false, r2.push({ role: `model`, parts: a5.map((e5) => {\n          switch (e5.type) {\n            case `text`:\n              return e5.text.length === 0 ? undefined : { text: e5.text, thoughtSignature: e5.providerOptions?.google?.thoughtSignature };\n            case `reasoning`:\n              return e5.text.length === 0 ? undefined : { text: e5.text, thought: true, thoughtSignature: e5.providerOptions?.google?.thoughtSignature };\n            case `file`:\n              if (e5.mediaType !== `image/png`)\n                throw new j2({ functionality: `Only PNG images are supported in assistant messages` });\n              if (e5.data instanceof URL)\n                throw new j2({ functionality: `File data URLs in assistant messages are not supported` });\n              return { inlineData: { mimeType: e5.mediaType, data: G2(e5.data) } };\n            case `tool-call`:\n              return { functionCall: { name: e5.toolName, args: e5.input }, thoughtSignature: e5.providerOptions?.google?.thoughtSignature };\n          }\n        }).filter((e5) => e5 !== undefined) });\n        break;\n      case `tool`: {\n        i3 = false;\n        let e5 = [];\n        for (let t4 of a5) {\n          let n3 = t4.output;\n          if (n3.type === `content`)\n            for (let r3 of n3.value)\n              switch (r3.type) {\n                case `text`:\n                  e5.push({ functionResponse: { name: t4.toolName, response: { name: t4.toolName, content: r3.text } } });\n                  break;\n                case `media`:\n                  e5.push({ inlineData: { mimeType: r3.mediaType, data: r3.data } }, { text: `Tool executed successfully and returned this image as a response` });\n                  break;\n                default:\n                  e5.push({ text: JSON.stringify(r3) });\n                  break;\n              }\n          else\n            e5.push({ functionResponse: { name: t4.toolName, response: { name: t4.toolName, content: n3.value } } });\n        }\n        r2.push({ role: `user`, parts: e5 });\n        break;\n      }\n    }\n  if (a4 && n2.length > 0 && r2.length > 0 && r2[0].role === `user`) {\n    let e5 = n2.map((e6) => e6.text).join(`\n\n`);\n    r2[0].parts.unshift({ text: e5 + `\n\n` });\n  }\n  return { systemInstruction: n2.length > 0 && !a4 ? { parts: n2 } : undefined, contents: r2 };\n}\nfunction wn(e4) {\n  return e4.includes(`/`) ? e4 : `models/${e4}`;\n}\nvar Tn = exports_external.object({ responseModalities: exports_external.array(exports_external.enum([`TEXT`, `IMAGE`])).optional(), thinkingConfig: exports_external.object({ thinkingBudget: exports_external.number().optional(), includeThoughts: exports_external.boolean().optional() }).optional(), cachedContent: exports_external.string().optional(), structuredOutputs: exports_external.boolean().optional(), safetySettings: exports_external.array(exports_external.object({ category: exports_external.enum([`HARM_CATEGORY_UNSPECIFIED`, `HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_DANGEROUS_CONTENT`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`, `HARM_CATEGORY_CIVIC_INTEGRITY`]), threshold: exports_external.enum([`HARM_BLOCK_THRESHOLD_UNSPECIFIED`, `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`]) })).optional(), threshold: exports_external.enum([`HARM_BLOCK_THRESHOLD_UNSPECIFIED`, `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`]).optional(), audioTimestamp: exports_external.boolean().optional(), labels: exports_external.record(exports_external.string(), exports_external.string()).optional() });\nfunction En({ tools: e4, toolChoice: t2, modelId: n2 }) {\n  e4 = e4?.length ? e4 : undefined;\n  let r2 = [], i3 = n2.includes(`gemini-2`), a4 = n2.includes(`gemini-1.5-flash`) && !n2.includes(`-8b`);\n  if (e4 == null)\n    return { tools: undefined, toolConfig: undefined, toolWarnings: r2 };\n  let o3 = e4.some((e5) => e5.type === `function`), s4 = e4.some((e5) => e5.type === `provider-defined`);\n  if (o3 && s4 && r2.push({ type: `unsupported-tool`, tool: e4.find((e5) => e5.type === `function`), details: `Cannot mix function tools with provider-defined tools in the same request. Please use either function tools or provider-defined tools, but not both.` }), s4) {\n    let t3 = {};\n    return e4.filter((e5) => e5.type === `provider-defined`).forEach((e5) => {\n      switch (e5.id) {\n        case `google.google_search`:\n          i3 ? t3.googleSearch = {} : a4 ? t3.googleSearchRetrieval = { dynamicRetrievalConfig: { mode: e5.args.mode, dynamicThreshold: e5.args.dynamicThreshold } } : t3.googleSearchRetrieval = {};\n          break;\n        case `google.url_context`:\n          i3 ? t3.urlContext = {} : r2.push({ type: `unsupported-tool`, tool: e5, details: `The URL context tool is not supported with other Gemini models than Gemini 2.` });\n          break;\n        case `google.code_execution`:\n          i3 ? t3.codeExecution = {} : r2.push({ type: `unsupported-tool`, tool: e5, details: `The code execution tools is not supported with other Gemini models than Gemini 2.` });\n          break;\n        default:\n          r2.push({ type: `unsupported-tool`, tool: e5 });\n          break;\n      }\n    }), { tools: Object.keys(t3).length > 0 ? t3 : undefined, toolConfig: undefined, toolWarnings: r2 };\n  }\n  let c4 = [];\n  for (let t3 of e4)\n    switch (t3.type) {\n      case `function`:\n        c4.push({ name: t3.name, description: t3.description ?? ``, parameters: X2(t3.inputSchema) });\n        break;\n      default:\n        r2.push({ type: `unsupported-tool`, tool: t3 });\n        break;\n    }\n  if (t2 == null)\n    return { tools: { functionDeclarations: c4 }, toolConfig: undefined, toolWarnings: r2 };\n  let l3 = t2.type;\n  switch (l3) {\n    case `auto`:\n      return { tools: { functionDeclarations: c4 }, toolConfig: { functionCallingConfig: { mode: `AUTO` } }, toolWarnings: r2 };\n    case `none`:\n      return { tools: { functionDeclarations: c4 }, toolConfig: { functionCallingConfig: { mode: `NONE` } }, toolWarnings: r2 };\n    case `required`:\n      return { tools: { functionDeclarations: c4 }, toolConfig: { functionCallingConfig: { mode: `ANY` } }, toolWarnings: r2 };\n    case `tool`:\n      return { tools: { functionDeclarations: c4 }, toolConfig: { functionCallingConfig: { mode: `ANY`, allowedFunctionNames: [t2.toolName] } }, toolWarnings: r2 };\n    default:\n      throw new j2({ functionality: `tool choice type: ${l3}` });\n  }\n}\nfunction Dn({ finishReason: e4, hasToolCalls: t2 }) {\n  switch (e4) {\n    case `STOP`:\n      return t2 ? `tool-calls` : `stop`;\n    case `MAX_TOKENS`:\n      return `length`;\n    case `IMAGE_SAFETY`:\n    case `RECITATION`:\n    case `SAFETY`:\n    case `BLOCKLIST`:\n    case `PROHIBITED_CONTENT`:\n    case `SPII`:\n      return `content-filter`;\n    case `FINISH_REASON_UNSPECIFIED`:\n    case `OTHER`:\n      return `other`;\n    case `MALFORMED_FUNCTION_CALL`:\n      return `error`;\n    default:\n      return `unknown`;\n  }\n}\nvar On = exports_external.object({ web: exports_external.object({ uri: exports_external.string(), title: exports_external.string() }).nullish(), retrievedContext: exports_external.object({ uri: exports_external.string(), title: exports_external.string() }).nullish() });\nvar kn = exports_external.object({ webSearchQueries: exports_external.array(exports_external.string()).nullish(), retrievalQueries: exports_external.array(exports_external.string()).nullish(), searchEntryPoint: exports_external.object({ renderedContent: exports_external.string() }).nullish(), groundingChunks: exports_external.array(On).nullish(), groundingSupports: exports_external.array(exports_external.object({ segment: exports_external.object({ startIndex: exports_external.number().nullish(), endIndex: exports_external.number().nullish(), text: exports_external.string().nullish() }), segment_text: exports_external.string().nullish(), groundingChunkIndices: exports_external.array(exports_external.number()).nullish(), supportChunkIndices: exports_external.array(exports_external.number()).nullish(), confidenceScores: exports_external.array(exports_external.number()).nullish(), confidenceScore: exports_external.array(exports_external.number()).nullish() })).nullish(), retrievalMetadata: exports_external.union([exports_external.object({ webDynamicRetrievalScore: exports_external.number() }), exports_external.object({})]).nullish() });\nvar An = z2({ id: `google.google_search`, name: `google_search`, inputSchema: exports_external.object({ mode: exports_external.enum([`MODE_DYNAMIC`, `MODE_UNSPECIFIED`]).default(`MODE_UNSPECIFIED`), dynamicThreshold: exports_external.number().default(1) }) });\nvar jn = exports_external.object({ retrievedUrl: exports_external.string(), urlRetrievalStatus: exports_external.string() });\nvar Mn = exports_external.object({ urlMetadata: exports_external.array(jn) });\nvar Nn = z2({ id: `google.url_context`, name: `url_context`, inputSchema: exports_external.object({}) });\nvar Pn = class {\n  constructor(e4, t2) {\n    this.specificationVersion = `v2`, this.modelId = e4, this.config = t2, this.generateId = t2.generateId ?? F2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get supportedUrls() {\n    var e4;\n    return (e4 = this.config).supportedUrls?.call(e4) ?? {};\n  }\n  async getArgs({ prompt: e4, maxOutputTokens: t2, temperature: n2, topP: r2, topK: i3, frequencyPenalty: a4, presencePenalty: o3, stopSequences: s4, responseFormat: c4, seed: l3, tools: u3, toolChoice: d2, providerOptions: f3 }) {\n    let p3 = [], m3 = await L2({ provider: `google`, providerOptions: f3, schema: Tn });\n    m3?.thinkingConfig?.includeThoughts === true && !this.config.provider.startsWith(`google.vertex.`) && p3.push({ type: `other`, message: `The \'includeThoughts\' option is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).` });\n    let h3 = this.modelId.toLowerCase().startsWith(`gemma-`), { contents: g3, systemInstruction: _3 } = Cn(e4, { isGemmaModel: h3 }), { tools: v3, toolConfig: y3, toolWarnings: b3 } = En({ tools: u3, toolChoice: d2, modelId: this.modelId });\n    return { args: { generationConfig: { maxOutputTokens: t2, temperature: n2, topK: i3, topP: r2, frequencyPenalty: a4, presencePenalty: o3, stopSequences: s4, seed: l3, responseMimeType: c4?.type === `json` ? `application/json` : undefined, responseSchema: c4?.type === `json` && c4.schema != null && (m3?.structuredOutputs ?? true) ? X2(c4.schema) : undefined, ...m3?.audioTimestamp && { audioTimestamp: m3.audioTimestamp }, responseModalities: m3?.responseModalities, thinkingConfig: m3?.thinkingConfig }, contents: g3, systemInstruction: h3 ? undefined : _3, safetySettings: m3?.safetySettings, tools: v3, toolConfig: y3, cachedContent: m3?.cachedContent, labels: m3?.labels }, warnings: [...p3, ...b3] };\n  }\n  async doGenerate(e4) {\n    let { args: t2, warnings: n2 } = await this.getArgs(e4), r2 = JSON.stringify(t2), i3 = M2(await V2(this.config.headers), e4.headers), { responseHeaders: a4, value: o3, rawValue: s4 } = await R2({ url: `${this.config.baseURL}/${wn(this.modelId)}:generateContent`, headers: i3, body: t2, failedResponseHandler: Y2, successfulResponseHandler: W2(Bn), abortSignal: e4.abortSignal, fetch: this.config.fetch }), c4 = o3.candidates[0], l3 = [], u3 = c4.content?.parts ?? [], d2 = o3.usageMetadata, f3;\n    for (let e5 of u3)\n      if (`executableCode` in e5 && e5.executableCode?.code) {\n        let t3 = this.config.generateId();\n        f3 = t3, l3.push({ type: `tool-call`, toolCallId: t3, toolName: `code_execution`, input: JSON.stringify(e5.executableCode), providerExecuted: true });\n      } else\n        `codeExecutionResult` in e5 && e5.codeExecutionResult ? (l3.push({ type: `tool-result`, toolCallId: f3, toolName: `code_execution`, result: { outcome: e5.codeExecutionResult.outcome, output: e5.codeExecutionResult.output }, providerExecuted: true }), f3 = undefined) : (`text` in e5) && e5.text != null && e5.text.length > 0 ? l3.push({ type: e5.thought === true ? `reasoning` : `text`, text: e5.text, providerMetadata: e5.thoughtSignature ? { google: { thoughtSignature: e5.thoughtSignature } } : undefined }) : (`functionCall` in e5) ? l3.push({ type: `tool-call`, toolCallId: this.config.generateId(), toolName: e5.functionCall.name, input: JSON.stringify(e5.functionCall.args), providerMetadata: e5.thoughtSignature ? { google: { thoughtSignature: e5.thoughtSignature } } : undefined }) : (`inlineData` in e5) && l3.push({ type: `file`, data: e5.inlineData.data, mediaType: e5.inlineData.mimeType });\n    let p3 = Ln({ groundingMetadata: c4.groundingMetadata, generateId: this.config.generateId }) ?? [];\n    for (let e5 of p3)\n      l3.push(e5);\n    return { content: l3, finishReason: Dn({ finishReason: c4.finishReason, hasToolCalls: l3.some((e5) => e5.type === `tool-call`) }), usage: { inputTokens: d2?.promptTokenCount ?? undefined, outputTokens: d2?.candidatesTokenCount ?? undefined, totalTokens: d2?.totalTokenCount ?? undefined, reasoningTokens: d2?.thoughtsTokenCount ?? undefined, cachedInputTokens: d2?.cachedContentTokenCount ?? undefined }, warnings: n2, providerMetadata: { google: { promptFeedback: o3.promptFeedback ?? null, groundingMetadata: c4.groundingMetadata ?? null, urlContextMetadata: c4.urlContextMetadata ?? null, safetyRatings: c4.safetyRatings ?? null, usageMetadata: d2 ?? null } }, request: { body: r2 }, response: { headers: a4, body: s4 } };\n  }\n  async doStream(e4) {\n    let { args: t2, warnings: n2 } = await this.getArgs(e4), r2 = JSON.stringify(t2), i3 = M2(await V2(this.config.headers), e4.headers), { responseHeaders: a4, value: o3 } = await R2({ url: `${this.config.baseURL}/${wn(this.modelId)}:streamGenerateContent?alt=sse`, headers: i3, body: t2, failedResponseHandler: Y2, successfulResponseHandler: U2(Vn), abortSignal: e4.abortSignal, fetch: this.config.fetch }), s4 = `unknown`, c4 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, l3, u3 = this.config.generateId, d2 = false, f3 = null, p3 = null, m3 = 0, h3 = new Set, g3;\n    return { stream: o3.pipeThrough(new TransformStream({ start(e5) {\n      e5.enqueue({ type: `stream-start`, warnings: n2 });\n    }, transform(t3, n3) {\n      if (e4.includeRawChunks && n3.enqueue({ type: `raw`, rawValue: t3.rawValue }), !t3.success) {\n        n3.enqueue({ type: `error`, error: t3.error });\n        return;\n      }\n      let r3 = t3.value, i4 = r3.usageMetadata;\n      i4 != null && (c4.inputTokens = i4.promptTokenCount ?? undefined, c4.outputTokens = i4.candidatesTokenCount ?? undefined, c4.totalTokens = i4.totalTokenCount ?? undefined, c4.reasoningTokens = i4.thoughtsTokenCount ?? undefined, c4.cachedInputTokens = i4.cachedContentTokenCount ?? undefined);\n      let a5 = r3.candidates?.[0];\n      if (a5 == null)\n        return;\n      let o4 = a5.content, _3 = Ln({ groundingMetadata: a5.groundingMetadata, generateId: u3 });\n      if (_3 != null)\n        for (let e5 of _3)\n          e5.sourceType === `url` && !h3.has(e5.url) && (h3.add(e5.url), n3.enqueue(e5));\n      if (o4 != null) {\n        let e5 = o4.parts ?? [];\n        for (let t5 of e5)\n          if (`executableCode` in t5 && t5.executableCode?.code) {\n            let e6 = u3();\n            g3 = e6, n3.enqueue({ type: `tool-call`, toolCallId: e6, toolName: `code_execution`, input: JSON.stringify(t5.executableCode), providerExecuted: true }), d2 = true;\n          } else if (`codeExecutionResult` in t5 && t5.codeExecutionResult) {\n            let e6 = g3;\n            e6 && (n3.enqueue({ type: `tool-result`, toolCallId: e6, toolName: `code_execution`, result: { outcome: t5.codeExecutionResult.outcome, output: t5.codeExecutionResult.output }, providerExecuted: true }), g3 = undefined);\n          } else\n            `text` in t5 && t5.text != null && t5.text.length > 0 && (t5.thought === true ? (f3 !== null && (n3.enqueue({ type: `text-end`, id: f3 }), f3 = null), p3 === null && (p3 = String(m3++), n3.enqueue({ type: `reasoning-start`, id: p3, providerMetadata: t5.thoughtSignature ? { google: { thoughtSignature: t5.thoughtSignature } } : undefined })), n3.enqueue({ type: `reasoning-delta`, id: p3, delta: t5.text, providerMetadata: t5.thoughtSignature ? { google: { thoughtSignature: t5.thoughtSignature } } : undefined })) : (p3 !== null && (n3.enqueue({ type: `reasoning-end`, id: p3 }), p3 = null), f3 === null && (f3 = String(m3++), n3.enqueue({ type: `text-start`, id: f3, providerMetadata: t5.thoughtSignature ? { google: { thoughtSignature: t5.thoughtSignature } } : undefined })), n3.enqueue({ type: `text-delta`, id: f3, delta: t5.text, providerMetadata: t5.thoughtSignature ? { google: { thoughtSignature: t5.thoughtSignature } } : undefined })));\n        let t4 = In(o4.parts);\n        if (t4 != null)\n          for (let e6 of t4)\n            n3.enqueue({ type: `file`, mediaType: e6.inlineData.mimeType, data: e6.inlineData.data });\n        let r4 = Fn({ parts: o4.parts, generateId: u3 });\n        if (r4 != null)\n          for (let e6 of r4)\n            n3.enqueue({ type: `tool-input-start`, id: e6.toolCallId, toolName: e6.toolName, providerMetadata: e6.providerMetadata }), n3.enqueue({ type: `tool-input-delta`, id: e6.toolCallId, delta: e6.args, providerMetadata: e6.providerMetadata }), n3.enqueue({ type: `tool-input-end`, id: e6.toolCallId, providerMetadata: e6.providerMetadata }), n3.enqueue({ type: `tool-call`, toolCallId: e6.toolCallId, toolName: e6.toolName, input: e6.args, providerMetadata: e6.providerMetadata }), d2 = true;\n      }\n      a5.finishReason != null && (s4 = Dn({ finishReason: a5.finishReason, hasToolCalls: d2 }), l3 = { google: { promptFeedback: r3.promptFeedback ?? null, groundingMetadata: a5.groundingMetadata ?? null, urlContextMetadata: a5.urlContextMetadata ?? null, safetyRatings: a5.safetyRatings ?? null } }, i4 != null && (l3.google.usageMetadata = i4));\n    }, flush(e5) {\n      f3 !== null && e5.enqueue({ type: `text-end`, id: f3 }), p3 !== null && e5.enqueue({ type: `reasoning-end`, id: p3 }), e5.enqueue({ type: `finish`, finishReason: s4, usage: c4, providerMetadata: l3 });\n    } })), response: { headers: a4 }, request: { body: r2 } };\n  }\n};\nfunction Fn({ parts: e4, generateId: t2 }) {\n  let n2 = e4?.filter((e5) => (`functionCall` in e5));\n  return n2 == null || n2.length === 0 ? undefined : n2.map((e5) => ({ type: `tool-call`, toolCallId: t2(), toolName: e5.functionCall.name, args: JSON.stringify(e5.functionCall.args), providerMetadata: e5.thoughtSignature ? { google: { thoughtSignature: e5.thoughtSignature } } : undefined }));\n}\nfunction In(e4) {\n  return e4?.filter((e5) => (`inlineData` in e5));\n}\nfunction Ln({ groundingMetadata: e4, generateId: t2 }) {\n  return e4?.groundingChunks?.filter((e5) => e5.web != null).map((e5) => ({ type: `source`, sourceType: `url`, id: t2(), url: e5.web.uri, title: e5.web.title }));\n}\nvar Rn = exports_external.object({ parts: exports_external.array(exports_external.union([exports_external.object({ functionCall: exports_external.object({ name: exports_external.string(), args: exports_external.unknown() }), thoughtSignature: exports_external.string().nullish() }), exports_external.object({ inlineData: exports_external.object({ mimeType: exports_external.string(), data: exports_external.string() }) }), exports_external.object({ executableCode: exports_external.object({ language: exports_external.string(), code: exports_external.string() }).nullish(), codeExecutionResult: exports_external.object({ outcome: exports_external.string(), output: exports_external.string() }).nullish(), text: exports_external.string().nullish(), thought: exports_external.boolean().nullish(), thoughtSignature: exports_external.string().nullish() })])).nullish() });\nvar Z2 = exports_external.object({ category: exports_external.string().nullish(), probability: exports_external.string().nullish(), probabilityScore: exports_external.number().nullish(), severity: exports_external.string().nullish(), severityScore: exports_external.number().nullish(), blocked: exports_external.boolean().nullish() });\nvar zn = exports_external.object({ cachedContentTokenCount: exports_external.number().nullish(), thoughtsTokenCount: exports_external.number().nullish(), promptTokenCount: exports_external.number().nullish(), candidatesTokenCount: exports_external.number().nullish(), totalTokenCount: exports_external.number().nullish() });\nvar Bn = exports_external.object({ candidates: exports_external.array(exports_external.object({ content: Rn.nullish().or(exports_external.object({}).strict()), finishReason: exports_external.string().nullish(), safetyRatings: exports_external.array(Z2).nullish(), groundingMetadata: kn.nullish(), urlContextMetadata: Mn.nullish() })), usageMetadata: zn.nullish(), promptFeedback: exports_external.object({ blockReason: exports_external.string().nullish(), safetyRatings: exports_external.array(Z2).nullish() }).nullish() });\nvar Vn = exports_external.object({ candidates: exports_external.array(exports_external.object({ content: Rn.nullish(), finishReason: exports_external.string().nullish(), safetyRatings: exports_external.array(Z2).nullish(), groundingMetadata: kn.nullish(), urlContextMetadata: Mn.nullish() })).nullish(), usageMetadata: zn.nullish(), promptFeedback: exports_external.object({ blockReason: exports_external.string().nullish(), safetyRatings: exports_external.array(Z2).nullish() }).nullish() });\nvar Hn = B2({ id: `google.code_execution`, name: `code_execution`, inputSchema: exports_external.object({ language: exports_external.string().describe(`The programming language of the code.`), code: exports_external.string().describe(`The code to be executed.`) }), outputSchema: exports_external.object({ outcome: exports_external.string().describe(`The outcome of the execution (e.g., "OUTCOME_OK").`), output: exports_external.string().describe(`The output from the code execution.`) }) });\nvar Un = { googleSearch: An, urlContext: Nn, codeExecution: Hn };\nvar Wn = class {\n  constructor(e4, t2, n2) {\n    this.modelId = e4, this.settings = t2, this.config = n2, this.specificationVersion = `v2`;\n  }\n  get maxImagesPerCall() {\n    return this.settings.maxImagesPerCall ?? 4;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate(e4) {\n    var t2;\n    let { prompt: n2, n: r2 = 1, size: i3 = `1024x1024`, aspectRatio: a4 = `1:1`, seed: o3, providerOptions: s4, headers: c4, abortSignal: l3 } = e4, u3 = [];\n    i3 != null && u3.push({ type: `unsupported-setting`, setting: `size`, details: "This model does not support the `size` option. Use `aspectRatio` instead." }), o3 != null && u3.push({ type: `unsupported-setting`, setting: `seed`, details: "This model does not support the `seed` option through this provider." });\n    let d2 = await L2({ provider: `google`, providerOptions: s4, schema: Kn }), f3 = (t2 = this.config._internal)?.currentDate?.call(t2) ?? new Date, p3 = { sampleCount: r2 };\n    a4 != null && (p3.aspectRatio = a4), d2 && Object.assign(p3, d2);\n    let m3 = { instances: [{ prompt: n2 }], parameters: p3 }, { responseHeaders: h3, value: g3 } = await R2({ url: `${this.config.baseURL}/models/${this.modelId}:predict`, headers: M2(await V2(this.config.headers), c4), body: m3, failedResponseHandler: Y2, successfulResponseHandler: W2(Gn), abortSignal: l3, fetch: this.config.fetch });\n    return { images: g3.predictions.map((e5) => e5.bytesBase64Encoded), warnings: u3 ?? [], providerMetadata: { google: { images: g3.predictions.map((e5) => ({})) } }, response: { timestamp: f3, modelId: this.modelId, headers: h3 } };\n  }\n};\nvar Gn = exports_external.object({ predictions: exports_external.array(exports_external.object({ bytesBase64Encoded: exports_external.string() })).default([]) });\nvar Kn = exports_external.object({ personGeneration: exports_external.enum([`dont_allow`, `allow_adult`, `allow_all`]).nullish(), aspectRatio: exports_external.enum([`1:1`, `3:4`, `4:3`, `9:16`, `16:9`]).nullish() });\nfunction qn(e4 = {}) {\n  let t2 = K2(e4.baseURL) ?? `https://generativelanguage.googleapis.com/v1beta`, n2 = () => P2({ "x-goog-api-key": I2({ apiKey: e4.apiKey, environmentVariableName: `GOOGLE_GENERATIVE_AI_API_KEY`, description: `Google Generative AI` }), ...e4.headers }, `ai-sdk/google/${gn}`), r2 = (r3) => new Pn(r3, { provider: `google.generative-ai`, baseURL: t2, headers: n2, generateId: e4.generateId ?? F2, supportedUrls: () => ({ "*": [RegExp(`^${t2}/files/.*$`), RegExp(`^https://(?:www\\\\.)?youtube\\\\.com/watch\\\\?v=[\\\\w-]+(?:&[\\\\w=&.-]*)?$`), RegExp(`^https://youtu\\\\.be/[\\\\w-]+(?:\\\\?[\\\\w=&.-]*)?$`)] }), fetch: e4.fetch }), i3 = (r3) => new yn(r3, { provider: `google.generative-ai`, baseURL: t2, headers: n2, fetch: e4.fetch }), a4 = (r3, i4 = {}) => new Wn(r3, i4, { provider: `google.generative-ai`, baseURL: t2, headers: n2, fetch: e4.fetch }), o3 = function(e5) {\n    if (new.target)\n      throw Error(`The Google Generative AI model function cannot be called with the new keyword.`);\n    return r2(e5);\n  };\n  return o3.languageModel = r2, o3.chat = r2, o3.generativeAI = r2, o3.embedding = i3, o3.textEmbedding = i3, o3.textEmbeddingModel = i3, o3.image = a4, o3.imageModel = a4, o3.tools = Un, o3;\n}\nqn();\nvar Jn = exports_external.object({ error: exports_external.object({ message: exports_external.string(), type: exports_external.string().nullish(), param: exports_external.any().nullish(), code: exports_external.union([exports_external.string(), exports_external.number()]).nullish() }) });\nvar Q2 = H2({ errorSchema: Jn, errorToMessage: (e4) => e4.error.message });\nfunction Yn({ prompt: e4, systemMessageMode: t2 = `system` }) {\n  let n2 = [], r2 = [];\n  for (let { role: i3, content: a4 } of e4)\n    switch (i3) {\n      case `system`:\n        switch (t2) {\n          case `system`:\n            n2.push({ role: `system`, content: a4 });\n            break;\n          case `developer`:\n            n2.push({ role: `developer`, content: a4 });\n            break;\n          case `remove`:\n            r2.push({ type: `other`, message: `system messages are removed for this model` });\n            break;\n          default: {\n            let e5 = t2;\n            throw Error(`Unsupported system message mode: ${e5}`);\n          }\n        }\n        break;\n      case `user`:\n        if (a4.length === 1 && a4[0].type === `text`) {\n          n2.push({ role: `user`, content: a4[0].text });\n          break;\n        }\n        n2.push({ role: `user`, content: a4.map((e5, t3) => {\n          switch (e5.type) {\n            case `text`:\n              return { type: `text`, text: e5.text };\n            case `file`:\n              if (e5.mediaType.startsWith(`image/`)) {\n                let t4 = e5.mediaType === `image/*` ? `image/jpeg` : e5.mediaType;\n                return { type: `image_url`, image_url: { url: e5.data instanceof URL ? e5.data.toString() : `data:${t4};base64,${G2(e5.data)}`, detail: e5.providerOptions?.openai?.imageDetail } };\n              } else if (e5.mediaType.startsWith(`audio/`)) {\n                if (e5.data instanceof URL)\n                  throw new j2({ functionality: `audio file parts with URLs` });\n                switch (e5.mediaType) {\n                  case `audio/wav`:\n                    return { type: `input_audio`, input_audio: { data: G2(e5.data), format: `wav` } };\n                  case `audio/mp3`:\n                  case `audio/mpeg`:\n                    return { type: `input_audio`, input_audio: { data: G2(e5.data), format: `mp3` } };\n                  default:\n                    throw new j2({ functionality: `audio content parts with media type ${e5.mediaType}` });\n                }\n              } else if (e5.mediaType === `application/pdf`) {\n                if (e5.data instanceof URL)\n                  throw new j2({ functionality: `PDF file parts with URLs` });\n                return { type: `file`, file: typeof e5.data == `string` && e5.data.startsWith(`file-`) ? { file_id: e5.data } : { filename: e5.filename ?? `part-${t3}.pdf`, file_data: `data:application/pdf;base64,${G2(e5.data)}` } };\n              } else\n                throw new j2({ functionality: `file part media type ${e5.mediaType}` });\n          }\n        }) });\n        break;\n      case `assistant`: {\n        let e5 = ``, t3 = [];\n        for (let n3 of a4)\n          switch (n3.type) {\n            case `text`:\n              e5 += n3.text;\n              break;\n            case `tool-call`:\n              t3.push({ id: n3.toolCallId, type: `function`, function: { name: n3.toolName, arguments: JSON.stringify(n3.input) } });\n              break;\n          }\n        n2.push({ role: `assistant`, content: e5, tool_calls: t3.length > 0 ? t3 : undefined });\n        break;\n      }\n      case `tool`:\n        for (let e5 of a4) {\n          let t3 = e5.output, r3;\n          switch (t3.type) {\n            case `text`:\n            case `error-text`:\n              r3 = t3.value;\n              break;\n            case `content`:\n            case `json`:\n            case `error-json`:\n              r3 = JSON.stringify(t3.value);\n              break;\n          }\n          n2.push({ role: `tool`, tool_call_id: e5.toolCallId, content: r3 });\n        }\n        break;\n      default: {\n        let e5 = i3;\n        throw Error(`Unsupported role: ${e5}`);\n      }\n    }\n  return { messages: n2, warnings: r2 };\n}\nfunction Xn({ id: e4, model: t2, created: n2 }) {\n  return { id: e4 ?? undefined, modelId: t2 ?? undefined, timestamp: n2 == null ? undefined : new Date(n2 * 1000) };\n}\nfunction Zn(e4) {\n  switch (e4) {\n    case `stop`:\n      return `stop`;\n    case `length`:\n      return `length`;\n    case `content_filter`:\n      return `content-filter`;\n    case `function_call`:\n    case `tool_calls`:\n      return `tool-calls`;\n    default:\n      return `unknown`;\n  }\n}\nvar Qn = exports_external.object({ logitBias: exports_external.record(exports_external.coerce.number(), exports_external.number()).optional(), logprobs: exports_external.union([exports_external.boolean(), exports_external.number()]).optional(), parallelToolCalls: exports_external.boolean().optional(), user: exports_external.string().optional(), reasoningEffort: exports_external.enum([`minimal`, `low`, `medium`, `high`]).optional(), maxCompletionTokens: exports_external.number().optional(), store: exports_external.boolean().optional(), metadata: exports_external.record(exports_external.string().max(64), exports_external.string().max(512)).optional(), prediction: exports_external.record(exports_external.string(), exports_external.any()).optional(), structuredOutputs: exports_external.boolean().optional(), serviceTier: exports_external.enum([`auto`, `flex`, `priority`]).optional(), strictJsonSchema: exports_external.boolean().optional(), textVerbosity: exports_external.enum([`low`, `medium`, `high`]).optional(), promptCacheKey: exports_external.string().optional(), safetyIdentifier: exports_external.string().optional() });\nfunction $n({ tools: e4, toolChoice: t2, structuredOutputs: n2, strictJsonSchema: r2 }) {\n  e4 = e4?.length ? e4 : undefined;\n  let i3 = [];\n  if (e4 == null)\n    return { tools: undefined, toolChoice: undefined, toolWarnings: i3 };\n  let a4 = [];\n  for (let t3 of e4)\n    switch (t3.type) {\n      case `function`:\n        a4.push({ type: `function`, function: { name: t3.name, description: t3.description, parameters: t3.inputSchema, strict: n2 ? r2 : undefined } });\n        break;\n      default:\n        i3.push({ type: `unsupported-tool`, tool: t3 });\n        break;\n    }\n  if (t2 == null)\n    return { tools: a4, toolChoice: undefined, toolWarnings: i3 };\n  let o3 = t2.type;\n  switch (o3) {\n    case `auto`:\n    case `none`:\n    case `required`:\n      return { tools: a4, toolChoice: o3, toolWarnings: i3 };\n    case `tool`:\n      return { tools: a4, toolChoice: { type: `function`, function: { name: t2.toolName } }, toolWarnings: i3 };\n    default:\n      throw new j2({ functionality: `tool choice type: ${o3}` });\n  }\n}\nvar er = class {\n  constructor(e4, t2) {\n    this.specificationVersion = `v2`, this.supportedUrls = { "image/*": [/^https?:\\/\\/.*$/] }, this.modelId = e4, this.config = t2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ prompt: e4, maxOutputTokens: t2, temperature: n2, topP: r2, topK: i3, frequencyPenalty: a4, presencePenalty: o3, stopSequences: s4, responseFormat: c4, seed: l3, tools: u3, toolChoice: d2, providerOptions: f3 }) {\n    let p3 = [], m3 = await L2({ provider: `openai`, providerOptions: f3, schema: Qn }) ?? {}, h3 = m3.structuredOutputs ?? true;\n    i3 != null && p3.push({ type: `unsupported-setting`, setting: `topK` }), c4?.type === `json` && c4.schema != null && !h3 && p3.push({ type: `unsupported-setting`, setting: `responseFormat`, details: `JSON response format schema is only supported with structuredOutputs` });\n    let { messages: g3, warnings: _3 } = Yn({ prompt: e4, systemMessageMode: sr(this.modelId) });\n    p3.push(..._3);\n    let v3 = m3.strictJsonSchema ?? false, y3 = { model: this.modelId, logit_bias: m3.logitBias, logprobs: m3.logprobs === true || typeof m3.logprobs == `number` ? true : undefined, top_logprobs: typeof m3.logprobs == `number` ? m3.logprobs : typeof m3.logprobs == `boolean` && m3.logprobs ? 0 : undefined, user: m3.user, parallel_tool_calls: m3.parallelToolCalls, max_tokens: t2, temperature: n2, top_p: r2, frequency_penalty: a4, presence_penalty: o3, response_format: c4?.type === `json` ? h3 && c4.schema != null ? { type: `json_schema`, json_schema: { schema: c4.schema, strict: v3, name: c4.name ?? `response`, description: c4.description } } : { type: `json_object` } : undefined, stop: s4, seed: l3, verbosity: m3.textVerbosity, max_completion_tokens: m3.maxCompletionTokens, store: m3.store, metadata: m3.metadata, prediction: m3.prediction, reasoning_effort: m3.reasoningEffort, service_tier: m3.serviceTier, prompt_cache_key: m3.promptCacheKey, safety_identifier: m3.safetyIdentifier, messages: g3 };\n    ir(this.modelId) ? (y3.temperature != null && (y3.temperature = undefined, p3.push({ type: `unsupported-setting`, setting: `temperature`, details: `temperature is not supported for reasoning models` })), y3.top_p != null && (y3.top_p = undefined, p3.push({ type: `unsupported-setting`, setting: `topP`, details: `topP is not supported for reasoning models` })), y3.frequency_penalty != null && (y3.frequency_penalty = undefined, p3.push({ type: `unsupported-setting`, setting: `frequencyPenalty`, details: `frequencyPenalty is not supported for reasoning models` })), y3.presence_penalty != null && (y3.presence_penalty = undefined, p3.push({ type: `unsupported-setting`, setting: `presencePenalty`, details: `presencePenalty is not supported for reasoning models` })), y3.logit_bias != null && (y3.logit_bias = undefined, p3.push({ type: `other`, message: `logitBias is not supported for reasoning models` })), y3.logprobs != null && (y3.logprobs = undefined, p3.push({ type: `other`, message: `logprobs is not supported for reasoning models` })), y3.top_logprobs != null && (y3.top_logprobs = undefined, p3.push({ type: `other`, message: `topLogprobs is not supported for reasoning models` })), y3.max_tokens != null && (y3.max_completion_tokens ??= y3.max_tokens, y3.max_tokens = undefined)) : (this.modelId.startsWith(`gpt-4o-search-preview`) || this.modelId.startsWith(`gpt-4o-mini-search-preview`)) && y3.temperature != null && (y3.temperature = undefined, p3.push({ type: `unsupported-setting`, setting: `temperature`, details: `temperature is not supported for the search preview models and has been removed.` })), m3.serviceTier === `flex` && !ar(this.modelId) && (p3.push({ type: `unsupported-setting`, setting: `serviceTier`, details: `flex processing is only available for o3, o4-mini, and gpt-5 models` }), y3.service_tier = undefined), m3.serviceTier === `priority` && !or(this.modelId) && (p3.push({ type: `unsupported-setting`, setting: `serviceTier`, details: `priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported` }), y3.service_tier = undefined);\n    let { tools: b3, toolChoice: x4, toolWarnings: S3 } = $n({ tools: u3, toolChoice: d2, structuredOutputs: h3, strictJsonSchema: v3 });\n    return { args: { ...y3, tools: b3, tool_choice: x4 }, warnings: [...p3, ...S3] };\n  }\n  async doGenerate(e4) {\n    let { args: t2, warnings: n2 } = await this.getArgs(e4), { responseHeaders: r2, value: i3, rawValue: a4 } = await R2({ url: this.config.url({ path: `/chat/completions`, modelId: this.modelId }), headers: M2(this.config.headers(), e4.headers), body: t2, failedResponseHandler: Q2, successfulResponseHandler: W2(nr), abortSignal: e4.abortSignal, fetch: this.config.fetch }), o3 = i3.choices[0], s4 = [], c4 = o3.message.content;\n    c4 != null && c4.length > 0 && s4.push({ type: `text`, text: c4 });\n    for (let e5 of o3.message.tool_calls ?? [])\n      s4.push({ type: `tool-call`, toolCallId: e5.id ?? F2(), toolName: e5.function.name, input: e5.function.arguments });\n    for (let e5 of o3.message.annotations ?? [])\n      s4.push({ type: `source`, sourceType: `url`, id: F2(), url: e5.url, title: e5.title });\n    let l3 = i3.usage?.completion_tokens_details, u3 = i3.usage?.prompt_tokens_details, d2 = { openai: {} };\n    return l3?.accepted_prediction_tokens != null && (d2.openai.acceptedPredictionTokens = l3?.accepted_prediction_tokens), l3?.rejected_prediction_tokens != null && (d2.openai.rejectedPredictionTokens = l3?.rejected_prediction_tokens), o3.logprobs?.content != null && (d2.openai.logprobs = o3.logprobs.content), { content: s4, finishReason: Zn(o3.finish_reason), usage: { inputTokens: i3.usage?.prompt_tokens ?? undefined, outputTokens: i3.usage?.completion_tokens ?? undefined, totalTokens: i3.usage?.total_tokens ?? undefined, reasoningTokens: l3?.reasoning_tokens ?? undefined, cachedInputTokens: u3?.cached_tokens ?? undefined }, request: { body: t2 }, response: { ...Xn(i3), headers: r2, body: a4 }, warnings: n2, providerMetadata: d2 };\n  }\n  async doStream(e4) {\n    let { args: t2, warnings: n2 } = await this.getArgs(e4), r2 = { ...t2, stream: true, stream_options: { include_usage: true } }, { responseHeaders: i3, value: a4 } = await R2({ url: this.config.url({ path: `/chat/completions`, modelId: this.modelId }), headers: M2(this.config.headers(), e4.headers), body: r2, failedResponseHandler: Q2, successfulResponseHandler: U2(rr), abortSignal: e4.abortSignal, fetch: this.config.fetch }), o3 = [], s4 = `unknown`, c4 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, l3 = true, u3 = false, d2 = { openai: {} };\n    return { stream: a4.pipeThrough(new TransformStream({ start(e5) {\n      e5.enqueue({ type: `stream-start`, warnings: n2 });\n    }, transform(t3, n3) {\n      if (e4.includeRawChunks && n3.enqueue({ type: `raw`, rawValue: t3.rawValue }), !t3.success) {\n        s4 = `error`, n3.enqueue({ type: `error`, error: t3.error });\n        return;\n      }\n      let r3 = t3.value;\n      if (`error` in r3) {\n        s4 = `error`, n3.enqueue({ type: `error`, error: r3.error });\n        return;\n      }\n      l3 && (l3 = false, n3.enqueue({ type: `response-metadata`, ...Xn(r3) })), r3.usage != null && (c4.inputTokens = r3.usage.prompt_tokens ?? undefined, c4.outputTokens = r3.usage.completion_tokens ?? undefined, c4.totalTokens = r3.usage.total_tokens ?? undefined, c4.reasoningTokens = r3.usage.completion_tokens_details?.reasoning_tokens ?? undefined, c4.cachedInputTokens = r3.usage.prompt_tokens_details?.cached_tokens ?? undefined, r3.usage.completion_tokens_details?.accepted_prediction_tokens != null && (d2.openai.acceptedPredictionTokens = r3.usage.completion_tokens_details?.accepted_prediction_tokens), r3.usage.completion_tokens_details?.rejected_prediction_tokens != null && (d2.openai.rejectedPredictionTokens = r3.usage.completion_tokens_details?.rejected_prediction_tokens));\n      let i4 = r3.choices[0];\n      if (i4?.finish_reason != null && (s4 = Zn(i4.finish_reason)), i4?.logprobs?.content != null && (d2.openai.logprobs = i4.logprobs.content), i4?.delta == null)\n        return;\n      let a5 = i4.delta;\n      if (a5.content != null && (u3 ||= (n3.enqueue({ type: `text-start`, id: `0` }), true), n3.enqueue({ type: `text-delta`, id: `0`, delta: a5.content })), a5.tool_calls != null)\n        for (let e5 of a5.tool_calls) {\n          let t4 = e5.index;\n          if (o3[t4] == null) {\n            if (e5.type !== `function`)\n              throw new E2({ data: e5, message: `Expected \'function\' type.` });\n            if (e5.id == null)\n              throw new E2({ data: e5, message: `Expected \'id\' to be a string.` });\n            if (e5.function?.name == null)\n              throw new E2({ data: e5, message: `Expected \'function.name\' to be a string.` });\n            n3.enqueue({ type: `tool-input-start`, id: e5.id, toolName: e5.function.name }), o3[t4] = { id: e5.id, type: `function`, function: { name: e5.function.name, arguments: e5.function.arguments ?? `` }, hasFinished: false };\n            let r5 = o3[t4];\n            r5.function?.name != null && r5.function?.arguments != null && (r5.function.arguments.length > 0 && n3.enqueue({ type: `tool-input-delta`, id: r5.id, delta: r5.function.arguments }), vt(r5.function.arguments) && (n3.enqueue({ type: `tool-input-end`, id: r5.id }), n3.enqueue({ type: `tool-call`, toolCallId: r5.id ?? F2(), toolName: r5.function.name, input: r5.function.arguments }), r5.hasFinished = true));\n            continue;\n          }\n          let r4 = o3[t4];\n          r4.hasFinished || (e5.function?.arguments != null && (r4.function.arguments += e5.function?.arguments ?? ``), n3.enqueue({ type: `tool-input-delta`, id: r4.id, delta: e5.function.arguments ?? `` }), r4.function?.name != null && r4.function?.arguments != null && vt(r4.function.arguments) && (n3.enqueue({ type: `tool-input-end`, id: r4.id }), n3.enqueue({ type: `tool-call`, toolCallId: r4.id ?? F2(), toolName: r4.function.name, input: r4.function.arguments }), r4.hasFinished = true));\n        }\n      if (a5.annotations != null)\n        for (let e5 of a5.annotations)\n          n3.enqueue({ type: `source`, sourceType: `url`, id: F2(), url: e5.url, title: e5.title });\n    }, flush(e5) {\n      u3 && e5.enqueue({ type: `text-end`, id: `0` }), e5.enqueue({ type: `finish`, finishReason: s4, usage: c4, ...d2 == null ? {} : { providerMetadata: d2 } });\n    } })), request: { body: r2 }, response: { headers: i3 } };\n  }\n};\nvar tr = exports_external.object({ prompt_tokens: exports_external.number().nullish(), completion_tokens: exports_external.number().nullish(), total_tokens: exports_external.number().nullish(), prompt_tokens_details: exports_external.object({ cached_tokens: exports_external.number().nullish() }).nullish(), completion_tokens_details: exports_external.object({ reasoning_tokens: exports_external.number().nullish(), accepted_prediction_tokens: exports_external.number().nullish(), rejected_prediction_tokens: exports_external.number().nullish() }).nullish() }).nullish();\nvar nr = exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ message: exports_external.object({ role: exports_external.literal(`assistant`).nullish(), content: exports_external.string().nullish(), tool_calls: exports_external.array(exports_external.object({ id: exports_external.string().nullish(), type: exports_external.literal(`function`), function: exports_external.object({ name: exports_external.string(), arguments: exports_external.string() }) })).nullish(), annotations: exports_external.array(exports_external.object({ type: exports_external.literal(`url_citation`), start_index: exports_external.number(), end_index: exports_external.number(), url: exports_external.string(), title: exports_external.string() })).nullish() }), index: exports_external.number(), logprobs: exports_external.object({ content: exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number(), top_logprobs: exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number() })) })).nullish() }).nullish(), finish_reason: exports_external.string().nullish() })), usage: tr });\nvar rr = exports_external.union([exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ delta: exports_external.object({ role: exports_external.enum([`assistant`]).nullish(), content: exports_external.string().nullish(), tool_calls: exports_external.array(exports_external.object({ index: exports_external.number(), id: exports_external.string().nullish(), type: exports_external.literal(`function`).nullish(), function: exports_external.object({ name: exports_external.string().nullish(), arguments: exports_external.string().nullish() }) })).nullish(), annotations: exports_external.array(exports_external.object({ type: exports_external.literal(`url_citation`), start_index: exports_external.number(), end_index: exports_external.number(), url: exports_external.string(), title: exports_external.string() })).nullish() }).nullish(), logprobs: exports_external.object({ content: exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number(), top_logprobs: exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number() })) })).nullish() }).nullish(), finish_reason: exports_external.string().nullish(), index: exports_external.number() })), usage: tr }), Jn]);\nfunction ir(e4) {\n  return (e4.startsWith(`o`) || e4.startsWith(`gpt-5`)) && !e4.startsWith(`gpt-5-chat`);\n}\nfunction ar(e4) {\n  return e4.startsWith(`o3`) || e4.startsWith(`o4-mini`) || e4.startsWith(`gpt-5`) && !e4.startsWith(`gpt-5-chat`);\n}\nfunction or(e4) {\n  return e4.startsWith(`gpt-4`) || e4.startsWith(`gpt-5-mini`) || e4.startsWith(`gpt-5`) && !e4.startsWith(`gpt-5-nano`) && !e4.startsWith(`gpt-5-chat`) || e4.startsWith(`o3`) || e4.startsWith(`o4-mini`);\n}\nfunction sr(e4) {\n  return ir(e4) ? cr[e4]?.systemMessageMode ?? `developer` : `system`;\n}\nvar cr = { "o1-mini": { systemMessageMode: `remove` }, "o1-mini-2024-09-12": { systemMessageMode: `remove` }, "o1-preview": { systemMessageMode: `remove` }, "o1-preview-2024-09-12": { systemMessageMode: `remove` }, o3: { systemMessageMode: `developer` }, "o3-2025-04-16": { systemMessageMode: `developer` }, "o3-mini": { systemMessageMode: `developer` }, "o3-mini-2025-01-31": { systemMessageMode: `developer` }, "o4-mini": { systemMessageMode: `developer` }, "o4-mini-2025-04-16": { systemMessageMode: `developer` } };\nfunction lr({ prompt: e4, user: t2 = `user`, assistant: n2 = `assistant` }) {\n  let r2 = ``;\n  e4[0].role === `system` && (r2 += `${e4[0].content}\n\n`, e4 = e4.slice(1));\n  for (let { role: i3, content: a4 } of e4)\n    switch (i3) {\n      case `system`:\n        throw new ye({ message: "Unexpected system message in prompt: ${content}", prompt: e4 });\n      case `user`: {\n        let e5 = a4.map((e6) => {\n          switch (e6.type) {\n            case `text`:\n              return e6.text;\n          }\n        }).filter(Boolean).join(``);\n        r2 += `${t2}:\n${e5}\n\n`;\n        break;\n      }\n      case `assistant`: {\n        let e5 = a4.map((e6) => {\n          switch (e6.type) {\n            case `text`:\n              return e6.text;\n            case `tool-call`:\n              throw new j2({ functionality: `tool-call messages` });\n          }\n        }).join(``);\n        r2 += `${n2}:\n${e5}\n\n`;\n        break;\n      }\n      case `tool`:\n        throw new j2({ functionality: `tool messages` });\n      default: {\n        let e5 = i3;\n        throw Error(`Unsupported role: ${e5}`);\n      }\n    }\n  return r2 += `${n2}:\n`, { prompt: r2, stopSequences: [`\n${t2}:`] };\n}\nfunction ur({ id: e4, model: t2, created: n2 }) {\n  return { id: e4 ?? undefined, modelId: t2 ?? undefined, timestamp: n2 == null ? undefined : new Date(n2 * 1000) };\n}\nfunction dr(e4) {\n  switch (e4) {\n    case `stop`:\n      return `stop`;\n    case `length`:\n      return `length`;\n    case `content_filter`:\n      return `content-filter`;\n    case `function_call`:\n    case `tool_calls`:\n      return `tool-calls`;\n    default:\n      return `unknown`;\n  }\n}\nvar fr = exports_external.object({ echo: exports_external.boolean().optional(), logitBias: exports_external.record(exports_external.string(), exports_external.number()).optional(), suffix: exports_external.string().optional(), user: exports_external.string().optional(), logprobs: exports_external.union([exports_external.boolean(), exports_external.number()]).optional() });\nvar pr = class {\n  constructor(e4, t2) {\n    this.specificationVersion = `v2`, this.supportedUrls = {}, this.modelId = e4, this.config = t2;\n  }\n  get providerOptionsName() {\n    return this.config.provider.split(`.`)[0].trim();\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ prompt: e4, maxOutputTokens: t2, temperature: n2, topP: r2, topK: i3, frequencyPenalty: a4, presencePenalty: o3, stopSequences: s4, responseFormat: c4, tools: l3, toolChoice: u3, seed: d2, providerOptions: f3 }) {\n    let p3 = [], m3 = { ...await L2({ provider: `openai`, providerOptions: f3, schema: fr }), ...await L2({ provider: this.providerOptionsName, providerOptions: f3, schema: fr }) };\n    i3 != null && p3.push({ type: `unsupported-setting`, setting: `topK` }), l3?.length && p3.push({ type: `unsupported-setting`, setting: `tools` }), u3 != null && p3.push({ type: `unsupported-setting`, setting: `toolChoice` }), c4 != null && c4.type !== `text` && p3.push({ type: `unsupported-setting`, setting: `responseFormat`, details: `JSON response format is not supported.` });\n    let { prompt: h3, stopSequences: g3 } = lr({ prompt: e4 }), _3 = [...g3 ?? [], ...s4 ?? []];\n    return { args: { model: this.modelId, echo: m3.echo, logit_bias: m3.logitBias, logprobs: m3?.logprobs === true ? 0 : m3?.logprobs === false ? undefined : m3?.logprobs, suffix: m3.suffix, user: m3.user, max_tokens: t2, temperature: n2, top_p: r2, frequency_penalty: a4, presence_penalty: o3, seed: d2, prompt: h3, stop: _3.length > 0 ? _3 : undefined }, warnings: p3 };\n  }\n  async doGenerate(e4) {\n    let { args: t2, warnings: n2 } = await this.getArgs(e4), { responseHeaders: r2, value: i3, rawValue: a4 } = await R2({ url: this.config.url({ path: `/completions`, modelId: this.modelId }), headers: M2(this.config.headers(), e4.headers), body: t2, failedResponseHandler: Q2, successfulResponseHandler: W2(hr), abortSignal: e4.abortSignal, fetch: this.config.fetch }), o3 = i3.choices[0], s4 = { openai: {} };\n    return o3.logprobs != null && (s4.openai.logprobs = o3.logprobs), { content: [{ type: `text`, text: o3.text }], usage: { inputTokens: i3.usage?.prompt_tokens, outputTokens: i3.usage?.completion_tokens, totalTokens: i3.usage?.total_tokens }, finishReason: dr(o3.finish_reason), request: { body: t2 }, response: { ...ur(i3), headers: r2, body: a4 }, providerMetadata: s4, warnings: n2 };\n  }\n  async doStream(e4) {\n    let { args: t2, warnings: n2 } = await this.getArgs(e4), r2 = { ...t2, stream: true, stream_options: { include_usage: true } }, { responseHeaders: i3, value: a4 } = await R2({ url: this.config.url({ path: `/completions`, modelId: this.modelId }), headers: M2(this.config.headers(), e4.headers), body: r2, failedResponseHandler: Q2, successfulResponseHandler: U2(gr), abortSignal: e4.abortSignal, fetch: this.config.fetch }), o3 = `unknown`, s4 = { openai: {} }, c4 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, l3 = true;\n    return { stream: a4.pipeThrough(new TransformStream({ start(e5) {\n      e5.enqueue({ type: `stream-start`, warnings: n2 });\n    }, transform(t3, n3) {\n      if (e4.includeRawChunks && n3.enqueue({ type: `raw`, rawValue: t3.rawValue }), !t3.success) {\n        o3 = `error`, n3.enqueue({ type: `error`, error: t3.error });\n        return;\n      }\n      let r3 = t3.value;\n      if (`error` in r3) {\n        o3 = `error`, n3.enqueue({ type: `error`, error: r3.error });\n        return;\n      }\n      l3 && (l3 = false, n3.enqueue({ type: `response-metadata`, ...ur(r3) }), n3.enqueue({ type: `text-start`, id: `0` })), r3.usage != null && (c4.inputTokens = r3.usage.prompt_tokens, c4.outputTokens = r3.usage.completion_tokens, c4.totalTokens = r3.usage.total_tokens);\n      let i4 = r3.choices[0];\n      i4?.finish_reason != null && (o3 = dr(i4.finish_reason)), i4?.logprobs != null && (s4.openai.logprobs = i4.logprobs), i4?.text != null && i4.text.length > 0 && n3.enqueue({ type: `text-delta`, id: `0`, delta: i4.text });\n    }, flush(e5) {\n      l3 || e5.enqueue({ type: `text-end`, id: `0` }), e5.enqueue({ type: `finish`, finishReason: o3, providerMetadata: s4, usage: c4 });\n    } })), request: { body: r2 }, response: { headers: i3 } };\n  }\n};\nvar mr = exports_external.object({ prompt_tokens: exports_external.number(), completion_tokens: exports_external.number(), total_tokens: exports_external.number() });\nvar hr = exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ text: exports_external.string(), finish_reason: exports_external.string(), logprobs: exports_external.object({ tokens: exports_external.array(exports_external.string()), token_logprobs: exports_external.array(exports_external.number()), top_logprobs: exports_external.array(exports_external.record(exports_external.string(), exports_external.number())).nullish() }).nullish() })), usage: mr.nullish() });\nvar gr = exports_external.union([exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ text: exports_external.string(), finish_reason: exports_external.string().nullish(), index: exports_external.number(), logprobs: exports_external.object({ tokens: exports_external.array(exports_external.string()), token_logprobs: exports_external.array(exports_external.number()), top_logprobs: exports_external.array(exports_external.record(exports_external.string(), exports_external.number())).nullish() }).nullish() })), usage: mr.nullish() }), Jn]);\nvar _r = exports_external.object({ dimensions: exports_external.number().optional(), user: exports_external.string().optional() });\nvar vr = class {\n  constructor(e4, t2) {\n    this.specificationVersion = `v2`, this.maxEmbeddingsPerCall = 2048, this.supportsParallelCalls = true, this.modelId = e4, this.config = t2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doEmbed({ values: e4, headers: t2, abortSignal: n2, providerOptions: r2 }) {\n    if (e4.length > this.maxEmbeddingsPerCall)\n      throw new Be({ provider: this.provider, modelId: this.modelId, maxEmbeddingsPerCall: this.maxEmbeddingsPerCall, values: e4 });\n    let i3 = await L2({ provider: `openai`, providerOptions: r2, schema: _r }) ?? {}, { responseHeaders: a4, value: o3, rawValue: s4 } = await R2({ url: this.config.url({ path: `/embeddings`, modelId: this.modelId }), headers: M2(this.config.headers(), t2), body: { model: this.modelId, input: e4, encoding_format: `float`, dimensions: i3.dimensions, user: i3.user }, failedResponseHandler: Q2, successfulResponseHandler: W2(yr), abortSignal: n2, fetch: this.config.fetch });\n    return { embeddings: o3.data.map((e5) => e5.embedding), usage: o3.usage ? { tokens: o3.usage.prompt_tokens } : undefined, response: { headers: a4, body: s4 } };\n  }\n};\nvar yr = exports_external.object({ data: exports_external.array(exports_external.object({ embedding: exports_external.array(exports_external.number()) })), usage: exports_external.object({ prompt_tokens: exports_external.number() }).nullish() });\nvar br = { "dall-e-3": 1, "dall-e-2": 10, "gpt-image-1": 10 };\nvar xr = new Set([`gpt-image-1`]);\nvar Sr = class {\n  constructor(e4, t2) {\n    this.modelId = e4, this.config = t2, this.specificationVersion = `v2`;\n  }\n  get maxImagesPerCall() {\n    return br[this.modelId] ?? 1;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate({ prompt: e4, n: t2, size: n2, aspectRatio: r2, seed: i3, providerOptions: a4, headers: o3, abortSignal: s4 }) {\n    var c4;\n    let l3 = [];\n    r2 != null && l3.push({ type: `unsupported-setting`, setting: `aspectRatio`, details: "This model does not support aspect ratio. Use `size` instead." }), i3 != null && l3.push({ type: `unsupported-setting`, setting: `seed` });\n    let u3 = (c4 = this.config._internal)?.currentDate?.call(c4) ?? new Date, { value: d2, responseHeaders: f3 } = await R2({ url: this.config.url({ path: `/images/generations`, modelId: this.modelId }), headers: M2(this.config.headers(), o3), body: { model: this.modelId, prompt: e4, n: t2, size: n2, ...a4.openai ?? {}, ...xr.has(this.modelId) ? {} : { response_format: `b64_json` } }, failedResponseHandler: Q2, successfulResponseHandler: W2(Cr), abortSignal: s4, fetch: this.config.fetch });\n    return { images: d2.data.map((e5) => e5.b64_json), warnings: l3, response: { timestamp: u3, modelId: this.modelId, headers: f3 }, providerMetadata: { openai: { images: d2.data.map((e5) => e5.revised_prompt ? { revisedPrompt: e5.revised_prompt } : null) } } };\n  }\n};\nvar Cr = exports_external.object({ data: exports_external.array(exports_external.object({ b64_json: exports_external.string(), revised_prompt: exports_external.string().optional() })) });\nvar wr = exports_external.object({ code: exports_external.string().nullish(), containerId: exports_external.string() });\nvar Tr = exports_external.object({ outputs: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`logs`), logs: exports_external.string() }), exports_external.object({ type: exports_external.literal(`image`), url: exports_external.string() })])).nullish() });\nvar Er = exports_external.object({ container: exports_external.union([exports_external.string(), exports_external.object({ fileIds: exports_external.array(exports_external.string()).optional() })]).optional() });\nvar Dr = B2({ id: `openai.code_interpreter`, name: `code_interpreter`, inputSchema: wr, outputSchema: Tr });\nvar Or = (e4 = {}) => Dr(e4);\nvar kr = exports_external.object({ key: exports_external.string(), type: exports_external.enum([`eq`, `ne`, `gt`, `gte`, `lt`, `lte`]), value: exports_external.union([exports_external.string(), exports_external.number(), exports_external.boolean()]) });\nvar Ar = exports_external.object({ type: exports_external.enum([`and`, `or`]), filters: exports_external.array(exports_external.union([kr, exports_external.lazy(() => Ar)])) });\nvar jr = exports_external.object({ vectorStoreIds: exports_external.array(exports_external.string()), maxNumResults: exports_external.number().optional(), ranking: exports_external.object({ ranker: exports_external.string().optional(), scoreThreshold: exports_external.number().optional() }).optional(), filters: exports_external.union([kr, Ar]).optional() });\nvar Mr = exports_external.object({ queries: exports_external.array(exports_external.string()), results: exports_external.array(exports_external.object({ attributes: exports_external.record(exports_external.string(), exports_external.unknown()), fileId: exports_external.string(), filename: exports_external.string(), score: exports_external.number(), text: exports_external.string() })).nullable() });\nvar Nr = B2({ id: `openai.file_search`, name: `file_search`, inputSchema: exports_external.object({}), outputSchema: Mr });\nvar Pr = exports_external.object({ background: exports_external.enum([`auto`, `opaque`, `transparent`]).optional(), inputFidelity: exports_external.enum([`low`, `high`]).optional(), inputImageMask: exports_external.object({ fileId: exports_external.string().optional(), imageUrl: exports_external.string().optional() }).optional(), model: exports_external.string().optional(), moderation: exports_external.enum([`auto`]).optional(), outputCompression: exports_external.number().int().min(0).max(100).optional(), outputFormat: exports_external.enum([`png`, `jpeg`, `webp`]).optional(), quality: exports_external.enum([`auto`, `low`, `medium`, `high`]).optional(), size: exports_external.enum([`1024x1024`, `1024x1536`, `1536x1024`, `auto`]).optional() }).strict();\nvar Fr = exports_external.object({ result: exports_external.string() });\nvar Ir = B2({ id: `openai.image_generation`, name: `image_generation`, inputSchema: exports_external.object({}), outputSchema: Fr });\nvar Lr = (e4 = {}) => Ir(e4);\nvar Rr = exports_external.object({ action: exports_external.object({ type: exports_external.literal(`exec`), command: exports_external.array(exports_external.string()), timeoutMs: exports_external.number().optional(), user: exports_external.string().optional(), workingDirectory: exports_external.string().optional(), env: exports_external.record(exports_external.string(), exports_external.string()).optional() }) });\nvar zr = exports_external.object({ output: exports_external.string() });\nvar Br = B2({ id: `openai.local_shell`, name: `local_shell`, inputSchema: Rr, outputSchema: zr });\nvar Vr = exports_external.object({ filters: exports_external.object({ allowedDomains: exports_external.array(exports_external.string()).optional() }).optional(), searchContextSize: exports_external.enum([`low`, `medium`, `high`]).optional(), userLocation: exports_external.object({ type: exports_external.literal(`approximate`), country: exports_external.string().optional(), city: exports_external.string().optional(), region: exports_external.string().optional(), timezone: exports_external.string().optional() }).optional() });\nvar Hr = z2({ id: `openai.web_search`, name: `web_search`, inputSchema: exports_external.object({ action: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`search`), query: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`open_page`), url: exports_external.string() }), exports_external.object({ type: exports_external.literal(`find`), url: exports_external.string(), pattern: exports_external.string() })]).nullish() }) });\nvar Ur = (e4 = {}) => Hr(e4);\nvar Wr = exports_external.object({ searchContextSize: exports_external.enum([`low`, `medium`, `high`]).optional(), userLocation: exports_external.object({ type: exports_external.literal(`approximate`), country: exports_external.string().optional(), city: exports_external.string().optional(), region: exports_external.string().optional(), timezone: exports_external.string().optional() }).optional() });\nvar Gr = z2({ id: `openai.web_search_preview`, name: `web_search_preview`, inputSchema: exports_external.object({ action: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`search`), query: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`open_page`), url: exports_external.string() }), exports_external.object({ type: exports_external.literal(`find`), url: exports_external.string(), pattern: exports_external.string() })]).nullish() }) });\nvar Kr = { codeInterpreter: Or, fileSearch: Nr, imageGeneration: Lr, localShell: Br, webSearchPreview: Gr, webSearch: Ur };\nfunction qr(e4, t2) {\n  return t2 ? t2.some((t3) => e4.startsWith(t3)) : false;\n}\nasync function Jr({ prompt: e4, systemMessageMode: t2, fileIdPrefixes: n2, store: r2, hasLocalShellTool: i3 = false }) {\n  let a4 = [], o3 = [];\n  for (let { role: s4, content: c4 } of e4)\n    switch (s4) {\n      case `system`:\n        switch (t2) {\n          case `system`:\n            a4.push({ role: `system`, content: c4 });\n            break;\n          case `developer`:\n            a4.push({ role: `developer`, content: c4 });\n            break;\n          case `remove`:\n            o3.push({ type: `other`, message: `system messages are removed for this model` });\n            break;\n          default: {\n            let e5 = t2;\n            throw Error(`Unsupported system message mode: ${e5}`);\n          }\n        }\n        break;\n      case `user`:\n        a4.push({ role: `user`, content: c4.map((e5, t3) => {\n          switch (e5.type) {\n            case `text`:\n              return { type: `input_text`, text: e5.text };\n            case `file`:\n              if (e5.mediaType.startsWith(`image/`)) {\n                let t4 = e5.mediaType === `image/*` ? `image/jpeg` : e5.mediaType;\n                return { type: `input_image`, ...e5.data instanceof URL ? { image_url: e5.data.toString() } : typeof e5.data == `string` && qr(e5.data, n2) ? { file_id: e5.data } : { image_url: `data:${t4};base64,${G2(e5.data)}` }, detail: e5.providerOptions?.openai?.imageDetail };\n              } else if (e5.mediaType === `application/pdf`)\n                return e5.data instanceof URL ? { type: `input_file`, file_url: e5.data.toString() } : { type: `input_file`, ...typeof e5.data == `string` && qr(e5.data, n2) ? { file_id: e5.data } : { filename: e5.filename ?? `part-${t3}.pdf`, file_data: `data:application/pdf;base64,${G2(e5.data)}` } };\n              else\n                throw new j2({ functionality: `file part media type ${e5.mediaType}` });\n          }\n        }) });\n        break;\n      case `assistant`: {\n        let e5 = {}, t3 = {};\n        for (let n3 of c4)\n          switch (n3.type) {\n            case `text`:\n              a4.push({ role: `assistant`, content: [{ type: `output_text`, text: n3.text }], id: n3.providerOptions?.openai?.itemId ?? undefined });\n              break;\n            case `tool-call`:\n              if (t3[n3.toolCallId] = n3, n3.providerExecuted)\n                break;\n              if (i3 && n3.toolName === `local_shell`) {\n                let e6 = Rr.parse(n3.input);\n                a4.push({ type: `local_shell_call`, call_id: n3.toolCallId, id: n3.providerOptions?.openai?.itemId ?? undefined, action: { type: `exec`, command: e6.action.command, timeout_ms: e6.action.timeoutMs, user: e6.action.user, working_directory: e6.action.workingDirectory, env: e6.action.env } });\n                break;\n              }\n              a4.push({ type: `function_call`, call_id: n3.toolCallId, name: n3.toolName, arguments: JSON.stringify(n3.input), id: n3.providerOptions?.openai?.itemId ?? undefined });\n              break;\n            case `tool-result`:\n              r2 ? a4.push({ type: `item_reference`, id: n3.toolCallId }) : o3.push({ type: `other`, message: `Results for OpenAI tool ${n3.toolName} are not sent to the API when store is false` });\n              break;\n            case `reasoning`: {\n              let t4 = await L2({ provider: `openai`, providerOptions: n3.providerOptions, schema: Yr }), i4 = t4?.itemId;\n              if (i4 != null) {\n                let s5 = e5[i4];\n                if (r2)\n                  s5 === undefined && (a4.push({ type: `item_reference`, id: i4 }), e5[i4] = { type: `reasoning`, id: i4, summary: [] });\n                else {\n                  let r3 = [];\n                  n3.text.length > 0 ? r3.push({ type: `summary_text`, text: n3.text }) : s5 !== undefined && o3.push({ type: `other`, message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(n3)}.` }), s5 === undefined ? (e5[i4] = { type: `reasoning`, id: i4, encrypted_content: t4?.reasoningEncryptedContent, summary: r3 }, a4.push(e5[i4])) : s5.summary.push(...r3);\n                }\n              } else\n                o3.push({ type: `other`, message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(n3)}.` });\n              break;\n            }\n          }\n        break;\n      }\n      case `tool`:\n        for (let e5 of c4) {\n          let t3 = e5.output;\n          if (i3 && e5.toolName === `local_shell` && t3.type === `json`) {\n            a4.push({ type: `local_shell_call_output`, call_id: e5.toolCallId, output: zr.parse(t3.value).output });\n            break;\n          }\n          let n3;\n          switch (t3.type) {\n            case `text`:\n            case `error-text`:\n              n3 = t3.value;\n              break;\n            case `content`:\n            case `json`:\n            case `error-json`:\n              n3 = JSON.stringify(t3.value);\n              break;\n          }\n          a4.push({ type: `function_call_output`, call_id: e5.toolCallId, output: n3 });\n        }\n        break;\n      default: {\n        let e5 = s4;\n        throw Error(`Unsupported role: ${e5}`);\n      }\n    }\n  return { input: a4, warnings: o3 };\n}\nvar Yr = exports_external.object({ itemId: exports_external.string().nullish(), reasoningEncryptedContent: exports_external.string().nullish() });\nfunction Xr({ finishReason: e4, hasFunctionCall: t2 }) {\n  switch (e4) {\n    case undefined:\n    case null:\n      return t2 ? `tool-calls` : `stop`;\n    case `max_output_tokens`:\n      return `length`;\n    case `content_filter`:\n      return `content-filter`;\n    default:\n      return t2 ? `tool-calls` : `unknown`;\n  }\n}\nfunction Zr({ tools: e4, toolChoice: t2, strictJsonSchema: n2 }) {\n  e4 = e4?.length ? e4 : undefined;\n  let r2 = [];\n  if (e4 == null)\n    return { tools: undefined, toolChoice: undefined, toolWarnings: r2 };\n  let i3 = [];\n  for (let t3 of e4)\n    switch (t3.type) {\n      case `function`:\n        i3.push({ type: `function`, name: t3.name, description: t3.description, parameters: t3.inputSchema, strict: n2 });\n        break;\n      case `provider-defined`:\n        switch (t3.id) {\n          case `openai.file_search`: {\n            let e5 = jr.parse(t3.args);\n            i3.push({ type: `file_search`, vector_store_ids: e5.vectorStoreIds, max_num_results: e5.maxNumResults, ranking_options: e5.ranking ? { ranker: e5.ranking.ranker, score_threshold: e5.ranking.scoreThreshold } : undefined, filters: e5.filters });\n            break;\n          }\n          case `openai.local_shell`:\n            i3.push({ type: `local_shell` });\n            break;\n          case `openai.web_search_preview`: {\n            let e5 = Wr.parse(t3.args);\n            i3.push({ type: `web_search_preview`, search_context_size: e5.searchContextSize, user_location: e5.userLocation });\n            break;\n          }\n          case `openai.web_search`: {\n            let e5 = Vr.parse(t3.args);\n            i3.push({ type: `web_search`, filters: e5.filters == null ? undefined : { allowed_domains: e5.filters.allowedDomains }, search_context_size: e5.searchContextSize, user_location: e5.userLocation });\n            break;\n          }\n          case `openai.code_interpreter`: {\n            let e5 = Er.parse(t3.args);\n            i3.push({ type: `code_interpreter`, container: e5.container == null ? { type: `auto`, file_ids: undefined } : typeof e5.container == `string` ? e5.container : { type: `auto`, file_ids: e5.container.fileIds } });\n            break;\n          }\n          case `openai.image_generation`: {\n            let e5 = Pr.parse(t3.args);\n            i3.push({ type: `image_generation`, background: e5.background, input_fidelity: e5.inputFidelity, input_image_mask: e5.inputImageMask ? { file_id: e5.inputImageMask.fileId, image_url: e5.inputImageMask.imageUrl } : undefined, model: e5.model, size: e5.size, quality: e5.quality, moderation: e5.moderation, output_format: e5.outputFormat, output_compression: e5.outputCompression });\n            break;\n          }\n        }\n        break;\n      default:\n        r2.push({ type: `unsupported-tool`, tool: t3 });\n        break;\n    }\n  if (t2 == null)\n    return { tools: i3, toolChoice: undefined, toolWarnings: r2 };\n  let a4 = t2.type;\n  switch (a4) {\n    case `auto`:\n    case `none`:\n    case `required`:\n      return { tools: i3, toolChoice: a4, toolWarnings: r2 };\n    case `tool`:\n      return { tools: i3, toolChoice: t2.toolName === `code_interpreter` || t2.toolName === `file_search` || t2.toolName === `image_generation` || t2.toolName === `web_search_preview` || t2.toolName === `web_search` ? { type: t2.toolName } : { type: `function`, name: t2.toolName }, toolWarnings: r2 };\n    default:\n      throw new j2({ functionality: `tool choice type: ${a4}` });\n  }\n}\nvar Qr = exports_external.object({ type: exports_external.literal(`web_search_call`), id: exports_external.string(), status: exports_external.string(), action: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`search`), query: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`open_page`), url: exports_external.string() }), exports_external.object({ type: exports_external.literal(`find`), url: exports_external.string(), pattern: exports_external.string() })]).nullish() });\nvar $r = exports_external.object({ type: exports_external.literal(`file_search_call`), id: exports_external.string(), queries: exports_external.array(exports_external.string()), results: exports_external.array(exports_external.object({ attributes: exports_external.record(exports_external.string(), exports_external.unknown()), file_id: exports_external.string(), filename: exports_external.string(), score: exports_external.number(), text: exports_external.string() })).nullish() });\nvar ei = exports_external.object({ type: exports_external.literal(`code_interpreter_call`), id: exports_external.string(), code: exports_external.string().nullable(), container_id: exports_external.string(), outputs: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`logs`), logs: exports_external.string() }), exports_external.object({ type: exports_external.literal(`image`), url: exports_external.string() })])).nullable() });\nvar ti = exports_external.object({ type: exports_external.literal(`local_shell_call`), id: exports_external.string(), call_id: exports_external.string(), action: exports_external.object({ type: exports_external.literal(`exec`), command: exports_external.array(exports_external.string()), timeout_ms: exports_external.number().optional(), user: exports_external.string().optional(), working_directory: exports_external.string().optional(), env: exports_external.record(exports_external.string(), exports_external.string()).optional() }) });\nvar ni = exports_external.object({ type: exports_external.literal(`image_generation_call`), id: exports_external.string(), result: exports_external.string() });\nvar ri = 20;\nvar ii = exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number(), top_logprobs: exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number() })) }));\nvar ai = class {\n  constructor(e4, t2) {\n    this.specificationVersion = `v2`, this.supportedUrls = { "image/*": [/^https?:\\/\\/.*$/], "application/pdf": [/^https?:\\/\\/.*$/] }, this.modelId = e4, this.config = t2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ maxOutputTokens: e4, temperature: t2, stopSequences: n2, topP: r2, topK: i3, presencePenalty: a4, frequencyPenalty: o3, seed: s4, prompt: c4, providerOptions: l3, tools: u3, toolChoice: d2, responseFormat: f3 }) {\n    let p3 = [], m3 = Pi(this.modelId);\n    i3 != null && p3.push({ type: `unsupported-setting`, setting: `topK` }), s4 != null && p3.push({ type: `unsupported-setting`, setting: `seed` }), a4 != null && p3.push({ type: `unsupported-setting`, setting: `presencePenalty` }), o3 != null && p3.push({ type: `unsupported-setting`, setting: `frequencyPenalty` }), n2 != null && p3.push({ type: `unsupported-setting`, setting: `stopSequences` });\n    let h3 = await L2({ provider: `openai`, providerOptions: l3, schema: Fi }), { input: g3, warnings: _3 } = await Jr({ prompt: c4, systemMessageMode: m3.systemMessageMode, fileIdPrefixes: this.config.fileIdPrefixes, store: h3?.store ?? true, hasLocalShellTool: x4(`openai.local_shell`) });\n    p3.push(..._3);\n    let v3 = h3?.strictJsonSchema ?? false, y3 = h3?.include;\n    function b3(e5) {\n      y3 = y3 == null ? [e5] : [...y3, e5];\n    }\n    function x4(e5) {\n      return u3?.find((t3) => t3.type === `provider-defined` && t3.id === e5) != null;\n    }\n    let S3 = typeof h3?.logprobs == `number` ? h3?.logprobs : h3?.logprobs === true ? ri : undefined;\n    S3 && b3(`message.output_text.logprobs`);\n    let C3 = u3?.find((e5) => e5.type === `provider-defined` && (e5.id === `openai.web_search` || e5.id === `openai.web_search_preview`))?.name;\n    C3 && b3(`web_search_call.action.sources`), x4(`openai.code_interpreter`) && b3(`code_interpreter_call.outputs`);\n    let w3 = { model: this.modelId, input: g3, temperature: t2, top_p: r2, max_output_tokens: e4, ...(f3?.type === `json` || h3?.textVerbosity) && { text: { ...f3?.type === `json` && { format: f3.schema == null ? { type: `json_object` } : { type: `json_schema`, strict: v3, name: f3.name ?? `response`, description: f3.description, schema: f3.schema } }, ...h3?.textVerbosity && { verbosity: h3.textVerbosity } } }, max_tool_calls: h3?.maxToolCalls, metadata: h3?.metadata, parallel_tool_calls: h3?.parallelToolCalls, previous_response_id: h3?.previousResponseId, store: h3?.store, user: h3?.user, instructions: h3?.instructions, service_tier: h3?.serviceTier, include: y3, prompt_cache_key: h3?.promptCacheKey, safety_identifier: h3?.safetyIdentifier, top_logprobs: S3, ...m3.isReasoningModel && (h3?.reasoningEffort != null || h3?.reasoningSummary != null) && { reasoning: { ...h3?.reasoningEffort != null && { effort: h3.reasoningEffort }, ...h3?.reasoningSummary != null && { summary: h3.reasoningSummary } } }, ...m3.requiredAutoTruncation && { truncation: `auto` } };\n    m3.isReasoningModel ? (w3.temperature != null && (w3.temperature = undefined, p3.push({ type: `unsupported-setting`, setting: `temperature`, details: `temperature is not supported for reasoning models` })), w3.top_p != null && (w3.top_p = undefined, p3.push({ type: `unsupported-setting`, setting: `topP`, details: `topP is not supported for reasoning models` }))) : (h3?.reasoningEffort != null && p3.push({ type: `unsupported-setting`, setting: `reasoningEffort`, details: `reasoningEffort is not supported for non-reasoning models` }), h3?.reasoningSummary != null && p3.push({ type: `unsupported-setting`, setting: `reasoningSummary`, details: `reasoningSummary is not supported for non-reasoning models` })), h3?.serviceTier === `flex` && !m3.supportsFlexProcessing && (p3.push({ type: `unsupported-setting`, setting: `serviceTier`, details: `flex processing is only available for o3, o4-mini, and gpt-5 models` }), delete w3.service_tier), h3?.serviceTier === `priority` && !m3.supportsPriorityProcessing && (p3.push({ type: `unsupported-setting`, setting: `serviceTier`, details: `priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported` }), delete w3.service_tier);\n    let { tools: ee3, toolChoice: te3, toolWarnings: ne3 } = Zr({ tools: u3, toolChoice: d2, strictJsonSchema: v3 });\n    return { webSearchToolName: C3, args: { ...w3, tools: ee3, tool_choice: te3 }, warnings: [...p3, ...ne3] };\n  }\n  async doGenerate(e4) {\n    var t2, n2;\n    let { args: r2, warnings: a4, webSearchToolName: o3 } = await this.getArgs(e4), s4 = this.config.url({ path: `/responses`, modelId: this.modelId }), { responseHeaders: c4, value: l3, rawValue: u3 } = await R2({ url: s4, headers: M2(this.config.headers(), e4.headers), body: r2, failedResponseHandler: Q2, successfulResponseHandler: W2(exports_external.object({ id: exports_external.string(), created_at: exports_external.number(), error: exports_external.object({ code: exports_external.string(), message: exports_external.string() }).nullish(), model: exports_external.string(), output: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`message`), role: exports_external.literal(`assistant`), id: exports_external.string(), content: exports_external.array(exports_external.object({ type: exports_external.literal(`output_text`), text: exports_external.string(), logprobs: ii.nullish(), annotations: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`url_citation`), start_index: exports_external.number(), end_index: exports_external.number(), url: exports_external.string(), title: exports_external.string() }), exports_external.object({ type: exports_external.literal(`file_citation`), file_id: exports_external.string(), filename: exports_external.string().nullish(), index: exports_external.number().nullish(), start_index: exports_external.number().nullish(), end_index: exports_external.number().nullish(), quote: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`container_file_citation`) })])) })) }), Qr, $r, ei, ni, ti, exports_external.object({ type: exports_external.literal(`function_call`), call_id: exports_external.string(), name: exports_external.string(), arguments: exports_external.string(), id: exports_external.string() }), exports_external.object({ type: exports_external.literal(`computer_call`), id: exports_external.string(), status: exports_external.string().optional() }), exports_external.object({ type: exports_external.literal(`reasoning`), id: exports_external.string(), encrypted_content: exports_external.string().nullish(), summary: exports_external.array(exports_external.object({ type: exports_external.literal(`summary_text`), text: exports_external.string() })) })])), service_tier: exports_external.string().nullish(), incomplete_details: exports_external.object({ reason: exports_external.string() }).nullish(), usage: oi })), abortSignal: e4.abortSignal, fetch: this.config.fetch });\n    if (l3.error)\n      throw new T2({ message: l3.error.message, url: s4, requestBodyValues: r2, statusCode: 400, responseHeaders: c4, responseBody: u3, isRetryable: false });\n    let d2 = [], f3 = [], p3 = false;\n    for (let r3 of l3.output)\n      switch (r3.type) {\n        case `reasoning`:\n          r3.summary.length === 0 && r3.summary.push({ type: `summary_text`, text: `` });\n          for (let e5 of r3.summary)\n            d2.push({ type: `reasoning`, text: e5.text, providerMetadata: { openai: { itemId: r3.id, reasoningEncryptedContent: r3.encrypted_content ?? null } } });\n          break;\n        case `image_generation_call`:\n          d2.push({ type: `tool-call`, toolCallId: r3.id, toolName: `image_generation`, input: `{}`, providerExecuted: true }), d2.push({ type: `tool-result`, toolCallId: r3.id, toolName: `image_generation`, result: { result: r3.result }, providerExecuted: true });\n          break;\n        case `local_shell_call`:\n          d2.push({ type: `tool-call`, toolCallId: r3.call_id, toolName: `local_shell`, input: JSON.stringify({ action: r3.action }), providerMetadata: { openai: { itemId: r3.id } } });\n          break;\n        case `message`:\n          for (let i3 of r3.content) {\n            e4.providerOptions?.openai?.logprobs && i3.logprobs && f3.push(i3.logprobs), d2.push({ type: `text`, text: i3.text, providerMetadata: { openai: { itemId: r3.id } } });\n            for (let e5 of i3.annotations)\n              e5.type === `url_citation` ? d2.push({ type: `source`, sourceType: `url`, id: (t2 = this.config).generateId?.call(t2) ?? F2(), url: e5.url, title: e5.title }) : e5.type === `file_citation` && d2.push({ type: `source`, sourceType: `document`, id: (n2 = this.config).generateId?.call(n2) ?? F2(), mediaType: `text/plain`, title: e5.quote ?? e5.filename ?? `Document`, filename: e5.filename ?? e5.file_id });\n          }\n          break;\n        case `function_call`:\n          p3 = true, d2.push({ type: `tool-call`, toolCallId: r3.call_id, toolName: r3.name, input: r3.arguments, providerMetadata: { openai: { itemId: r3.id } } });\n          break;\n        case `web_search_call`:\n          d2.push({ type: `tool-call`, toolCallId: r3.id, toolName: o3 ?? `web_search`, input: JSON.stringify({ action: r3.action }), providerExecuted: true }), d2.push({ type: `tool-result`, toolCallId: r3.id, toolName: o3 ?? `web_search`, result: { status: r3.status }, providerExecuted: true });\n          break;\n        case `computer_call`:\n          d2.push({ type: `tool-call`, toolCallId: r3.id, toolName: `computer_use`, input: ``, providerExecuted: true }), d2.push({ type: `tool-result`, toolCallId: r3.id, toolName: `computer_use`, result: { type: `computer_use_tool_result`, status: r3.status || `completed` }, providerExecuted: true });\n          break;\n        case `file_search_call`:\n          d2.push({ type: `tool-call`, toolCallId: r3.id, toolName: `file_search`, input: `{}`, providerExecuted: true }), d2.push({ type: `tool-result`, toolCallId: r3.id, toolName: `file_search`, result: { queries: r3.queries, results: r3.results?.map((e5) => ({ attributes: e5.attributes, fileId: e5.file_id, filename: e5.filename, score: e5.score, text: e5.text })) ?? null }, providerExecuted: true });\n          break;\n        case `code_interpreter_call`:\n          d2.push({ type: `tool-call`, toolCallId: r3.id, toolName: `code_interpreter`, input: JSON.stringify({ code: r3.code, containerId: r3.container_id }), providerExecuted: true }), d2.push({ type: `tool-result`, toolCallId: r3.id, toolName: `code_interpreter`, result: { outputs: r3.outputs }, providerExecuted: true });\n          break;\n      }\n    let m3 = { openai: { responseId: l3.id } };\n    return f3.length > 0 && (m3.openai.logprobs = f3), typeof l3.service_tier == `string` && (m3.openai.serviceTier = l3.service_tier), { content: d2, finishReason: Xr({ finishReason: l3.incomplete_details?.reason, hasFunctionCall: p3 }), usage: { inputTokens: l3.usage.input_tokens, outputTokens: l3.usage.output_tokens, totalTokens: l3.usage.input_tokens + l3.usage.output_tokens, reasoningTokens: l3.usage.output_tokens_details?.reasoning_tokens ?? undefined, cachedInputTokens: l3.usage.input_tokens_details?.cached_tokens ?? undefined }, request: { body: r2 }, response: { id: l3.id, timestamp: new Date(l3.created_at * 1000), modelId: l3.model, headers: c4, body: u3 }, providerMetadata: m3, warnings: a4 };\n  }\n  async doStream(e4) {\n    let { args: t2, warnings: n2, webSearchToolName: r2 } = await this.getArgs(e4), { responseHeaders: i3, value: a4 } = await R2({ url: this.config.url({ path: `/responses`, modelId: this.modelId }), headers: M2(this.config.headers(), e4.headers), body: { ...t2, stream: true }, failedResponseHandler: Q2, successfulResponseHandler: U2(yi), abortSignal: e4.abortSignal, fetch: this.config.fetch }), o3 = this, s4 = `unknown`, c4 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, l3 = [], u3 = null, d2 = {}, f3 = false, p3 = {}, m3;\n    return { stream: a4.pipeThrough(new TransformStream({ start(e5) {\n      e5.enqueue({ type: `stream-start`, warnings: n2 });\n    }, transform(t3, n3) {\n      var i4, a5, h3;\n      if (e4.includeRawChunks && n3.enqueue({ type: `raw`, rawValue: t3.rawValue }), !t3.success) {\n        s4 = `error`, n3.enqueue({ type: `error`, error: t3.error });\n        return;\n      }\n      let g3 = t3.value;\n      if (Oi(g3))\n        g3.item.type === `function_call` ? (d2[g3.output_index] = { toolName: g3.item.name, toolCallId: g3.item.call_id }, n3.enqueue({ type: `tool-input-start`, id: g3.item.call_id, toolName: g3.item.name })) : g3.item.type === `web_search_call` ? (d2[g3.output_index] = { toolName: r2 ?? `web_search`, toolCallId: g3.item.id }, n3.enqueue({ type: `tool-input-start`, id: g3.item.id, toolName: r2 ?? `web_search` })) : g3.item.type === `computer_call` ? (d2[g3.output_index] = { toolName: `computer_use`, toolCallId: g3.item.id }, n3.enqueue({ type: `tool-input-start`, id: g3.item.id, toolName: `computer_use` })) : g3.item.type === `code_interpreter_call` ? (d2[g3.output_index] = { toolName: `code_interpreter`, toolCallId: g3.item.id, codeInterpreter: { containerId: g3.item.container_id } }, n3.enqueue({ type: `tool-input-start`, id: g3.item.id, toolName: `code_interpreter` }), n3.enqueue({ type: `tool-input-delta`, id: g3.item.id, delta: `{"containerId":"${g3.item.container_id}","code":"` })) : g3.item.type === `file_search_call` ? n3.enqueue({ type: `tool-call`, toolCallId: g3.item.id, toolName: `file_search`, input: `{}`, providerExecuted: true }) : g3.item.type === `image_generation_call` ? n3.enqueue({ type: `tool-call`, toolCallId: g3.item.id, toolName: `image_generation`, input: `{}`, providerExecuted: true }) : g3.item.type === `message` ? n3.enqueue({ type: `text-start`, id: g3.item.id, providerMetadata: { openai: { itemId: g3.item.id } } }) : ki(g3) && (p3[g3.item.id] = { encryptedContent: g3.item.encrypted_content, summaryParts: [0] }, n3.enqueue({ type: `reasoning-start`, id: `${g3.item.id}:0`, providerMetadata: { openai: { itemId: g3.item.id, reasoningEncryptedContent: g3.item.encrypted_content ?? null } } }));\n      else if (xi(g3)) {\n        if (g3.item.type === `function_call`)\n          d2[g3.output_index] = undefined, f3 = true, n3.enqueue({ type: `tool-input-end`, id: g3.item.call_id }), n3.enqueue({ type: `tool-call`, toolCallId: g3.item.call_id, toolName: g3.item.name, input: g3.item.arguments, providerMetadata: { openai: { itemId: g3.item.id } } });\n        else if (g3.item.type === `web_search_call`)\n          d2[g3.output_index] = undefined, n3.enqueue({ type: `tool-input-end`, id: g3.item.id }), n3.enqueue({ type: `tool-call`, toolCallId: g3.item.id, toolName: `web_search`, input: JSON.stringify({ action: g3.item.action }), providerExecuted: true }), n3.enqueue({ type: `tool-result`, toolCallId: g3.item.id, toolName: `web_search`, result: { status: g3.item.status }, providerExecuted: true });\n        else if (g3.item.type === `computer_call`)\n          d2[g3.output_index] = undefined, n3.enqueue({ type: `tool-input-end`, id: g3.item.id }), n3.enqueue({ type: `tool-call`, toolCallId: g3.item.id, toolName: `computer_use`, input: ``, providerExecuted: true }), n3.enqueue({ type: `tool-result`, toolCallId: g3.item.id, toolName: `computer_use`, result: { type: `computer_use_tool_result`, status: g3.item.status || `completed` }, providerExecuted: true });\n        else if (g3.item.type === `file_search_call`)\n          d2[g3.output_index] = undefined, n3.enqueue({ type: `tool-result`, toolCallId: g3.item.id, toolName: `file_search`, result: { queries: g3.item.queries, results: g3.item.results?.map((e5) => ({ attributes: e5.attributes, fileId: e5.file_id, filename: e5.filename, score: e5.score, text: e5.text })) ?? null }, providerExecuted: true });\n        else if (g3.item.type === `code_interpreter_call`)\n          d2[g3.output_index] = undefined, n3.enqueue({ type: `tool-result`, toolCallId: g3.item.id, toolName: `code_interpreter`, result: { outputs: g3.item.outputs }, providerExecuted: true });\n        else if (g3.item.type === `image_generation_call`)\n          n3.enqueue({ type: `tool-result`, toolCallId: g3.item.id, toolName: `image_generation`, result: { result: g3.item.result }, providerExecuted: true });\n        else if (g3.item.type === `local_shell_call`)\n          d2[g3.output_index] = undefined, n3.enqueue({ type: `tool-call`, toolCallId: g3.item.call_id, toolName: `local_shell`, input: JSON.stringify({ action: { type: `exec`, command: g3.item.action.command, timeoutMs: g3.item.action.timeout_ms, user: g3.item.action.user, workingDirectory: g3.item.action.working_directory, env: g3.item.action.env } }), providerMetadata: { openai: { itemId: g3.item.id } } });\n        else if (g3.item.type === `message`)\n          n3.enqueue({ type: `text-end`, id: g3.item.id });\n        else if (Si(g3)) {\n          let e5 = p3[g3.item.id];\n          for (let t4 of e5.summaryParts)\n            n3.enqueue({ type: `reasoning-end`, id: `${g3.item.id}:${t4}`, providerMetadata: { openai: { itemId: g3.item.id, reasoningEncryptedContent: g3.item.encrypted_content ?? null } } });\n          delete p3[g3.item.id];\n        }\n      } else if (Ti(g3)) {\n        let e5 = d2[g3.output_index];\n        e5 != null && n3.enqueue({ type: `tool-input-delta`, id: e5.toolCallId, delta: g3.delta });\n      } else if (Ei(g3)) {\n        let e5 = d2[g3.output_index];\n        e5 != null && n3.enqueue({ type: `tool-input-delta`, id: e5.toolCallId, delta: JSON.stringify(g3.delta).slice(1, -1) });\n      } else if (Di(g3)) {\n        let e5 = d2[g3.output_index];\n        e5 != null && (n3.enqueue({ type: `tool-input-delta`, id: e5.toolCallId, delta: `"}` }), n3.enqueue({ type: `tool-input-end`, id: e5.toolCallId }), n3.enqueue({ type: `tool-call`, toolCallId: e5.toolCallId, toolName: `code_interpreter`, input: JSON.stringify({ code: g3.code, containerId: e5.codeInterpreter.containerId }), providerExecuted: true }));\n      } else\n        wi(g3) ? (u3 = g3.response.id, n3.enqueue({ type: `response-metadata`, id: g3.response.id, timestamp: new Date(g3.response.created_at * 1000), modelId: g3.response.model })) : bi(g3) ? (n3.enqueue({ type: `text-delta`, id: g3.item_id, delta: g3.delta }), e4.providerOptions?.openai?.logprobs && g3.logprobs && l3.push(g3.logprobs)) : ji(g3) ? g3.summary_index > 0 && ((i4 = p3[g3.item_id]) == null || i4.summaryParts.push(g3.summary_index), n3.enqueue({ type: `reasoning-start`, id: `${g3.item_id}:${g3.summary_index}`, providerMetadata: { openai: { itemId: g3.item_id, reasoningEncryptedContent: p3[g3.item_id]?.encryptedContent ?? null } } })) : Mi(g3) ? n3.enqueue({ type: `reasoning-delta`, id: `${g3.item_id}:${g3.summary_index}`, delta: g3.delta, providerMetadata: { openai: { itemId: g3.item_id } } }) : Ci(g3) ? (s4 = Xr({ finishReason: g3.response.incomplete_details?.reason, hasFunctionCall: f3 }), c4.inputTokens = g3.response.usage.input_tokens, c4.outputTokens = g3.response.usage.output_tokens, c4.totalTokens = g3.response.usage.input_tokens + g3.response.usage.output_tokens, c4.reasoningTokens = g3.response.usage.output_tokens_details?.reasoning_tokens ?? undefined, c4.cachedInputTokens = g3.response.usage.input_tokens_details?.cached_tokens ?? undefined, typeof g3.response.service_tier == `string` && (m3 = g3.response.service_tier)) : Ai(g3) ? g3.annotation.type === `url_citation` ? n3.enqueue({ type: `source`, sourceType: `url`, id: (a5 = o3.config).generateId?.call(a5) ?? F2(), url: g3.annotation.url, title: g3.annotation.title }) : g3.annotation.type === `file_citation` && n3.enqueue({ type: `source`, sourceType: `document`, id: (h3 = o3.config).generateId?.call(h3) ?? F2(), mediaType: `text/plain`, title: g3.annotation.quote ?? g3.annotation.filename ?? `Document`, filename: g3.annotation.filename ?? g3.annotation.file_id }) : Ni(g3) && n3.enqueue({ type: `error`, error: g3 });\n    }, flush(e5) {\n      let t3 = { openai: { responseId: u3 } };\n      l3.length > 0 && (t3.openai.logprobs = l3), m3 !== undefined && (t3.openai.serviceTier = m3), e5.enqueue({ type: `finish`, finishReason: s4, usage: c4, providerMetadata: t3 });\n    } })), request: { body: t2 }, response: { headers: i3 } };\n  }\n};\nvar oi = exports_external.object({ input_tokens: exports_external.number(), input_tokens_details: exports_external.object({ cached_tokens: exports_external.number().nullish() }).nullish(), output_tokens: exports_external.number(), output_tokens_details: exports_external.object({ reasoning_tokens: exports_external.number().nullish() }).nullish() });\nvar si = exports_external.object({ type: exports_external.literal(`response.output_text.delta`), item_id: exports_external.string(), delta: exports_external.string(), logprobs: ii.nullish() });\nvar ci = exports_external.object({ type: exports_external.literal(`error`), code: exports_external.string(), message: exports_external.string(), param: exports_external.string().nullish(), sequence_number: exports_external.number() });\nvar li = exports_external.object({ type: exports_external.enum([`response.completed`, `response.incomplete`]), response: exports_external.object({ incomplete_details: exports_external.object({ reason: exports_external.string() }).nullish(), usage: oi, service_tier: exports_external.string().nullish() }) });\nvar ui = exports_external.object({ type: exports_external.literal(`response.created`), response: exports_external.object({ id: exports_external.string(), created_at: exports_external.number(), model: exports_external.string(), service_tier: exports_external.string().nullish() }) });\nvar di = exports_external.object({ type: exports_external.literal(`response.output_item.added`), output_index: exports_external.number(), item: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`message`), id: exports_external.string() }), exports_external.object({ type: exports_external.literal(`reasoning`), id: exports_external.string(), encrypted_content: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`function_call`), id: exports_external.string(), call_id: exports_external.string(), name: exports_external.string(), arguments: exports_external.string() }), exports_external.object({ type: exports_external.literal(`web_search_call`), id: exports_external.string(), status: exports_external.string(), action: exports_external.object({ type: exports_external.literal(`search`), query: exports_external.string().optional() }).nullish() }), exports_external.object({ type: exports_external.literal(`computer_call`), id: exports_external.string(), status: exports_external.string() }), exports_external.object({ type: exports_external.literal(`file_search_call`), id: exports_external.string() }), exports_external.object({ type: exports_external.literal(`image_generation_call`), id: exports_external.string() }), exports_external.object({ type: exports_external.literal(`code_interpreter_call`), id: exports_external.string(), container_id: exports_external.string(), code: exports_external.string().nullable(), outputs: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`logs`), logs: exports_external.string() }), exports_external.object({ type: exports_external.literal(`image`), url: exports_external.string() })])).nullable(), status: exports_external.string() })]) });\nvar fi = exports_external.object({ type: exports_external.literal(`response.output_item.done`), output_index: exports_external.number(), item: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`message`), id: exports_external.string() }), exports_external.object({ type: exports_external.literal(`reasoning`), id: exports_external.string(), encrypted_content: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`function_call`), id: exports_external.string(), call_id: exports_external.string(), name: exports_external.string(), arguments: exports_external.string(), status: exports_external.literal(`completed`) }), ei, ni, Qr, $r, ti, exports_external.object({ type: exports_external.literal(`computer_call`), id: exports_external.string(), status: exports_external.literal(`completed`) })]) });\nvar pi = exports_external.object({ type: exports_external.literal(`response.function_call_arguments.delta`), item_id: exports_external.string(), output_index: exports_external.number(), delta: exports_external.string() });\nvar mi = exports_external.object({ type: exports_external.literal(`response.code_interpreter_call_code.delta`), item_id: exports_external.string(), output_index: exports_external.number(), delta: exports_external.string() });\nvar hi = exports_external.object({ type: exports_external.literal(`response.code_interpreter_call_code.done`), item_id: exports_external.string(), output_index: exports_external.number(), code: exports_external.string() });\nvar gi = exports_external.object({ type: exports_external.literal(`response.output_text.annotation.added`), annotation: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`url_citation`), url: exports_external.string(), title: exports_external.string() }), exports_external.object({ type: exports_external.literal(`file_citation`), file_id: exports_external.string(), filename: exports_external.string().nullish(), index: exports_external.number().nullish(), start_index: exports_external.number().nullish(), end_index: exports_external.number().nullish(), quote: exports_external.string().nullish() })]) });\nvar _i = exports_external.object({ type: exports_external.literal(`response.reasoning_summary_part.added`), item_id: exports_external.string(), summary_index: exports_external.number() });\nvar vi = exports_external.object({ type: exports_external.literal(`response.reasoning_summary_text.delta`), item_id: exports_external.string(), summary_index: exports_external.number(), delta: exports_external.string() });\nvar yi = exports_external.union([si, li, ui, di, fi, pi, mi, hi, gi, _i, vi, ci, exports_external.object({ type: exports_external.string() }).loose()]);\nfunction bi(e4) {\n  return e4.type === `response.output_text.delta`;\n}\nfunction xi(e4) {\n  return e4.type === `response.output_item.done`;\n}\nfunction Si(e4) {\n  return xi(e4) && e4.item.type === `reasoning`;\n}\nfunction Ci(e4) {\n  return e4.type === `response.completed` || e4.type === `response.incomplete`;\n}\nfunction wi(e4) {\n  return e4.type === `response.created`;\n}\nfunction Ti(e4) {\n  return e4.type === `response.function_call_arguments.delta`;\n}\nfunction Ei(e4) {\n  return e4.type === `response.code_interpreter_call_code.delta`;\n}\nfunction Di(e4) {\n  return e4.type === `response.code_interpreter_call_code.done`;\n}\nfunction Oi(e4) {\n  return e4.type === `response.output_item.added`;\n}\nfunction ki(e4) {\n  return Oi(e4) && e4.item.type === `reasoning`;\n}\nfunction Ai(e4) {\n  return e4.type === `response.output_text.annotation.added`;\n}\nfunction ji(e4) {\n  return e4.type === `response.reasoning_summary_part.added`;\n}\nfunction Mi(e4) {\n  return e4.type === `response.reasoning_summary_text.delta`;\n}\nfunction Ni(e4) {\n  return e4.type === `error`;\n}\nfunction Pi(e4) {\n  let t2 = e4.startsWith(`o3`) || e4.startsWith(`o4-mini`) || e4.startsWith(`gpt-5`) && !e4.startsWith(`gpt-5-chat`), n2 = e4.startsWith(`gpt-4`) || e4.startsWith(`gpt-5-mini`) || e4.startsWith(`gpt-5`) && !e4.startsWith(`gpt-5-nano`) && !e4.startsWith(`gpt-5-chat`) || e4.startsWith(`o3`) || e4.startsWith(`o4-mini`), r2 = { requiredAutoTruncation: false, systemMessageMode: `system`, supportsFlexProcessing: t2, supportsPriorityProcessing: n2 };\n  return e4.startsWith(`gpt-5-chat`) ? { ...r2, isReasoningModel: false } : e4.startsWith(`o`) || e4.startsWith(`gpt-5`) || e4.startsWith(`codex-`) || e4.startsWith(`computer-use`) ? e4.startsWith(`o1-mini`) || e4.startsWith(`o1-preview`) ? { ...r2, isReasoningModel: true, systemMessageMode: `remove` } : { ...r2, isReasoningModel: true, systemMessageMode: `developer` } : { ...r2, isReasoningModel: false };\n}\nvar Fi = exports_external.object({ include: exports_external.array(exports_external.enum([`reasoning.encrypted_content`, `file_search_call.results`, `message.output_text.logprobs`])).nullish(), instructions: exports_external.string().nullish(), logprobs: exports_external.union([exports_external.boolean(), exports_external.number().min(1).max(ri)]).optional(), maxToolCalls: exports_external.number().nullish(), metadata: exports_external.any().nullish(), parallelToolCalls: exports_external.boolean().nullish(), previousResponseId: exports_external.string().nullish(), promptCacheKey: exports_external.string().nullish(), reasoningEffort: exports_external.string().nullish(), reasoningSummary: exports_external.string().nullish(), safetyIdentifier: exports_external.string().nullish(), serviceTier: exports_external.enum([`auto`, `flex`, `priority`]).nullish(), store: exports_external.boolean().nullish(), strictJsonSchema: exports_external.boolean().nullish(), textVerbosity: exports_external.enum([`low`, `medium`, `high`]).nullish(), user: exports_external.string().nullish() });\nvar Ii = exports_external.object({ instructions: exports_external.string().nullish(), speed: exports_external.number().min(0.25).max(4).default(1).nullish() });\nvar Li = class {\n  constructor(e4, t2) {\n    this.modelId = e4, this.config = t2, this.specificationVersion = `v2`;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ text: e4, voice: t2 = `alloy`, outputFormat: n2 = `mp3`, speed: r2, instructions: i3, language: a4, providerOptions: o3 }) {\n    let s4 = [], c4 = await L2({ provider: `openai`, providerOptions: o3, schema: Ii }), l3 = { model: this.modelId, input: e4, voice: t2, response_format: `mp3`, speed: r2, instructions: i3 };\n    if (n2 && ([`mp3`, `opus`, `aac`, `flac`, `wav`, `pcm`].includes(n2) ? l3.response_format = n2 : s4.push({ type: `unsupported-setting`, setting: `outputFormat`, details: `Unsupported output format: ${n2}. Using mp3 instead.` })), c4) {\n      let e5 = {};\n      for (let t3 in e5) {\n        let n3 = e5[t3];\n        n3 !== undefined && (l3[t3] = n3);\n      }\n    }\n    return a4 && s4.push({ type: `unsupported-setting`, setting: `language`, details: `OpenAI speech models do not support language selection. Language parameter "${a4}" was ignored.` }), { requestBody: l3, warnings: s4 };\n  }\n  async doGenerate(e4) {\n    var t2;\n    let n2 = (t2 = this.config._internal)?.currentDate?.call(t2) ?? new Date, { requestBody: r2, warnings: i3 } = await this.getArgs(e4), { value: a4, responseHeaders: o3, rawValue: s4 } = await R2({ url: this.config.url({ path: `/audio/speech`, modelId: this.modelId }), headers: M2(this.config.headers(), e4.headers), body: r2, failedResponseHandler: Q2, successfulResponseHandler: wt(), abortSignal: e4.abortSignal, fetch: this.config.fetch });\n    return { audio: a4, warnings: i3, request: { body: JSON.stringify(r2) }, response: { timestamp: n2, modelId: this.modelId, headers: o3, body: s4 } };\n  }\n};\nvar Ri = exports_external.object({ include: exports_external.array(exports_external.string()).optional(), language: exports_external.string().optional(), prompt: exports_external.string().optional(), temperature: exports_external.number().min(0).max(1).default(0).optional(), timestampGranularities: exports_external.array(exports_external.enum([`word`, `segment`])).default([`segment`]).optional() });\nvar zi = { afrikaans: `af`, arabic: `ar`, armenian: `hy`, azerbaijani: `az`, belarusian: `be`, bosnian: `bs`, bulgarian: `bg`, catalan: `ca`, chinese: `zh`, croatian: `hr`, czech: `cs`, danish: `da`, dutch: `nl`, english: `en`, estonian: `et`, finnish: `fi`, french: `fr`, galician: `gl`, german: `de`, greek: `el`, hebrew: `he`, hindi: `hi`, hungarian: `hu`, icelandic: `is`, indonesian: `id`, italian: `it`, japanese: `ja`, kannada: `kn`, kazakh: `kk`, korean: `ko`, latvian: `lv`, lithuanian: `lt`, macedonian: `mk`, malay: `ms`, marathi: `mr`, maori: `mi`, nepali: `ne`, norwegian: `no`, persian: `fa`, polish: `pl`, portuguese: `pt`, romanian: `ro`, russian: `ru`, serbian: `sr`, slovak: `sk`, slovenian: `sl`, spanish: `es`, swahili: `sw`, swedish: `sv`, tagalog: `tl`, tamil: `ta`, thai: `th`, turkish: `tr`, ukrainian: `uk`, urdu: `ur`, vietnamese: `vi`, welsh: `cy` };\nvar Bi = class {\n  constructor(e4, t2) {\n    this.modelId = e4, this.config = t2, this.specificationVersion = `v2`;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ audio: e4, mediaType: t2, providerOptions: n2 }) {\n    let r2 = [], i3 = await L2({ provider: `openai`, providerOptions: n2, schema: Ri }), a4 = new FormData, o3 = e4 instanceof Uint8Array ? new Blob([e4]) : new Blob([Dt(e4)]);\n    a4.append(`model`, this.modelId);\n    let s4 = rt(t2);\n    if (a4.append(`file`, new File([o3], `audio`, { type: t2 }), `audio.${s4}`), i3) {\n      let e5 = { include: i3.include, language: i3.language, prompt: i3.prompt, response_format: [`gpt-4o-transcribe`, `gpt-4o-mini-transcribe`].includes(this.modelId) ? `json` : `verbose_json`, temperature: i3.temperature, timestamp_granularities: i3.timestampGranularities };\n      for (let [t3, n3] of Object.entries(e5))\n        if (n3 != null)\n          if (Array.isArray(n3))\n            for (let e6 of n3)\n              a4.append(`${t3}[]`, String(e6));\n          else\n            a4.append(t3, String(n3));\n    }\n    return { formData: a4, warnings: r2 };\n  }\n  async doGenerate(e4) {\n    var t2;\n    let n2 = (t2 = this.config._internal)?.currentDate?.call(t2) ?? new Date, { formData: r2, warnings: i3 } = await this.getArgs(e4), { value: a4, responseHeaders: o3, rawValue: s4 } = await xt({ url: this.config.url({ path: `/audio/transcriptions`, modelId: this.modelId }), headers: M2(this.config.headers(), e4.headers), formData: r2, failedResponseHandler: Q2, successfulResponseHandler: W2(Vi), abortSignal: e4.abortSignal, fetch: this.config.fetch }), c4 = a4.language != null && a4.language in zi ? zi[a4.language] : undefined;\n    return { text: a4.text, segments: a4.segments?.map((e5) => ({ text: e5.text, startSecond: e5.start, endSecond: e5.end })) ?? a4.words?.map((e5) => ({ text: e5.word, startSecond: e5.start, endSecond: e5.end })) ?? [], language: c4, durationInSeconds: a4.duration ?? undefined, warnings: i3, response: { timestamp: n2, modelId: this.modelId, headers: o3, body: s4 } };\n  }\n};\nvar Vi = exports_external.object({ text: exports_external.string(), language: exports_external.string().nullish(), duration: exports_external.number().nullish(), words: exports_external.array(exports_external.object({ word: exports_external.string(), start: exports_external.number(), end: exports_external.number() })).nullish(), segments: exports_external.array(exports_external.object({ id: exports_external.number(), seek: exports_external.number(), start: exports_external.number(), end: exports_external.number(), text: exports_external.string(), tokens: exports_external.array(exports_external.number()), temperature: exports_external.number(), avg_logprob: exports_external.number(), compression_ratio: exports_external.number(), no_speech_prob: exports_external.number() })).nullish() });\nvar Hi = `2.0.42`;\nfunction $2(e4 = {}) {\n  let t2 = K2(nt({ settingValue: e4.baseURL, environmentVariableName: `OPENAI_BASE_URL` })) ?? `https://api.openai.com/v1`, n2 = e4.name ?? `openai`, r2 = () => P2({ Authorization: `Bearer ${I2({ apiKey: e4.apiKey, environmentVariableName: `OPENAI_API_KEY`, description: `OpenAI` })}`, "OpenAI-Organization": e4.organization, "OpenAI-Project": e4.project, ...e4.headers }, `ai-sdk/openai/${Hi}`), i3 = (i4) => new er(i4, { provider: `${n2}.chat`, url: ({ path: e5 }) => `${t2}${e5}`, headers: r2, fetch: e4.fetch }), a4 = (i4) => new pr(i4, { provider: `${n2}.completion`, url: ({ path: e5 }) => `${t2}${e5}`, headers: r2, fetch: e4.fetch }), o3 = (i4) => new vr(i4, { provider: `${n2}.embedding`, url: ({ path: e5 }) => `${t2}${e5}`, headers: r2, fetch: e4.fetch }), s4 = (i4) => new Sr(i4, { provider: `${n2}.image`, url: ({ path: e5 }) => `${t2}${e5}`, headers: r2, fetch: e4.fetch }), c4 = (i4) => new Bi(i4, { provider: `${n2}.transcription`, url: ({ path: e5 }) => `${t2}${e5}`, headers: r2, fetch: e4.fetch }), l3 = (i4) => new Li(i4, { provider: `${n2}.speech`, url: ({ path: e5 }) => `${t2}${e5}`, headers: r2, fetch: e4.fetch }), u3 = (e5) => {\n    if (new.target)\n      throw Error(`The OpenAI model function cannot be called with the new keyword.`);\n    return d2(e5);\n  }, d2 = (i4) => new ai(i4, { provider: `${n2}.responses`, url: ({ path: e5 }) => `${t2}${e5}`, headers: r2, fetch: e4.fetch, fileIdPrefixes: [`file-`] }), f3 = function(e5) {\n    return u3(e5);\n  };\n  return f3.languageModel = u3, f3.chat = i3, f3.completion = a4, f3.responses = d2, f3.embedding = o3, f3.textEmbedding = o3, f3.textEmbeddingModel = o3, f3.image = s4, f3.imageModel = s4, f3.transcription = c4, f3.transcriptionModel = c4, f3.speech = l3, f3.speechModel = l3, f3.tools = Kr, f3;\n}\n$2(), exports_external.object({ user: exports_external.string().optional(), reasoningEffort: exports_external.string().optional() });\nvar Ui = { errorSchema: exports_external.object({ error: exports_external.object({ message: exports_external.string(), type: exports_external.string().nullish(), param: exports_external.any().nullish(), code: exports_external.union([exports_external.string(), exports_external.number()]).nullish() }) }), errorToMessage: (e4) => e4.error.message };\nvar Wi = exports_external.object({ prompt_tokens: exports_external.number().nullish(), completion_tokens: exports_external.number().nullish(), total_tokens: exports_external.number().nullish(), prompt_tokens_details: exports_external.object({ cached_tokens: exports_external.number().nullish() }).nullish(), completion_tokens_details: exports_external.object({ reasoning_tokens: exports_external.number().nullish(), accepted_prediction_tokens: exports_external.number().nullish(), rejected_prediction_tokens: exports_external.number().nullish() }).nullish() }).nullish();\nexports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ message: exports_external.object({ role: exports_external.literal(`assistant`).nullish(), content: exports_external.string().nullish(), reasoning_content: exports_external.string().nullish(), reasoning: exports_external.string().nullish(), tool_calls: exports_external.array(exports_external.object({ id: exports_external.string().nullish(), function: exports_external.object({ name: exports_external.string(), arguments: exports_external.string() }) })).nullish() }), finish_reason: exports_external.string().nullish() })), usage: Wi }), exports_external.object({ echo: exports_external.boolean().optional(), logitBias: exports_external.record(exports_external.string(), exports_external.number()).optional(), suffix: exports_external.string().optional(), user: exports_external.string().optional() });\nvar Gi = exports_external.object({ prompt_tokens: exports_external.number(), completion_tokens: exports_external.number(), total_tokens: exports_external.number() });\nexports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ text: exports_external.string(), finish_reason: exports_external.string() })), usage: Gi.nullish() }), exports_external.object({ dimensions: exports_external.number().optional(), user: exports_external.string().optional() }), exports_external.object({ data: exports_external.array(exports_external.object({ embedding: exports_external.array(exports_external.number()) })), usage: exports_external.object({ prompt_tokens: exports_external.number() }).nullish(), providerMetadata: exports_external.record(exports_external.string(), exports_external.record(exports_external.string(), exports_external.any())).optional() });\nvar Ki = class {\n  constructor(e4, t2) {\n    this.modelId = e4, this.config = t2, this.specificationVersion = `v2`, this.maxImagesPerCall = 10;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate({ prompt: e4, n: t2, size: n2, aspectRatio: r2, seed: i3, providerOptions: a4, headers: o3, abortSignal: s4 }) {\n    var c4;\n    let l3 = [];\n    r2 != null && l3.push({ type: `unsupported-setting`, setting: `aspectRatio`, details: "This model does not support aspect ratio. Use `size` instead." }), i3 != null && l3.push({ type: `unsupported-setting`, setting: `seed` });\n    let u3 = (c4 = this.config._internal)?.currentDate?.call(c4) ?? new Date, { value: d2, responseHeaders: f3 } = await R2({ url: this.config.url({ path: `/images/generations`, modelId: this.modelId }), headers: M2(this.config.headers(), o3), body: { model: this.modelId, prompt: e4, n: t2, size: n2, ...a4.openai ?? {}, response_format: `b64_json` }, failedResponseHandler: H2(this.config.errorStructure ?? Ui), successfulResponseHandler: W2(qi), abortSignal: s4, fetch: this.config.fetch });\n    return { images: d2.data.map((e5) => e5.b64_json), warnings: l3, response: { timestamp: u3, modelId: this.modelId, headers: f3 } };\n  }\n};\nvar qi = exports_external.object({ data: exports_external.array(exports_external.object({ b64_json: exports_external.string() })) });\nfunction Ji(e4) {\n  let t2 = [], n2 = [];\n  for (let { role: n3, content: r2 } of e4)\n    switch (n3) {\n      case `system`:\n        t2.push({ role: `system`, content: r2 });\n        break;\n      case `user`:\n        if (r2.length === 1 && r2[0].type === `text`) {\n          t2.push({ role: `user`, content: r2[0].text });\n          break;\n        }\n        t2.push({ role: `user`, content: r2.map((e5) => {\n          switch (e5.type) {\n            case `text`:\n              return { type: `text`, text: e5.text };\n            case `file`:\n              if (e5.mediaType.startsWith(`image/`)) {\n                let t3 = e5.mediaType === `image/*` ? `image/jpeg` : e5.mediaType;\n                return { type: `image_url`, image_url: { url: e5.data instanceof URL ? e5.data.toString() : `data:${t3};base64,${G2(e5.data)}` } };\n              } else\n                throw new j2({ functionality: `file part media type ${e5.mediaType}` });\n          }\n        }) });\n        break;\n      case `assistant`: {\n        let e5 = ``, n4 = [];\n        for (let t3 of r2)\n          switch (t3.type) {\n            case `text`:\n              e5 += t3.text;\n              break;\n            case `tool-call`:\n              n4.push({ id: t3.toolCallId, type: `function`, function: { name: t3.toolName, arguments: JSON.stringify(t3.input) } });\n              break;\n          }\n        t2.push({ role: `assistant`, content: e5, tool_calls: n4.length > 0 ? n4 : undefined });\n        break;\n      }\n      case `tool`:\n        for (let e5 of r2) {\n          let n4 = e5.output, r3;\n          switch (n4.type) {\n            case `text`:\n            case `error-text`:\n              r3 = n4.value;\n              break;\n            case `content`:\n            case `json`:\n            case `error-json`:\n              r3 = JSON.stringify(n4.value);\n              break;\n          }\n          t2.push({ role: `tool`, tool_call_id: e5.toolCallId, content: r3 });\n        }\n        break;\n      default: {\n        let e5 = n3;\n        throw Error(`Unsupported role: ${e5}`);\n      }\n    }\n  return { messages: t2, warnings: n2 };\n}\nfunction Yi({ id: e4, model: t2, created: n2 }) {\n  return { id: e4 ?? undefined, modelId: t2 ?? undefined, timestamp: n2 == null ? undefined : new Date(n2 * 1000) };\n}\nfunction Xi(e4) {\n  switch (e4) {\n    case `stop`:\n      return `stop`;\n    case `length`:\n      return `length`;\n    case `tool_calls`:\n    case `function_call`:\n      return `tool-calls`;\n    case `content_filter`:\n      return `content-filter`;\n    default:\n      return `unknown`;\n  }\n}\nvar Zi = exports_external.object({ type: exports_external.literal(`web`), country: exports_external.string().length(2).optional(), excludedWebsites: exports_external.array(exports_external.string()).max(5).optional(), allowedWebsites: exports_external.array(exports_external.string()).max(5).optional(), safeSearch: exports_external.boolean().optional() });\nvar Qi = exports_external.object({ type: exports_external.literal(`x`), excludedXHandles: exports_external.array(exports_external.string()).optional(), includedXHandles: exports_external.array(exports_external.string()).optional(), postFavoriteCount: exports_external.number().int().optional(), postViewCount: exports_external.number().int().optional(), xHandles: exports_external.array(exports_external.string()).optional() });\nvar $i = exports_external.object({ type: exports_external.literal(`news`), country: exports_external.string().length(2).optional(), excludedWebsites: exports_external.array(exports_external.string()).max(5).optional(), safeSearch: exports_external.boolean().optional() });\nvar ea = exports_external.object({ type: exports_external.literal(`rss`), links: exports_external.array(exports_external.string().url()).max(1) });\nvar ta = exports_external.discriminatedUnion(`type`, [Zi, Qi, $i, ea]);\nvar na = exports_external.object({ reasoningEffort: exports_external.enum([`low`, `high`]).optional(), searchParameters: exports_external.object({ mode: exports_external.enum([`off`, `auto`, `on`]), returnCitations: exports_external.boolean().optional(), fromDate: exports_external.string().optional(), toDate: exports_external.string().optional(), maxSearchResults: exports_external.number().min(1).max(50).optional(), sources: exports_external.array(ta).optional() }).optional() });\nvar ra = exports_external.object({ error: exports_external.object({ message: exports_external.string(), type: exports_external.string().nullish(), param: exports_external.any().nullish(), code: exports_external.union([exports_external.string(), exports_external.number()]).nullish() }) });\nvar ia = H2({ errorSchema: ra, errorToMessage: (e4) => e4.error.message });\nfunction aa({ tools: e4, toolChoice: t2 }) {\n  e4 = e4?.length ? e4 : undefined;\n  let n2 = [];\n  if (e4 == null)\n    return { tools: undefined, toolChoice: undefined, toolWarnings: n2 };\n  let r2 = [];\n  for (let t3 of e4)\n    t3.type === `provider-defined` ? n2.push({ type: `unsupported-tool`, tool: t3 }) : r2.push({ type: `function`, function: { name: t3.name, description: t3.description, parameters: t3.inputSchema } });\n  if (t2 == null)\n    return { tools: r2, toolChoice: undefined, toolWarnings: n2 };\n  let i3 = t2.type;\n  switch (i3) {\n    case `auto`:\n    case `none`:\n      return { tools: r2, toolChoice: i3, toolWarnings: n2 };\n    case `required`:\n      return { tools: r2, toolChoice: `required`, toolWarnings: n2 };\n    case `tool`:\n      return { tools: r2, toolChoice: { type: `function`, function: { name: t2.toolName } }, toolWarnings: n2 };\n    default:\n      throw new j2({ functionality: `tool choice type: ${i3}` });\n  }\n}\nvar oa = class {\n  constructor(e4, t2) {\n    this.specificationVersion = `v2`, this.supportedUrls = { "image/*": [/^https?:\\/\\/.*$/] }, this.modelId = e4, this.config = t2;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ prompt: e4, maxOutputTokens: t2, temperature: n2, topP: r2, topK: i3, frequencyPenalty: a4, presencePenalty: o3, stopSequences: s4, seed: c4, responseFormat: l3, providerOptions: u3, tools: d2, toolChoice: f3 }) {\n    let p3 = [], m3 = await L2({ provider: `xai`, providerOptions: u3, schema: na }) ?? {};\n    i3 != null && p3.push({ type: `unsupported-setting`, setting: `topK` }), a4 != null && p3.push({ type: `unsupported-setting`, setting: `frequencyPenalty` }), o3 != null && p3.push({ type: `unsupported-setting`, setting: `presencePenalty` }), s4 != null && p3.push({ type: `unsupported-setting`, setting: `stopSequences` }), l3 != null && l3.type === `json` && l3.schema != null && p3.push({ type: `unsupported-setting`, setting: `responseFormat`, details: `JSON response format schema is not supported` });\n    let { messages: h3, warnings: g3 } = Ji(e4);\n    p3.push(...g3);\n    let { tools: _3, toolChoice: v3, toolWarnings: y3 } = aa({ tools: d2, toolChoice: f3 });\n    return p3.push(...y3), { args: { model: this.modelId, max_tokens: t2, temperature: n2, top_p: r2, seed: c4, reasoning_effort: m3.reasoningEffort, response_format: l3?.type === `json` ? l3.schema == null ? { type: `json_object` } : { type: `json_schema`, json_schema: { name: l3.name ?? `response`, schema: l3.schema, strict: true } } : undefined, search_parameters: m3.searchParameters ? { mode: m3.searchParameters.mode, return_citations: m3.searchParameters.returnCitations, from_date: m3.searchParameters.fromDate, to_date: m3.searchParameters.toDate, max_search_results: m3.searchParameters.maxSearchResults, sources: m3.searchParameters.sources?.map((e5) => ({ type: e5.type, ...e5.type === `web` && { country: e5.country, excluded_websites: e5.excludedWebsites, allowed_websites: e5.allowedWebsites, safe_search: e5.safeSearch }, ...e5.type === `x` && { excluded_x_handles: e5.excludedXHandles, included_x_handles: e5.includedXHandles ?? e5.xHandles, post_favorite_count: e5.postFavoriteCount, post_view_count: e5.postViewCount }, ...e5.type === `news` && { country: e5.country, excluded_websites: e5.excludedWebsites, safe_search: e5.safeSearch }, ...e5.type === `rss` && { links: e5.links } })) } : undefined, messages: h3, tools: _3, tool_choice: v3 }, warnings: p3 };\n  }\n  async doGenerate(e4) {\n    let { args: t2, warnings: n2 } = await this.getArgs(e4), { responseHeaders: r2, value: i3, rawValue: a4 } = await R2({ url: `${this.config.baseURL ?? `https://api.x.ai/v1`}/chat/completions`, headers: M2(this.config.headers(), e4.headers), body: t2, failedResponseHandler: ia, successfulResponseHandler: W2(ca), abortSignal: e4.abortSignal, fetch: this.config.fetch }), o3 = i3.choices[0], s4 = [];\n    if (o3.message.content != null && o3.message.content.length > 0) {\n      let e5 = o3.message.content, n3 = t2.messages[t2.messages.length - 1];\n      n3?.role === `assistant` && e5 === n3.content && (e5 = ``), e5.length > 0 && s4.push({ type: `text`, text: e5 });\n    }\n    if (o3.message.reasoning_content != null && o3.message.reasoning_content.length > 0 && s4.push({ type: `reasoning`, text: o3.message.reasoning_content }), o3.message.tool_calls != null)\n      for (let e5 of o3.message.tool_calls)\n        s4.push({ type: `tool-call`, toolCallId: e5.id, toolName: e5.function.name, input: e5.function.arguments });\n    if (i3.citations != null)\n      for (let e5 of i3.citations)\n        s4.push({ type: `source`, sourceType: `url`, id: this.config.generateId(), url: e5 });\n    return { content: s4, finishReason: Xi(o3.finish_reason), usage: { inputTokens: i3.usage.prompt_tokens, outputTokens: i3.usage.completion_tokens, totalTokens: i3.usage.total_tokens, reasoningTokens: i3.usage.completion_tokens_details?.reasoning_tokens ?? undefined }, request: { body: t2 }, response: { ...Yi(i3), headers: r2, body: a4 }, warnings: n2 };\n  }\n  async doStream(e4) {\n    let { args: t2, warnings: n2 } = await this.getArgs(e4), r2 = { ...t2, stream: true, stream_options: { include_usage: true } }, { responseHeaders: i3, value: a4 } = await R2({ url: `${this.config.baseURL ?? `https://api.x.ai/v1`}/chat/completions`, headers: M2(this.config.headers(), e4.headers), body: r2, failedResponseHandler: ia, successfulResponseHandler: U2(la), abortSignal: e4.abortSignal, fetch: this.config.fetch }), o3 = `unknown`, s4 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, c4 = true, l3 = {}, u3 = {}, d2 = this;\n    return { stream: a4.pipeThrough(new TransformStream({ start(e5) {\n      e5.enqueue({ type: `stream-start`, warnings: n2 });\n    }, transform(t3, n3) {\n      if (e4.includeRawChunks && n3.enqueue({ type: `raw`, rawValue: t3.rawValue }), !t3.success) {\n        n3.enqueue({ type: `error`, error: t3.error });\n        return;\n      }\n      let i4 = t3.value;\n      if (c4 &&= (n3.enqueue({ type: `response-metadata`, ...Yi(i4) }), false), i4.citations != null)\n        for (let e5 of i4.citations)\n          n3.enqueue({ type: `source`, sourceType: `url`, id: d2.config.generateId(), url: e5 });\n      i4.usage != null && (s4.inputTokens = i4.usage.prompt_tokens, s4.outputTokens = i4.usage.completion_tokens, s4.totalTokens = i4.usage.total_tokens, s4.reasoningTokens = i4.usage.completion_tokens_details?.reasoning_tokens ?? undefined);\n      let a5 = i4.choices[0];\n      if (a5?.finish_reason != null && (o3 = Xi(a5.finish_reason)), a5?.delta == null)\n        return;\n      let { delta: f3, index: p3 } = a5;\n      if (f3.content != null && f3.content.length > 0) {\n        let e5 = f3.content, t4 = r2.messages[r2.messages.length - 1];\n        if (t4?.role === `assistant` && e5 === t4.content)\n          return;\n        let a6 = `text-${i4.id || p3}`;\n        l3[a6] ?? (l3[a6] = { type: `text` }, n3.enqueue({ type: `text-start`, id: a6 })), n3.enqueue({ type: `text-delta`, id: a6, delta: e5 });\n      }\n      if (f3.reasoning_content != null && f3.reasoning_content.length > 0) {\n        let e5 = `reasoning-${i4.id || p3}`;\n        if (u3[e5] === f3.reasoning_content)\n          return;\n        u3[e5] = f3.reasoning_content, l3[e5] ?? (l3[e5] = { type: `reasoning` }, n3.enqueue({ type: `reasoning-start`, id: e5 })), n3.enqueue({ type: `reasoning-delta`, id: e5, delta: f3.reasoning_content });\n      }\n      if (f3.tool_calls != null)\n        for (let e5 of f3.tool_calls) {\n          let t4 = e5.id;\n          n3.enqueue({ type: `tool-input-start`, id: t4, toolName: e5.function.name }), n3.enqueue({ type: `tool-input-delta`, id: t4, delta: e5.function.arguments }), n3.enqueue({ type: `tool-input-end`, id: t4 }), n3.enqueue({ type: `tool-call`, toolCallId: t4, toolName: e5.function.name, input: e5.function.arguments });\n        }\n    }, flush(e5) {\n      for (let [t3, n3] of Object.entries(l3))\n        e5.enqueue({ type: n3.type === `text` ? `text-end` : `reasoning-end`, id: t3 });\n      e5.enqueue({ type: `finish`, finishReason: o3, usage: s4 });\n    } })), request: { body: r2 }, response: { headers: i3 } };\n  }\n};\nvar sa = exports_external.object({ prompt_tokens: exports_external.number(), completion_tokens: exports_external.number(), total_tokens: exports_external.number(), completion_tokens_details: exports_external.object({ reasoning_tokens: exports_external.number().nullish() }).nullish() });\nvar ca = exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ message: exports_external.object({ role: exports_external.literal(`assistant`), content: exports_external.string().nullish(), reasoning_content: exports_external.string().nullish(), tool_calls: exports_external.array(exports_external.object({ id: exports_external.string(), type: exports_external.literal(`function`), function: exports_external.object({ name: exports_external.string(), arguments: exports_external.string() }) })).nullish() }), index: exports_external.number(), finish_reason: exports_external.string().nullish() })), object: exports_external.literal(`chat.completion`), usage: sa, citations: exports_external.array(exports_external.string().url()).nullish() });\nvar la = exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ delta: exports_external.object({ role: exports_external.enum([`assistant`]).optional(), content: exports_external.string().nullish(), reasoning_content: exports_external.string().nullish(), tool_calls: exports_external.array(exports_external.object({ id: exports_external.string(), type: exports_external.literal(`function`), function: exports_external.object({ name: exports_external.string(), arguments: exports_external.string() }) })).nullish() }), finish_reason: exports_external.string().nullish(), index: exports_external.number() })), usage: sa.nullish(), citations: exports_external.array(exports_external.string().url()).nullish() });\nvar ua = `2.0.23`;\nvar da = { errorSchema: ra, errorToMessage: (e4) => e4.error.message };\nfunction fa(e4 = {}) {\n  let t2 = K2(e4.baseURL ?? `https://api.x.ai/v1`), n2 = () => P2({ Authorization: `Bearer ${I2({ apiKey: e4.apiKey, environmentVariableName: `XAI_API_KEY`, description: `xAI API key` })}`, ...e4.headers }, `ai-sdk/xai/${ua}`), r2 = (r3) => new oa(r3, { provider: `xai.chat`, baseURL: t2, headers: n2, generateId: F2, fetch: e4.fetch }), i3 = (r3) => new Ki(r3, { provider: `xai.image`, url: ({ path: e5 }) => `${t2}${e5}`, headers: n2, fetch: e4.fetch, errorStructure: da }), a4 = (e5) => r2(e5);\n  return a4.languageModel = r2, a4.chat = r2, a4.textEmbeddingModel = (e5) => {\n    throw new k2({ modelId: e5, modelType: `textEmbeddingModel` });\n  }, a4.imageModel = i3, a4.image = i3, a4;\n}\nfa();\nvar ma = `BLINK_API_URL`;\n\n// src/server.ts\nfunction startInternalAPIServer() {\n  let blinkAuthToken;\n  const getClient = () => {\n    return new AgentInvocationClient({\n      baseURL: process.env[InternalAPIServerURLEnvironmentVariable],\n      authToken: blinkAuthToken\n    });\n  };\n  const port = process.env[InternalAPIServerListenPortEnvironmentVariable] ? parseInt(process.env[InternalAPIServerListenPortEnvironmentVariable]) : 12345;\n  const store = {\n    get(key) {\n      return getClient().getStorage(key);\n    },\n    set(key, value) {\n      return getClient().setStorage(key, value);\n    },\n    delete(key) {\n      return getClient().deleteStorage(key);\n    },\n    list(prefix, options) {\n      return getClient().listStorage(prefix, options);\n    }\n  };\n  const otlp = {\n    traces(request) {\n      return getClient().proxyOtlpTraces(request);\n    }\n  };\n  const chat = {\n    upsert: async (key) => {\n      const resp = await getClient().upsertChat(JSON.stringify(key));\n      return {\n        created: resp.created,\n        id: resp.id,\n        createdAt: resp.created_at\n      };\n    },\n    delete: async (id) => {\n      await getClient().deleteChat(id);\n    },\n    deleteMessages: async (id, messageIds) => {\n      await getClient().deleteMessages(id, messageIds);\n    },\n    get: async (id) => {\n      const resp = await getClient().getChat(id);\n      if (!resp) {\n        return;\n      }\n      return {\n        id: resp.id,\n        createdAt: resp.createdAt\n      };\n    },\n    getMessages: async (id) => {\n      const messages = await getClient().getMessages(id);\n      return messages.map((message) => ({\n        id: message.id,\n        role: message.role,\n        parts: message.parts,\n        metadata: message.metadata\n      }));\n    },\n    start: async (id) => {\n      await getClient().startChat(id);\n    },\n    stop: async (id) => {\n      await getClient().stopChat(id);\n    },\n    sendMessages: async (id, messages, options) => {\n      await getClient().sendMessages(id, {\n        messages: messages.map((msg) => ({\n          id: msg.id,\n          role: msg.role,\n          parts: msg.parts,\n          metadata: msg.metadata\n        })),\n        behavior: options?.behavior ?? "enqueue"\n      });\n    }\n  };\n  const server = createServer(createServerAdapter((request) => {\n    return ve.fetch(request, {\n      chat,\n      store,\n      otlp\n    });\n  }));\n  server.listen(port, "127.0.0.1");\n  process.env[ma] = `http://127.0.0.1:${port}`;\n  return {\n    server,\n    port,\n    setAuthToken(authToken) {\n      blinkAuthToken = authToken;\n      process.env["BLINK_INVOCATION_AUTH_TOKEN"] = authToken;\n    }\n  };\n}\nasync function startAgentServer(entrypoint, port, unref = false) {\n  const priorEnvPort = process.env.PORT;\n  process.env.PORT = port.toString();\n  const originalListen = Server.prototype.listen;\n  const listeningPromise = new Promise((resolve, reject) => {\n    Server.prototype.listen = function(...args) {\n      this.on("listening", () => {\n        resolve(undefined);\n      });\n      this.on("error", (err) => {\n        reject(err);\n      });\n      if (unref) {\n        this.unref();\n      }\n      return originalListen.apply(this, args);\n    };\n  });\n  await import(entrypoint);\n  process.env.PORT = priorEnvPort;\n  const agentUrl = `http://127.0.0.1:${port}`;\n  const handler = createServerAdapter((request) => {\n    const reqURL = new URL(request.url);\n    const newURL = new URL(agentUrl);\n    newURL.pathname = reqURL.pathname;\n    newURL.search = reqURL.search;\n    return fetch(newURL.toString(), request);\n  });\n  await listeningPromise;\n  return handler;\n}\n\n// src/lambda/wrapper-lambda.ts\nvar { setAuthToken, server, port } = startInternalAPIServer();\nserver.unref();\nif (!process.env.ENTRYPOINT) {\n  throw new Error("developer error: ENTRYPOINT is not set");\n}\nvar agent = await startAgentServer(resolve(process.env.ENTRYPOINT), port + 1, true);\nvar handler = awslambda.streamifyResponse(async (event, responseStream, context) => {\n  const waitUntilSymbol = Symbol.for("@blink/waitUntil");\n  let waitUntilPromises = [];\n  globalThis[waitUntilSymbol] = (promise2) => {\n    waitUntilPromises.push(promise2);\n  };\n  const isV2 = "rawPath" in event;\n  const path = isV2 ? event.rawPath : event.path;\n  const query = isV2 ? event.rawQueryString : new URLSearchParams(event.queryStringParameters || {}).toString();\n  const method = isV2 ? event.requestContext?.http?.method : event.httpMethod;\n  const url2 = new URL(path + (query ? `?${query}` : ""), "https://lambda.internal");\n  const headers = buildHeaders(event);\n  for (const [k3, v3] of headers.entries()) {\n    if (k3.toLowerCase() === BlinkInvocationTokenHeader.toLowerCase()) {\n      setAuthToken(v3);\n      headers.delete(k3);\n      break;\n    }\n  }\n  let body;\n  if (event.body != null && method !== "GET" && method !== "HEAD") {\n    body = event.isBase64Encoded ? Buffer.from(event.body, "base64") : event.body;\n  }\n  const controller = new AbortController;\n  const onCloseOrError = () => {\n    controller.abort();\n  };\n  responseStream.on("close", onCloseOrError);\n  responseStream.on("error", onCloseOrError);\n  const msLeft = Math.max(0, context.getRemainingTimeInMillis() - 5000);\n  const timeout = setTimeout(() => controller.abort(), msLeft);\n  try {\n    const res = await agent.fetch(url2, { method, body, headers, signal: controller.signal }, { event, lambdaContext: context });\n    const resHeaders = {};\n    res.headers.forEach((value, key) => {\n      resHeaders[key] = value;\n    });\n    const cookies = res.headers.getSetCookie?.() ?? (res.headers.get("set-cookie") ? [res.headers.get("set-cookie")] : []);\n    const http = awslambda.HttpResponseStream.from(responseStream, {\n      statusCode: res.status,\n      headers: resHeaders,\n      cookies\n    });\n    if (res.body) {\n      await res.body.pipeTo(Writable.toWeb(http), { signal: controller.signal });\n    } else {\n      http.end();\n    }\n  } catch (err) {\n    try {\n      const http = awslambda.HttpResponseStream.from(responseStream, {\n        statusCode: controller.signal.aborted ? 499 : 502,\n        headers: { "content-type": "application/json" }\n      });\n      http.write(JSON.stringify({\n        message: controller.signal.aborted ? "client closed" : "upstream error"\n      }));\n      http.end();\n    } catch {}\n  } finally {\n    clearTimeout(timeout);\n    responseStream.off("close", onCloseOrError);\n    responseStream.off("error", onCloseOrError);\n    const flushController = new AbortController;\n    const flushTimeout = setTimeout(() => flushController.abort("timeout"), 5000);\n    try {\n      await Promise.allSettled(waitUntilPromises);\n      await agent.fetch(new URL("/_agent/flush-otel", "http://lambda.internal"), {\n        method: "POST",\n        signal: flushController.signal\n      });\n    } catch {} finally {\n      clearTimeout(flushTimeout);\n    }\n  }\n});\nfunction buildHeaders(event) {\n  const out = new Headers;\n  const hv1 = event?.headers ?? {};\n  for (const [k3, v3] of Object.entries(hv1)) {\n    if (v3 == null)\n      continue;\n    out.set(k3, String(v3));\n  }\n  const mv = event?.multiValueHeaders ?? {};\n  for (const [k3, arr] of Object.entries(mv)) {\n    if (!Array.isArray(arr))\n      continue;\n    out.delete(k3);\n    for (const v3 of arr)\n      out.append(k3, String(v3));\n  }\n  if (Array.isArray(event?.cookies) && event.cookies.length) {\n    const existing = out.get("cookie");\n    const merged = [existing, event.cookies.join("; ")].filter(Boolean).join("; ");\n    out.set("cookie", merged);\n  }\n  if (!out.has("x-forwarded-proto"))\n    out.set("x-forwarded-proto", "https");\n  if (!out.has("x-forwarded-host") && out.has("host")) {\n    out.set("x-forwarded-host", out.get("host"));\n  }\n  const sourceIp = event?.requestContext?.http?.sourceIp ?? event?.requestContext?.identity?.sourceIp;\n  if (sourceIp) {\n    const xff = out.get("x-forwarded-for");\n    out.set("x-forwarded-for", xff ? `${xff}, ${sourceIp}` : sourceIp);\n  }\n  return out;\n}\nexport {\n  handler\n};\n';
