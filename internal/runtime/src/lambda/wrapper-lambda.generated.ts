// This file has been generated by the /home/hugodutka/dev/blink/internal/runtime/scripts/generate.ts script.
// Do not edit this file manually.

export default 'import { createRequire } from "node:module";\nvar __defProp = Object.defineProperty;\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, {\n      get: all[name],\n      enumerable: true,\n      configurable: true,\n      set: (newValue) => all[name] = () => newValue\n    });\n};\nvar __require = /* @__PURE__ */ createRequire(import.meta.url);\n\n// ../../node_modules/@whatwg-node/fetch/dist/shouldSkipPonyfill.js\nvar require_shouldSkipPonyfill = __commonJS((exports, module) => {\n  function isNextJs() {\n    return Object.keys(globalThis).some((key) => key.startsWith("__NEXT"));\n  }\n  module.exports = function shouldSkipPonyfill() {\n    if (globalThis.Deno) {\n      return true;\n    }\n    if (globalThis.Bun) {\n      return true;\n    }\n    if (isNextJs()) {\n      return true;\n    }\n    return false;\n  };\n});\n\n// ../../node_modules/urlpattern-polyfill/dist/urlpattern.cjs\nvar require_urlpattern = __commonJS((exports, module) => {\n  var U = Object.defineProperty;\n  var Re = Object.getOwnPropertyDescriptor;\n  var Ee = Object.getOwnPropertyNames;\n  var Oe = Object.prototype.hasOwnProperty;\n  var a2 = (e2, t2) => U(e2, "name", { value: t2, configurable: true });\n  var ke = (e2, t2) => {\n    for (var r2 in t2)\n      U(e2, r2, { get: t2[r2], enumerable: true });\n  };\n  var Te = (e2, t2, r2, n2) => {\n    if (t2 && typeof t2 == "object" || typeof t2 == "function")\n      for (let o of Ee(t2))\n        !Oe.call(e2, o) && o !== r2 && U(e2, o, { get: () => t2[o], enumerable: !(n2 = Re(t2, o)) || n2.enumerable });\n    return e2;\n  };\n  var Ae = (e2) => Te(U({}, "__esModule", { value: true }), e2);\n  var He = {};\n  ke(He, { URLPattern: () => M });\n  module.exports = Ae(He);\n  var P = class {\n    type = 3;\n    name = "";\n    prefix = "";\n    value = "";\n    suffix = "";\n    modifier = 3;\n    constructor(t2, r2, n2, o, l, f) {\n      this.type = t2, this.name = r2, this.prefix = n2, this.value = o, this.suffix = l, this.modifier = f;\n    }\n    hasCustomName() {\n      return this.name !== "" && typeof this.name != "number";\n    }\n  };\n  a2(P, "Part");\n  var ye = /[$_\\p{ID_Start}]/u;\n  var we = /[$_\\u200C\\u200D\\p{ID_Continue}]/u;\n  var F = ".*";\n  function Ce(e2, t2) {\n    return (t2 ? /^[\\x00-\\xFF]*$/ : /^[\\x00-\\x7F]*$/).test(e2);\n  }\n  a2(Ce, "isASCII");\n  function W(e2, t2 = false) {\n    let r2 = [], n2 = 0;\n    for (;n2 < e2.length; ) {\n      let o = e2[n2], l = a2(function(f) {\n        if (!t2)\n          throw new TypeError(f);\n        r2.push({ type: "INVALID_CHAR", index: n2, value: e2[n2++] });\n      }, "ErrorOrInvalid");\n      if (o === "*") {\n        r2.push({ type: "ASTERISK", index: n2, value: e2[n2++] });\n        continue;\n      }\n      if (o === "+" || o === "?") {\n        r2.push({ type: "OTHER_MODIFIER", index: n2, value: e2[n2++] });\n        continue;\n      }\n      if (o === "\\\\") {\n        r2.push({ type: "ESCAPED_CHAR", index: n2++, value: e2[n2++] });\n        continue;\n      }\n      if (o === "{") {\n        r2.push({ type: "OPEN", index: n2, value: e2[n2++] });\n        continue;\n      }\n      if (o === "}") {\n        r2.push({ type: "CLOSE", index: n2, value: e2[n2++] });\n        continue;\n      }\n      if (o === ":") {\n        let f = "", s = n2 + 1;\n        for (;s < e2.length; ) {\n          let i2 = e2.substr(s, 1);\n          if (s === n2 + 1 && ye.test(i2) || s !== n2 + 1 && we.test(i2)) {\n            f += e2[s++];\n            continue;\n          }\n          break;\n        }\n        if (!f) {\n          l(`Missing parameter name at ${n2}`);\n          continue;\n        }\n        r2.push({ type: "NAME", index: n2, value: f }), n2 = s;\n        continue;\n      }\n      if (o === "(") {\n        let f = 1, s = "", i2 = n2 + 1, c = false;\n        if (e2[i2] === "?") {\n          l(`Pattern cannot start with "?" at ${i2}`);\n          continue;\n        }\n        for (;i2 < e2.length; ) {\n          if (!Ce(e2[i2], false)) {\n            l(`Invalid character \'${e2[i2]}\' at ${i2}.`), c = true;\n            break;\n          }\n          if (e2[i2] === "\\\\") {\n            s += e2[i2++] + e2[i2++];\n            continue;\n          }\n          if (e2[i2] === ")") {\n            if (f--, f === 0) {\n              i2++;\n              break;\n            }\n          } else if (e2[i2] === "(" && (f++, e2[i2 + 1] !== "?")) {\n            l(`Capturing groups are not allowed at ${i2}`), c = true;\n            break;\n          }\n          s += e2[i2++];\n        }\n        if (c)\n          continue;\n        if (f) {\n          l(`Unbalanced pattern at ${n2}`);\n          continue;\n        }\n        if (!s) {\n          l(`Missing pattern at ${n2}`);\n          continue;\n        }\n        r2.push({ type: "REGEX", index: n2, value: s }), n2 = i2;\n        continue;\n      }\n      r2.push({ type: "CHAR", index: n2, value: e2[n2++] });\n    }\n    return r2.push({ type: "END", index: n2, value: "" }), r2;\n  }\n  a2(W, "lexer");\n  function _(e2, t2 = {}) {\n    let r2 = W(e2);\n    t2.delimiter ??= "/#?", t2.prefixes ??= "./";\n    let n2 = `[^${x(t2.delimiter)}]+?`, o = [], l = 0, f = 0, s = "", i2 = new Set, c = a2((u) => {\n      if (f < r2.length && r2[f].type === u)\n        return r2[f++].value;\n    }, "tryConsume"), h = a2(() => c("OTHER_MODIFIER") ?? c("ASTERISK"), "tryConsumeModifier"), p = a2((u) => {\n      let d = c(u);\n      if (d !== undefined)\n        return d;\n      let { type: g, index: y } = r2[f];\n      throw new TypeError(`Unexpected ${g} at ${y}, expected ${u}`);\n    }, "mustConsume"), A = a2(() => {\n      let u = "", d;\n      for (;d = c("CHAR") ?? c("ESCAPED_CHAR"); )\n        u += d;\n      return u;\n    }, "consumeText"), be = a2((u) => u, "DefaultEncodePart"), N = t2.encodePart || be, H = "", v = a2((u) => {\n      H += u;\n    }, "appendToPendingFixedValue"), D = a2(() => {\n      H.length && (o.push(new P(3, "", "", N(H), "", 3)), H = "");\n    }, "maybeAddPartFromPendingFixedValue"), Z = a2((u, d, g, y, B) => {\n      let m = 3;\n      switch (B) {\n        case "?":\n          m = 1;\n          break;\n        case "*":\n          m = 0;\n          break;\n        case "+":\n          m = 2;\n          break;\n      }\n      if (!d && !g && m === 3) {\n        v(u);\n        return;\n      }\n      if (D(), !d && !g) {\n        if (!u)\n          return;\n        o.push(new P(3, "", "", N(u), "", m));\n        return;\n      }\n      let S;\n      g ? g === "*" ? S = F : S = g : S = n2;\n      let k = 2;\n      S === n2 ? (k = 1, S = "") : S === F && (k = 0, S = "");\n      let E;\n      if (d ? E = d : g && (E = l++), i2.has(E))\n        throw new TypeError(`Duplicate name \'${E}\'.`);\n      i2.add(E), o.push(new P(k, E, N(u), S, N(y), m));\n    }, "addPart");\n    for (;f < r2.length; ) {\n      let u = c("CHAR"), d = c("NAME"), g = c("REGEX");\n      if (!d && !g && (g = c("ASTERISK")), d || g) {\n        let m = u ?? "";\n        t2.prefixes.indexOf(m) === -1 && (v(m), m = ""), D();\n        let S = h();\n        Z(m, d, g, "", S);\n        continue;\n      }\n      let y = u ?? c("ESCAPED_CHAR");\n      if (y) {\n        v(y);\n        continue;\n      }\n      if (c("OPEN")) {\n        let m = A(), S = c("NAME"), k = c("REGEX");\n        !S && !k && (k = c("ASTERISK"));\n        let E = A();\n        p("CLOSE");\n        let Pe = h();\n        Z(m, S, k, E, Pe);\n        continue;\n      }\n      D(), p("END");\n    }\n    return o;\n  }\n  a2(_, "parse");\n  function x(e2) {\n    return e2.replace(/([.+*?^${}()[\\]|/\\\\])/g, "\\\\$1");\n  }\n  a2(x, "escapeString");\n  function q(e2) {\n    return e2 && e2.ignoreCase ? "ui" : "u";\n  }\n  a2(q, "flags");\n  function J(e2, t2, r2) {\n    return z(_(e2, r2), t2, r2);\n  }\n  a2(J, "stringToRegexp");\n  function T(e2) {\n    switch (e2) {\n      case 0:\n        return "*";\n      case 1:\n        return "?";\n      case 2:\n        return "+";\n      case 3:\n        return "";\n    }\n  }\n  a2(T, "modifierToString");\n  function z(e2, t2, r2 = {}) {\n    r2.delimiter ??= "/#?", r2.prefixes ??= "./", r2.sensitive ??= false, r2.strict ??= false, r2.end ??= true, r2.start ??= true, r2.endsWith = "";\n    let n2 = r2.start ? "^" : "";\n    for (let s of e2) {\n      if (s.type === 3) {\n        s.modifier === 3 ? n2 += x(s.value) : n2 += `(?:${x(s.value)})${T(s.modifier)}`;\n        continue;\n      }\n      t2 && t2.push(s.name);\n      let i2 = `[^${x(r2.delimiter)}]+?`, c = s.value;\n      if (s.type === 1 ? c = i2 : s.type === 0 && (c = F), !s.prefix.length && !s.suffix.length) {\n        s.modifier === 3 || s.modifier === 1 ? n2 += `(${c})${T(s.modifier)}` : n2 += `((?:${c})${T(s.modifier)})`;\n        continue;\n      }\n      if (s.modifier === 3 || s.modifier === 1) {\n        n2 += `(?:${x(s.prefix)}(${c})${x(s.suffix)})`, n2 += T(s.modifier);\n        continue;\n      }\n      n2 += `(?:${x(s.prefix)}`, n2 += `((?:${c})(?:`, n2 += x(s.suffix), n2 += x(s.prefix), n2 += `(?:${c}))*)${x(s.suffix)})`, s.modifier === 0 && (n2 += "?");\n    }\n    let o = `[${x(r2.endsWith)}]|$`, l = `[${x(r2.delimiter)}]`;\n    if (r2.end)\n      return r2.strict || (n2 += `${l}?`), r2.endsWith.length ? n2 += `(?=${o})` : n2 += "$", new RegExp(n2, q(r2));\n    r2.strict || (n2 += `(?:${l}(?=${o}))?`);\n    let f = false;\n    if (e2.length) {\n      let s = e2[e2.length - 1];\n      s.type === 3 && s.modifier === 3 && (f = r2.delimiter.indexOf(s) > -1);\n    }\n    return f || (n2 += `(?=${l}|${o})`), new RegExp(n2, q(r2));\n  }\n  a2(z, "partsToRegexp");\n  var b = { delimiter: "", prefixes: "", sensitive: true, strict: true };\n  var Q = { delimiter: ".", prefixes: "", sensitive: true, strict: true };\n  var ee = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };\n  function te(e2, t2) {\n    return e2.length ? e2[0] === "/" ? true : !t2 || e2.length < 2 ? false : (e2[0] == "\\\\" || e2[0] == "{") && e2[1] == "/" : false;\n  }\n  a2(te, "isAbsolutePathname");\n  function re(e2, t2) {\n    return e2.startsWith(t2) ? e2.substring(t2.length, e2.length) : e2;\n  }\n  a2(re, "maybeStripPrefix");\n  function Le(e2, t2) {\n    return e2.endsWith(t2) ? e2.substr(0, e2.length - t2.length) : e2;\n  }\n  a2(Le, "maybeStripSuffix");\n  function j(e2) {\n    return !e2 || e2.length < 2 ? false : e2[0] === "[" || (e2[0] === "\\\\" || e2[0] === "{") && e2[1] === "[";\n  }\n  a2(j, "treatAsIPv6Hostname");\n  var ne = ["ftp", "file", "http", "https", "ws", "wss"];\n  function $(e2) {\n    if (!e2)\n      return true;\n    for (let t2 of ne)\n      if (e2.test(t2))\n        return true;\n    return false;\n  }\n  a2($, "isSpecialScheme");\n  function se(e2, t2) {\n    if (e2 = re(e2, "#"), t2 || e2 === "")\n      return e2;\n    let r2 = new URL("https://example.com");\n    return r2.hash = e2, r2.hash ? r2.hash.substring(1, r2.hash.length) : "";\n  }\n  a2(se, "canonicalizeHash");\n  function ie(e2, t2) {\n    if (e2 = re(e2, "?"), t2 || e2 === "")\n      return e2;\n    let r2 = new URL("https://example.com");\n    return r2.search = e2, r2.search ? r2.search.substring(1, r2.search.length) : "";\n  }\n  a2(ie, "canonicalizeSearch");\n  function ae(e2, t2) {\n    return t2 || e2 === "" ? e2 : j(e2) ? V(e2) : G(e2);\n  }\n  a2(ae, "canonicalizeHostname");\n  function oe(e2, t2) {\n    if (t2 || e2 === "")\n      return e2;\n    let r2 = new URL("https://example.com");\n    return r2.password = e2, r2.password;\n  }\n  a2(oe, "canonicalizePassword");\n  function ce(e2, t2) {\n    if (t2 || e2 === "")\n      return e2;\n    let r2 = new URL("https://example.com");\n    return r2.username = e2, r2.username;\n  }\n  a2(ce, "canonicalizeUsername");\n  function le(e2, t2, r2) {\n    if (r2 || e2 === "")\n      return e2;\n    if (t2 && !ne.includes(t2))\n      return new URL(`${t2}:${e2}`).pathname;\n    let n2 = e2[0] == "/";\n    return e2 = new URL(n2 ? e2 : "/-" + e2, "https://example.com").pathname, n2 || (e2 = e2.substring(2, e2.length)), e2;\n  }\n  a2(le, "canonicalizePathname");\n  function fe(e2, t2, r2) {\n    return K(t2) === e2 && (e2 = ""), r2 || e2 === "" ? e2 : Y(e2);\n  }\n  a2(fe, "canonicalizePort");\n  function he(e2, t2) {\n    return e2 = Le(e2, ":"), t2 || e2 === "" ? e2 : w(e2);\n  }\n  a2(he, "canonicalizeProtocol");\n  function K(e2) {\n    switch (e2) {\n      case "ws":\n      case "http":\n        return "80";\n      case "wws":\n      case "https":\n        return "443";\n      case "ftp":\n        return "21";\n      default:\n        return "";\n    }\n  }\n  a2(K, "defaultPortForProtocol");\n  function w(e2) {\n    if (e2 === "")\n      return e2;\n    if (/^[-+.A-Za-z0-9]*$/.test(e2))\n      return e2.toLowerCase();\n    throw new TypeError(`Invalid protocol \'${e2}\'.`);\n  }\n  a2(w, "protocolEncodeCallback");\n  function ue(e2) {\n    if (e2 === "")\n      return e2;\n    let t2 = new URL("https://example.com");\n    return t2.username = e2, t2.username;\n  }\n  a2(ue, "usernameEncodeCallback");\n  function de(e2) {\n    if (e2 === "")\n      return e2;\n    let t2 = new URL("https://example.com");\n    return t2.password = e2, t2.password;\n  }\n  a2(de, "passwordEncodeCallback");\n  function G(e2) {\n    if (e2 === "")\n      return e2;\n    if (/[\\t\\n\\r #%/:<>?@[\\]^\\\\|]/g.test(e2))\n      throw new TypeError(`Invalid hostname \'${e2}\'`);\n    let t2 = new URL("https://example.com");\n    return t2.hostname = e2, t2.hostname;\n  }\n  a2(G, "hostnameEncodeCallback");\n  function V(e2) {\n    if (e2 === "")\n      return e2;\n    if (/[^0-9a-fA-F[\\]:]/g.test(e2))\n      throw new TypeError(`Invalid IPv6 hostname \'${e2}\'`);\n    return e2.toLowerCase();\n  }\n  a2(V, "ipv6HostnameEncodeCallback");\n  function Y(e2) {\n    if (e2 === "" || /^[0-9]*$/.test(e2) && parseInt(e2) <= 65535)\n      return e2;\n    throw new TypeError(`Invalid port \'${e2}\'.`);\n  }\n  a2(Y, "portEncodeCallback");\n  function pe(e2) {\n    if (e2 === "")\n      return e2;\n    let t2 = new URL("https://example.com");\n    return t2.pathname = e2[0] !== "/" ? "/-" + e2 : e2, e2[0] !== "/" ? t2.pathname.substring(2, t2.pathname.length) : t2.pathname;\n  }\n  a2(pe, "standardURLPathnameEncodeCallback");\n  function ge(e2) {\n    return e2 === "" ? e2 : new URL(`data:${e2}`).pathname;\n  }\n  a2(ge, "pathURLPathnameEncodeCallback");\n  function me(e2) {\n    if (e2 === "")\n      return e2;\n    let t2 = new URL("https://example.com");\n    return t2.search = e2, t2.search.substring(1, t2.search.length);\n  }\n  a2(me, "searchEncodeCallback");\n  function Se(e2) {\n    if (e2 === "")\n      return e2;\n    let t2 = new URL("https://example.com");\n    return t2.hash = e2, t2.hash.substring(1, t2.hash.length);\n  }\n  a2(Se, "hashEncodeCallback");\n  var C = class {\n    #i;\n    #n = [];\n    #t = {};\n    #e = 0;\n    #s = 1;\n    #l = 0;\n    #o = 0;\n    #d = 0;\n    #p = 0;\n    #g = false;\n    constructor(t2) {\n      this.#i = t2;\n    }\n    get result() {\n      return this.#t;\n    }\n    parse() {\n      for (this.#n = W(this.#i, true);this.#e < this.#n.length; this.#e += this.#s) {\n        if (this.#s = 1, this.#n[this.#e].type === "END") {\n          if (this.#o === 0) {\n            this.#b(), this.#f() ? this.#r(9, 1) : this.#h() ? this.#r(8, 1) : this.#r(7, 0);\n            continue;\n          } else if (this.#o === 2) {\n            this.#u(5);\n            continue;\n          }\n          this.#r(10, 0);\n          break;\n        }\n        if (this.#d > 0)\n          if (this.#A())\n            this.#d -= 1;\n          else\n            continue;\n        if (this.#T()) {\n          this.#d += 1;\n          continue;\n        }\n        switch (this.#o) {\n          case 0:\n            this.#P() && this.#u(1);\n            break;\n          case 1:\n            if (this.#P()) {\n              this.#C();\n              let t2 = 7, r2 = 1;\n              this.#E() ? (t2 = 2, r2 = 3) : this.#g && (t2 = 2), this.#r(t2, r2);\n            }\n            break;\n          case 2:\n            this.#S() ? this.#u(3) : (this.#x() || this.#h() || this.#f()) && this.#u(5);\n            break;\n          case 3:\n            this.#O() ? this.#r(4, 1) : this.#S() && this.#r(5, 1);\n            break;\n          case 4:\n            this.#S() && this.#r(5, 1);\n            break;\n          case 5:\n            this.#y() ? this.#p += 1 : this.#w() && (this.#p -= 1), this.#k() && !this.#p ? this.#r(6, 1) : this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);\n            break;\n          case 6:\n            this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);\n            break;\n          case 7:\n            this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);\n            break;\n          case 8:\n            this.#f() && this.#r(9, 1);\n            break;\n          case 9:\n            break;\n          case 10:\n            break;\n        }\n      }\n      this.#t.hostname !== undefined && this.#t.port === undefined && (this.#t.port = "");\n    }\n    #r(t2, r2) {\n      switch (this.#o) {\n        case 0:\n          break;\n        case 1:\n          this.#t.protocol = this.#c();\n          break;\n        case 2:\n          break;\n        case 3:\n          this.#t.username = this.#c();\n          break;\n        case 4:\n          this.#t.password = this.#c();\n          break;\n        case 5:\n          this.#t.hostname = this.#c();\n          break;\n        case 6:\n          this.#t.port = this.#c();\n          break;\n        case 7:\n          this.#t.pathname = this.#c();\n          break;\n        case 8:\n          this.#t.search = this.#c();\n          break;\n        case 9:\n          this.#t.hash = this.#c();\n          break;\n        case 10:\n          break;\n      }\n      this.#o !== 0 && t2 !== 10 && ([1, 2, 3, 4].includes(this.#o) && [6, 7, 8, 9].includes(t2) && (this.#t.hostname ??= ""), [1, 2, 3, 4, 5, 6].includes(this.#o) && [8, 9].includes(t2) && (this.#t.pathname ??= this.#g ? "/" : ""), [1, 2, 3, 4, 5, 6, 7].includes(this.#o) && t2 === 9 && (this.#t.search ??= "")), this.#R(t2, r2);\n    }\n    #R(t2, r2) {\n      this.#o = t2, this.#l = this.#e + r2, this.#e += r2, this.#s = 0;\n    }\n    #b() {\n      this.#e = this.#l, this.#s = 0;\n    }\n    #u(t2) {\n      this.#b(), this.#o = t2;\n    }\n    #m(t2) {\n      return t2 < 0 && (t2 = this.#n.length - t2), t2 < this.#n.length ? this.#n[t2] : this.#n[this.#n.length - 1];\n    }\n    #a(t2, r2) {\n      let n2 = this.#m(t2);\n      return n2.value === r2 && (n2.type === "CHAR" || n2.type === "ESCAPED_CHAR" || n2.type === "INVALID_CHAR");\n    }\n    #P() {\n      return this.#a(this.#e, ":");\n    }\n    #E() {\n      return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");\n    }\n    #S() {\n      return this.#a(this.#e, "@");\n    }\n    #O() {\n      return this.#a(this.#e, ":");\n    }\n    #k() {\n      return this.#a(this.#e, ":");\n    }\n    #x() {\n      return this.#a(this.#e, "/");\n    }\n    #h() {\n      if (this.#a(this.#e, "?"))\n        return true;\n      if (this.#n[this.#e].value !== "?")\n        return false;\n      let t2 = this.#m(this.#e - 1);\n      return t2.type !== "NAME" && t2.type !== "REGEX" && t2.type !== "CLOSE" && t2.type !== "ASTERISK";\n    }\n    #f() {\n      return this.#a(this.#e, "#");\n    }\n    #T() {\n      return this.#n[this.#e].type == "OPEN";\n    }\n    #A() {\n      return this.#n[this.#e].type == "CLOSE";\n    }\n    #y() {\n      return this.#a(this.#e, "[");\n    }\n    #w() {\n      return this.#a(this.#e, "]");\n    }\n    #c() {\n      let t2 = this.#n[this.#e], r2 = this.#m(this.#l).index;\n      return this.#i.substring(r2, t2.index);\n    }\n    #C() {\n      let t2 = {};\n      Object.assign(t2, b), t2.encodePart = w;\n      let r2 = J(this.#c(), undefined, t2);\n      this.#g = $(r2);\n    }\n  };\n  a2(C, "Parser");\n  var X = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];\n  var O = "*";\n  function xe(e2, t2) {\n    if (typeof e2 != "string")\n      throw new TypeError("parameter 1 is not of type \'string\'.");\n    let r2 = new URL(e2, t2);\n    return { protocol: r2.protocol.substring(0, r2.protocol.length - 1), username: r2.username, password: r2.password, hostname: r2.hostname, port: r2.port, pathname: r2.pathname, search: r2.search !== "" ? r2.search.substring(1, r2.search.length) : undefined, hash: r2.hash !== "" ? r2.hash.substring(1, r2.hash.length) : undefined };\n  }\n  a2(xe, "extractValues");\n  function R(e2, t2) {\n    return t2 ? I(e2) : e2;\n  }\n  a2(R, "processBaseURLString");\n  function L(e2, t2, r2) {\n    let n2;\n    if (typeof t2.baseURL == "string")\n      try {\n        n2 = new URL(t2.baseURL), t2.protocol === undefined && (e2.protocol = R(n2.protocol.substring(0, n2.protocol.length - 1), r2)), !r2 && t2.protocol === undefined && t2.hostname === undefined && t2.port === undefined && t2.username === undefined && (e2.username = R(n2.username, r2)), !r2 && t2.protocol === undefined && t2.hostname === undefined && t2.port === undefined && t2.username === undefined && t2.password === undefined && (e2.password = R(n2.password, r2)), t2.protocol === undefined && t2.hostname === undefined && (e2.hostname = R(n2.hostname, r2)), t2.protocol === undefined && t2.hostname === undefined && t2.port === undefined && (e2.port = R(n2.port, r2)), t2.protocol === undefined && t2.hostname === undefined && t2.port === undefined && t2.pathname === undefined && (e2.pathname = R(n2.pathname, r2)), t2.protocol === undefined && t2.hostname === undefined && t2.port === undefined && t2.pathname === undefined && t2.search === undefined && (e2.search = R(n2.search.substring(1, n2.search.length), r2)), t2.protocol === undefined && t2.hostname === undefined && t2.port === undefined && t2.pathname === undefined && t2.search === undefined && t2.hash === undefined && (e2.hash = R(n2.hash.substring(1, n2.hash.length), r2));\n      } catch {\n        throw new TypeError(`invalid baseURL \'${t2.baseURL}\'.`);\n      }\n    if (typeof t2.protocol == "string" && (e2.protocol = he(t2.protocol, r2)), typeof t2.username == "string" && (e2.username = ce(t2.username, r2)), typeof t2.password == "string" && (e2.password = oe(t2.password, r2)), typeof t2.hostname == "string" && (e2.hostname = ae(t2.hostname, r2)), typeof t2.port == "string" && (e2.port = fe(t2.port, e2.protocol, r2)), typeof t2.pathname == "string") {\n      if (e2.pathname = t2.pathname, n2 && !te(e2.pathname, r2)) {\n        let o = n2.pathname.lastIndexOf("/");\n        o >= 0 && (e2.pathname = R(n2.pathname.substring(0, o + 1), r2) + e2.pathname);\n      }\n      e2.pathname = le(e2.pathname, e2.protocol, r2);\n    }\n    return typeof t2.search == "string" && (e2.search = ie(t2.search, r2)), typeof t2.hash == "string" && (e2.hash = se(t2.hash, r2)), e2;\n  }\n  a2(L, "applyInit");\n  function I(e2) {\n    return e2.replace(/([+*?:{}()\\\\])/g, "\\\\$1");\n  }\n  a2(I, "escapePatternString");\n  function Ie(e2) {\n    return e2.replace(/([.+*?^${}()[\\]|/\\\\])/g, "\\\\$1");\n  }\n  a2(Ie, "escapeRegexpString");\n  function Ne(e2, t2) {\n    t2.delimiter ??= "/#?", t2.prefixes ??= "./", t2.sensitive ??= false, t2.strict ??= false, t2.end ??= true, t2.start ??= true, t2.endsWith = "";\n    let r2 = ".*", n2 = `[^${Ie(t2.delimiter)}]+?`, o = /[$_\\u200C\\u200D\\p{ID_Continue}]/u, l = "";\n    for (let f = 0;f < e2.length; ++f) {\n      let s = e2[f];\n      if (s.type === 3) {\n        if (s.modifier === 3) {\n          l += I(s.value);\n          continue;\n        }\n        l += `{${I(s.value)}}${T(s.modifier)}`;\n        continue;\n      }\n      let i2 = s.hasCustomName(), c = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t2.prefixes.includes(s.prefix)), h = f > 0 ? e2[f - 1] : null, p = f < e2.length - 1 ? e2[f + 1] : null;\n      if (!c && i2 && s.type === 1 && s.modifier === 3 && p && !p.prefix.length && !p.suffix.length)\n        if (p.type === 3) {\n          let A = p.value.length > 0 ? p.value[0] : "";\n          c = o.test(A);\n        } else\n          c = !p.hasCustomName();\n      if (!c && !s.prefix.length && h && h.type === 3) {\n        let A = h.value[h.value.length - 1];\n        c = t2.prefixes.includes(A);\n      }\n      c && (l += "{"), l += I(s.prefix), i2 && (l += `:${s.name}`), s.type === 2 ? l += `(${s.value})` : s.type === 1 ? i2 || (l += `(${n2})`) : s.type === 0 && (!i2 && (!h || h.type === 3 || h.modifier !== 3 || c || s.prefix !== "") ? l += "*" : l += `(${r2})`), s.type === 1 && i2 && s.suffix.length && o.test(s.suffix[0]) && (l += "\\\\"), l += I(s.suffix), c && (l += "}"), s.modifier !== 3 && (l += T(s.modifier));\n    }\n    return l;\n  }\n  a2(Ne, "partsToPattern");\n  var M = class {\n    #i;\n    #n = {};\n    #t = {};\n    #e = {};\n    #s = {};\n    #l = false;\n    constructor(t2 = {}, r2, n2) {\n      try {\n        let o;\n        if (typeof r2 == "string" ? o = r2 : n2 = r2, typeof t2 == "string") {\n          let i2 = new C(t2);\n          if (i2.parse(), t2 = i2.result, o === undefined && typeof t2.protocol != "string")\n            throw new TypeError("A base URL must be provided for a relative constructor string.");\n          t2.baseURL = o;\n        } else {\n          if (!t2 || typeof t2 != "object")\n            throw new TypeError("parameter 1 is not of type \'string\' and cannot convert to dictionary.");\n          if (o)\n            throw new TypeError("parameter 1 is not of type \'string\'.");\n        }\n        typeof n2 > "u" && (n2 = { ignoreCase: false });\n        let l = { ignoreCase: n2.ignoreCase === true }, f = { pathname: O, protocol: O, username: O, password: O, hostname: O, port: O, search: O, hash: O };\n        this.#i = L(f, t2, true), K(this.#i.protocol) === this.#i.port && (this.#i.port = "");\n        let s;\n        for (s of X) {\n          if (!(s in this.#i))\n            continue;\n          let i2 = {}, c = this.#i[s];\n          switch (this.#t[s] = [], s) {\n            case "protocol":\n              Object.assign(i2, b), i2.encodePart = w;\n              break;\n            case "username":\n              Object.assign(i2, b), i2.encodePart = ue;\n              break;\n            case "password":\n              Object.assign(i2, b), i2.encodePart = de;\n              break;\n            case "hostname":\n              Object.assign(i2, Q), j(c) ? i2.encodePart = V : i2.encodePart = G;\n              break;\n            case "port":\n              Object.assign(i2, b), i2.encodePart = Y;\n              break;\n            case "pathname":\n              $(this.#n.protocol) ? (Object.assign(i2, ee, l), i2.encodePart = pe) : (Object.assign(i2, b, l), i2.encodePart = ge);\n              break;\n            case "search":\n              Object.assign(i2, b, l), i2.encodePart = me;\n              break;\n            case "hash":\n              Object.assign(i2, b, l), i2.encodePart = Se;\n              break;\n          }\n          try {\n            this.#s[s] = _(c, i2), this.#n[s] = z(this.#s[s], this.#t[s], i2), this.#e[s] = Ne(this.#s[s], i2), this.#l = this.#l || this.#s[s].some((h) => h.type === 2);\n          } catch {\n            throw new TypeError(`invalid ${s} pattern \'${this.#i[s]}\'.`);\n          }\n        }\n      } catch (o) {\n        throw new TypeError(`Failed to construct \'URLPattern\': ${o.message}`);\n      }\n    }\n    get [Symbol.toStringTag]() {\n      return "URLPattern";\n    }\n    test(t2 = {}, r2) {\n      let n2 = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };\n      if (typeof t2 != "string" && r2)\n        throw new TypeError("parameter 1 is not of type \'string\'.");\n      if (typeof t2 > "u")\n        return false;\n      try {\n        typeof t2 == "object" ? n2 = L(n2, t2, false) : n2 = L(n2, xe(t2, r2), false);\n      } catch {\n        return false;\n      }\n      let o;\n      for (o of X)\n        if (!this.#n[o].exec(n2[o]))\n          return false;\n      return true;\n    }\n    exec(t2 = {}, r2) {\n      let n2 = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };\n      if (typeof t2 != "string" && r2)\n        throw new TypeError("parameter 1 is not of type \'string\'.");\n      if (typeof t2 > "u")\n        return;\n      try {\n        typeof t2 == "object" ? n2 = L(n2, t2, false) : n2 = L(n2, xe(t2, r2), false);\n      } catch {\n        return null;\n      }\n      let o = {};\n      r2 ? o.inputs = [t2, r2] : o.inputs = [t2];\n      let l;\n      for (l of X) {\n        let f = this.#n[l].exec(n2[l]);\n        if (!f)\n          return null;\n        let s = {};\n        for (let [i2, c] of this.#t[l].entries())\n          if (typeof c == "string" || typeof c == "number") {\n            let h = f[i2 + 1];\n            s[c] = h;\n          }\n        o[l] = { input: n2[l] ?? "", groups: s };\n      }\n      return o;\n    }\n    static compareComponent(t2, r2, n2) {\n      let o = a2((i2, c) => {\n        for (let h of ["type", "modifier", "prefix", "value", "suffix"]) {\n          if (i2[h] < c[h])\n            return -1;\n          if (i2[h] === c[h])\n            continue;\n          return 1;\n        }\n        return 0;\n      }, "comparePart"), l = new P(3, "", "", "", "", 3), f = new P(0, "", "", "", "", 3), s = a2((i2, c) => {\n        let h = 0;\n        for (;h < Math.min(i2.length, c.length); ++h) {\n          let p = o(i2[h], c[h]);\n          if (p)\n            return p;\n        }\n        return i2.length === c.length ? 0 : o(i2[h] ?? l, c[h] ?? l);\n      }, "comparePartList");\n      return !r2.#e[t2] && !n2.#e[t2] ? 0 : r2.#e[t2] && !n2.#e[t2] ? s(r2.#s[t2], [f]) : !r2.#e[t2] && n2.#e[t2] ? s([f], n2.#s[t2]) : s(r2.#s[t2], n2.#s[t2]);\n    }\n    get protocol() {\n      return this.#e.protocol;\n    }\n    get username() {\n      return this.#e.username;\n    }\n    get password() {\n      return this.#e.password;\n    }\n    get hostname() {\n      return this.#e.hostname;\n    }\n    get port() {\n      return this.#e.port;\n    }\n    get pathname() {\n      return this.#e.pathname;\n    }\n    get search() {\n      return this.#e.search;\n    }\n    get hash() {\n      return this.#e.hash;\n    }\n    get hasRegExpGroups() {\n      return this.#l;\n    }\n  };\n  a2(M, "URLPattern");\n});\n\n// ../../node_modules/urlpattern-polyfill/index.cjs\nvar require_urlpattern_polyfill = __commonJS((exports, module) => {\n  var { URLPattern } = require_urlpattern();\n  module.exports = { URLPattern };\n  if (!globalThis.URLPattern) {\n    globalThis.URLPattern = URLPattern;\n  }\n});\n\n// ../../node_modules/@whatwg-node/promise-helpers/cjs/index.js\nvar require_cjs = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.isPromise = isPromise2;\n  exports.isActualPromise = isActualPromise2;\n  exports.handleMaybePromise = handleMaybePromise2;\n  exports.fakePromise = fakePromise2;\n  exports.createDeferredPromise = createDeferredPromise2;\n  exports.iterateAsync = iterateAsync2;\n  exports.iterateAsyncVoid = iterateAsync2;\n  exports.fakeRejectPromise = fakeRejectPromise2;\n  exports.mapMaybePromise = mapMaybePromise;\n  exports.mapAsyncIterator = mapAsyncIterator;\n  exports.promiseLikeFinally = promiseLikeFinally2;\n  exports.unfakePromise = unfakePromise2;\n  var kFakePromise2 = Symbol.for("@whatwg-node/promise-helpers/FakePromise");\n  function isPromise2(value) {\n    return value?.then != null;\n  }\n  function isActualPromise2(value) {\n    const maybePromise = value;\n    return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;\n  }\n  function handleMaybePromise2(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {\n    let result$ = fakePromise2().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);\n    if (finallyFactory) {\n      result$ = result$.finally(finallyFactory);\n    }\n    return unfakePromise2(result$);\n  }\n  function fakePromise2(value) {\n    if (value && isActualPromise2(value)) {\n      return value;\n    }\n    if (isPromise2(value)) {\n      return {\n        then: (resolve, reject) => fakePromise2(value.then(resolve, reject)),\n        catch: (reject) => fakePromise2(value.then((res) => res, reject)),\n        finally: (cb) => fakePromise2(cb ? promiseLikeFinally2(value, cb) : value),\n        [Symbol.toStringTag]: "Promise"\n      };\n    }\n    return {\n      then(resolve) {\n        if (resolve) {\n          try {\n            return fakePromise2(resolve(value));\n          } catch (err) {\n            return fakeRejectPromise2(err);\n          }\n        }\n        return this;\n      },\n      catch() {\n        return this;\n      },\n      finally(cb) {\n        if (cb) {\n          try {\n            return fakePromise2(cb()).then(() => value, () => value);\n          } catch (err) {\n            return fakeRejectPromise2(err);\n          }\n        }\n        return this;\n      },\n      [Symbol.toStringTag]: "Promise",\n      __fakePromiseValue: value,\n      [kFakePromise2]: "resolved"\n    };\n  }\n  function createDeferredPromise2() {\n    if (Promise.withResolvers) {\n      return Promise.withResolvers();\n    }\n    let resolveFn;\n    let rejectFn;\n    const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {\n      resolveFn = resolve;\n      rejectFn = reject;\n    });\n    return {\n      promise,\n      get resolve() {\n        return resolveFn;\n      },\n      get reject() {\n        return rejectFn;\n      }\n    };\n  }\n  function iterateAsync2(iterable, callback, results) {\n    if (iterable?.length === 0) {\n      return;\n    }\n    const iterator = iterable[Symbol.iterator]();\n    let index = 0;\n    function iterate() {\n      const { done: endOfIterator, value } = iterator.next();\n      if (endOfIterator) {\n        return;\n      }\n      let endedEarly = false;\n      function endEarly() {\n        endedEarly = true;\n      }\n      return handleMaybePromise2(function handleCallback() {\n        return callback(value, endEarly, index++);\n      }, function handleCallbackResult(result) {\n        if (result) {\n          results?.push(result);\n        }\n        if (endedEarly) {\n          return;\n        }\n        return iterate();\n      });\n    }\n    return iterate();\n  }\n  function fakeRejectPromise2(error) {\n    return {\n      then(_resolve, reject) {\n        if (reject) {\n          try {\n            return fakePromise2(reject(error));\n          } catch (err) {\n            return fakeRejectPromise2(err);\n          }\n        }\n        return this;\n      },\n      catch(reject) {\n        if (reject) {\n          try {\n            return fakePromise2(reject(error));\n          } catch (err) {\n            return fakeRejectPromise2(err);\n          }\n        }\n        return this;\n      },\n      finally(cb) {\n        if (cb) {\n          try {\n            cb();\n          } catch (err) {\n            return fakeRejectPromise2(err);\n          }\n        }\n        return this;\n      },\n      __fakeRejectError: error,\n      [Symbol.toStringTag]: "Promise",\n      [kFakePromise2]: "rejected"\n    };\n  }\n  function mapMaybePromise(input, onSuccess, onError) {\n    return handleMaybePromise2(() => input, onSuccess, onError);\n  }\n  function mapAsyncIterator(iterator, onNext, onError, onEnd) {\n    if (Symbol.asyncIterator in iterator) {\n      iterator = iterator[Symbol.asyncIterator]();\n    }\n    let $return;\n    let abruptClose;\n    let onEndWithValue;\n    if (onEnd) {\n      let onEndWithValueResult;\n      onEndWithValue = (value) => {\n        onEndWithValueResult ||= handleMaybePromise2(onEnd, () => value, () => value);\n        return onEndWithValueResult;\n      };\n    }\n    if (typeof iterator.return === "function") {\n      $return = iterator.return;\n      abruptClose = (error) => {\n        const rethrow = () => {\n          throw error;\n        };\n        return $return.call(iterator).then(rethrow, rethrow);\n      };\n    }\n    function mapResult(result) {\n      if (result.done) {\n        return onEndWithValue ? onEndWithValue(result) : result;\n      }\n      return handleMaybePromise2(() => result.value, (value) => handleMaybePromise2(() => onNext(value), iteratorResult, abruptClose));\n    }\n    let mapReject;\n    if (onError) {\n      let onErrorResult;\n      const reject = onError;\n      mapReject = (error) => {\n        onErrorResult ||= handleMaybePromise2(() => error, (error2) => handleMaybePromise2(() => reject(error2), iteratorResult, abruptClose));\n        return onErrorResult;\n      };\n    }\n    return {\n      next() {\n        return iterator.next().then(mapResult, mapReject);\n      },\n      return() {\n        const res$ = $return ? $return.call(iterator).then(mapResult, mapReject) : fakePromise2({ value: undefined, done: true });\n        return onEndWithValue ? res$.then(onEndWithValue) : res$;\n      },\n      throw(error) {\n        if (typeof iterator.throw === "function") {\n          return iterator.throw(error).then(mapResult, mapReject);\n        }\n        if (abruptClose) {\n          return abruptClose(error);\n        }\n        return fakeRejectPromise2(error);\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      }\n    };\n  }\n  function iteratorResult(value) {\n    return { value, done: false };\n  }\n  function isFakePromise2(value) {\n    return value?.[kFakePromise2] === "resolved";\n  }\n  function isFakeRejectPromise2(value) {\n    return value?.[kFakePromise2] === "rejected";\n  }\n  function promiseLikeFinally2(value, onFinally) {\n    if ("finally" in value) {\n      return value.finally(onFinally);\n    }\n    return value.then((res) => {\n      const finallyRes = onFinally();\n      return isPromise2(finallyRes) ? finallyRes.then(() => res) : res;\n    }, (err) => {\n      const finallyRes = onFinally();\n      if (isPromise2(finallyRes)) {\n        return finallyRes.then(() => {\n          throw err;\n        });\n      } else {\n        throw err;\n      }\n    });\n  }\n  function unfakePromise2(promise) {\n    if (isFakePromise2(promise)) {\n      return promise.__fakePromiseValue;\n    }\n    if (isFakeRejectPromise2(promise)) {\n      throw promise.__fakeRejectError;\n    }\n    return promise;\n  }\n});\n\n// ../../node_modules/@fastify/busboy/deps/streamsearch/sbmh.js\nvar require_sbmh = __commonJS((exports, module) => {\n  var { EventEmitter } = __require("node:events");\n  var { inherits } = __require("node:util");\n  function SBMH(needle) {\n    if (typeof needle === "string") {\n      needle = Buffer.from(needle);\n    }\n    if (!Buffer.isBuffer(needle)) {\n      throw new TypeError("The needle has to be a String or a Buffer.");\n    }\n    const needleLength = needle.length;\n    const needleLastCharIndex = needleLength - 1;\n    if (needleLength === 0) {\n      throw new Error("The needle cannot be an empty String/Buffer.");\n    }\n    if (needleLength > 256) {\n      throw new Error("The needle cannot have a length bigger than 256.");\n    }\n    this.maxMatches = Infinity;\n    this.matches = 0;\n    this._occ = new Uint8Array(256).fill(needleLength);\n    this._lookbehind_size = 0;\n    this._needle = needle;\n    this._bufpos = 0;\n    this._lookbehind = Buffer.alloc(needleLastCharIndex);\n    for (var i2 = 0;i2 < needleLastCharIndex; ++i2) {\n      this._occ[needle[i2]] = needleLastCharIndex - i2;\n    }\n  }\n  inherits(SBMH, EventEmitter);\n  SBMH.prototype.reset = function() {\n    this._lookbehind_size = 0;\n    this.matches = 0;\n    this._bufpos = 0;\n  };\n  SBMH.prototype.push = function(chunk, pos) {\n    if (!Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, "binary");\n    }\n    const chlen = chunk.length;\n    this._bufpos = pos || 0;\n    let r2;\n    while (r2 !== chlen && this.matches < this.maxMatches) {\n      r2 = this._sbmh_feed(chunk);\n    }\n    return r2;\n  };\n  SBMH.prototype._sbmh_feed = function(data) {\n    const len = data.length;\n    const needle = this._needle;\n    const needleLength = needle.length;\n    const needleLastCharIndex = needleLength - 1;\n    const needleLastChar = needle[needleLastCharIndex];\n    let pos = -this._lookbehind_size;\n    let ch;\n    if (pos < 0) {\n      while (pos < 0 && pos <= len - needleLength) {\n        ch = data[pos + needleLastCharIndex];\n        if (ch === needleLastChar && this._sbmh_memcmp(data, pos, needleLastCharIndex)) {\n          this._lookbehind_size = 0;\n          ++this.matches;\n          this.emit("info", true);\n          return this._bufpos = pos + needleLength;\n        }\n        pos += this._occ[ch];\n      }\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {\n        ++pos;\n      }\n      if (pos >= 0) {\n        this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);\n        this._lookbehind_size = 0;\n      } else {\n        const bytesToCutOff = this._lookbehind_size + pos;\n        if (bytesToCutOff > 0) {\n          this.emit("info", false, this._lookbehind, 0, bytesToCutOff);\n        }\n        this._lookbehind_size -= bytesToCutOff;\n        this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size);\n        data.copy(this._lookbehind, this._lookbehind_size);\n        this._lookbehind_size += len;\n        this._bufpos = len;\n        return len;\n      }\n    }\n    pos = data.indexOf(needle, pos + this._bufpos);\n    if (pos !== -1) {\n      ++this.matches;\n      if (pos === 0) {\n        this.emit("info", true);\n      } else {\n        this.emit("info", true, data, this._bufpos, pos);\n      }\n      return this._bufpos = pos + needleLength;\n    }\n    pos = len - needleLastCharIndex;\n    if (pos < 0) {\n      pos = 0;\n    }\n    while (pos !== len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos + 1, len), needle.subarray(1, len - pos)) !== 0)) {\n      ++pos;\n    }\n    if (pos !== len) {\n      data.copy(this._lookbehind, 0, pos, len);\n      this._lookbehind_size = len - pos;\n    }\n    if (pos !== 0) {\n      this.emit("info", false, data, this._bufpos, pos);\n    }\n    this._bufpos = len;\n    return len;\n  };\n  SBMH.prototype._sbmh_lookup_char = function(data, pos) {\n    return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];\n  };\n  SBMH.prototype._sbmh_memcmp = function(data, pos, len) {\n    for (var i2 = 0;i2 < len; ++i2) {\n      if (this._sbmh_lookup_char(data, pos + i2) !== this._needle[i2]) {\n        return false;\n      }\n    }\n    return true;\n  };\n  module.exports = SBMH;\n});\n\n// ../../node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js\nvar require_PartStream = __commonJS((exports, module) => {\n  var inherits = __require("node:util").inherits;\n  var ReadableStream2 = __require("node:stream").Readable;\n  function PartStream(opts) {\n    ReadableStream2.call(this, opts);\n  }\n  inherits(PartStream, ReadableStream2);\n  PartStream.prototype._read = function(n2) {};\n  module.exports = PartStream;\n});\n\n// ../../node_modules/@fastify/busboy/lib/utils/getLimit.js\nvar require_getLimit = __commonJS((exports, module) => {\n  module.exports = function getLimit(limits, name, defaultLimit) {\n    if (!limits || limits[name] === undefined || limits[name] === null) {\n      return defaultLimit;\n    }\n    if (typeof limits[name] !== "number" || isNaN(limits[name])) {\n      throw new TypeError("Limit " + name + " is not a valid number");\n    }\n    return limits[name];\n  };\n});\n\n// ../../node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js\nvar require_HeaderParser = __commonJS((exports, module) => {\n  var EventEmitter = __require("node:events").EventEmitter;\n  var inherits = __require("node:util").inherits;\n  var getLimit = require_getLimit();\n  var StreamSearch = require_sbmh();\n  var B_DCRLF = Buffer.from(`\\r\n\\r\n`);\n  var RE_CRLF = /\\r\\n/g;\n  var RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/;\n  function HeaderParser(cfg) {\n    EventEmitter.call(this);\n    cfg = cfg || {};\n    const self2 = this;\n    this.nread = 0;\n    this.maxed = false;\n    this.npairs = 0;\n    this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2000);\n    this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);\n    this.buffer = "";\n    this.header = {};\n    this.finished = false;\n    this.ss = new StreamSearch(B_DCRLF);\n    this.ss.on("info", function(isMatch, data, start, end) {\n      if (data && !self2.maxed) {\n        if (self2.nread + end - start >= self2.maxHeaderSize) {\n          end = self2.maxHeaderSize - self2.nread + start;\n          self2.nread = self2.maxHeaderSize;\n          self2.maxed = true;\n        } else {\n          self2.nread += end - start;\n        }\n        self2.buffer += data.toString("binary", start, end);\n      }\n      if (isMatch) {\n        self2._finish();\n      }\n    });\n  }\n  inherits(HeaderParser, EventEmitter);\n  HeaderParser.prototype.push = function(data) {\n    const r2 = this.ss.push(data);\n    if (this.finished) {\n      return r2;\n    }\n  };\n  HeaderParser.prototype.reset = function() {\n    this.finished = false;\n    this.buffer = "";\n    this.header = {};\n    this.ss.reset();\n  };\n  HeaderParser.prototype._finish = function() {\n    if (this.buffer) {\n      this._parseHeader();\n    }\n    this.ss.matches = this.ss.maxMatches;\n    const header = this.header;\n    this.header = {};\n    this.buffer = "";\n    this.finished = true;\n    this.nread = this.npairs = 0;\n    this.maxed = false;\n    this.emit("header", header);\n  };\n  HeaderParser.prototype._parseHeader = function() {\n    if (this.npairs === this.maxHeaderPairs) {\n      return;\n    }\n    const lines = this.buffer.split(RE_CRLF);\n    const len = lines.length;\n    let m, h;\n    for (var i2 = 0;i2 < len; ++i2) {\n      if (lines[i2].length === 0) {\n        continue;\n      }\n      if (lines[i2][0] === "\\t" || lines[i2][0] === " ") {\n        if (h) {\n          this.header[h][this.header[h].length - 1] += lines[i2];\n          continue;\n        }\n      }\n      const posColon = lines[i2].indexOf(":");\n      if (posColon === -1 || posColon === 0) {\n        return;\n      }\n      m = RE_HDR.exec(lines[i2]);\n      h = m[1].toLowerCase();\n      this.header[h] = this.header[h] || [];\n      this.header[h].push(m[2] || "");\n      if (++this.npairs === this.maxHeaderPairs) {\n        break;\n      }\n    }\n  };\n  module.exports = HeaderParser;\n});\n\n// ../../node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js\nvar require_Dicer = __commonJS((exports, module) => {\n  var WritableStream2 = __require("node:stream").Writable;\n  var inherits = __require("node:util").inherits;\n  var StreamSearch = require_sbmh();\n  var PartStream = require_PartStream();\n  var HeaderParser = require_HeaderParser();\n  var DASH = 45;\n  var B_ONEDASH = Buffer.from("-");\n  var B_CRLF = Buffer.from(`\\r\n`);\n  var EMPTY_FN = function() {};\n  function Dicer(cfg) {\n    if (!(this instanceof Dicer)) {\n      return new Dicer(cfg);\n    }\n    WritableStream2.call(this, cfg);\n    if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {\n      throw new TypeError("Boundary required");\n    }\n    if (typeof cfg.boundary === "string") {\n      this.setBoundary(cfg.boundary);\n    } else {\n      this._bparser = undefined;\n    }\n    this._headerFirst = cfg.headerFirst;\n    this._dashes = 0;\n    this._parts = 0;\n    this._finished = false;\n    this._realFinish = false;\n    this._isPreamble = true;\n    this._justMatched = false;\n    this._firstWrite = true;\n    this._inHeader = true;\n    this._part = undefined;\n    this._cb = undefined;\n    this._ignoreData = false;\n    this._partOpts = { highWaterMark: cfg.partHwm };\n    this._pause = false;\n    const self2 = this;\n    this._hparser = new HeaderParser(cfg);\n    this._hparser.on("header", function(header) {\n      self2._inHeader = false;\n      self2._part.emit("header", header);\n    });\n  }\n  inherits(Dicer, WritableStream2);\n  Dicer.prototype.emit = function(ev) {\n    if (ev === "finish" && !this._realFinish) {\n      if (!this._finished) {\n        const self2 = this;\n        process.nextTick(function() {\n          self2.emit("error", new Error("Unexpected end of multipart data"));\n          if (self2._part && !self2._ignoreData) {\n            const type = self2._isPreamble ? "Preamble" : "Part";\n            self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));\n            self2._part.push(null);\n            process.nextTick(function() {\n              self2._realFinish = true;\n              self2.emit("finish");\n              self2._realFinish = false;\n            });\n            return;\n          }\n          self2._realFinish = true;\n          self2.emit("finish");\n          self2._realFinish = false;\n        });\n      }\n    } else {\n      WritableStream2.prototype.emit.apply(this, arguments);\n    }\n  };\n  Dicer.prototype._write = function(data, encoding, cb) {\n    if (!this._hparser && !this._bparser) {\n      return cb();\n    }\n    if (this._headerFirst && this._isPreamble) {\n      if (!this._part) {\n        this._part = new PartStream(this._partOpts);\n        if (this.listenerCount("preamble") !== 0) {\n          this.emit("preamble", this._part);\n        } else {\n          this._ignore();\n        }\n      }\n      const r2 = this._hparser.push(data);\n      if (!this._inHeader && r2 !== undefined && r2 < data.length) {\n        data = data.slice(r2);\n      } else {\n        return cb();\n      }\n    }\n    if (this._firstWrite) {\n      this._bparser.push(B_CRLF);\n      this._firstWrite = false;\n    }\n    this._bparser.push(data);\n    if (this._pause) {\n      this._cb = cb;\n    } else {\n      cb();\n    }\n  };\n  Dicer.prototype.reset = function() {\n    this._part = undefined;\n    this._bparser = undefined;\n    this._hparser = undefined;\n  };\n  Dicer.prototype.setBoundary = function(boundary) {\n    const self2 = this;\n    this._bparser = new StreamSearch(`\\r\n--` + boundary);\n    this._bparser.on("info", function(isMatch, data, start, end) {\n      self2._oninfo(isMatch, data, start, end);\n    });\n  };\n  Dicer.prototype._ignore = function() {\n    if (this._part && !this._ignoreData) {\n      this._ignoreData = true;\n      this._part.on("error", EMPTY_FN);\n      this._part.resume();\n    }\n  };\n  Dicer.prototype._oninfo = function(isMatch, data, start, end) {\n    let buf;\n    const self2 = this;\n    let i2 = 0;\n    let r2;\n    let shouldWriteMore = true;\n    if (!this._part && this._justMatched && data) {\n      while (this._dashes < 2 && start + i2 < end) {\n        if (data[start + i2] === DASH) {\n          ++i2;\n          ++this._dashes;\n        } else {\n          if (this._dashes) {\n            buf = B_ONEDASH;\n          }\n          this._dashes = 0;\n          break;\n        }\n      }\n      if (this._dashes === 2) {\n        if (start + i2 < end && this.listenerCount("trailer") !== 0) {\n          this.emit("trailer", data.slice(start + i2, end));\n        }\n        this.reset();\n        this._finished = true;\n        if (self2._parts === 0) {\n          self2._realFinish = true;\n          self2.emit("finish");\n          self2._realFinish = false;\n        }\n      }\n      if (this._dashes) {\n        return;\n      }\n    }\n    if (this._justMatched) {\n      this._justMatched = false;\n    }\n    if (!this._part) {\n      this._part = new PartStream(this._partOpts);\n      this._part._read = function(n2) {\n        self2._unpause();\n      };\n      if (this._isPreamble && this.listenerCount("preamble") !== 0) {\n        this.emit("preamble", this._part);\n      } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {\n        this.emit("part", this._part);\n      } else {\n        this._ignore();\n      }\n      if (!this._isPreamble) {\n        this._inHeader = true;\n      }\n    }\n    if (data && start < end && !this._ignoreData) {\n      if (this._isPreamble || !this._inHeader) {\n        if (buf) {\n          shouldWriteMore = this._part.push(buf);\n        }\n        shouldWriteMore = this._part.push(data.slice(start, end));\n        if (!shouldWriteMore) {\n          this._pause = true;\n        }\n      } else if (!this._isPreamble && this._inHeader) {\n        if (buf) {\n          this._hparser.push(buf);\n        }\n        r2 = this._hparser.push(data.slice(start, end));\n        if (!this._inHeader && r2 !== undefined && r2 < end) {\n          this._oninfo(false, data, start + r2, end);\n        }\n      }\n    }\n    if (isMatch) {\n      this._hparser.reset();\n      if (this._isPreamble) {\n        this._isPreamble = false;\n      } else {\n        if (start !== end) {\n          ++this._parts;\n          this._part.on("end", function() {\n            if (--self2._parts === 0) {\n              if (self2._finished) {\n                self2._realFinish = true;\n                self2.emit("finish");\n                self2._realFinish = false;\n              } else {\n                self2._unpause();\n              }\n            }\n          });\n        }\n      }\n      this._part.push(null);\n      this._part = undefined;\n      this._ignoreData = false;\n      this._justMatched = true;\n      this._dashes = 0;\n    }\n  };\n  Dicer.prototype._unpause = function() {\n    if (!this._pause) {\n      return;\n    }\n    this._pause = false;\n    if (this._cb) {\n      const cb = this._cb;\n      this._cb = undefined;\n      cb();\n    }\n  };\n  module.exports = Dicer;\n});\n\n// ../../node_modules/@fastify/busboy/lib/utils/decodeText.js\nvar require_decodeText = __commonJS((exports, module) => {\n  var utf8Decoder = new TextDecoder("utf-8");\n  var textDecoders = new Map([\n    ["utf-8", utf8Decoder],\n    ["utf8", utf8Decoder]\n  ]);\n  function getDecoder(charset) {\n    let lc;\n    while (true) {\n      switch (charset) {\n        case "utf-8":\n        case "utf8":\n          return decoders.utf8;\n        case "latin1":\n        case "ascii":\n        case "us-ascii":\n        case "iso-8859-1":\n        case "iso8859-1":\n        case "iso88591":\n        case "iso_8859-1":\n        case "windows-1252":\n        case "iso_8859-1:1987":\n        case "cp1252":\n        case "x-cp1252":\n          return decoders.latin1;\n        case "utf16le":\n        case "utf-16le":\n        case "ucs2":\n        case "ucs-2":\n          return decoders.utf16le;\n        case "base64":\n          return decoders.base64;\n        default:\n          if (lc === undefined) {\n            lc = true;\n            charset = charset.toLowerCase();\n            continue;\n          }\n          return decoders.other.bind(charset);\n      }\n    }\n  }\n  var decoders = {\n    utf8: (data, sourceEncoding) => {\n      if (data.length === 0) {\n        return "";\n      }\n      if (typeof data === "string") {\n        data = Buffer.from(data, sourceEncoding);\n      }\n      return data.utf8Slice(0, data.length);\n    },\n    latin1: (data, sourceEncoding) => {\n      if (data.length === 0) {\n        return "";\n      }\n      if (typeof data === "string") {\n        return data;\n      }\n      return data.latin1Slice(0, data.length);\n    },\n    utf16le: (data, sourceEncoding) => {\n      if (data.length === 0) {\n        return "";\n      }\n      if (typeof data === "string") {\n        data = Buffer.from(data, sourceEncoding);\n      }\n      return data.ucs2Slice(0, data.length);\n    },\n    base64: (data, sourceEncoding) => {\n      if (data.length === 0) {\n        return "";\n      }\n      if (typeof data === "string") {\n        data = Buffer.from(data, sourceEncoding);\n      }\n      return data.base64Slice(0, data.length);\n    },\n    other: (data, sourceEncoding) => {\n      if (data.length === 0) {\n        return "";\n      }\n      if (typeof data === "string") {\n        data = Buffer.from(data, sourceEncoding);\n      }\n      if (textDecoders.has(exports.toString())) {\n        try {\n          return textDecoders.get(exports).decode(data);\n        } catch {}\n      }\n      return typeof data === "string" ? data : data.toString();\n    }\n  };\n  function decodeText(text, sourceEncoding, destEncoding) {\n    if (text) {\n      return getDecoder(destEncoding)(text, sourceEncoding);\n    }\n    return text;\n  }\n  module.exports = decodeText;\n});\n\n// ../../node_modules/@fastify/busboy/lib/utils/parseParams.js\nvar require_parseParams = __commonJS((exports, module) => {\n  var decodeText = require_decodeText();\n  var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;\n  var EncodedLookup = {\n    "%00": "\\x00",\n    "%01": "\\x01",\n    "%02": "\\x02",\n    "%03": "\\x03",\n    "%04": "\\x04",\n    "%05": "\\x05",\n    "%06": "\\x06",\n    "%07": "\\x07",\n    "%08": "\\b",\n    "%09": "\\t",\n    "%0a": `\n`,\n    "%0A": `\n`,\n    "%0b": "\\v",\n    "%0B": "\\v",\n    "%0c": "\\f",\n    "%0C": "\\f",\n    "%0d": "\\r",\n    "%0D": "\\r",\n    "%0e": "\\x0E",\n    "%0E": "\\x0E",\n    "%0f": "\\x0F",\n    "%0F": "\\x0F",\n    "%10": "\\x10",\n    "%11": "\\x11",\n    "%12": "\\x12",\n    "%13": "\\x13",\n    "%14": "\\x14",\n    "%15": "\\x15",\n    "%16": "\\x16",\n    "%17": "\\x17",\n    "%18": "\\x18",\n    "%19": "\\x19",\n    "%1a": "\\x1A",\n    "%1A": "\\x1A",\n    "%1b": "\\x1B",\n    "%1B": "\\x1B",\n    "%1c": "\\x1C",\n    "%1C": "\\x1C",\n    "%1d": "\\x1D",\n    "%1D": "\\x1D",\n    "%1e": "\\x1E",\n    "%1E": "\\x1E",\n    "%1f": "\\x1F",\n    "%1F": "\\x1F",\n    "%20": " ",\n    "%21": "!",\n    "%22": \'"\',\n    "%23": "#",\n    "%24": "$",\n    "%25": "%",\n    "%26": "&",\n    "%27": "\'",\n    "%28": "(",\n    "%29": ")",\n    "%2a": "*",\n    "%2A": "*",\n    "%2b": "+",\n    "%2B": "+",\n    "%2c": ",",\n    "%2C": ",",\n    "%2d": "-",\n    "%2D": "-",\n    "%2e": ".",\n    "%2E": ".",\n    "%2f": "/",\n    "%2F": "/",\n    "%30": "0",\n    "%31": "1",\n    "%32": "2",\n    "%33": "3",\n    "%34": "4",\n    "%35": "5",\n    "%36": "6",\n    "%37": "7",\n    "%38": "8",\n    "%39": "9",\n    "%3a": ":",\n    "%3A": ":",\n    "%3b": ";",\n    "%3B": ";",\n    "%3c": "<",\n    "%3C": "<",\n    "%3d": "=",\n    "%3D": "=",\n    "%3e": ">",\n    "%3E": ">",\n    "%3f": "?",\n    "%3F": "?",\n    "%40": "@",\n    "%41": "A",\n    "%42": "B",\n    "%43": "C",\n    "%44": "D",\n    "%45": "E",\n    "%46": "F",\n    "%47": "G",\n    "%48": "H",\n    "%49": "I",\n    "%4a": "J",\n    "%4A": "J",\n    "%4b": "K",\n    "%4B": "K",\n    "%4c": "L",\n    "%4C": "L",\n    "%4d": "M",\n    "%4D": "M",\n    "%4e": "N",\n    "%4E": "N",\n    "%4f": "O",\n    "%4F": "O",\n    "%50": "P",\n    "%51": "Q",\n    "%52": "R",\n    "%53": "S",\n    "%54": "T",\n    "%55": "U",\n    "%56": "V",\n    "%57": "W",\n    "%58": "X",\n    "%59": "Y",\n    "%5a": "Z",\n    "%5A": "Z",\n    "%5b": "[",\n    "%5B": "[",\n    "%5c": "\\\\",\n    "%5C": "\\\\",\n    "%5d": "]",\n    "%5D": "]",\n    "%5e": "^",\n    "%5E": "^",\n    "%5f": "_",\n    "%5F": "_",\n    "%60": "`",\n    "%61": "a",\n    "%62": "b",\n    "%63": "c",\n    "%64": "d",\n    "%65": "e",\n    "%66": "f",\n    "%67": "g",\n    "%68": "h",\n    "%69": "i",\n    "%6a": "j",\n    "%6A": "j",\n    "%6b": "k",\n    "%6B": "k",\n    "%6c": "l",\n    "%6C": "l",\n    "%6d": "m",\n    "%6D": "m",\n    "%6e": "n",\n    "%6E": "n",\n    "%6f": "o",\n    "%6F": "o",\n    "%70": "p",\n    "%71": "q",\n    "%72": "r",\n    "%73": "s",\n    "%74": "t",\n    "%75": "u",\n    "%76": "v",\n    "%77": "w",\n    "%78": "x",\n    "%79": "y",\n    "%7a": "z",\n    "%7A": "z",\n    "%7b": "{",\n    "%7B": "{",\n    "%7c": "|",\n    "%7C": "|",\n    "%7d": "}",\n    "%7D": "}",\n    "%7e": "~",\n    "%7E": "~",\n    "%7f": "",\n    "%7F": "",\n    "%80": "",\n    "%81": "",\n    "%82": "",\n    "%83": "",\n    "%84": "",\n    "%85": "",\n    "%86": "",\n    "%87": "",\n    "%88": "",\n    "%89": "",\n    "%8a": "",\n    "%8A": "",\n    "%8b": "",\n    "%8B": "",\n    "%8c": "",\n    "%8C": "",\n    "%8d": "",\n    "%8D": "",\n    "%8e": "",\n    "%8E": "",\n    "%8f": "",\n    "%8F": "",\n    "%90": "",\n    "%91": "",\n    "%92": "",\n    "%93": "",\n    "%94": "",\n    "%95": "",\n    "%96": "",\n    "%97": "",\n    "%98": "",\n    "%99": "",\n    "%9a": "",\n    "%9A": "",\n    "%9b": "",\n    "%9B": "",\n    "%9c": "",\n    "%9C": "",\n    "%9d": "",\n    "%9D": "",\n    "%9e": "",\n    "%9E": "",\n    "%9f": "",\n    "%9F": "",\n    "%a0": "",\n    "%A0": "",\n    "%a1": "",\n    "%A1": "",\n    "%a2": "",\n    "%A2": "",\n    "%a3": "",\n    "%A3": "",\n    "%a4": "",\n    "%A4": "",\n    "%a5": "",\n    "%A5": "",\n    "%a6": "",\n    "%A6": "",\n    "%a7": "",\n    "%A7": "",\n    "%a8": "",\n    "%A8": "",\n    "%a9": "",\n    "%A9": "",\n    "%aa": "",\n    "%Aa": "",\n    "%aA": "",\n    "%AA": "",\n    "%ab": "",\n    "%Ab": "",\n    "%aB": "",\n    "%AB": "",\n    "%ac": "",\n    "%Ac": "",\n    "%aC": "",\n    "%AC": "",\n    "%ad": "",\n    "%Ad": "",\n    "%aD": "",\n    "%AD": "",\n    "%ae": "",\n    "%Ae": "",\n    "%aE": "",\n    "%AE": "",\n    "%af": "",\n    "%Af": "",\n    "%aF": "",\n    "%AF": "",\n    "%b0": "",\n    "%B0": "",\n    "%b1": "",\n    "%B1": "",\n    "%b2": "",\n    "%B2": "",\n    "%b3": "",\n    "%B3": "",\n    "%b4": "",\n    "%B4": "",\n    "%b5": "",\n    "%B5": "",\n    "%b6": "",\n    "%B6": "",\n    "%b7": "",\n    "%B7": "",\n    "%b8": "",\n    "%B8": "",\n    "%b9": "",\n    "%B9": "",\n    "%ba": "",\n    "%Ba": "",\n    "%bA": "",\n    "%BA": "",\n    "%bb": "",\n    "%Bb": "",\n    "%bB": "",\n    "%BB": "",\n    "%bc": "",\n    "%Bc": "",\n    "%bC": "",\n    "%BC": "",\n    "%bd": "",\n    "%Bd": "",\n    "%bD": "",\n    "%BD": "",\n    "%be": "",\n    "%Be": "",\n    "%bE": "",\n    "%BE": "",\n    "%bf": "",\n    "%Bf": "",\n    "%bF": "",\n    "%BF": "",\n    "%c0": "",\n    "%C0": "",\n    "%c1": "",\n    "%C1": "",\n    "%c2": "",\n    "%C2": "",\n    "%c3": "",\n    "%C3": "",\n    "%c4": "",\n    "%C4": "",\n    "%c5": "",\n    "%C5": "",\n    "%c6": "",\n    "%C6": "",\n    "%c7": "",\n    "%C7": "",\n    "%c8": "",\n    "%C8": "",\n    "%c9": "",\n    "%C9": "",\n    "%ca": "",\n    "%Ca": "",\n    "%cA": "",\n    "%CA": "",\n    "%cb": "",\n    "%Cb": "",\n    "%cB": "",\n    "%CB": "",\n    "%cc": "",\n    "%Cc": "",\n    "%cC": "",\n    "%CC": "",\n    "%cd": "",\n    "%Cd": "",\n    "%cD": "",\n    "%CD": "",\n    "%ce": "",\n    "%Ce": "",\n    "%cE": "",\n    "%CE": "",\n    "%cf": "",\n    "%Cf": "",\n    "%cF": "",\n    "%CF": "",\n    "%d0": "",\n    "%D0": "",\n    "%d1": "",\n    "%D1": "",\n    "%d2": "",\n    "%D2": "",\n    "%d3": "",\n    "%D3": "",\n    "%d4": "",\n    "%D4": "",\n    "%d5": "",\n    "%D5": "",\n    "%d6": "",\n    "%D6": "",\n    "%d7": "",\n    "%D7": "",\n    "%d8": "",\n    "%D8": "",\n    "%d9": "",\n    "%D9": "",\n    "%da": "",\n    "%Da": "",\n    "%dA": "",\n    "%DA": "",\n    "%db": "",\n    "%Db": "",\n    "%dB": "",\n    "%DB": "",\n    "%dc": "",\n    "%Dc": "",\n    "%dC": "",\n    "%DC": "",\n    "%dd": "",\n    "%Dd": "",\n    "%dD": "",\n    "%DD": "",\n    "%de": "",\n    "%De": "",\n    "%dE": "",\n    "%DE": "",\n    "%df": "",\n    "%Df": "",\n    "%dF": "",\n    "%DF": "",\n    "%e0": "",\n    "%E0": "",\n    "%e1": "",\n    "%E1": "",\n    "%e2": "",\n    "%E2": "",\n    "%e3": "",\n    "%E3": "",\n    "%e4": "",\n    "%E4": "",\n    "%e5": "",\n    "%E5": "",\n    "%e6": "",\n    "%E6": "",\n    "%e7": "",\n    "%E7": "",\n    "%e8": "",\n    "%E8": "",\n    "%e9": "",\n    "%E9": "",\n    "%ea": "",\n    "%Ea": "",\n    "%eA": "",\n    "%EA": "",\n    "%eb": "",\n    "%Eb": "",\n    "%eB": "",\n    "%EB": "",\n    "%ec": "",\n    "%Ec": "",\n    "%eC": "",\n    "%EC": "",\n    "%ed": "",\n    "%Ed": "",\n    "%eD": "",\n    "%ED": "",\n    "%ee": "",\n    "%Ee": "",\n    "%eE": "",\n    "%EE": "",\n    "%ef": "",\n    "%Ef": "",\n    "%eF": "",\n    "%EF": "",\n    "%f0": "",\n    "%F0": "",\n    "%f1": "",\n    "%F1": "",\n    "%f2": "",\n    "%F2": "",\n    "%f3": "",\n    "%F3": "",\n    "%f4": "",\n    "%F4": "",\n    "%f5": "",\n    "%F5": "",\n    "%f6": "",\n    "%F6": "",\n    "%f7": "",\n    "%F7": "",\n    "%f8": "",\n    "%F8": "",\n    "%f9": "",\n    "%F9": "",\n    "%fa": "",\n    "%Fa": "",\n    "%fA": "",\n    "%FA": "",\n    "%fb": "",\n    "%Fb": "",\n    "%fB": "",\n    "%FB": "",\n    "%fc": "",\n    "%Fc": "",\n    "%fC": "",\n    "%FC": "",\n    "%fd": "",\n    "%Fd": "",\n    "%fD": "",\n    "%FD": "",\n    "%fe": "",\n    "%Fe": "",\n    "%fE": "",\n    "%FE": "",\n    "%ff": "",\n    "%Ff": "",\n    "%fF": "",\n    "%FF": ""\n  };\n  function encodedReplacer(match) {\n    return EncodedLookup[match];\n  }\n  var STATE_KEY = 0;\n  var STATE_VALUE = 1;\n  var STATE_CHARSET = 2;\n  var STATE_LANG = 3;\n  function parseParams(str) {\n    const res = [];\n    let state = STATE_KEY;\n    let charset = "";\n    let inquote = false;\n    let escaping = false;\n    let p = 0;\n    let tmp = "";\n    const len = str.length;\n    for (var i2 = 0;i2 < len; ++i2) {\n      const char = str[i2];\n      if (char === "\\\\" && inquote) {\n        if (escaping) {\n          escaping = false;\n        } else {\n          escaping = true;\n          continue;\n        }\n      } else if (char === \'"\') {\n        if (!escaping) {\n          if (inquote) {\n            inquote = false;\n            state = STATE_KEY;\n            while (i2 + 1 < len && str[i2 + 1] !== ";") {\n              ++i2;\n            }\n          } else {\n            inquote = true;\n          }\n          continue;\n        } else {\n          escaping = false;\n        }\n      } else {\n        if (escaping && inquote) {\n          tmp += "\\\\";\n        }\n        escaping = false;\n        if ((state === STATE_CHARSET || state === STATE_LANG) && char === "\'") {\n          if (state === STATE_CHARSET) {\n            state = STATE_LANG;\n            charset = tmp.substring(1);\n          } else {\n            state = STATE_VALUE;\n          }\n          tmp = "";\n          continue;\n        } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {\n          state = char === "*" ? STATE_CHARSET : STATE_VALUE;\n          res[p] = [tmp, undefined];\n          tmp = "";\n          continue;\n        } else if (!inquote && char === ";") {\n          state = STATE_KEY;\n          if (charset) {\n            if (tmp.length) {\n              tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);\n            }\n            charset = "";\n          } else if (tmp.length) {\n            tmp = decodeText(tmp, "binary", "utf8");\n          }\n          if (res[p] === undefined) {\n            res[p] = tmp;\n          } else {\n            res[p][1] = tmp;\n          }\n          tmp = "";\n          ++p;\n          continue;\n        } else if (!inquote && (char === " " || char === "\\t")) {\n          continue;\n        }\n      }\n      tmp += char;\n    }\n    if (charset && tmp.length) {\n      tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);\n    } else if (tmp) {\n      tmp = decodeText(tmp, "binary", "utf8");\n    }\n    if (res[p] === undefined) {\n      if (tmp) {\n        res[p] = tmp;\n      }\n    } else {\n      res[p][1] = tmp;\n    }\n    return res;\n  }\n  module.exports = parseParams;\n});\n\n// ../../node_modules/@fastify/busboy/lib/utils/basename.js\nvar require_basename = __commonJS((exports, module) => {\n  module.exports = function basename(path) {\n    if (typeof path !== "string") {\n      return "";\n    }\n    for (var i2 = path.length - 1;i2 >= 0; --i2) {\n      switch (path.charCodeAt(i2)) {\n        case 47:\n        case 92:\n          path = path.slice(i2 + 1);\n          return path === ".." || path === "." ? "" : path;\n      }\n    }\n    return path === ".." || path === "." ? "" : path;\n  };\n});\n\n// ../../node_modules/@fastify/busboy/lib/types/multipart.js\nvar require_multipart = __commonJS((exports, module) => {\n  var { Readable } = __require("node:stream");\n  var { inherits } = __require("node:util");\n  var Dicer = require_Dicer();\n  var parseParams = require_parseParams();\n  var decodeText = require_decodeText();\n  var basename = require_basename();\n  var getLimit = require_getLimit();\n  var RE_BOUNDARY = /^boundary$/i;\n  var RE_FIELD = /^form-data$/i;\n  var RE_CHARSET = /^charset$/i;\n  var RE_FILENAME = /^filename$/i;\n  var RE_NAME = /^name$/i;\n  Multipart.detect = /^multipart\\/form-data/i;\n  function Multipart(boy, cfg) {\n    let i2;\n    let len;\n    const self2 = this;\n    let boundary;\n    const limits = cfg.limits;\n    const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== undefined);\n    const parsedConType = cfg.parsedConType || [];\n    const defCharset = cfg.defCharset || "utf8";\n    const preservePath = cfg.preservePath;\n    const fileOpts = { highWaterMark: cfg.fileHwm };\n    for (i2 = 0, len = parsedConType.length;i2 < len; ++i2) {\n      if (Array.isArray(parsedConType[i2]) && RE_BOUNDARY.test(parsedConType[i2][0])) {\n        boundary = parsedConType[i2][1];\n        break;\n      }\n    }\n    function checkFinished() {\n      if (nends === 0 && finished && !boy._done) {\n        finished = false;\n        self2.end();\n      }\n    }\n    if (typeof boundary !== "string") {\n      throw new Error("Multipart: Boundary not found");\n    }\n    const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);\n    const fileSizeLimit = getLimit(limits, "fileSize", Infinity);\n    const filesLimit = getLimit(limits, "files", Infinity);\n    const fieldsLimit = getLimit(limits, "fields", Infinity);\n    const partsLimit = getLimit(limits, "parts", Infinity);\n    const headerPairsLimit = getLimit(limits, "headerPairs", 2000);\n    const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);\n    let nfiles = 0;\n    let nfields = 0;\n    let nends = 0;\n    let curFile;\n    let curField;\n    let finished = false;\n    this._needDrain = false;\n    this._pause = false;\n    this._cb = undefined;\n    this._nparts = 0;\n    this._boy = boy;\n    const parserCfg = {\n      boundary,\n      maxHeaderPairs: headerPairsLimit,\n      maxHeaderSize: headerSizeLimit,\n      partHwm: fileOpts.highWaterMark,\n      highWaterMark: cfg.highWaterMark\n    };\n    this.parser = new Dicer(parserCfg);\n    this.parser.on("drain", function() {\n      self2._needDrain = false;\n      if (self2._cb && !self2._pause) {\n        const cb = self2._cb;\n        self2._cb = undefined;\n        cb();\n      }\n    }).on("part", function onPart(part) {\n      if (++self2._nparts > partsLimit) {\n        self2.parser.removeListener("part", onPart);\n        self2.parser.on("part", skipPart);\n        boy.hitPartsLimit = true;\n        boy.emit("partsLimit");\n        return skipPart(part);\n      }\n      if (curField) {\n        const field = curField;\n        field.emit("end");\n        field.removeAllListeners("end");\n      }\n      part.on("header", function(header) {\n        let contype;\n        let fieldname;\n        let parsed;\n        let charset;\n        let encoding;\n        let filename;\n        let nsize = 0;\n        if (header["content-type"]) {\n          parsed = parseParams(header["content-type"][0]);\n          if (parsed[0]) {\n            contype = parsed[0].toLowerCase();\n            for (i2 = 0, len = parsed.length;i2 < len; ++i2) {\n              if (RE_CHARSET.test(parsed[i2][0])) {\n                charset = parsed[i2][1].toLowerCase();\n                break;\n              }\n            }\n          }\n        }\n        if (contype === undefined) {\n          contype = "text/plain";\n        }\n        if (charset === undefined) {\n          charset = defCharset;\n        }\n        if (header["content-disposition"]) {\n          parsed = parseParams(header["content-disposition"][0]);\n          if (!RE_FIELD.test(parsed[0])) {\n            return skipPart(part);\n          }\n          for (i2 = 0, len = parsed.length;i2 < len; ++i2) {\n            if (RE_NAME.test(parsed[i2][0])) {\n              fieldname = parsed[i2][1];\n            } else if (RE_FILENAME.test(parsed[i2][0])) {\n              filename = parsed[i2][1];\n              if (!preservePath) {\n                filename = basename(filename);\n              }\n            }\n          }\n        } else {\n          return skipPart(part);\n        }\n        if (header["content-transfer-encoding"]) {\n          encoding = header["content-transfer-encoding"][0].toLowerCase();\n        } else {\n          encoding = "7bit";\n        }\n        let onData, onEnd;\n        if (isPartAFile(fieldname, contype, filename)) {\n          if (nfiles === filesLimit) {\n            if (!boy.hitFilesLimit) {\n              boy.hitFilesLimit = true;\n              boy.emit("filesLimit");\n            }\n            return skipPart(part);\n          }\n          ++nfiles;\n          if (boy.listenerCount("file") === 0) {\n            self2.parser._ignore();\n            return;\n          }\n          ++nends;\n          const file = new FileStream(fileOpts);\n          curFile = file;\n          file.on("end", function() {\n            --nends;\n            self2._pause = false;\n            checkFinished();\n            if (self2._cb && !self2._needDrain) {\n              const cb = self2._cb;\n              self2._cb = undefined;\n              cb();\n            }\n          });\n          file._read = function(n2) {\n            if (!self2._pause) {\n              return;\n            }\n            self2._pause = false;\n            if (self2._cb && !self2._needDrain) {\n              const cb = self2._cb;\n              self2._cb = undefined;\n              cb();\n            }\n          };\n          boy.emit("file", fieldname, file, filename, encoding, contype);\n          onData = function(data) {\n            if ((nsize += data.length) > fileSizeLimit) {\n              const extralen = fileSizeLimit - nsize + data.length;\n              if (extralen > 0) {\n                file.push(data.slice(0, extralen));\n              }\n              file.truncated = true;\n              file.bytesRead = fileSizeLimit;\n              part.removeAllListeners("data");\n              file.emit("limit");\n              return;\n            } else if (!file.push(data)) {\n              self2._pause = true;\n            }\n            file.bytesRead = nsize;\n          };\n          onEnd = function() {\n            curFile = undefined;\n            file.push(null);\n          };\n        } else {\n          if (nfields === fieldsLimit) {\n            if (!boy.hitFieldsLimit) {\n              boy.hitFieldsLimit = true;\n              boy.emit("fieldsLimit");\n            }\n            return skipPart(part);\n          }\n          ++nfields;\n          ++nends;\n          let buffer = "";\n          let truncated = false;\n          curField = part;\n          onData = function(data) {\n            if ((nsize += data.length) > fieldSizeLimit) {\n              const extralen = fieldSizeLimit - (nsize - data.length);\n              buffer += data.toString("binary", 0, extralen);\n              truncated = true;\n              part.removeAllListeners("data");\n            } else {\n              buffer += data.toString("binary");\n            }\n          };\n          onEnd = function() {\n            curField = undefined;\n            if (buffer.length) {\n              buffer = decodeText(buffer, "binary", charset);\n            }\n            boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);\n            --nends;\n            checkFinished();\n          };\n        }\n        part._readableState.sync = false;\n        part.on("data", onData);\n        part.on("end", onEnd);\n      }).on("error", function(err) {\n        if (curFile) {\n          curFile.emit("error", err);\n        }\n      });\n    }).on("error", function(err) {\n      boy.emit("error", err);\n    }).on("finish", function() {\n      finished = true;\n      checkFinished();\n    });\n  }\n  Multipart.prototype.write = function(chunk, cb) {\n    const r2 = this.parser.write(chunk);\n    if (r2 && !this._pause) {\n      cb();\n    } else {\n      this._needDrain = !r2;\n      this._cb = cb;\n    }\n  };\n  Multipart.prototype.end = function() {\n    const self2 = this;\n    if (self2.parser.writable) {\n      self2.parser.end();\n    } else if (!self2._boy._done) {\n      process.nextTick(function() {\n        self2._boy._done = true;\n        self2._boy.emit("finish");\n      });\n    }\n  };\n  function skipPart(part) {\n    part.resume();\n  }\n  function FileStream(opts) {\n    Readable.call(this, opts);\n    this.bytesRead = 0;\n    this.truncated = false;\n  }\n  inherits(FileStream, Readable);\n  FileStream.prototype._read = function(n2) {};\n  module.exports = Multipart;\n});\n\n// ../../node_modules/@fastify/busboy/lib/utils/Decoder.js\nvar require_Decoder = __commonJS((exports, module) => {\n  var RE_PLUS = /\\+/g;\n  var HEX = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  ];\n  function Decoder() {\n    this.buffer = undefined;\n  }\n  Decoder.prototype.write = function(str) {\n    str = str.replace(RE_PLUS, " ");\n    let res = "";\n    let i2 = 0;\n    let p = 0;\n    const len = str.length;\n    for (;i2 < len; ++i2) {\n      if (this.buffer !== undefined) {\n        if (!HEX[str.charCodeAt(i2)]) {\n          res += "%" + this.buffer;\n          this.buffer = undefined;\n          --i2;\n        } else {\n          this.buffer += str[i2];\n          ++p;\n          if (this.buffer.length === 2) {\n            res += String.fromCharCode(parseInt(this.buffer, 16));\n            this.buffer = undefined;\n          }\n        }\n      } else if (str[i2] === "%") {\n        if (i2 > p) {\n          res += str.substring(p, i2);\n          p = i2;\n        }\n        this.buffer = "";\n        ++p;\n      }\n    }\n    if (p < len && this.buffer === undefined) {\n      res += str.substring(p);\n    }\n    return res;\n  };\n  Decoder.prototype.reset = function() {\n    this.buffer = undefined;\n  };\n  module.exports = Decoder;\n});\n\n// ../../node_modules/@fastify/busboy/lib/types/urlencoded.js\nvar require_urlencoded = __commonJS((exports, module) => {\n  var Decoder = require_Decoder();\n  var decodeText = require_decodeText();\n  var getLimit = require_getLimit();\n  var RE_CHARSET = /^charset$/i;\n  UrlEncoded.detect = /^application\\/x-www-form-urlencoded/i;\n  function UrlEncoded(boy, cfg) {\n    const limits = cfg.limits;\n    const parsedConType = cfg.parsedConType;\n    this.boy = boy;\n    this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);\n    this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);\n    this.fieldsLimit = getLimit(limits, "fields", Infinity);\n    let charset;\n    for (var i2 = 0, len = parsedConType.length;i2 < len; ++i2) {\n      if (Array.isArray(parsedConType[i2]) && RE_CHARSET.test(parsedConType[i2][0])) {\n        charset = parsedConType[i2][1].toLowerCase();\n        break;\n      }\n    }\n    if (charset === undefined) {\n      charset = cfg.defCharset || "utf8";\n    }\n    this.decoder = new Decoder;\n    this.charset = charset;\n    this._fields = 0;\n    this._state = "key";\n    this._checkingBytes = true;\n    this._bytesKey = 0;\n    this._bytesVal = 0;\n    this._key = "";\n    this._val = "";\n    this._keyTrunc = false;\n    this._valTrunc = false;\n    this._hitLimit = false;\n  }\n  UrlEncoded.prototype.write = function(data, cb) {\n    if (this._fields === this.fieldsLimit) {\n      if (!this.boy.hitFieldsLimit) {\n        this.boy.hitFieldsLimit = true;\n        this.boy.emit("fieldsLimit");\n      }\n      return cb();\n    }\n    let idxeq;\n    let idxamp;\n    let i2;\n    let p = 0;\n    const len = data.length;\n    while (p < len) {\n      if (this._state === "key") {\n        idxeq = idxamp = undefined;\n        for (i2 = p;i2 < len; ++i2) {\n          if (!this._checkingBytes) {\n            ++p;\n          }\n          if (data[i2] === 61) {\n            idxeq = i2;\n            break;\n          } else if (data[i2] === 38) {\n            idxamp = i2;\n            break;\n          }\n          if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {\n            this._hitLimit = true;\n            break;\n          } else if (this._checkingBytes) {\n            ++this._bytesKey;\n          }\n        }\n        if (idxeq !== undefined) {\n          if (idxeq > p) {\n            this._key += this.decoder.write(data.toString("binary", p, idxeq));\n          }\n          this._state = "val";\n          this._hitLimit = false;\n          this._checkingBytes = true;\n          this._val = "";\n          this._bytesVal = 0;\n          this._valTrunc = false;\n          this.decoder.reset();\n          p = idxeq + 1;\n        } else if (idxamp !== undefined) {\n          ++this._fields;\n          let key;\n          const keyTrunc = this._keyTrunc;\n          if (idxamp > p) {\n            key = this._key += this.decoder.write(data.toString("binary", p, idxamp));\n          } else {\n            key = this._key;\n          }\n          this._hitLimit = false;\n          this._checkingBytes = true;\n          this._key = "";\n          this._bytesKey = 0;\n          this._keyTrunc = false;\n          this.decoder.reset();\n          if (key.length) {\n            this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, false);\n          }\n          p = idxamp + 1;\n          if (this._fields === this.fieldsLimit) {\n            return cb();\n          }\n        } else if (this._hitLimit) {\n          if (i2 > p) {\n            this._key += this.decoder.write(data.toString("binary", p, i2));\n          }\n          p = i2;\n          if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {\n            this._checkingBytes = false;\n            this._keyTrunc = true;\n          }\n        } else {\n          if (p < len) {\n            this._key += this.decoder.write(data.toString("binary", p));\n          }\n          p = len;\n        }\n      } else {\n        idxamp = undefined;\n        for (i2 = p;i2 < len; ++i2) {\n          if (!this._checkingBytes) {\n            ++p;\n          }\n          if (data[i2] === 38) {\n            idxamp = i2;\n            break;\n          }\n          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {\n            this._hitLimit = true;\n            break;\n          } else if (this._checkingBytes) {\n            ++this._bytesVal;\n          }\n        }\n        if (idxamp !== undefined) {\n          ++this._fields;\n          if (idxamp > p) {\n            this._val += this.decoder.write(data.toString("binary", p, idxamp));\n          }\n          this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);\n          this._state = "key";\n          this._hitLimit = false;\n          this._checkingBytes = true;\n          this._key = "";\n          this._bytesKey = 0;\n          this._keyTrunc = false;\n          this.decoder.reset();\n          p = idxamp + 1;\n          if (this._fields === this.fieldsLimit) {\n            return cb();\n          }\n        } else if (this._hitLimit) {\n          if (i2 > p) {\n            this._val += this.decoder.write(data.toString("binary", p, i2));\n          }\n          p = i2;\n          if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {\n            this._checkingBytes = false;\n            this._valTrunc = true;\n          }\n        } else {\n          if (p < len) {\n            this._val += this.decoder.write(data.toString("binary", p));\n          }\n          p = len;\n        }\n      }\n    }\n    cb();\n  };\n  UrlEncoded.prototype.end = function() {\n    if (this.boy._done) {\n      return;\n    }\n    if (this._state === "key" && this._key.length > 0) {\n      this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, false);\n    } else if (this._state === "val") {\n      this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);\n    }\n    this.boy._done = true;\n    this.boy.emit("finish");\n  };\n  module.exports = UrlEncoded;\n});\n\n// ../../node_modules/@fastify/busboy/lib/main.js\nvar require_main = __commonJS((exports, module) => {\n  var WritableStream2 = __require("node:stream").Writable;\n  var { inherits } = __require("node:util");\n  var Dicer = require_Dicer();\n  var MultipartParser = require_multipart();\n  var UrlencodedParser = require_urlencoded();\n  var parseParams = require_parseParams();\n  function Busboy(opts) {\n    if (!(this instanceof Busboy)) {\n      return new Busboy(opts);\n    }\n    if (typeof opts !== "object") {\n      throw new TypeError("Busboy expected an options-Object.");\n    }\n    if (typeof opts.headers !== "object") {\n      throw new TypeError("Busboy expected an options-Object with headers-attribute.");\n    }\n    if (typeof opts.headers["content-type"] !== "string") {\n      throw new TypeError("Missing Content-Type-header.");\n    }\n    const {\n      headers,\n      ...streamOptions\n    } = opts;\n    this.opts = {\n      autoDestroy: false,\n      ...streamOptions\n    };\n    WritableStream2.call(this, this.opts);\n    this._done = false;\n    this._parser = this.getParserByHeaders(headers);\n    this._finished = false;\n  }\n  inherits(Busboy, WritableStream2);\n  Busboy.prototype.emit = function(ev) {\n    if (ev === "finish") {\n      if (!this._done) {\n        this._parser?.end();\n        return;\n      } else if (this._finished) {\n        return;\n      }\n      this._finished = true;\n    }\n    WritableStream2.prototype.emit.apply(this, arguments);\n  };\n  Busboy.prototype.getParserByHeaders = function(headers) {\n    const parsed = parseParams(headers["content-type"]);\n    const cfg = {\n      defCharset: this.opts.defCharset,\n      fileHwm: this.opts.fileHwm,\n      headers,\n      highWaterMark: this.opts.highWaterMark,\n      isPartAFile: this.opts.isPartAFile,\n      limits: this.opts.limits,\n      parsedConType: parsed,\n      preservePath: this.opts.preservePath\n    };\n    if (MultipartParser.detect.test(parsed[0])) {\n      return new MultipartParser(this, cfg);\n    }\n    if (UrlencodedParser.detect.test(parsed[0])) {\n      return new UrlencodedParser(this, cfg);\n    }\n    throw new Error("Unsupported Content-Type.");\n  };\n  Busboy.prototype._write = function(chunk, encoding, cb) {\n    this._parser.write(chunk, cb);\n  };\n  module.exports = Busboy;\n  module.exports.default = Busboy;\n  module.exports.Busboy = Busboy;\n  module.exports.Dicer = Dicer;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/utils.js\nvar require_utils = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.fakePromise = undefined;\n  exports.getHeadersObj = getHeadersObj;\n  exports.defaultHeadersSerializer = defaultHeadersSerializer;\n  exports.isArrayBufferView = isArrayBufferView;\n  exports.isNodeReadable = isNodeReadable;\n  exports.isIterable = isIterable;\n  exports.shouldRedirect = shouldRedirect;\n  exports.pipeThrough = pipeThrough;\n  exports.endStream = endStream;\n  exports.safeWrite = safeWrite;\n  var node_events_1 = __require("node:events");\n  function isHeadersInstance(obj) {\n    return obj?.forEach != null;\n  }\n  function getHeadersObj(headers) {\n    if (headers == null || !isHeadersInstance(headers)) {\n      return headers;\n    }\n    if (headers.headersInit && !headers._map && !isHeadersInstance(headers.headersInit)) {\n      return headers.headersInit;\n    }\n    return Object.fromEntries(headers.entries());\n  }\n  function defaultHeadersSerializer(headers, onContentLength) {\n    const headerArray = [];\n    headers.forEach((value, key) => {\n      if (onContentLength && key === "content-length") {\n        onContentLength(value);\n      }\n      headerArray.push(`${key}: ${value}`);\n    });\n    return headerArray;\n  }\n  var promise_helpers_1 = require_cjs();\n  Object.defineProperty(exports, "fakePromise", { enumerable: true, get: function() {\n    return promise_helpers_1.fakePromise;\n  } });\n  function isArrayBufferView(obj) {\n    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;\n  }\n  function isNodeReadable(obj) {\n    return obj != null && obj.pipe != null;\n  }\n  function isIterable(value) {\n    return value?.[Symbol.iterator] != null;\n  }\n  function shouldRedirect(status) {\n    return status === 301 || status === 302 || status === 303 || status === 307 || status === 308;\n  }\n  function pipeThrough({ src, dest, signal, onError }) {\n    if (onError) {\n      dest.once("error", onError);\n    }\n    src.once("error", (e2) => {\n      dest.destroy(e2);\n    });\n    dest.once("close", () => {\n      if (!src.destroyed) {\n        src.destroy();\n      }\n    });\n    if (signal) {\n      let cleanup = function() {\n        signalRef.deref()?.removeEventListener("abort", onAbort);\n        srcRef.deref()?.removeListener("end", cleanup);\n        srcRef.deref()?.removeListener("error", cleanup);\n        srcRef.deref()?.removeListener("close", cleanup);\n      }, onAbort = function() {\n        srcRef.deref()?.destroy(new AbortError);\n        cleanup();\n      };\n      const srcRef = new WeakRef(src);\n      const signalRef = new WeakRef(signal);\n      signal.addEventListener("abort", onAbort, { once: true });\n      src.once("end", cleanup);\n      src.once("error", cleanup);\n      src.once("close", cleanup);\n    }\n    src.pipe(dest, { end: true });\n  }\n  function endStream(stream) {\n    return stream.end(null, null, null);\n  }\n  function safeWrite(chunk, stream) {\n    const result = stream.write(chunk);\n    if (!result) {\n      return (0, node_events_1.once)(stream, "drain");\n    }\n  }\n\n  class AbortError extends Error {\n    constructor(message = "The operation was aborted", options = undefined) {\n      super(message, options);\n      this.name = "AbortError";\n    }\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js\nvar require_ReadableStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillReadableStream = undefined;\n  var node_buffer_1 = __require("node:buffer");\n  var node_events_1 = __require("node:events");\n  var node_stream_1 = __require("node:stream");\n  var promises_1 = __require("node:stream/promises");\n  var promise_helpers_1 = require_cjs();\n  var utils_js_1 = require_utils();\n  function createController(desiredSize, readable) {\n    let chunks = [];\n    let _closed = false;\n    let flushed = false;\n    return {\n      desiredSize,\n      enqueue(chunk) {\n        const buf = typeof chunk === "string" ? node_buffer_1.Buffer.from(chunk) : chunk;\n        if (!flushed) {\n          chunks.push(buf);\n        } else {\n          readable.push(buf);\n        }\n      },\n      close() {\n        if (chunks.length > 0) {\n          this._flush();\n        }\n        readable.push(null);\n        _closed = true;\n      },\n      error(error) {\n        if (chunks.length > 0) {\n          this._flush();\n        }\n        readable.destroy(error);\n      },\n      get _closed() {\n        return _closed;\n      },\n      _flush() {\n        flushed = true;\n        if (chunks.length > 0) {\n          const concatenated = chunks.length > 1 ? node_buffer_1.Buffer.concat(chunks) : chunks[0];\n          readable.push(concatenated);\n          chunks = [];\n        }\n      }\n    };\n  }\n  function isNodeReadable(obj) {\n    return obj?.read != null;\n  }\n  function isReadableStream(obj) {\n    return obj?.getReader != null;\n  }\n\n  class PonyfillReadableStream {\n    readable;\n    constructor(underlyingSource) {\n      if (underlyingSource instanceof PonyfillReadableStream && underlyingSource.readable != null) {\n        this.readable = underlyingSource.readable;\n      } else if (isNodeReadable(underlyingSource)) {\n        this.readable = underlyingSource;\n      } else if (isReadableStream(underlyingSource)) {\n        this.readable = node_stream_1.Readable.fromWeb(underlyingSource);\n      } else {\n        let started = false;\n        let ongoing = false;\n        const handleStart = (desiredSize) => {\n          if (!started) {\n            const controller = createController(desiredSize, this.readable);\n            started = true;\n            return (0, promise_helpers_1.handleMaybePromise)(() => underlyingSource?.start?.(controller), () => {\n              controller._flush();\n              if (controller._closed) {\n                return false;\n              }\n              return true;\n            });\n          }\n          return true;\n        };\n        const readImpl = (desiredSize) => {\n          return (0, promise_helpers_1.handleMaybePromise)(() => handleStart(desiredSize), (shouldContinue) => {\n            if (!shouldContinue) {\n              return;\n            }\n            const controller = createController(desiredSize, this.readable);\n            return (0, promise_helpers_1.handleMaybePromise)(() => underlyingSource?.pull?.(controller), () => {\n              controller._flush();\n              ongoing = false;\n            });\n          });\n        };\n        this.readable = new node_stream_1.Readable({\n          read(desiredSize) {\n            if (ongoing) {\n              return;\n            }\n            ongoing = true;\n            return readImpl(desiredSize);\n          },\n          destroy(err, callback) {\n            if (underlyingSource?.cancel) {\n              try {\n                const res$ = underlyingSource.cancel(err);\n                if (res$?.then) {\n                  return res$.then(() => {\n                    callback(null);\n                  }, (err2) => {\n                    callback(err2);\n                  });\n                }\n              } catch (err2) {\n                callback(err2);\n                return;\n              }\n            }\n            callback(null);\n          }\n        });\n      }\n    }\n    cancel(reason) {\n      this.readable.destroy(reason);\n      return (0, node_events_1.once)(this.readable, "close");\n    }\n    locked = false;\n    getReader(_options) {\n      const iterator = this.readable[Symbol.asyncIterator]();\n      this.locked = true;\n      const thisReadable = this.readable;\n      return {\n        read() {\n          return iterator.next();\n        },\n        releaseLock: () => {\n          if (iterator.return) {\n            const retResult$ = iterator.return();\n            if (retResult$.then) {\n              retResult$.then(() => {\n                this.locked = false;\n              });\n              return;\n            }\n          }\n          this.locked = false;\n        },\n        cancel: (reason) => {\n          if (iterator.return) {\n            const retResult$ = iterator.return(reason);\n            if (retResult$.then) {\n              return retResult$.then(() => {\n                this.locked = false;\n              });\n            }\n          }\n          this.locked = false;\n          return (0, utils_js_1.fakePromise)();\n        },\n        get closed() {\n          return Promise.race([\n            (0, node_events_1.once)(thisReadable, "end"),\n            (0, node_events_1.once)(thisReadable, "error").then((err) => Promise.reject(err))\n          ]);\n        }\n      };\n    }\n    [Symbol.asyncIterator]() {\n      const iterator = this.readable[Symbol.asyncIterator]();\n      return {\n        [Symbol.asyncIterator]() {\n          return this;\n        },\n        next: () => iterator.next(),\n        return: () => {\n          if (!this.readable.destroyed) {\n            this.readable.destroy();\n          }\n          return iterator.return?.() || (0, utils_js_1.fakePromise)({ done: true, value: undefined });\n        },\n        throw: (err) => {\n          if (!this.readable.destroyed) {\n            this.readable.destroy(err);\n          }\n          return iterator.throw?.(err) || (0, utils_js_1.fakePromise)({ done: true, value: undefined });\n        }\n      };\n    }\n    tee() {\n      throw new Error("Not implemented");\n    }\n    async pipeToWriter(writer) {\n      try {\n        for await (const chunk of this) {\n          await writer.write(chunk);\n        }\n        await writer.close();\n      } catch (err) {\n        await writer.abort(err);\n      }\n    }\n    pipeTo(destination) {\n      if (isPonyfillWritableStream(destination)) {\n        return (0, promises_1.pipeline)(this.readable, destination.writable, {\n          end: true\n        });\n      } else {\n        const writer = destination.getWriter();\n        return this.pipeToWriter(writer);\n      }\n    }\n    pipeThrough({ writable, readable }) {\n      this.pipeTo(writable).catch((err) => {\n        this.readable.destroy(err);\n      });\n      if (isPonyfillReadableStream(readable)) {\n        readable.readable.once("error", (err) => this.readable.destroy(err));\n        readable.readable.once("finish", () => this.readable.push(null));\n        readable.readable.once("close", () => this.readable.push(null));\n      }\n      return readable;\n    }\n    static [Symbol.hasInstance](instance) {\n      return isReadableStream(instance);\n    }\n    static from(iterable) {\n      return new PonyfillReadableStream(node_stream_1.Readable.from(iterable));\n    }\n    [Symbol.toStringTag] = "ReadableStream";\n  }\n  exports.PonyfillReadableStream = PonyfillReadableStream;\n  function isPonyfillReadableStream(obj) {\n    return obj?.readable != null;\n  }\n  function isPonyfillWritableStream(obj) {\n    return obj?.writable != null;\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/Blob.js\nvar require_Blob = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillBlob = undefined;\n  exports.hasBufferMethod = hasBufferMethod;\n  exports.hasArrayBufferMethod = hasArrayBufferMethod;\n  exports.hasBytesMethod = hasBytesMethod;\n  exports.hasTextMethod = hasTextMethod;\n  exports.hasSizeProperty = hasSizeProperty;\n  exports.hasStreamMethod = hasStreamMethod;\n  exports.hasBlobSignature = hasBlobSignature;\n  exports.isArrayBuffer = isArrayBuffer;\n  var node_buffer_1 = __require("node:buffer");\n  var ReadableStream_js_1 = require_ReadableStream();\n  var utils_js_1 = require_utils();\n  function getBlobPartAsBuffer(blobPart) {\n    if (typeof blobPart === "string") {\n      return node_buffer_1.Buffer.from(blobPart);\n    } else if (node_buffer_1.Buffer.isBuffer(blobPart)) {\n      return blobPart;\n    } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {\n      return node_buffer_1.Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);\n    } else {\n      return node_buffer_1.Buffer.from(blobPart);\n    }\n  }\n  function hasBufferMethod(obj) {\n    return obj != null && obj.buffer != null && typeof obj.buffer === "function";\n  }\n  function hasArrayBufferMethod(obj) {\n    return obj != null && obj.arrayBuffer != null && typeof obj.arrayBuffer === "function";\n  }\n  function hasBytesMethod(obj) {\n    return obj != null && obj.bytes != null && typeof obj.bytes === "function";\n  }\n  function hasTextMethod(obj) {\n    return obj != null && obj.text != null && typeof obj.text === "function";\n  }\n  function hasSizeProperty(obj) {\n    return obj != null && typeof obj.size === "number";\n  }\n  function hasStreamMethod(obj) {\n    return obj != null && obj.stream != null && typeof obj.stream === "function";\n  }\n  function hasBlobSignature(obj) {\n    return obj != null && obj[Symbol.toStringTag] === "Blob";\n  }\n  function isArrayBuffer(obj) {\n    return obj != null && obj.byteLength != null && obj.slice != null;\n  }\n\n  class PonyfillBlob {\n    blobParts;\n    type;\n    encoding;\n    _size = null;\n    constructor(blobParts = [], options) {\n      this.blobParts = blobParts;\n      this.type = options?.type || "application/octet-stream";\n      this.encoding = options?.encoding || "utf8";\n      this._size = options?.size || null;\n      if (blobParts.length === 1 && hasBlobSignature(blobParts[0])) {\n        return blobParts[0];\n      }\n    }\n    _buffer = null;\n    buffer() {\n      if (this._buffer) {\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      if (this.blobParts.length === 1) {\n        const blobPart = this.blobParts[0];\n        if (hasBufferMethod(blobPart)) {\n          return blobPart.buffer().then((buf) => {\n            this._buffer = buf;\n            return this._buffer;\n          });\n        }\n        if (hasBytesMethod(blobPart)) {\n          return blobPart.bytes().then((bytes) => {\n            this._buffer = node_buffer_1.Buffer.from(bytes);\n            return this._buffer;\n          });\n        }\n        if (hasArrayBufferMethod(blobPart)) {\n          return blobPart.arrayBuffer().then((arrayBuf) => {\n            this._buffer = node_buffer_1.Buffer.from(arrayBuf, undefined, blobPart.size);\n            return this._buffer;\n          });\n        }\n        this._buffer = getBlobPartAsBuffer(blobPart);\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      const jobs = [];\n      const bufferChunks = this.blobParts.map((blobPart, i2) => {\n        if (hasBufferMethod(blobPart)) {\n          jobs.push(blobPart.buffer().then((buf) => {\n            bufferChunks[i2] = buf;\n          }));\n          return;\n        } else if (hasArrayBufferMethod(blobPart)) {\n          jobs.push(blobPart.arrayBuffer().then((arrayBuf) => {\n            bufferChunks[i2] = node_buffer_1.Buffer.from(arrayBuf, undefined, blobPart.size);\n          }));\n          return;\n        } else if (hasBytesMethod(blobPart)) {\n          jobs.push(blobPart.bytes().then((bytes) => {\n            bufferChunks[i2] = node_buffer_1.Buffer.from(bytes);\n          }));\n          return;\n        } else {\n          return getBlobPartAsBuffer(blobPart);\n        }\n      });\n      if (jobs.length > 0) {\n        return Promise.all(jobs).then(() => node_buffer_1.Buffer.concat(bufferChunks, this._size || undefined));\n      }\n      return (0, utils_js_1.fakePromise)(node_buffer_1.Buffer.concat(bufferChunks, this._size || undefined));\n    }\n    arrayBuffer() {\n      if (this._buffer) {\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      if (this.blobParts.length === 1) {\n        if (isArrayBuffer(this.blobParts[0])) {\n          return (0, utils_js_1.fakePromise)(this.blobParts[0]);\n        }\n        if (hasArrayBufferMethod(this.blobParts[0])) {\n          return this.blobParts[0].arrayBuffer();\n        }\n      }\n      return this.buffer();\n    }\n    bytes() {\n      if (this._buffer) {\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      if (this.blobParts.length === 1) {\n        if (node_buffer_1.Buffer.isBuffer(this.blobParts[0])) {\n          this._buffer = this.blobParts[0];\n          return (0, utils_js_1.fakePromise)(this._buffer);\n        }\n        if (this.blobParts[0] instanceof Uint8Array) {\n          this._buffer = node_buffer_1.Buffer.from(this.blobParts[0]);\n          return (0, utils_js_1.fakePromise)(this._buffer);\n        }\n        if (hasBytesMethod(this.blobParts[0])) {\n          return this.blobParts[0].bytes();\n        }\n        if (hasBufferMethod(this.blobParts[0])) {\n          return this.blobParts[0].buffer();\n        }\n      }\n      return this.buffer();\n    }\n    _text = null;\n    text() {\n      if (this._text) {\n        return (0, utils_js_1.fakePromise)(this._text);\n      }\n      if (this.blobParts.length === 1) {\n        const blobPart = this.blobParts[0];\n        if (typeof blobPart === "string") {\n          this._text = blobPart;\n          return (0, utils_js_1.fakePromise)(this._text);\n        }\n        if (hasTextMethod(blobPart)) {\n          return blobPart.text().then((text) => {\n            this._text = text;\n            return this._text;\n          });\n        }\n        const buf = getBlobPartAsBuffer(blobPart);\n        this._text = buf.toString(this.encoding);\n        return (0, utils_js_1.fakePromise)(this._text);\n      }\n      return this.buffer().then((buf) => {\n        this._text = buf.toString(this.encoding);\n        return this._text;\n      });\n    }\n    _json = null;\n    json() {\n      if (this._json) {\n        return (0, utils_js_1.fakePromise)(this._json);\n      }\n      return this.text().then((text) => {\n        this._json = JSON.parse(text);\n        return this._json;\n      });\n    }\n    _formData = null;\n    formData() {\n      if (this._formData) {\n        return (0, utils_js_1.fakePromise)(this._formData);\n      }\n      throw new Error("Not implemented");\n    }\n    get size() {\n      if (this._size == null) {\n        this._size = 0;\n        for (const blobPart of this.blobParts) {\n          if (typeof blobPart === "string") {\n            this._size += node_buffer_1.Buffer.byteLength(blobPart);\n          } else if (hasSizeProperty(blobPart)) {\n            this._size += blobPart.size;\n          } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {\n            this._size += blobPart.byteLength;\n          }\n        }\n      }\n      return this._size;\n    }\n    stream() {\n      if (this.blobParts.length === 1) {\n        const blobPart = this.blobParts[0];\n        if (hasStreamMethod(blobPart)) {\n          return blobPart.stream();\n        }\n        const buf = getBlobPartAsBuffer(blobPart);\n        return new ReadableStream_js_1.PonyfillReadableStream({\n          start: (controller) => {\n            controller.enqueue(buf);\n            controller.close();\n          }\n        });\n      }\n      if (this._buffer != null) {\n        return new ReadableStream_js_1.PonyfillReadableStream({\n          start: (controller) => {\n            controller.enqueue(this._buffer);\n            controller.close();\n          }\n        });\n      }\n      let blobPartIterator;\n      return new ReadableStream_js_1.PonyfillReadableStream({\n        start: (controller) => {\n          if (this.blobParts.length === 0) {\n            controller.close();\n            return;\n          }\n          blobPartIterator = this.blobParts[Symbol.iterator]();\n        },\n        pull: (controller) => {\n          const { value: blobPart, done } = blobPartIterator.next();\n          if (done) {\n            controller.close();\n            return;\n          }\n          if (blobPart) {\n            if (hasBufferMethod(blobPart)) {\n              return blobPart.buffer().then((buf2) => {\n                controller.enqueue(buf2);\n              });\n            }\n            if (hasBytesMethod(blobPart)) {\n              return blobPart.bytes().then((bytes) => {\n                const buf2 = node_buffer_1.Buffer.from(bytes);\n                controller.enqueue(buf2);\n              });\n            }\n            if (hasArrayBufferMethod(blobPart)) {\n              return blobPart.arrayBuffer().then((arrayBuffer) => {\n                const buf2 = node_buffer_1.Buffer.from(arrayBuffer, undefined, blobPart.size);\n                controller.enqueue(buf2);\n              });\n            }\n            const buf = getBlobPartAsBuffer(blobPart);\n            controller.enqueue(buf);\n          }\n        }\n      });\n    }\n    slice() {\n      throw new Error("Not implemented");\n    }\n  }\n  exports.PonyfillBlob = PonyfillBlob;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/File.js\nvar require_File = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillFile = undefined;\n  var Blob_js_1 = require_Blob();\n\n  class PonyfillFile extends Blob_js_1.PonyfillBlob {\n    name;\n    lastModified;\n    constructor(fileBits, name, options) {\n      super(fileBits, options);\n      this.name = name;\n      this.lastModified = options?.lastModified || Date.now();\n    }\n    webkitRelativePath = "";\n  }\n  exports.PonyfillFile = PonyfillFile;\n});\n\n// ../../node_modules/tslib/tslib.js\nvar require_tslib = __commonJS((exports, module) => {\n  var __extends;\n  var __assign;\n  var __rest;\n  var __decorate;\n  var __param;\n  var __esDecorate;\n  var __runInitializers;\n  var __propKey;\n  var __setFunctionName;\n  var __metadata;\n  var __awaiter;\n  var __generator;\n  var __exportStar;\n  var __values;\n  var __read;\n  var __spread;\n  var __spreadArrays;\n  var __spreadArray;\n  var __await;\n  var __asyncGenerator;\n  var __asyncDelegator;\n  var __asyncValues;\n  var __makeTemplateObject;\n  var __importStar;\n  var __importDefault;\n  var __classPrivateFieldGet;\n  var __classPrivateFieldSet;\n  var __classPrivateFieldIn;\n  var __createBinding;\n  var __addDisposableResource;\n  var __disposeResources;\n  var __rewriteRelativeImportExtension;\n  (function(factory) {\n    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};\n    if (typeof define === "function" && define.amd) {\n      define("tslib", ["exports"], function(exports2) {\n        factory(createExporter(root, createExporter(exports2)));\n      });\n    } else if (typeof module === "object" && typeof exports === "object") {\n      factory(createExporter(root, createExporter(exports)));\n    } else {\n      factory(createExporter(root));\n    }\n    function createExporter(exports2, previous) {\n      if (exports2 !== root) {\n        if (typeof Object.create === "function") {\n          Object.defineProperty(exports2, "__esModule", { value: true });\n        } else {\n          exports2.__esModule = true;\n        }\n      }\n      return function(id, v) {\n        return exports2[id] = previous ? previous(id, v) : v;\n      };\n    }\n  })(function(exporter) {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {\n      d.__proto__ = b;\n    } || function(d, b) {\n      for (var p in b)\n        if (Object.prototype.hasOwnProperty.call(b, p))\n          d[p] = b[p];\n    };\n    __extends = function(d, b) {\n      if (typeof b !== "function" && b !== null)\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n      extendStatics(d, b);\n      function __() {\n        this.constructor = d;\n      }\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);\n    };\n    __assign = Object.assign || function(t2) {\n      for (var s, i2 = 1, n2 = arguments.length;i2 < n2; i2++) {\n        s = arguments[i2];\n        for (var p in s)\n          if (Object.prototype.hasOwnProperty.call(s, p))\n            t2[p] = s[p];\n      }\n      return t2;\n    };\n    __rest = function(s, e2) {\n      var t2 = {};\n      for (var p in s)\n        if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)\n          t2[p] = s[p];\n      if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i2 = 0, p = Object.getOwnPropertySymbols(s);i2 < p.length; i2++) {\n          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))\n            t2[p[i2]] = s[p[i2]];\n        }\n      return t2;\n    };\n    __decorate = function(decorators, target, key, desc) {\n      var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")\n        r2 = Reflect.decorate(decorators, target, key, desc);\n      else\n        for (var i2 = decorators.length - 1;i2 >= 0; i2--)\n          if (d = decorators[i2])\n            r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;\n      return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;\n    };\n    __param = function(paramIndex, decorator) {\n      return function(target, key) {\n        decorator(target, key, paramIndex);\n      };\n    };\n    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n      function accept(f) {\n        if (f !== undefined && typeof f !== "function")\n          throw new TypeError("Function expected");\n        return f;\n      }\n      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";\n      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;\n      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n      var _, done = false;\n      for (var i2 = decorators.length - 1;i2 >= 0; i2--) {\n        var context = {};\n        for (var p in contextIn)\n          context[p] = p === "access" ? {} : contextIn[p];\n        for (var p in contextIn.access)\n          context.access[p] = contextIn.access[p];\n        context.addInitializer = function(f) {\n          if (done)\n            throw new TypeError("Cannot add initializers after decoration has completed");\n          extraInitializers.push(accept(f || null));\n        };\n        var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === "accessor") {\n          if (result === undefined)\n            continue;\n          if (result === null || typeof result !== "object")\n            throw new TypeError("Object expected");\n          if (_ = accept(result.get))\n            descriptor.get = _;\n          if (_ = accept(result.set))\n            descriptor.set = _;\n          if (_ = accept(result.init))\n            initializers.unshift(_);\n        } else if (_ = accept(result)) {\n          if (kind === "field")\n            initializers.unshift(_);\n          else\n            descriptor[key] = _;\n        }\n      }\n      if (target)\n        Object.defineProperty(target, contextIn.name, descriptor);\n      done = true;\n    };\n    __runInitializers = function(thisArg, initializers, value) {\n      var useValue = arguments.length > 2;\n      for (var i2 = 0;i2 < initializers.length; i2++) {\n        value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);\n      }\n      return useValue ? value : undefined;\n    };\n    __propKey = function(x) {\n      return typeof x === "symbol" ? x : "".concat(x);\n    };\n    __setFunctionName = function(f, name, prefix) {\n      if (typeof name === "symbol")\n        name = name.description ? "[".concat(name.description, "]") : "";\n      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });\n    };\n    __metadata = function(metadataKey, metadataValue) {\n      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")\n        return Reflect.metadata(metadataKey, metadataValue);\n    };\n    __awaiter = function(thisArg, _arguments, P, generator) {\n      function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n          resolve(value);\n        });\n      }\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e2) {\n            reject(e2);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator["throw"](value));\n          } catch (e2) {\n            reject(e2);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    __generator = function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t2[0] & 1)\n          throw t2[1];\n        return t2[1];\n      }, trys: [], ops: [] }, f, y, t2, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);\n      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n2) {\n        return function(v) {\n          return step([n2, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError("Generator is already executing.");\n        while (g && (g = 0, op[0] && (_ = 0)), _)\n          try {\n            if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)\n              return t2;\n            if (y = 0, t2)\n              op = [op[0] & 2, t2.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t2 = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t2[1]) {\n                  _.label = t2[1];\n                  t2 = op;\n                  break;\n                }\n                if (t2 && _.label < t2[2]) {\n                  _.label = t2[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t2[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e2) {\n            op = [6, e2];\n            y = 0;\n          } finally {\n            f = t2 = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : undefined, done: true };\n      }\n    };\n    __exportStar = function(m, o) {\n      for (var p in m)\n        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))\n          __createBinding(o, m, p);\n    };\n    __createBinding = Object.create ? function(o, m, k, k2) {\n      if (k2 === undefined)\n        k2 = k;\n      var desc = Object.getOwnPropertyDescriptor(m, k);\n      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function() {\n          return m[k];\n        } };\n      }\n      Object.defineProperty(o, k2, desc);\n    } : function(o, m, k, k2) {\n      if (k2 === undefined)\n        k2 = k;\n      o[k2] = m[k];\n    };\n    __values = function(o) {\n      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;\n      if (m)\n        return m.call(o);\n      if (o && typeof o.length === "number")\n        return {\n          next: function() {\n            if (o && i2 >= o.length)\n              o = undefined;\n            return { value: o && o[i2++], done: !o };\n          }\n        };\n      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n    };\n    __read = function(o, n2) {\n      var m = typeof Symbol === "function" && o[Symbol.iterator];\n      if (!m)\n        return o;\n      var i2 = m.call(o), r2, ar = [], e2;\n      try {\n        while ((n2 === undefined || n2-- > 0) && !(r2 = i2.next()).done)\n          ar.push(r2.value);\n      } catch (error) {\n        e2 = { error };\n      } finally {\n        try {\n          if (r2 && !r2.done && (m = i2["return"]))\n            m.call(i2);\n        } finally {\n          if (e2)\n            throw e2.error;\n        }\n      }\n      return ar;\n    };\n    __spread = function() {\n      for (var ar = [], i2 = 0;i2 < arguments.length; i2++)\n        ar = ar.concat(__read(arguments[i2]));\n      return ar;\n    };\n    __spreadArrays = function() {\n      for (var s = 0, i2 = 0, il = arguments.length;i2 < il; i2++)\n        s += arguments[i2].length;\n      for (var r2 = Array(s), k = 0, i2 = 0;i2 < il; i2++)\n        for (var a2 = arguments[i2], j = 0, jl = a2.length;j < jl; j++, k++)\n          r2[k] = a2[j];\n      return r2;\n    };\n    __spreadArray = function(to, from, pack) {\n      if (pack || arguments.length === 2)\n        for (var i2 = 0, l = from.length, ar;i2 < l; i2++) {\n          if (ar || !(i2 in from)) {\n            if (!ar)\n              ar = Array.prototype.slice.call(from, 0, i2);\n            ar[i2] = from[i2];\n          }\n        }\n      return to.concat(ar || Array.prototype.slice.call(from));\n    };\n    __await = function(v) {\n      return this instanceof __await ? (this.v = v, this) : new __await(v);\n    };\n    __asyncGenerator = function(thisArg, _arguments, generator) {\n      if (!Symbol.asyncIterator)\n        throw new TypeError("Symbol.asyncIterator is not defined.");\n      var g = generator.apply(thisArg, _arguments || []), i2, q = [];\n      return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {\n        return this;\n      }, i2;\n      function awaitReturn(f) {\n        return function(v) {\n          return Promise.resolve(v).then(f, reject);\n        };\n      }\n      function verb(n2, f) {\n        if (g[n2]) {\n          i2[n2] = function(v) {\n            return new Promise(function(a2, b) {\n              q.push([n2, v, a2, b]) > 1 || resume(n2, v);\n            });\n          };\n          if (f)\n            i2[n2] = f(i2[n2]);\n        }\n      }\n      function resume(n2, v) {\n        try {\n          step(g[n2](v));\n        } catch (e2) {\n          settle(q[0][3], e2);\n        }\n      }\n      function step(r2) {\n        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);\n      }\n      function fulfill(value) {\n        resume("next", value);\n      }\n      function reject(value) {\n        resume("throw", value);\n      }\n      function settle(f, v) {\n        if (f(v), q.shift(), q.length)\n          resume(q[0][0], q[0][1]);\n      }\n    };\n    __asyncDelegator = function(o) {\n      var i2, p;\n      return i2 = {}, verb("next"), verb("throw", function(e2) {\n        throw e2;\n      }), verb("return"), i2[Symbol.iterator] = function() {\n        return this;\n      }, i2;\n      function verb(n2, f) {\n        i2[n2] = o[n2] ? function(v) {\n          return (p = !p) ? { value: __await(o[n2](v)), done: false } : f ? f(v) : v;\n        } : f;\n      }\n    };\n    __asyncValues = function(o) {\n      if (!Symbol.asyncIterator)\n        throw new TypeError("Symbol.asyncIterator is not defined.");\n      var m = o[Symbol.asyncIterator], i2;\n      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {\n        return this;\n      }, i2);\n      function verb(n2) {\n        i2[n2] = o[n2] && function(v) {\n          return new Promise(function(resolve, reject) {\n            v = o[n2](v), settle(resolve, reject, v.done, v.value);\n          });\n        };\n      }\n      function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v2) {\n          resolve({ value: v2, done: d });\n        }, reject);\n      }\n    };\n    __makeTemplateObject = function(cooked, raw) {\n      if (Object.defineProperty) {\n        Object.defineProperty(cooked, "raw", { value: raw });\n      } else {\n        cooked.raw = raw;\n      }\n      return cooked;\n    };\n    var __setModuleDefault = Object.create ? function(o, v) {\n      Object.defineProperty(o, "default", { enumerable: true, value: v });\n    } : function(o, v) {\n      o["default"] = v;\n    };\n    var ownKeys = function(o) {\n      ownKeys = Object.getOwnPropertyNames || function(o2) {\n        var ar = [];\n        for (var k in o2)\n          if (Object.prototype.hasOwnProperty.call(o2, k))\n            ar[ar.length] = k;\n        return ar;\n      };\n      return ownKeys(o);\n    };\n    __importStar = function(mod) {\n      if (mod && mod.__esModule)\n        return mod;\n      var result = {};\n      if (mod != null) {\n        for (var k = ownKeys(mod), i2 = 0;i2 < k.length; i2++)\n          if (k[i2] !== "default")\n            __createBinding(result, mod, k[i2]);\n      }\n      __setModuleDefault(result, mod);\n      return result;\n    };\n    __importDefault = function(mod) {\n      return mod && mod.__esModule ? mod : { default: mod };\n    };\n    __classPrivateFieldGet = function(receiver, state, kind, f) {\n      if (kind === "a" && !f)\n        throw new TypeError("Private accessor was defined without a getter");\n      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))\n        throw new TypeError("Cannot read private member from an object whose class did not declare it");\n      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\n    };\n    __classPrivateFieldSet = function(receiver, state, value, kind, f) {\n      if (kind === "m")\n        throw new TypeError("Private method is not writable");\n      if (kind === "a" && !f)\n        throw new TypeError("Private accessor was defined without a setter");\n      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))\n        throw new TypeError("Cannot write private member to an object whose class did not declare it");\n      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n    };\n    __classPrivateFieldIn = function(state, receiver) {\n      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")\n        throw new TypeError("Cannot use \'in\' operator on non-object");\n      return typeof state === "function" ? receiver === state : state.has(receiver);\n    };\n    __addDisposableResource = function(env, value, async) {\n      if (value !== null && value !== undefined) {\n        if (typeof value !== "object" && typeof value !== "function")\n          throw new TypeError("Object expected.");\n        var dispose, inner;\n        if (async) {\n          if (!Symbol.asyncDispose)\n            throw new TypeError("Symbol.asyncDispose is not defined.");\n          dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === undefined) {\n          if (!Symbol.dispose)\n            throw new TypeError("Symbol.dispose is not defined.");\n          dispose = value[Symbol.dispose];\n          if (async)\n            inner = dispose;\n        }\n        if (typeof dispose !== "function")\n          throw new TypeError("Object not disposable.");\n        if (inner)\n          dispose = function() {\n            try {\n              inner.call(this);\n            } catch (e2) {\n              return Promise.reject(e2);\n            }\n          };\n        env.stack.push({ value, dispose, async });\n      } else if (async) {\n        env.stack.push({ async: true });\n      }\n      return value;\n    };\n    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {\n      var e2 = new Error(message);\n      return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;\n    };\n    __disposeResources = function(env) {\n      function fail(e2) {\n        env.error = env.hasError ? new _SuppressedError(e2, env.error, "An error was suppressed during disposal.") : e2;\n        env.hasError = true;\n      }\n      var r2, s = 0;\n      function next() {\n        while (r2 = env.stack.pop()) {\n          try {\n            if (!r2.async && s === 1)\n              return s = 0, env.stack.push(r2), Promise.resolve().then(next);\n            if (r2.dispose) {\n              var result = r2.dispose.call(r2.value);\n              if (r2.async)\n                return s |= 2, Promise.resolve(result).then(next, function(e2) {\n                  fail(e2);\n                  return next();\n                });\n            } else\n              s |= 1;\n          } catch (e2) {\n            fail(e2);\n          }\n        }\n        if (s === 1)\n          return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n        if (env.hasError)\n          throw env.error;\n      }\n      return next();\n    };\n    __rewriteRelativeImportExtension = function(path, preserveJsx) {\n      if (typeof path === "string" && /^\\.\\.?\\//.test(path)) {\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";\n        });\n      }\n      return path;\n    };\n    exporter("__extends", __extends);\n    exporter("__assign", __assign);\n    exporter("__rest", __rest);\n    exporter("__decorate", __decorate);\n    exporter("__param", __param);\n    exporter("__esDecorate", __esDecorate);\n    exporter("__runInitializers", __runInitializers);\n    exporter("__propKey", __propKey);\n    exporter("__setFunctionName", __setFunctionName);\n    exporter("__metadata", __metadata);\n    exporter("__awaiter", __awaiter);\n    exporter("__generator", __generator);\n    exporter("__exportStar", __exportStar);\n    exporter("__createBinding", __createBinding);\n    exporter("__values", __values);\n    exporter("__read", __read);\n    exporter("__spread", __spread);\n    exporter("__spreadArrays", __spreadArrays);\n    exporter("__spreadArray", __spreadArray);\n    exporter("__await", __await);\n    exporter("__asyncGenerator", __asyncGenerator);\n    exporter("__asyncDelegator", __asyncDelegator);\n    exporter("__asyncValues", __asyncValues);\n    exporter("__makeTemplateObject", __makeTemplateObject);\n    exporter("__importStar", __importStar);\n    exporter("__importDefault", __importDefault);\n    exporter("__classPrivateFieldGet", __classPrivateFieldGet);\n    exporter("__classPrivateFieldSet", __classPrivateFieldSet);\n    exporter("__classPrivateFieldIn", __classPrivateFieldIn);\n    exporter("__addDisposableResource", __addDisposableResource);\n    exporter("__disposeResources", __disposeResources);\n    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);\n  });\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/SupressedError.js\nvar require_SupressedError = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillSuppressedError = undefined;\n\n  class PonyfillSuppressedError2 extends Error {\n    error;\n    suppressed;\n    constructor(error, suppressed, message) {\n      super(message);\n      this.error = error;\n      this.suppressed = suppressed;\n      this.name = "SuppressedError";\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n  exports.PonyfillSuppressedError = PonyfillSuppressedError2;\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/symbols.js\nvar require_symbols = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.DisposableSymbols = undefined;\n  exports.patchSymbols = patchSymbols;\n  exports.DisposableSymbols = {\n    get dispose() {\n      return Symbol.dispose || Symbol.for("dispose");\n    },\n    get asyncDispose() {\n      return Symbol.asyncDispose || Symbol.for("asyncDispose");\n    }\n  };\n  function patchSymbols() {\n    Symbol.dispose ||= Symbol.for("dispose");\n    Symbol.asyncDispose ||= Symbol.for("asyncDispose");\n  }\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/utils.js\nvar require_utils2 = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.isSyncDisposable = isSyncDisposable2;\n  exports.isAsyncDisposable = isAsyncDisposable2;\n  var symbols_js_1 = require_symbols();\n  function isSyncDisposable2(obj) {\n    return obj?.[symbols_js_1.DisposableSymbols.dispose] != null;\n  }\n  function isAsyncDisposable2(obj) {\n    return obj?.[symbols_js_1.DisposableSymbols.asyncDispose] != null;\n  }\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/AsyncDisposableStack.js\nvar require_AsyncDisposableStack = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillAsyncDisposableStack = undefined;\n  var promise_helpers_1 = require_cjs();\n  var SupressedError_js_1 = require_SupressedError();\n  var symbols_js_1 = require_symbols();\n  var utils_js_1 = require_utils2();\n  var SuppressedError5 = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;\n\n  class PonyfillAsyncDisposableStack2 {\n    callbacks = [];\n    get disposed() {\n      return this.callbacks.length === 0;\n    }\n    use(value) {\n      if ((0, utils_js_1.isAsyncDisposable)(value)) {\n        this.callbacks.push(() => value[symbols_js_1.DisposableSymbols.asyncDispose]());\n      } else if ((0, utils_js_1.isSyncDisposable)(value)) {\n        this.callbacks.push(() => value[symbols_js_1.DisposableSymbols.dispose]());\n      }\n      return value;\n    }\n    adopt(value, onDisposeAsync) {\n      if (onDisposeAsync) {\n        this.callbacks.push(() => onDisposeAsync(value));\n      }\n      return value;\n    }\n    defer(onDisposeAsync) {\n      if (onDisposeAsync) {\n        this.callbacks.push(onDisposeAsync);\n      }\n    }\n    move() {\n      const stack = new PonyfillAsyncDisposableStack2;\n      stack.callbacks = this.callbacks;\n      this.callbacks = [];\n      return stack;\n    }\n    disposeAsync() {\n      return this[symbols_js_1.DisposableSymbols.asyncDispose]();\n    }\n    _error;\n    _iterateCallbacks() {\n      const cb = this.callbacks.pop();\n      if (cb) {\n        return (0, promise_helpers_1.handleMaybePromise)(cb, () => this._iterateCallbacks(), (error) => {\n          this._error = this._error ? new SuppressedError5(error, this._error) : error;\n          return this._iterateCallbacks();\n        });\n      }\n    }\n    [symbols_js_1.DisposableSymbols.asyncDispose]() {\n      const res$ = this._iterateCallbacks();\n      if (res$?.then) {\n        return res$.then(() => {\n          if (this._error) {\n            const error = this._error;\n            this._error = undefined;\n            throw error;\n          }\n        });\n      }\n      if (this._error) {\n        const error = this._error;\n        this._error = undefined;\n        throw error;\n      }\n      return;\n    }\n    [Symbol.toStringTag] = "AsyncDisposableStack";\n  }\n  exports.PonyfillAsyncDisposableStack = PonyfillAsyncDisposableStack2;\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/DisposableStack.js\nvar require_DisposableStack = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillDisposableStack = undefined;\n  var SupressedError_js_1 = require_SupressedError();\n  var symbols_js_1 = require_symbols();\n  var utils_js_1 = require_utils2();\n  var SuppressedError5 = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;\n\n  class PonyfillDisposableStack2 {\n    callbacks = [];\n    get disposed() {\n      return this.callbacks.length === 0;\n    }\n    use(value) {\n      if ((0, utils_js_1.isSyncDisposable)(value)) {\n        this.callbacks.push(() => value[symbols_js_1.DisposableSymbols.dispose]());\n      }\n      return value;\n    }\n    adopt(value, onDispose) {\n      if (onDispose) {\n        this.callbacks.push(() => onDispose(value));\n      }\n      return value;\n    }\n    defer(onDispose) {\n      if (onDispose) {\n        this.callbacks.push(onDispose);\n      }\n    }\n    move() {\n      const stack = new PonyfillDisposableStack2;\n      stack.callbacks = this.callbacks;\n      this.callbacks = [];\n      return stack;\n    }\n    dispose() {\n      return this[symbols_js_1.DisposableSymbols.dispose]();\n    }\n    _error;\n    _iterateCallbacks() {\n      const cb = this.callbacks.pop();\n      if (cb) {\n        try {\n          cb();\n        } catch (error) {\n          this._error = this._error ? new SuppressedError5(error, this._error) : error;\n        }\n        return this._iterateCallbacks();\n      }\n    }\n    [symbols_js_1.DisposableSymbols.dispose]() {\n      this._iterateCallbacks();\n      if (this._error) {\n        const error = this._error;\n        this._error = undefined;\n        throw error;\n      }\n    }\n    [Symbol.toStringTag] = "DisposableStack";\n  }\n  exports.PonyfillDisposableStack = PonyfillDisposableStack2;\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/cjs/index.js\nvar require_cjs2 = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.SuppressedError = exports.AsyncDisposableStack = exports.DisposableStack = undefined;\n  var tslib_1 = require_tslib();\n  var AsyncDisposableStack_js_1 = require_AsyncDisposableStack();\n  var DisposableStack_js_1 = require_DisposableStack();\n  var SupressedError_js_1 = require_SupressedError();\n  exports.DisposableStack = globalThis.DisposableStack || DisposableStack_js_1.PonyfillDisposableStack;\n  exports.AsyncDisposableStack = globalThis.AsyncDisposableStack || AsyncDisposableStack_js_1.PonyfillAsyncDisposableStack;\n  exports.SuppressedError = globalThis.SuppressedError || SupressedError_js_1.PonyfillSuppressedError;\n  tslib_1.__exportStar(require_symbols(), exports);\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/IteratorObject.js\nvar require_IteratorObject = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillIteratorObject = undefined;\n  var node_util_1 = __require("node:util");\n  var disposablestack_1 = require_cjs2();\n  var utils_js_1 = require_utils();\n\n  class PonyfillIteratorObject {\n    iterableIterator;\n    [Symbol.toStringTag] = "IteratorObject";\n    constructor(iterableIterator, className) {\n      this.iterableIterator = iterableIterator;\n      this[Symbol.toStringTag] = className;\n    }\n    *map(callbackfn) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        yield callbackfn(value, index++);\n      }\n      return;\n    }\n    *filter(callbackfn) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (callbackfn(value, index++)) {\n          yield value;\n        }\n      }\n      return;\n    }\n    reduce(callbackfn, initialValue) {\n      let index = 0;\n      let accumulator = initialValue;\n      for (const value of this.iterableIterator) {\n        accumulator = callbackfn(accumulator, value, index++);\n      }\n      return accumulator;\n    }\n    forEach(callbackfn) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        callbackfn(value, index++);\n      }\n    }\n    *take(limit) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (index >= limit) {\n          break;\n        }\n        yield value;\n        index++;\n      }\n      return;\n    }\n    *drop(count) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (index >= count) {\n          yield value;\n        }\n        index++;\n      }\n      return;\n    }\n    *flatMap(callback) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        const iteratorOrIterable = callback(value, index++);\n        if ((0, utils_js_1.isIterable)(iteratorOrIterable)) {\n          for (const innerValue of iteratorOrIterable) {\n            yield innerValue;\n          }\n        } else {\n          for (const innerValue of {\n            [Symbol.iterator]: () => iteratorOrIterable\n          }) {\n            yield innerValue;\n          }\n        }\n      }\n      return;\n    }\n    some(predicate) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (predicate(value, index++)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    every(predicate) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (!predicate(value, index++)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    find(predicate) {\n      let index = 0;\n      for (const value of this.iterableIterator) {\n        if (predicate(value, index++)) {\n          return value;\n        }\n      }\n      return;\n    }\n    toArray() {\n      return Array.from(this.iterableIterator);\n    }\n    [disposablestack_1.DisposableSymbols.dispose]() {\n      this.iterableIterator.return?.();\n    }\n    next(...[value]) {\n      return this.iterableIterator.next(value);\n    }\n    [Symbol.iterator]() {\n      return this;\n    }\n    [Symbol.for("nodejs.util.inspect.custom")]() {\n      const record = {};\n      this.forEach((value, key) => {\n        const inspectedValue = (0, node_util_1.inspect)(value);\n        record[key] = inspectedValue.includes(",") ? inspectedValue.split(",").map((el) => el.trim()) : inspectedValue;\n      });\n      return `${this[Symbol.toStringTag]} ${(0, node_util_1.inspect)(record)}`;\n    }\n  }\n  exports.PonyfillIteratorObject = PonyfillIteratorObject;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/FormData.js\nvar require_FormData = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillFormData = undefined;\n  exports.getStreamFromFormData = getStreamFromFormData;\n  var node_buffer_1 = __require("node:buffer");\n  var IteratorObject_js_1 = require_IteratorObject();\n  var ReadableStream_js_1 = require_ReadableStream();\n\n  class PonyfillFormData {\n    map = new Map;\n    append(name, value, fileName) {\n      let values = this.map.get(name);\n      if (!values) {\n        values = [];\n        this.map.set(name, values);\n      }\n      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;\n      values.push(entry);\n    }\n    delete(name) {\n      this.map.delete(name);\n    }\n    get(name) {\n      const values = this.map.get(name);\n      return values ? values[0] : null;\n    }\n    getAll(name) {\n      return this.map.get(name) || [];\n    }\n    has(name) {\n      return this.map.has(name);\n    }\n    set(name, value, fileName) {\n      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;\n      this.map.set(name, [entry]);\n    }\n    [Symbol.iterator]() {\n      return this._entries();\n    }\n    *_entries() {\n      for (const [key, values] of this.map) {\n        for (const value of values) {\n          yield [key, value];\n        }\n      }\n    }\n    entries() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._entries(), "FormDataIterator");\n    }\n    _keys() {\n      return this.map.keys();\n    }\n    keys() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._keys(), "FormDataIterator");\n    }\n    *_values() {\n      for (const values of this.map.values()) {\n        for (const value of values) {\n          yield value;\n        }\n      }\n    }\n    values() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._values(), "FormDataIterator");\n    }\n    forEach(callback) {\n      for (const [key, value] of this) {\n        callback(value, key, this);\n      }\n    }\n  }\n  exports.PonyfillFormData = PonyfillFormData;\n  function getStreamFromFormData(formData, boundary = "---") {\n    let entriesIterator;\n    let sentInitialHeader = false;\n    let currentAsyncIterator;\n    let hasBefore = false;\n    function handleNextEntry(controller) {\n      const { done, value } = entriesIterator.next();\n      if (done) {\n        controller.enqueue(node_buffer_1.Buffer.from(`\\r\n--${boundary}--\\r\n`));\n        return controller.close();\n      }\n      if (hasBefore) {\n        controller.enqueue(node_buffer_1.Buffer.from(`\\r\n--${boundary}\\r\n`));\n      }\n      if (value) {\n        const [key, blobOrString] = value;\n        if (typeof blobOrString === "string") {\n          controller.enqueue(node_buffer_1.Buffer.from(`Content-Disposition: form-data; name="${key}"\\r\n\\r\n`));\n          controller.enqueue(node_buffer_1.Buffer.from(blobOrString));\n        } else {\n          let filenamePart = "";\n          if (blobOrString.name) {\n            filenamePart = `; filename="${blobOrString.name}"`;\n          }\n          controller.enqueue(node_buffer_1.Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\\r\n`));\n          controller.enqueue(node_buffer_1.Buffer.from(`Content-Type: ${blobOrString.type || "application/octet-stream"}\\r\n\\r\n`));\n          const entryStream = blobOrString.stream();\n          currentAsyncIterator = entryStream[Symbol.asyncIterator]();\n        }\n        hasBefore = true;\n      }\n    }\n    return new ReadableStream_js_1.PonyfillReadableStream({\n      start: () => {\n        entriesIterator = formData.entries();\n      },\n      pull: (controller) => {\n        if (!sentInitialHeader) {\n          sentInitialHeader = true;\n          return controller.enqueue(node_buffer_1.Buffer.from(`--${boundary}\\r\n`));\n        }\n        if (currentAsyncIterator) {\n          return currentAsyncIterator.next().then(({ done, value }) => {\n            if (done) {\n              currentAsyncIterator = undefined;\n            }\n            if (value) {\n              return controller.enqueue(value);\n            } else {\n              return handleNextEntry(controller);\n            }\n          });\n        }\n        return handleNextEntry(controller);\n      },\n      cancel: (err) => {\n        entriesIterator?.return?.(err);\n        currentAsyncIterator?.return?.(err);\n      }\n    });\n  }\n  function getNormalizedFile(name, blob, fileName) {\n    Object.defineProperty(blob, "name", {\n      configurable: true,\n      enumerable: true,\n      value: fileName || blob.name || name\n    });\n    return blob;\n  }\n  function isBlob(value) {\n    return value?.arrayBuffer != null;\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/Body.js\nvar require_Body = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillBody = undefined;\n  var node_buffer_1 = __require("node:buffer");\n  var node_stream_1 = __require("node:stream");\n  var busboy_1 = require_main();\n  var promise_helpers_1 = require_cjs();\n  var Blob_js_1 = require_Blob();\n  var File_js_1 = require_File();\n  var FormData_js_1 = require_FormData();\n  var ReadableStream_js_1 = require_ReadableStream();\n  var utils_js_1 = require_utils();\n  var BodyInitType;\n  (function(BodyInitType2) {\n    BodyInitType2["ReadableStream"] = "ReadableStream";\n    BodyInitType2["Blob"] = "Blob";\n    BodyInitType2["FormData"] = "FormData";\n    BodyInitType2["String"] = "String";\n    BodyInitType2["Readable"] = "Readable";\n    BodyInitType2["Buffer"] = "Buffer";\n    BodyInitType2["AsyncIterable"] = "AsyncIterable";\n  })(BodyInitType || (BodyInitType = {}));\n\n  class PonyfillBody {\n    bodyInit;\n    options;\n    bodyUsed = false;\n    contentType = null;\n    contentLength = null;\n    constructor(bodyInit, options = {}) {\n      this.bodyInit = bodyInit;\n      this.options = options;\n      const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit);\n      this._bodyFactory = bodyFactory;\n      this.contentType = contentType;\n      this.contentLength = contentLength;\n      this.bodyType = bodyType;\n      this._buffer = buffer;\n      this._signal = options.signal;\n    }\n    bodyType;\n    _bodyFactory = () => null;\n    _generatedBody = null;\n    _buffer;\n    _signal;\n    generateBody() {\n      if (this._generatedBody?.readable?.destroyed && this._buffer) {\n        this._generatedBody.readable = node_stream_1.Readable.from(this._buffer);\n      }\n      if (this._generatedBody) {\n        return this._generatedBody;\n      }\n      const body = this._bodyFactory();\n      this._generatedBody = body;\n      return body;\n    }\n    handleContentLengthHeader(forceSet = false) {\n      const contentTypeInHeaders = this.headers.get("content-type");\n      if (!contentTypeInHeaders) {\n        if (this.contentType) {\n          this.headers.set("content-type", this.contentType);\n        }\n      } else {\n        this.contentType = contentTypeInHeaders;\n      }\n      const contentLengthInHeaders = this.headers.get("content-length");\n      if (forceSet && this.bodyInit == null && !contentLengthInHeaders) {\n        this.contentLength = 0;\n        this.headers.set("content-length", "0");\n      }\n      if (!contentLengthInHeaders) {\n        if (this.contentLength) {\n          this.headers.set("content-length", this.contentLength.toString());\n        }\n      } else {\n        this.contentLength = parseInt(contentLengthInHeaders, 10);\n      }\n    }\n    get body() {\n      const _body = this.generateBody();\n      if (_body != null) {\n        const ponyfillReadableStream = _body;\n        const readable = _body.readable;\n        return new Proxy(_body.readable, {\n          get(_, prop) {\n            if (prop in ponyfillReadableStream) {\n              const ponyfillReadableStreamProp = ponyfillReadableStream[prop];\n              if (typeof ponyfillReadableStreamProp === "function") {\n                return ponyfillReadableStreamProp.bind(ponyfillReadableStream);\n              }\n              return ponyfillReadableStreamProp;\n            }\n            if (prop in readable) {\n              const readableProp = readable[prop];\n              if (typeof readableProp === "function") {\n                return readableProp.bind(readable);\n              }\n              return readableProp;\n            }\n          }\n        });\n      }\n      return null;\n    }\n    _chunks = null;\n    _doCollectChunksFromReadableJob() {\n      if (this.bodyType === BodyInitType.AsyncIterable) {\n        if (Array.fromAsync) {\n          return (0, promise_helpers_1.handleMaybePromise)(() => Array.fromAsync(this.bodyInit), (chunks3) => {\n            this._chunks = chunks3;\n            return this._chunks;\n          });\n        }\n        const iterator = this.bodyInit[Symbol.asyncIterator]();\n        const chunks2 = [];\n        const collectValue = () => (0, promise_helpers_1.handleMaybePromise)(() => iterator.next(), ({ value, done }) => {\n          if (value) {\n            chunks2.push(value);\n          }\n          if (!done) {\n            return collectValue();\n          }\n          this._chunks = chunks2;\n          return this._chunks;\n        });\n        return collectValue();\n      }\n      const _body = this.generateBody();\n      if (!_body) {\n        this._chunks = [];\n        return (0, utils_js_1.fakePromise)(this._chunks);\n      }\n      if (_body.readable.destroyed) {\n        return (0, utils_js_1.fakePromise)(this._chunks = []);\n      }\n      const chunks = [];\n      return new Promise((resolve, reject) => {\n        _body.readable.on("data", (chunk) => {\n          chunks.push(chunk);\n        });\n        _body.readable.once("error", reject);\n        _body.readable.once("end", () => {\n          resolve(this._chunks = chunks);\n        });\n      });\n    }\n    _collectChunksFromReadable() {\n      if (this._chunks) {\n        return (0, utils_js_1.fakePromise)(this._chunks);\n      }\n      this._chunks ||= this._doCollectChunksFromReadableJob();\n      return this._chunks;\n    }\n    _blob = null;\n    blob() {\n      if (this._blob) {\n        return (0, utils_js_1.fakePromise)(this._blob);\n      }\n      if (this.bodyType === BodyInitType.String) {\n        this._text = this.bodyInit;\n        this._blob = new Blob_js_1.PonyfillBlob([this._text], {\n          type: this.contentType || "text/plain;charset=UTF-8",\n          size: this.contentLength\n        });\n      }\n      if (this.bodyType === BodyInitType.Blob) {\n        this._blob = this.bodyInit;\n        return (0, utils_js_1.fakePromise)(this._blob);\n      }\n      if (this._buffer) {\n        this._blob = new Blob_js_1.PonyfillBlob([this._buffer], {\n          type: this.contentType || "",\n          size: this.contentLength\n        });\n        return (0, utils_js_1.fakePromise)(this._blob);\n      }\n      return (0, utils_js_1.fakePromise)((0, promise_helpers_1.handleMaybePromise)(() => this._collectChunksFromReadable(), (chunks) => {\n        this._blob = new Blob_js_1.PonyfillBlob(chunks, {\n          type: this.contentType || "",\n          size: this.contentLength\n        });\n        return this._blob;\n      }));\n    }\n    _formData = null;\n    formData(opts) {\n      if (this._formData) {\n        return (0, utils_js_1.fakePromise)(this._formData);\n      }\n      if (this.bodyType === BodyInitType.FormData) {\n        this._formData = this.bodyInit;\n        return (0, utils_js_1.fakePromise)(this._formData);\n      }\n      this._formData = new FormData_js_1.PonyfillFormData;\n      const _body = this.generateBody();\n      if (_body == null) {\n        return (0, utils_js_1.fakePromise)(this._formData);\n      }\n      const formDataLimits = {\n        ...this.options.formDataLimits,\n        ...opts?.formDataLimits\n      };\n      return new Promise((resolve, reject) => {\n        const stream = this.body?.readable;\n        if (!stream) {\n          return reject(new Error("No stream available"));\n        }\n        let currFile = null;\n        const bb = new busboy_1.Busboy({\n          headers: {\n            "content-length": typeof this.contentLength === "number" ? this.contentLength.toString() : this.contentLength || "",\n            "content-type": this.contentType || ""\n          },\n          limits: formDataLimits,\n          defCharset: "utf-8"\n        });\n        if (this._signal) {\n          (0, node_stream_1.addAbortSignal)(this._signal, bb);\n        }\n        let completed = false;\n        const complete = (err) => {\n          if (completed)\n            return;\n          completed = true;\n          stream.unpipe(bb);\n          bb.destroy();\n          if (currFile) {\n            currFile.destroy();\n            currFile = null;\n          }\n          if (err) {\n            reject(err);\n          } else {\n            resolve(this._formData);\n          }\n        };\n        stream.on("error", complete);\n        bb.on("field", (name, value, fieldnameTruncated, valueTruncated) => {\n          if (fieldnameTruncated) {\n            return complete(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));\n          }\n          if (valueTruncated) {\n            return complete(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));\n          }\n          this._formData.set(name, value);\n        });\n        bb.on("file", (name, fileStream, filename, _transferEncoding, mimeType) => {\n          currFile = fileStream;\n          const chunks = [];\n          fileStream.on("data", (chunk) => {\n            chunks.push(chunk);\n          });\n          fileStream.on("error", complete);\n          fileStream.on("limit", () => {\n            complete(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));\n          });\n          fileStream.on("close", () => {\n            if (fileStream.truncated) {\n              complete(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));\n            }\n            currFile = null;\n            const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });\n            this._formData.set(name, file);\n          });\n        });\n        bb.on("fieldsLimit", () => {\n          complete(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));\n        });\n        bb.on("filesLimit", () => {\n          complete(new Error(`Files limit exceeded: ${formDataLimits?.files}`));\n        });\n        bb.on("partsLimit", () => {\n          complete(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));\n        });\n        bb.on("end", complete);\n        bb.on("finish", complete);\n        bb.on("close", complete);\n        bb.on("error", complete);\n        stream.pipe(bb);\n      });\n    }\n    buffer() {\n      if (this._buffer) {\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      if (this._text) {\n        this._buffer = node_buffer_1.Buffer.from(this._text, "utf-8");\n        return (0, utils_js_1.fakePromise)(this._buffer);\n      }\n      if (this.bodyType === BodyInitType.String) {\n        return this.text().then((text) => {\n          this._text = text;\n          this._buffer = node_buffer_1.Buffer.from(text, "utf-8");\n          return this._buffer;\n        });\n      }\n      if (this.bodyType === BodyInitType.Blob) {\n        if ((0, Blob_js_1.hasBufferMethod)(this.bodyInit)) {\n          return this.bodyInit.buffer().then((buf) => {\n            this._buffer = buf;\n            return this._buffer;\n          });\n        }\n        if ((0, Blob_js_1.hasBytesMethod)(this.bodyInit)) {\n          return this.bodyInit.bytes().then((bytes) => {\n            this._buffer = node_buffer_1.Buffer.from(bytes);\n            return this._buffer;\n          });\n        }\n        if ((0, Blob_js_1.hasArrayBufferMethod)(this.bodyInit)) {\n          return this.bodyInit.arrayBuffer().then((buf) => {\n            this._buffer = node_buffer_1.Buffer.from(buf, undefined, buf.byteLength);\n            return this._buffer;\n          });\n        }\n      }\n      return (0, utils_js_1.fakePromise)((0, promise_helpers_1.handleMaybePromise)(() => this._collectChunksFromReadable(), (chunks) => {\n        if (chunks.length === 1) {\n          this._buffer = chunks[0];\n          return this._buffer;\n        }\n        this._buffer = node_buffer_1.Buffer.concat(chunks);\n        return this._buffer;\n      }));\n    }\n    bytes() {\n      return this.buffer();\n    }\n    arrayBuffer() {\n      return this.buffer();\n    }\n    _json = null;\n    json() {\n      if (this._json) {\n        return (0, utils_js_1.fakePromise)(this._json);\n      }\n      return this.text().then((text) => {\n        try {\n          this._json = JSON.parse(text);\n        } catch (e2) {\n          if (e2 instanceof SyntaxError) {\n            e2.message += `, "${text}" is not valid JSON`;\n          }\n          throw e2;\n        }\n        return this._json;\n      });\n    }\n    _text = null;\n    text() {\n      if (this._text) {\n        return (0, utils_js_1.fakePromise)(this._text);\n      }\n      if (this.bodyType === BodyInitType.String) {\n        this._text = this.bodyInit;\n        return (0, utils_js_1.fakePromise)(this._text);\n      }\n      return this.buffer().then((buffer) => {\n        this._text = buffer.toString("utf-8");\n        return this._text;\n      });\n    }\n  }\n  exports.PonyfillBody = PonyfillBody;\n  function processBodyInit(bodyInit) {\n    if (bodyInit == null) {\n      return {\n        bodyFactory: () => null,\n        contentType: null,\n        contentLength: null\n      };\n    }\n    if (typeof bodyInit === "string") {\n      const contentLength = node_buffer_1.Buffer.byteLength(bodyInit);\n      return {\n        bodyType: BodyInitType.String,\n        contentType: "text/plain;charset=UTF-8",\n        contentLength,\n        bodyFactory() {\n          const readable = node_stream_1.Readable.from(node_buffer_1.Buffer.from(bodyInit, "utf-8"));\n          return new ReadableStream_js_1.PonyfillReadableStream(readable);\n        }\n      };\n    }\n    if (node_buffer_1.Buffer.isBuffer(bodyInit)) {\n      const buffer = bodyInit;\n      return {\n        bodyType: BodyInitType.Buffer,\n        contentType: null,\n        contentLength: bodyInit.length,\n        buffer: bodyInit,\n        bodyFactory() {\n          const readable = node_stream_1.Readable.from(buffer);\n          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);\n          return body;\n        }\n      };\n    }\n    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {\n      const buffer = node_buffer_1.Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);\n      return {\n        bodyType: BodyInitType.Buffer,\n        contentLength: bodyInit.byteLength,\n        contentType: null,\n        buffer,\n        bodyFactory() {\n          const readable = node_stream_1.Readable.from(buffer);\n          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);\n          return body;\n        }\n      };\n    }\n    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream && bodyInit.readable != null) {\n      const readableStream = bodyInit;\n      return {\n        bodyType: BodyInitType.ReadableStream,\n        bodyFactory: () => readableStream,\n        contentType: null,\n        contentLength: null\n      };\n    }\n    if (isBlob(bodyInit)) {\n      const blob = bodyInit;\n      return {\n        bodyType: BodyInitType.Blob,\n        contentType: bodyInit.type,\n        contentLength: bodyInit.size,\n        bodyFactory() {\n          return blob.stream();\n        }\n      };\n    }\n    if (bodyInit instanceof ArrayBuffer) {\n      const contentLength = bodyInit.byteLength;\n      const buffer = node_buffer_1.Buffer.from(bodyInit, undefined, bodyInit.byteLength);\n      return {\n        bodyType: BodyInitType.Buffer,\n        contentType: null,\n        contentLength,\n        buffer,\n        bodyFactory() {\n          const readable = node_stream_1.Readable.from(buffer);\n          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);\n          return body;\n        }\n      };\n    }\n    if (bodyInit instanceof node_stream_1.Readable) {\n      return {\n        bodyType: BodyInitType.Readable,\n        contentType: null,\n        contentLength: null,\n        bodyFactory() {\n          const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);\n          return body;\n        }\n      };\n    }\n    if (isURLSearchParams(bodyInit)) {\n      const contentType = "application/x-www-form-urlencoded;charset=UTF-8";\n      return {\n        bodyType: BodyInitType.String,\n        contentType,\n        contentLength: null,\n        bodyFactory() {\n          const body = new ReadableStream_js_1.PonyfillReadableStream(node_stream_1.Readable.from(bodyInit.toString()));\n          return body;\n        }\n      };\n    }\n    if (isFormData(bodyInit)) {\n      const boundary = Math.random().toString(36).substr(2);\n      const contentType = `multipart/form-data; boundary=${boundary}`;\n      return {\n        bodyType: BodyInitType.FormData,\n        contentType,\n        contentLength: null,\n        bodyFactory() {\n          return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);\n        }\n      };\n    }\n    if (isReadableStream(bodyInit)) {\n      return {\n        contentType: null,\n        contentLength: null,\n        bodyFactory() {\n          return new ReadableStream_js_1.PonyfillReadableStream(bodyInit);\n        }\n      };\n    }\n    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {\n      return {\n        contentType: null,\n        contentLength: null,\n        bodyType: BodyInitType.AsyncIterable,\n        bodyFactory() {\n          const readable = node_stream_1.Readable.from(bodyInit);\n          return new ReadableStream_js_1.PonyfillReadableStream(readable);\n        }\n      };\n    }\n    throw new Error("Unknown body type");\n  }\n  function isFormData(value) {\n    return value?.forEach != null;\n  }\n  function isBlob(value) {\n    return value?.stream != null && typeof value.stream === "function";\n  }\n  function isURLSearchParams(value) {\n    return value?.sort != null;\n  }\n  function isReadableStream(value) {\n    return value?.getReader != null;\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/Headers.js\nvar require_Headers = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillHeaders = undefined;\n  exports.isHeadersLike = isHeadersLike;\n  var node_util_1 = __require("node:util");\n  var IteratorObject_js_1 = require_IteratorObject();\n  function isHeadersLike(headers) {\n    return headers?.get && headers?.forEach;\n  }\n\n  class PonyfillHeaders {\n    headersInit;\n    _map;\n    objectNormalizedKeysOfHeadersInit = [];\n    objectOriginalKeysOfHeadersInit = [];\n    _setCookies;\n    constructor(headersInit) {\n      this.headersInit = headersInit;\n    }\n    _get(key) {\n      const normalized = key.toLowerCase();\n      if (normalized === "set-cookie" && this._setCookies?.length) {\n        return this._setCookies.join(", ");\n      }\n      if (this._map) {\n        return this._map.get(normalized) || null;\n      }\n      if (this.headersInit == null) {\n        return null;\n      }\n      if (Array.isArray(this.headersInit)) {\n        const found = this.headersInit.filter(([headerKey]) => headerKey.toLowerCase() === normalized);\n        if (found.length === 0) {\n          return null;\n        }\n        if (found.length === 1) {\n          return found[0][1];\n        }\n        return found.map(([, value]) => value).join(", ");\n      } else if (isHeadersLike(this.headersInit)) {\n        return this.headersInit.get(normalized);\n      } else {\n        const initValue = this.headersInit[key] || this.headersInit[normalized];\n        if (initValue != null) {\n          return initValue;\n        }\n        if (!this.objectNormalizedKeysOfHeadersInit.length) {\n          Object.keys(this.headersInit).forEach((k) => {\n            this.objectOriginalKeysOfHeadersInit.push(k);\n            this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());\n          });\n        }\n        const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);\n        if (index === -1) {\n          return null;\n        }\n        const originalKey = this.objectOriginalKeysOfHeadersInit[index];\n        return this.headersInit[originalKey];\n      }\n    }\n    getMap() {\n      if (!this._map) {\n        this._setCookies ||= [];\n        if (this.headersInit != null) {\n          if (Array.isArray(this.headersInit)) {\n            this._map = new Map;\n            for (const [key, value] of this.headersInit) {\n              const normalizedKey = key.toLowerCase();\n              if (normalizedKey === "set-cookie") {\n                this._setCookies.push(value);\n                continue;\n              }\n              this._map.set(normalizedKey, value);\n            }\n          } else if (isHeadersLike(this.headersInit)) {\n            this._map = new Map;\n            this.headersInit.forEach((value, key) => {\n              if (key === "set-cookie") {\n                this._setCookies ||= [];\n                this._setCookies.push(value);\n                return;\n              }\n              this._map.set(key, value);\n            });\n          } else {\n            this._map = new Map;\n            for (const initKey in this.headersInit) {\n              const initValue = this.headersInit[initKey];\n              if (initValue != null) {\n                const normalizedKey = initKey.toLowerCase();\n                if (normalizedKey === "set-cookie") {\n                  this._setCookies ||= [];\n                  this._setCookies.push(initValue);\n                  continue;\n                }\n                this._map.set(normalizedKey, initValue);\n              }\n            }\n          }\n        } else {\n          this._map = new Map;\n        }\n      }\n      return this._map;\n    }\n    append(name, value) {\n      const key = name.toLowerCase();\n      if (key === "set-cookie") {\n        this._setCookies ||= [];\n        this._setCookies.push(value);\n        return;\n      }\n      const existingValue = this.getMap().get(key);\n      const finalValue = existingValue ? `${existingValue}, ${value}` : value;\n      this.getMap().set(key, finalValue);\n    }\n    get(name) {\n      const value = this._get(name);\n      if (value == null) {\n        return null;\n      }\n      return value.toString();\n    }\n    has(name) {\n      const key = name.toLowerCase();\n      if (key === "set-cookie") {\n        return !!this._setCookies?.length;\n      }\n      return !!this._get(name);\n    }\n    set(name, value) {\n      const key = name.toLowerCase();\n      if (key === "set-cookie") {\n        this._setCookies = [value];\n        return;\n      }\n      if (!this._map && this.headersInit != null) {\n        if (Array.isArray(this.headersInit)) {\n          const found = this.headersInit.find(([headerKey]) => headerKey.toLowerCase() === key);\n          if (found) {\n            found[1] = value;\n          } else {\n            this.headersInit.push([key, value]);\n          }\n          return;\n        } else if (isHeadersLike(this.headersInit)) {\n          this.headersInit.set(key, value);\n          return;\n        } else {\n          this.headersInit[key] = value;\n          return;\n        }\n      }\n      this.getMap().set(key, value);\n    }\n    delete(name) {\n      const key = name.toLowerCase();\n      if (key === "set-cookie") {\n        this._setCookies = [];\n        return;\n      }\n      this.getMap().delete(key);\n    }\n    forEach(callback) {\n      this._setCookies?.forEach((setCookie) => {\n        callback(setCookie, "set-cookie", this);\n      });\n      if (!this._map) {\n        if (this.headersInit) {\n          if (Array.isArray(this.headersInit)) {\n            this.headersInit.forEach(([key, value]) => {\n              callback(value, key, this);\n            });\n            return;\n          }\n          if (isHeadersLike(this.headersInit)) {\n            this.headersInit.forEach(callback);\n            return;\n          }\n          Object.entries(this.headersInit).forEach(([key, value]) => {\n            if (value != null) {\n              callback(value, key, this);\n            }\n          });\n        }\n        return;\n      }\n      this.getMap().forEach((value, key) => {\n        callback(value, key, this);\n      });\n    }\n    *_keys() {\n      if (this._setCookies?.length) {\n        yield "set-cookie";\n      }\n      if (!this._map) {\n        if (this.headersInit) {\n          if (Array.isArray(this.headersInit)) {\n            yield* this.headersInit.map(([key]) => key)[Symbol.iterator]();\n            return;\n          }\n          if (isHeadersLike(this.headersInit)) {\n            yield* this.headersInit.keys();\n            return;\n          }\n          yield* Object.keys(this.headersInit)[Symbol.iterator]();\n          return;\n        }\n      }\n      yield* this.getMap().keys();\n    }\n    keys() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._keys(), "HeadersIterator");\n    }\n    *_values() {\n      if (this._setCookies?.length) {\n        yield* this._setCookies;\n      }\n      if (!this._map) {\n        if (this.headersInit) {\n          if (Array.isArray(this.headersInit)) {\n            yield* this.headersInit.map(([, value]) => value)[Symbol.iterator]();\n            return;\n          }\n          if (isHeadersLike(this.headersInit)) {\n            yield* this.headersInit.values();\n            return;\n          }\n          yield* Object.values(this.headersInit)[Symbol.iterator]();\n          return;\n        }\n      }\n      yield* this.getMap().values();\n    }\n    values() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._values(), "HeadersIterator");\n    }\n    *_entries() {\n      if (this._setCookies?.length) {\n        yield* this._setCookies.map((cookie) => ["set-cookie", cookie]);\n      }\n      if (!this._map) {\n        if (this.headersInit) {\n          if (Array.isArray(this.headersInit)) {\n            yield* this.headersInit;\n            return;\n          }\n          if (isHeadersLike(this.headersInit)) {\n            yield* this.headersInit.entries();\n            return;\n          }\n          yield* Object.entries(this.headersInit);\n          return;\n        }\n      }\n      yield* this.getMap().entries();\n    }\n    entries() {\n      return new IteratorObject_js_1.PonyfillIteratorObject(this._entries(), "HeadersIterator");\n    }\n    getSetCookie() {\n      if (!this._setCookies) {\n        this.getMap();\n      }\n      return this._setCookies;\n    }\n    [Symbol.iterator]() {\n      return this.entries();\n    }\n    [Symbol.for("nodejs.util.inspect.custom")]() {\n      const record = {};\n      this.forEach((value, key) => {\n        if (key === "set-cookie") {\n          record["set-cookie"] = this._setCookies || [];\n        } else {\n          record[key] = value?.includes(",") ? value.split(",").map((el) => el.trim()) : value;\n        }\n      });\n      return `Headers ${(0, node_util_1.inspect)(record)}`;\n    }\n  }\n  exports.PonyfillHeaders = PonyfillHeaders;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/Response.js\nvar require_Response = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillResponse = undefined;\n  var node_http_1 = __require("node:http");\n  var Body_js_1 = require_Body();\n  var Headers_js_1 = require_Headers();\n  var JSON_CONTENT_TYPE = "application/json; charset=utf-8";\n\n  class PonyfillResponse extends Body_js_1.PonyfillBody {\n    headers;\n    constructor(body, init) {\n      super(body || null, init);\n      this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);\n      this.status = init?.status || 200;\n      this.statusText = init?.statusText || node_http_1.STATUS_CODES[this.status] || "OK";\n      this.url = init?.url || "";\n      this.redirected = init?.redirected || false;\n      this.type = init?.type || "default";\n      this.handleContentLengthHeader();\n    }\n    get ok() {\n      return this.status >= 200 && this.status < 300;\n    }\n    status;\n    statusText;\n    url;\n    redirected;\n    type;\n    clone() {\n      return this;\n    }\n    static error() {\n      return new PonyfillResponse(null, {\n        status: 500,\n        statusText: "Internal Server Error"\n      });\n    }\n    static redirect(url, status = 302) {\n      if (status < 300 || status > 399) {\n        throw new RangeError("Invalid status code");\n      }\n      return new PonyfillResponse(null, {\n        headers: {\n          location: url\n        },\n        status\n      });\n    }\n    static json(data, init) {\n      const bodyInit = JSON.stringify(data);\n      if (!init) {\n        init = {\n          headers: {\n            "content-type": JSON_CONTENT_TYPE,\n            "content-length": Buffer.byteLength(bodyInit).toString()\n          }\n        };\n      } else if (!init.headers) {\n        init.headers = {\n          "content-type": JSON_CONTENT_TYPE,\n          "content-length": Buffer.byteLength(bodyInit).toString()\n        };\n      } else if ((0, Headers_js_1.isHeadersLike)(init.headers)) {\n        if (!init.headers.has("content-type")) {\n          init.headers.set("content-type", JSON_CONTENT_TYPE);\n        }\n        if (!init.headers.has("content-length")) {\n          init.headers.set("content-length", Buffer.byteLength(bodyInit).toString());\n        }\n      } else if (Array.isArray(init.headers)) {\n        let contentTypeExists = false;\n        let contentLengthExists = false;\n        for (const [key] of init.headers) {\n          if (contentLengthExists && contentTypeExists) {\n            break;\n          }\n          if (!contentTypeExists && key.toLowerCase() === "content-type") {\n            contentTypeExists = true;\n          } else if (!contentLengthExists && key.toLowerCase() === "content-length") {\n            contentLengthExists = true;\n          }\n        }\n        if (!contentTypeExists) {\n          init.headers.push(["content-type", JSON_CONTENT_TYPE]);\n        }\n        if (!contentLengthExists) {\n          init.headers.push(["content-length", Buffer.byteLength(bodyInit).toString()]);\n        }\n      } else if (typeof init.headers === "object") {\n        if (init.headers?.["content-type"] == null) {\n          init.headers["content-type"] = JSON_CONTENT_TYPE;\n        }\n        if (init.headers?.["content-length"] == null) {\n          init.headers["content-length"] = Buffer.byteLength(bodyInit).toString();\n        }\n      }\n      return new PonyfillResponse(bodyInit, init);\n    }\n    [Symbol.toStringTag] = "Response";\n  }\n  exports.PonyfillResponse = PonyfillResponse;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js\nvar require_fetchCurl = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.fetchCurl = fetchCurl;\n  var node_stream_1 = __require("node:stream");\n  var node_tls_1 = __require("node:tls");\n  var promise_helpers_1 = require_cjs();\n  var Response_js_1 = require_Response();\n  var utils_js_1 = require_utils();\n  function fetchCurl(fetchRequest) {\n    const { Curl, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];\n    const curlHandle = new Curl;\n    curlHandle.enable(CurlFeature.NoDataParsing);\n    curlHandle.setOpt("URL", fetchRequest.url);\n    if (process.env.NODE_TLS_REJECT_UNAUTHORIZED === "0") {\n      curlHandle.setOpt("SSL_VERIFYPEER", false);\n    }\n    if (process.env.NODE_EXTRA_CA_CERTS) {\n      curlHandle.setOpt("CAINFO", process.env.NODE_EXTRA_CA_CERTS);\n    } else {\n      curlHandle.setOpt("CAINFO_BLOB", node_tls_1.rootCertificates.join(`\n`));\n    }\n    curlHandle.enable(CurlFeature.StreamResponse);\n    let signal;\n    if (fetchRequest._signal === null) {\n      signal = undefined;\n    } else if (fetchRequest._signal) {\n      signal = fetchRequest._signal;\n    }\n    curlHandle.setStreamProgressCallback(function() {\n      return signal?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;\n    });\n    if (fetchRequest["bodyType"] === "String") {\n      curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);\n    } else {\n      const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;\n      if (nodeReadable) {\n        curlHandle.setOpt("UPLOAD", true);\n        curlHandle.setUploadStream(nodeReadable);\n      }\n    }\n    if (process.env.DEBUG) {\n      curlHandle.setOpt("VERBOSE", true);\n    }\n    curlHandle.setOpt("TRANSFER_ENCODING", false);\n    curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);\n    curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");\n    curlHandle.setOpt("MAXREDIRS", 20);\n    curlHandle.setOpt("ACCEPT_ENCODING", "");\n    curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);\n    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;\n    let size;\n    const curlHeaders = headersSerializer(fetchRequest.headers, (value) => {\n      size = Number(value);\n    });\n    if (size != null) {\n      curlHandle.setOpt("INFILESIZE", size);\n    }\n    curlHandle.setOpt("HTTPHEADER", curlHeaders);\n    curlHandle.enable(CurlFeature.NoHeaderParsing);\n    const deferredPromise = (0, promise_helpers_1.createDeferredPromise)();\n    let streamResolved;\n    function onAbort() {\n      if (curlHandle.isOpen) {\n        try {\n          curlHandle.pause(CurlPause.Recv);\n        } catch (e2) {\n          deferredPromise.reject(e2);\n        }\n      }\n    }\n    signal?.addEventListener("abort", onAbort, { once: true });\n    curlHandle.once("end", function endListener() {\n      try {\n        curlHandle.close();\n      } catch (e2) {\n        deferredPromise.reject(e2);\n      }\n      signal?.removeEventListener("abort", onAbort);\n    });\n    curlHandle.once("error", function errorListener(error) {\n      if (streamResolved && !streamResolved.closed && !streamResolved.destroyed) {\n        streamResolved.destroy(error);\n      } else {\n        if (error.message === "Operation was aborted by an application callback") {\n          error.message = "The operation was aborted.";\n        }\n        deferredPromise.reject(error);\n      }\n      try {\n        curlHandle.close();\n      } catch (e2) {\n        deferredPromise.reject(e2);\n      }\n    });\n    curlHandle.once("stream", function streamListener(stream, status, headersBuf) {\n      const outputStream = stream.pipe(new node_stream_1.PassThrough, {\n        end: true\n      });\n      const headersFlat = headersBuf.toString("utf8").split(/\\r?\\n|\\r/g).filter((headerFilter) => {\n        if (headerFilter && !headerFilter.startsWith("HTTP/")) {\n          if (fetchRequest.redirect === "error" && headerFilter.toLowerCase().includes("location") && (0, utils_js_1.shouldRedirect)(status)) {\n            if (!stream.destroyed) {\n              stream.resume();\n            }\n            outputStream.destroy();\n            deferredPromise.reject(new Error("redirect is not allowed"));\n          }\n          return true;\n        }\n        return false;\n      });\n      const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\\s(.+)/).slice(0, 2));\n      const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream, {\n        status,\n        headers: headersInit,\n        url: curlHandle.getInfo(Curl.info.REDIRECT_URL)?.toString() || fetchRequest.url,\n        redirected: Number(curlHandle.getInfo(Curl.info.REDIRECT_COUNT)) > 0\n      });\n      deferredPromise.resolve(ponyfillResponse);\n      streamResolved = outputStream;\n    });\n    setImmediate(() => {\n      curlHandle.perform();\n    });\n    return deferredPromise.promise;\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/URL.js\nvar require_URL = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillURL = undefined;\n  var tslib_1 = require_tslib();\n  var node_buffer_1 = tslib_1.__importDefault(__require("node:buffer"));\n  var node_crypto_1 = __require("node:crypto");\n  var NativeURL = globalThis.URL;\n\n  class URL2 extends NativeURL {\n    static blobRegistry = new Map;\n    static createObjectURL(blob) {\n      const blobUrl = `blob:whatwgnode:${(0, node_crypto_1.randomUUID)()}`;\n      this.blobRegistry.set(blobUrl, blob);\n      return blobUrl;\n    }\n    static revokeObjectURL(url) {\n      if (!this.blobRegistry.has(url)) {\n        NativeURL.revokeObjectURL(url);\n      } else {\n        this.blobRegistry.delete(url);\n      }\n    }\n    static getBlobFromURL(url) {\n      return this.blobRegistry.get(url) || node_buffer_1.default?.resolveObjectURL?.(url);\n    }\n  }\n  exports.PonyfillURL = URL2;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/Request.js\nvar require_Request = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillRequest = undefined;\n  var node_http_1 = __require("node:http");\n  var node_https_1 = __require("node:https");\n  var Body_js_1 = require_Body();\n  var Headers_js_1 = require_Headers();\n  var URL_js_1 = require_URL();\n  function isRequest(input) {\n    return input[Symbol.toStringTag] === "Request";\n  }\n  function isURL(obj) {\n    return obj?.href != null;\n  }\n\n  class PonyfillRequest extends Body_js_1.PonyfillBody {\n    constructor(input, options) {\n      let _url;\n      let _parsedUrl;\n      let bodyInit = null;\n      let requestInit;\n      if (typeof input === "string") {\n        _url = input;\n      } else if (isURL(input)) {\n        _parsedUrl = input;\n      } else if (isRequest(input)) {\n        if (input._parsedUrl) {\n          _parsedUrl = input._parsedUrl;\n        } else if (input._url) {\n          _url = input._url;\n        } else {\n          _url = input.url;\n        }\n        bodyInit = input.body;\n        requestInit = input;\n      }\n      if (options != null) {\n        bodyInit = options.body || null;\n        requestInit = options;\n      }\n      super(bodyInit, requestInit);\n      this._url = _url;\n      this._parsedUrl = _parsedUrl;\n      this.cache = requestInit?.cache || "default";\n      this.credentials = requestInit?.credentials || "same-origin";\n      this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);\n      this.integrity = requestInit?.integrity || "";\n      this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;\n      this.method = requestInit?.method?.toUpperCase() || "GET";\n      this.mode = requestInit?.mode || "cors";\n      this.redirect = requestInit?.redirect || "follow";\n      this.referrer = requestInit?.referrer || "about:client";\n      this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";\n      this.headersSerializer = requestInit?.headersSerializer;\n      this.duplex = requestInit?.duplex || "half";\n      this.destination = "document";\n      this.priority = "auto";\n      if (this.method !== "GET" && this.method !== "HEAD") {\n        this.handleContentLengthHeader(true);\n      }\n      if (requestInit?.agent != null) {\n        const protocol = _parsedUrl?.protocol || _url || this.url;\n        if (requestInit.agent === false) {\n          this.agent = false;\n        } else if (protocol.startsWith("http:") && requestInit.agent instanceof node_http_1.Agent) {\n          this.agent = requestInit.agent;\n        } else if (protocol.startsWith("https:") && requestInit.agent instanceof node_https_1.Agent) {\n          this.agent = requestInit.agent;\n        }\n      }\n    }\n    headersSerializer;\n    cache;\n    credentials;\n    destination;\n    headers;\n    integrity;\n    keepalive;\n    method;\n    mode;\n    priority;\n    redirect;\n    referrer;\n    referrerPolicy;\n    _url;\n    get signal() {\n      this._signal ||= new AbortController().signal;\n      return this._signal;\n    }\n    get url() {\n      if (this._url == null) {\n        if (this._parsedUrl) {\n          this._url = this._parsedUrl.toString();\n        } else {\n          throw new TypeError("Invalid URL");\n        }\n      }\n      return this._url;\n    }\n    _parsedUrl;\n    get parsedUrl() {\n      if (this._parsedUrl == null) {\n        if (this._url != null) {\n          this._parsedUrl = new URL_js_1.PonyfillURL(this._url, "http://localhost");\n        } else {\n          throw new TypeError("Invalid URL");\n        }\n      }\n      return this._parsedUrl;\n    }\n    duplex;\n    agent;\n    clone() {\n      return this;\n    }\n    [Symbol.toStringTag] = "Request";\n  }\n  exports.PonyfillRequest = PonyfillRequest;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js\nvar require_fetchNodeHttp = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.fetchNodeHttp = fetchNodeHttp;\n  var node_http_1 = __require("node:http");\n  var node_https_1 = __require("node:https");\n  var node_stream_1 = __require("node:stream");\n  var node_zlib_1 = __require("node:zlib");\n  var promise_helpers_1 = require_cjs();\n  var Request_js_1 = require_Request();\n  var Response_js_1 = require_Response();\n  var URL_js_1 = require_URL();\n  var utils_js_1 = require_utils();\n  function getRequestFnForProtocol(url) {\n    if (url.startsWith("http:")) {\n      return node_http_1.request;\n    } else if (url.startsWith("https:")) {\n      return node_https_1.request;\n    }\n    throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);\n  }\n  function fetchNodeHttp(fetchRequest) {\n    return new Promise((resolve, reject) => {\n      try {\n        const requestFn = getRequestFnForProtocol(fetchRequest.parsedUrl?.protocol || fetchRequest.url);\n        const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;\n        const nodeHeaders = headersSerializer(fetchRequest.headers);\n        nodeHeaders["accept-encoding"] ||= "gzip, deflate, br";\n        nodeHeaders["user-agent"] ||= "node";\n        let signal;\n        if (fetchRequest._signal == null) {\n          signal = undefined;\n        } else if (fetchRequest._signal) {\n          signal = fetchRequest._signal;\n        }\n        let nodeRequest;\n        if (fetchRequest.parsedUrl) {\n          nodeRequest = requestFn(fetchRequest.parsedUrl, {\n            method: fetchRequest.method,\n            headers: nodeHeaders,\n            signal,\n            agent: fetchRequest.agent\n          });\n        } else {\n          nodeRequest = requestFn(fetchRequest.url, {\n            method: fetchRequest.method,\n            headers: nodeHeaders,\n            signal,\n            agent: fetchRequest.agent\n          });\n        }\n        nodeRequest.once("error", reject);\n        nodeRequest.once("response", (nodeResponse) => {\n          let outputStream;\n          const contentEncoding = nodeResponse.headers["content-encoding"];\n          switch (contentEncoding) {\n            case "x-gzip":\n            case "gzip":\n              outputStream = (0, node_zlib_1.createGunzip)();\n              break;\n            case "x-deflate":\n            case "deflate":\n              outputStream = (0, node_zlib_1.createInflate)();\n              break;\n            case "x-deflate-raw":\n            case "deflate-raw":\n              outputStream = (0, node_zlib_1.createInflateRaw)();\n              break;\n            case "br":\n              outputStream = (0, node_zlib_1.createBrotliDecompress)();\n              break;\n          }\n          if (nodeResponse.headers.location && (0, utils_js_1.shouldRedirect)(nodeResponse.statusCode)) {\n            if (fetchRequest.redirect === "error") {\n              const redirectError = new Error("Redirects are not allowed");\n              reject(redirectError);\n              nodeResponse.resume();\n              return;\n            }\n            if (fetchRequest.redirect === "follow") {\n              const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.parsedUrl || fetchRequest.url);\n              const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));\n              resolve(redirectResponse$.then((redirectResponse) => {\n                redirectResponse.redirected = true;\n                return redirectResponse;\n              }));\n              nodeResponse.resume();\n              return;\n            }\n          }\n          outputStream ||= new node_stream_1.PassThrough;\n          (0, utils_js_1.pipeThrough)({\n            src: nodeResponse,\n            dest: outputStream,\n            signal,\n            onError: (e2) => {\n              if (!nodeResponse.destroyed) {\n                nodeResponse.destroy(e2);\n              }\n              if (!outputStream.destroyed) {\n                outputStream.destroy(e2);\n              }\n              reject(e2);\n            }\n          });\n          const statusCode = nodeResponse.statusCode || 200;\n          let statusText = nodeResponse.statusMessage || node_http_1.STATUS_CODES[statusCode];\n          if (statusText == null) {\n            statusText = "";\n          }\n          const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream || nodeResponse, {\n            status: statusCode,\n            statusText,\n            headers: nodeResponse.headers,\n            url: fetchRequest.url,\n            signal\n          });\n          resolve(ponyfillResponse);\n        });\n        if (fetchRequest["_buffer"] != null) {\n          (0, promise_helpers_1.handleMaybePromise)(() => (0, utils_js_1.safeWrite)(fetchRequest["_buffer"], nodeRequest), () => (0, utils_js_1.endStream)(nodeRequest), reject);\n        } else {\n          const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;\n          if (nodeReadable) {\n            nodeReadable.pipe(nodeRequest);\n          } else {\n            (0, utils_js_1.endStream)(nodeRequest);\n          }\n        }\n      } catch (e2) {\n        reject(e2);\n      }\n    });\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/fetch.js\nvar require_fetch = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.fetchPonyfill = fetchPonyfill;\n  var node_buffer_1 = __require("node:buffer");\n  var node_fs_1 = __require("node:fs");\n  var node_url_1 = __require("node:url");\n  var fetchCurl_js_1 = require_fetchCurl();\n  var fetchNodeHttp_js_1 = require_fetchNodeHttp();\n  var Request_js_1 = require_Request();\n  var Response_js_1 = require_Response();\n  var URL_js_1 = require_URL();\n  var utils_js_1 = require_utils();\n  var BASE64_SUFFIX = ";base64";\n  async function getResponseForFile(url) {\n    const path = (0, node_url_1.fileURLToPath)(url);\n    try {\n      await node_fs_1.promises.access(path, node_fs_1.promises.constants.R_OK);\n      const stats = await node_fs_1.promises.stat(path, {\n        bigint: true\n      });\n      const readable = (0, node_fs_1.createReadStream)(path);\n      return new Response_js_1.PonyfillResponse(readable, {\n        status: 200,\n        statusText: "OK",\n        headers: {\n          "content-type": "application/octet-stream",\n          "last-modified": stats.mtime.toUTCString()\n        }\n      });\n    } catch (err) {\n      if (err.code === "ENOENT") {\n        return new Response_js_1.PonyfillResponse(null, {\n          status: 404,\n          statusText: "Not Found"\n        });\n      } else if (err.code === "EACCES") {\n        return new Response_js_1.PonyfillResponse(null, {\n          status: 403,\n          statusText: "Forbidden"\n        });\n      }\n      throw err;\n    }\n  }\n  function getResponseForDataUri(url) {\n    const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");\n    const data = decodeURIComponent(datas.join(","));\n    if (mimeType.endsWith(BASE64_SUFFIX)) {\n      const buffer = node_buffer_1.Buffer.from(data, "base64url");\n      const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);\n      return new Response_js_1.PonyfillResponse(buffer, {\n        status: 200,\n        statusText: "OK",\n        headers: {\n          "content-type": realMimeType\n        }\n      });\n    }\n    return new Response_js_1.PonyfillResponse(data, {\n      status: 200,\n      statusText: "OK",\n      headers: {\n        "content-type": mimeType\n      }\n    });\n  }\n  function getResponseForBlob(url) {\n    const blob = URL_js_1.PonyfillURL.getBlobFromURL(url);\n    if (!blob) {\n      throw new TypeError("Invalid Blob URL");\n    }\n    return new Response_js_1.PonyfillResponse(blob, {\n      status: 200,\n      headers: {\n        "content-type": blob.type,\n        "content-length": blob.size.toString()\n      }\n    });\n  }\n  function isURL(obj) {\n    return obj != null && obj.href != null;\n  }\n  function fetchPonyfill(info, init) {\n    if (typeof info === "string" || isURL(info)) {\n      const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);\n      return fetchPonyfill(ponyfillRequest);\n    }\n    const fetchRequest = info;\n    if (fetchRequest.url.startsWith("data:")) {\n      const response = getResponseForDataUri(fetchRequest.url);\n      return (0, utils_js_1.fakePromise)(response);\n    }\n    if (fetchRequest.url.startsWith("file:")) {\n      const response = getResponseForFile(fetchRequest.url);\n      return response;\n    }\n    if (fetchRequest.url.startsWith("blob:")) {\n      const response = getResponseForBlob(fetchRequest.url);\n      return (0, utils_js_1.fakePromise)(response);\n    }\n    if (globalThis.libcurl && !fetchRequest.agent) {\n      return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);\n    }\n    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js\nvar require_TextEncoderDecoder = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = undefined;\n  exports.PonyfillBtoa = PonyfillBtoa;\n  var node_buffer_1 = __require("node:buffer");\n  var utils_js_1 = require_utils();\n\n  class PonyfillTextEncoder {\n    encoding;\n    constructor(encoding = "utf-8") {\n      this.encoding = encoding;\n    }\n    encode(input) {\n      return node_buffer_1.Buffer.from(input, this.encoding);\n    }\n    encodeInto(source, destination) {\n      const buffer = this.encode(source);\n      const copied = buffer.copy(destination);\n      return {\n        read: copied,\n        written: copied\n      };\n    }\n  }\n  exports.PonyfillTextEncoder = PonyfillTextEncoder;\n\n  class PonyfillTextDecoder {\n    encoding;\n    fatal = false;\n    ignoreBOM = false;\n    constructor(encoding = "utf-8", options) {\n      this.encoding = encoding;\n      if (options) {\n        this.fatal = options.fatal || false;\n        this.ignoreBOM = options.ignoreBOM || false;\n      }\n    }\n    decode(input) {\n      if (node_buffer_1.Buffer.isBuffer(input)) {\n        return input.toString(this.encoding);\n      }\n      if ((0, utils_js_1.isArrayBufferView)(input)) {\n        return node_buffer_1.Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);\n      }\n      return node_buffer_1.Buffer.from(input).toString(this.encoding);\n    }\n  }\n  exports.PonyfillTextDecoder = PonyfillTextDecoder;\n  function PonyfillBtoa(input) {\n    return node_buffer_1.Buffer.from(input, "binary").toString("base64");\n  }\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js\nvar require_URLSearchParams = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillURLSearchParams = undefined;\n  exports.PonyfillURLSearchParams = globalThis.URLSearchParams;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/WritableStream.js\nvar require_WritableStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillWritableStream = undefined;\n  var node_events_1 = __require("node:events");\n  var node_stream_1 = __require("node:stream");\n  var promise_helpers_1 = require_cjs();\n  var utils_js_1 = require_utils();\n\n  class PonyfillWritableStream {\n    writable;\n    constructor(underlyingSink) {\n      if (underlyingSink instanceof node_stream_1.Writable) {\n        this.writable = underlyingSink;\n      } else if (underlyingSink) {\n        const writable = new node_stream_1.Writable({\n          write(chunk, _encoding, callback) {\n            try {\n              const result = underlyingSink.write?.(chunk, controller);\n              if (result instanceof Promise) {\n                result.then(() => {\n                  callback();\n                }, (err) => {\n                  callback(err);\n                });\n              } else {\n                callback();\n              }\n            } catch (err) {\n              callback(err);\n            }\n          },\n          final(callback) {\n            const result = underlyingSink.close?.();\n            if (result instanceof Promise) {\n              result.then(() => {\n                callback();\n              }, (err) => {\n                callback(err);\n              });\n            } else {\n              callback();\n            }\n          }\n        });\n        this.writable = writable;\n        const abortCtrl = new AbortController;\n        const controller = {\n          signal: abortCtrl.signal,\n          error(e2) {\n            writable.destroy(e2);\n          }\n        };\n        writable.once("error", (err) => abortCtrl.abort(err));\n        writable.once("close", () => abortCtrl.abort());\n      } else {\n        this.writable = new node_stream_1.Writable;\n      }\n    }\n    getWriter() {\n      const writable = this.writable;\n      return {\n        get closed() {\n          return (0, node_events_1.once)(writable, "close");\n        },\n        get desiredSize() {\n          return writable.writableLength;\n        },\n        get ready() {\n          return (0, node_events_1.once)(writable, "drain");\n        },\n        releaseLock() {},\n        write(chunk) {\n          const promise = (0, utils_js_1.fakePromise)();\n          if (chunk == null) {\n            return promise;\n          }\n          return promise.then(() => (0, utils_js_1.safeWrite)(chunk, writable));\n        },\n        close() {\n          if (!writable.errored && writable.closed) {\n            return (0, utils_js_1.fakePromise)();\n          }\n          if (writable.errored) {\n            return (0, promise_helpers_1.fakeRejectPromise)(writable.errored);\n          }\n          return (0, utils_js_1.fakePromise)().then(() => (0, utils_js_1.endStream)(writable));\n        },\n        abort(reason) {\n          writable.destroy(reason);\n          return (0, node_events_1.once)(writable, "close");\n        }\n      };\n    }\n    close() {\n      if (!this.writable.errored && this.writable.closed) {\n        return (0, utils_js_1.fakePromise)();\n      }\n      if (this.writable.errored) {\n        return (0, promise_helpers_1.fakeRejectPromise)(this.writable.errored);\n      }\n      return (0, utils_js_1.fakePromise)().then(() => (0, utils_js_1.endStream)(this.writable));\n    }\n    abort(reason) {\n      this.writable.destroy(reason);\n      return (0, node_events_1.once)(this.writable, "close");\n    }\n    locked = false;\n  }\n  exports.PonyfillWritableStream = PonyfillWritableStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/TransformStream.js\nvar require_TransformStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillTransformStream = undefined;\n  var node_stream_1 = __require("node:stream");\n  var ReadableStream_js_1 = require_ReadableStream();\n  var utils_js_1 = require_utils();\n  var WritableStream_js_1 = require_WritableStream();\n\n  class PonyfillTransformStream {\n    transform;\n    writable;\n    readable;\n    constructor(transformer) {\n      if (transformer instanceof node_stream_1.Transform) {\n        this.transform = transformer;\n      } else if (transformer) {\n        const controller = {\n          enqueue(chunk) {\n            transform.push(chunk);\n          },\n          error(reason) {\n            transform.destroy(reason);\n          },\n          terminate() {\n            (0, utils_js_1.endStream)(transform);\n          },\n          get desiredSize() {\n            return transform.writableLength;\n          }\n        };\n        const transform = new node_stream_1.Transform({\n          read() {},\n          write(chunk, _encoding, callback) {\n            try {\n              const result = transformer.transform?.(chunk, controller);\n              if (result instanceof Promise) {\n                result.then(() => {\n                  callback();\n                }, (err) => {\n                  callback(err);\n                });\n              } else {\n                callback();\n              }\n            } catch (err) {\n              callback(err);\n            }\n          },\n          final(callback) {\n            try {\n              const result = transformer.flush?.(controller);\n              if (result instanceof Promise) {\n                result.then(() => {\n                  callback();\n                }, (err) => {\n                  callback(err);\n                });\n              } else {\n                callback();\n              }\n            } catch (err) {\n              callback(err);\n            }\n          }\n        });\n        this.transform = transform;\n      } else {\n        this.transform = new node_stream_1.Transform;\n      }\n      this.writable = new WritableStream_js_1.PonyfillWritableStream(this.transform);\n      this.readable = new ReadableStream_js_1.PonyfillReadableStream(this.transform);\n    }\n  }\n  exports.PonyfillTransformStream = PonyfillTransformStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/CompressionStream.js\nvar require_CompressionStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillCompressionStream = undefined;\n  var node_zlib_1 = __require("node:zlib");\n  var TransformStream_js_1 = require_TransformStream();\n\n  class PonyfillCompressionStream extends TransformStream_js_1.PonyfillTransformStream {\n    static supportedFormats = globalThis.process?.version?.startsWith("v2") ? ["gzip", "deflate", "br"] : ["gzip", "deflate", "deflate-raw", "br"];\n    constructor(compressionFormat) {\n      switch (compressionFormat) {\n        case "x-gzip":\n        case "gzip":\n          super((0, node_zlib_1.createGzip)());\n          break;\n        case "x-deflate":\n        case "deflate":\n          super((0, node_zlib_1.createDeflate)());\n          break;\n        case "deflate-raw":\n          super((0, node_zlib_1.createDeflateRaw)());\n          break;\n        case "br":\n          super((0, node_zlib_1.createBrotliCompress)());\n          break;\n        default:\n          throw new Error(`Unsupported compression format: ${compressionFormat}`);\n      }\n    }\n  }\n  exports.PonyfillCompressionStream = PonyfillCompressionStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/DecompressionStream.js\nvar require_DecompressionStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillDecompressionStream = undefined;\n  var node_zlib_1 = __require("node:zlib");\n  var TransformStream_js_1 = require_TransformStream();\n\n  class PonyfillDecompressionStream extends TransformStream_js_1.PonyfillTransformStream {\n    static supportedFormats = globalThis.process?.version?.startsWith("v2") ? ["gzip", "deflate", "br"] : ["gzip", "deflate", "deflate-raw", "br"];\n    constructor(compressionFormat) {\n      switch (compressionFormat) {\n        case "x-gzip":\n        case "gzip":\n          super((0, node_zlib_1.createGunzip)());\n          break;\n        case "x-deflate":\n        case "deflate":\n          super((0, node_zlib_1.createInflate)());\n          break;\n        case "deflate-raw":\n          super((0, node_zlib_1.createInflateRaw)());\n          break;\n        case "br":\n          super((0, node_zlib_1.createBrotliDecompress)());\n          break;\n        default:\n          throw new TypeError(`Unsupported compression format: \'${compressionFormat}\'`);\n      }\n    }\n  }\n  exports.PonyfillDecompressionStream = PonyfillDecompressionStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoderStream.js\nvar require_TextEncoderDecoderStream = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.PonyfillTextEncoderStream = exports.PonyfillTextDecoderStream = undefined;\n  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();\n  var TransformStream_js_1 = require_TransformStream();\n\n  class PonyfillTextDecoderStream extends TransformStream_js_1.PonyfillTransformStream {\n    textDecoder;\n    constructor(encoding, options) {\n      super({\n        transform: (chunk, controller) => controller.enqueue(this.textDecoder.decode(chunk, { stream: true }))\n      });\n      this.textDecoder = new TextEncoderDecoder_js_1.PonyfillTextDecoder(encoding, options);\n    }\n    get encoding() {\n      return this.textDecoder.encoding;\n    }\n    get fatal() {\n      return this.textDecoder.fatal;\n    }\n    get ignoreBOM() {\n      return this.textDecoder.ignoreBOM;\n    }\n  }\n  exports.PonyfillTextDecoderStream = PonyfillTextDecoderStream;\n\n  class PonyfillTextEncoderStream extends TransformStream_js_1.PonyfillTransformStream {\n    textEncoder;\n    constructor(encoding) {\n      super({\n        transform: (chunk, controller) => controller.enqueue(this.textEncoder.encode(chunk))\n      });\n      this.textEncoder = new TextEncoderDecoder_js_1.PonyfillTextEncoder(encoding);\n    }\n    get encoding() {\n      return this.textEncoder.encoding;\n    }\n    encode(input) {\n      return this.textEncoder.encode(input);\n    }\n  }\n  exports.PonyfillTextEncoderStream = PonyfillTextEncoderStream;\n});\n\n// ../../node_modules/@whatwg-node/node-fetch/cjs/index.js\nvar require_cjs3 = __commonJS((exports) => {\n  Object.defineProperty(exports, "__esModule", { value: true });\n  exports.TextEncoderStream = exports.TextDecoderStream = exports.IteratorObject = exports.DecompressionStream = exports.CompressionStream = exports.TransformStream = exports.WritableStream = exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = undefined;\n  var fetch_js_1 = require_fetch();\n  Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {\n    return fetch_js_1.fetchPonyfill;\n  } });\n  var Headers_js_1 = require_Headers();\n  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {\n    return Headers_js_1.PonyfillHeaders;\n  } });\n  var Body_js_1 = require_Body();\n  Object.defineProperty(exports, "Body", { enumerable: true, get: function() {\n    return Body_js_1.PonyfillBody;\n  } });\n  var Request_js_1 = require_Request();\n  Object.defineProperty(exports, "Request", { enumerable: true, get: function() {\n    return Request_js_1.PonyfillRequest;\n  } });\n  var Response_js_1 = require_Response();\n  Object.defineProperty(exports, "Response", { enumerable: true, get: function() {\n    return Response_js_1.PonyfillResponse;\n  } });\n  var ReadableStream_js_1 = require_ReadableStream();\n  Object.defineProperty(exports, "ReadableStream", { enumerable: true, get: function() {\n    return ReadableStream_js_1.PonyfillReadableStream;\n  } });\n  var File_js_1 = require_File();\n  Object.defineProperty(exports, "File", { enumerable: true, get: function() {\n    return File_js_1.PonyfillFile;\n  } });\n  var FormData_js_1 = require_FormData();\n  Object.defineProperty(exports, "FormData", { enumerable: true, get: function() {\n    return FormData_js_1.PonyfillFormData;\n  } });\n  var Blob_js_1 = require_Blob();\n  Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {\n    return Blob_js_1.PonyfillBlob;\n  } });\n  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();\n  Object.defineProperty(exports, "TextEncoder", { enumerable: true, get: function() {\n    return TextEncoderDecoder_js_1.PonyfillTextEncoder;\n  } });\n  Object.defineProperty(exports, "TextDecoder", { enumerable: true, get: function() {\n    return TextEncoderDecoder_js_1.PonyfillTextDecoder;\n  } });\n  Object.defineProperty(exports, "btoa", { enumerable: true, get: function() {\n    return TextEncoderDecoder_js_1.PonyfillBtoa;\n  } });\n  var URL_js_1 = require_URL();\n  Object.defineProperty(exports, "URL", { enumerable: true, get: function() {\n    return URL_js_1.PonyfillURL;\n  } });\n  var URLSearchParams_js_1 = require_URLSearchParams();\n  Object.defineProperty(exports, "URLSearchParams", { enumerable: true, get: function() {\n    return URLSearchParams_js_1.PonyfillURLSearchParams;\n  } });\n  var WritableStream_js_1 = require_WritableStream();\n  Object.defineProperty(exports, "WritableStream", { enumerable: true, get: function() {\n    return WritableStream_js_1.PonyfillWritableStream;\n  } });\n  var TransformStream_js_1 = require_TransformStream();\n  Object.defineProperty(exports, "TransformStream", { enumerable: true, get: function() {\n    return TransformStream_js_1.PonyfillTransformStream;\n  } });\n  var CompressionStream_js_1 = require_CompressionStream();\n  Object.defineProperty(exports, "CompressionStream", { enumerable: true, get: function() {\n    return CompressionStream_js_1.PonyfillCompressionStream;\n  } });\n  var DecompressionStream_js_1 = require_DecompressionStream();\n  Object.defineProperty(exports, "DecompressionStream", { enumerable: true, get: function() {\n    return DecompressionStream_js_1.PonyfillDecompressionStream;\n  } });\n  var IteratorObject_js_1 = require_IteratorObject();\n  Object.defineProperty(exports, "IteratorObject", { enumerable: true, get: function() {\n    return IteratorObject_js_1.PonyfillIteratorObject;\n  } });\n  var TextEncoderDecoderStream_js_1 = require_TextEncoderDecoderStream();\n  Object.defineProperty(exports, "TextDecoderStream", { enumerable: true, get: function() {\n    return TextEncoderDecoderStream_js_1.PonyfillTextDecoderStream;\n  } });\n  Object.defineProperty(exports, "TextEncoderStream", { enumerable: true, get: function() {\n    return TextEncoderDecoderStream_js_1.PonyfillTextEncoderStream;\n  } });\n});\n\n// ../../node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js\nvar require_create_node_ponyfill = __commonJS((exports, module) => {\n  var shouldSkipPonyfill = require_shouldSkipPonyfill();\n  var newNodeFetch;\n  module.exports = function createNodePonyfill(opts = {}) {\n    const ponyfills = {};\n    ponyfills.URLPattern = globalThis.URLPattern;\n    if (!ponyfills.URLPattern) {\n      const urlPatternModule = require_urlpattern_polyfill();\n      ponyfills.URLPattern = urlPatternModule.URLPattern;\n    }\n    if (opts.skipPonyfill || shouldSkipPonyfill()) {\n      return {\n        fetch: globalThis.fetch,\n        Headers: globalThis.Headers,\n        Request: globalThis.Request,\n        Response: globalThis.Response,\n        FormData: globalThis.FormData,\n        ReadableStream: globalThis.ReadableStream,\n        WritableStream: globalThis.WritableStream,\n        TransformStream: globalThis.TransformStream,\n        CompressionStream: globalThis.CompressionStream,\n        DecompressionStream: globalThis.DecompressionStream,\n        TextDecoderStream: globalThis.TextDecoderStream,\n        TextEncoderStream: globalThis.TextEncoderStream,\n        Blob: globalThis.Blob,\n        File: globalThis.File,\n        crypto: globalThis.crypto,\n        btoa: globalThis.btoa,\n        TextEncoder: globalThis.TextEncoder,\n        TextDecoder: globalThis.TextDecoder,\n        URLPattern: ponyfills.URLPattern,\n        URL: globalThis.URL,\n        URLSearchParams: globalThis.URLSearchParams\n      };\n    }\n    newNodeFetch ||= require_cjs3();\n    ponyfills.fetch = newNodeFetch.fetch;\n    ponyfills.Request = newNodeFetch.Request;\n    ponyfills.Response = newNodeFetch.Response;\n    ponyfills.Headers = newNodeFetch.Headers;\n    ponyfills.FormData = newNodeFetch.FormData;\n    ponyfills.ReadableStream = newNodeFetch.ReadableStream;\n    ponyfills.URL = newNodeFetch.URL;\n    ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;\n    ponyfills.WritableStream = newNodeFetch.WritableStream;\n    ponyfills.TransformStream = newNodeFetch.TransformStream;\n    ponyfills.CompressionStream = newNodeFetch.CompressionStream;\n    ponyfills.DecompressionStream = newNodeFetch.DecompressionStream;\n    ponyfills.TextDecoderStream = newNodeFetch.TextDecoderStream;\n    ponyfills.TextEncoderStream = newNodeFetch.TextEncoderStream;\n    ponyfills.Blob = newNodeFetch.Blob;\n    ponyfills.File = newNodeFetch.File;\n    ponyfills.crypto = globalThis.crypto;\n    ponyfills.btoa = newNodeFetch.btoa;\n    ponyfills.TextEncoder = newNodeFetch.TextEncoder;\n    ponyfills.TextDecoder = newNodeFetch.TextDecoder;\n    if (opts.formDataLimits) {\n      ponyfills.Body = class Body extends newNodeFetch.Body {\n        constructor(body, userOpts) {\n          super(body, {\n            formDataLimits: opts.formDataLimits,\n            ...userOpts\n          });\n        }\n      };\n      ponyfills.Request = class Request2 extends newNodeFetch.Request {\n        constructor(input, userOpts) {\n          super(input, {\n            formDataLimits: opts.formDataLimits,\n            ...userOpts\n          });\n        }\n      };\n      ponyfills.Response = class Response2 extends newNodeFetch.Response {\n        constructor(body, userOpts) {\n          super(body, {\n            formDataLimits: opts.formDataLimits,\n            ...userOpts\n          });\n        }\n      };\n    }\n    if (!ponyfills.crypto) {\n      const cryptoModule = __require("crypto");\n      ponyfills.crypto = cryptoModule.webcrypto;\n    }\n    return ponyfills;\n  };\n});\n\n// src/types.ts\nvar BlinkInvocationTokenHeader = "x-blink-invocation-token";\nvar InternalAPIServerURLEnvironmentVariable = "INTERNAL_BLINK_API_SERVER_URL";\nvar InternalAPIServerListenPortEnvironmentVariable = "INTERNAL_BLINK_API_SERVER_LISTEN_PORT";\nvar BlinkDeploymentTokenEnvironmentVariable = "BLINK_DEPLOYMENT_TOKEN";\nvar BlinkInvocationAuthTokenEnvironmentVariable = "BLINK_INVOCATION_AUTH_TOKEN";\n\n// ../../packages/blink/dist/node/context-Ch5QyxHM.js\nimport { AsyncLocalStorage as e } from "node:async_hooks";\nvar t = Symbol.for(`@blink/authContext`);\nfunction n() {\n  let n2 = globalThis;\n  return n2[t] || (n2[t] = new e), n2[t];\n}\nvar r = n();\nfunction i() {\n  return n().getStore()?.authToken;\n}\nfunction a(e2, t2) {\n  return n().run({ authToken: e2 }, t2);\n}\n\n// src/lambda/wrapper-lambda.ts\nimport { resolve } from "node:path";\nimport { Writable } from "node:stream";\n\n// ../api/src/routes/agents/me/me.client.ts\nclass AgentInvocationClient {\n  baseURL;\n  authToken;\n  deploymentToken;\n  constructor(options) {\n    this.baseURL = options?.baseURL ?? "https://blink.so";\n    this.authToken = options?.authToken;\n    this.deploymentToken = options?.deploymentToken;\n  }\n  async deleteStorage(key) {\n    const resp = await this.request("DELETE", `/api/agents/me/storage/${encodeURIComponent(key)}`);\n    await this.assertResponseStatus(resp, 204);\n  }\n  async setStorage(key, value, options) {\n    const searchParams = new URLSearchParams;\n    if (options?.ttl) {\n      searchParams.set("ttl", options.ttl.toString());\n    }\n    const resp = await this.request("PUT", `/api/agents/me/storage/${encodeURIComponent(key)}?${searchParams.toString()}`, value);\n    await this.assertResponseStatus(resp, 204);\n  }\n  async getStorage(key) {\n    const resp = await this.request("GET", `/api/agents/me/storage/${encodeURIComponent(key)}`);\n    if (resp.status === 404) {\n      return;\n    }\n    await this.assertResponseStatus(resp, 200);\n    return await resp.text();\n  }\n  async listStorage(prefix, options) {\n    const resp = await this.request("GET", `/api/agents/me/storage`, JSON.stringify({ prefix, limit: options?.limit, cursor: options?.cursor }));\n    await this.assertResponseStatus(resp, 200);\n    return await resp.json();\n  }\n  async upsertChat(key) {\n    const resp = await this.request("PUT", `/api/agents/me/chats/${encodeURIComponent(key)}`);\n    if (resp.status !== 200 && resp.status !== 204) {\n      await this.assertResponseStatus(resp, 200);\n    }\n    return await resp.json();\n  }\n  async sendMessages(key, request) {\n    const resp = await this.request("POST", `/api/agents/me/chats/${encodeURIComponent(key)}/messages`, JSON.stringify(request));\n    await this.assertResponseStatus(resp, 204);\n  }\n  async getChat(id) {\n    const resp = await this.request("GET", `/api/agents/me/chats/${encodeURIComponent(id)}`);\n    if (resp.status === 404) {\n      return;\n    }\n    await this.assertResponseStatus(resp, 200);\n    return await resp.json();\n  }\n  async deleteChat(id) {\n    const resp = await this.request("DELETE", `/api/agents/me/chats/${encodeURIComponent(id)}`);\n    await this.assertResponseStatus(resp, 204);\n  }\n  async startChat(id) {\n    const resp = await this.request("POST", `/api/agents/me/chats/${encodeURIComponent(id)}/start`);\n    await this.assertResponseStatus(resp, 204);\n  }\n  async stopChat(id) {\n    const resp = await this.request("POST", `/api/agents/me/chats/${encodeURIComponent(id)}/stop`);\n    await this.assertResponseStatus(resp, 204);\n  }\n  async getMessages(id) {\n    const resp = await this.request("GET", `/api/agents/me/chats/${encodeURIComponent(id)}/messages`);\n    await this.assertResponseStatus(resp, 200);\n    return await resp.json();\n  }\n  async deleteMessages(id, messageIds) {\n    const resp = await this.request("POST", `/api/agents/me/chats/${encodeURIComponent(id)}/messages/delete`, JSON.stringify({ message_ids: messageIds }));\n    await this.assertResponseStatus(resp, 204);\n  }\n  async proxyOtlpTraces(request) {\n    if (!this.authToken && !this.deploymentToken) {\n      const contentType = request.headers.get("content-type")?.toLowerCase() || "";\n      if (contentType.includes("application/x-protobuf")) {\n        return new Response(new Uint8Array(0), {\n          status: 200,\n          headers: { "Content-Type": "application/x-protobuf" }\n        });\n      }\n      return new Response(JSON.stringify({}), {\n        status: 200,\n        headers: { "Content-Type": "application/json" }\n      });\n    }\n    const hopByHopHeaders = new Set([\n      "transfer-encoding",\n      "content-length",\n      "host",\n      "connection",\n      "keep-alive",\n      "proxy-authenticate",\n      "proxy-authorization",\n      "te",\n      "trailer",\n      "upgrade"\n    ]);\n    const headers = {};\n    request.headers.forEach((value, key) => {\n      if (hopByHopHeaders.has(key.toLowerCase())) {\n        return;\n      }\n      headers[key] = value;\n    });\n    if (this.deploymentToken) {\n      headers.Authorization = `Bearer ${this.deploymentToken}`;\n    } else if (this.authToken) {\n      headers.Authorization = `Bearer ${this.authToken}`;\n    }\n    return this.request(request.method, `/api/otlp/v1/traces`, request.body ?? undefined, { headers });\n  }\n  async assertResponseStatus(resp, status) {\n    if (resp.status === status) {\n      return;\n    }\n    const body = await resp.text();\n    try {\n      const parsed = JSON.parse(body);\n      if (parsed.error) {\n        throw new Error(parsed.error);\n      }\n      throw new Error(body);\n    } catch (err) {\n      throw new Error(`Expected status ${status}, got ${resp.status}: ${body}`);\n    }\n  }\n  request(method, path, body, options) {\n    const url = new URL(path, this.baseURL);\n    const headers = new Headers;\n    if (this.authToken) {\n      headers.set("Authorization", `Bearer ${this.authToken}`);\n    }\n    if (typeof body === "string") {\n      headers.set("Content-Type", "application/json");\n    }\n    if (options?.headers) {\n      for (const [key, value] of Object.entries(options.headers)) {\n        headers.set(key, value);\n      }\n    }\n    let signal;\n    if (options?.timeout) {\n      signal = AbortSignal.timeout(options.timeout);\n    }\n    return fetch(url.toString(), {\n      method,\n      headers,\n      body,\n      signal,\n      duplex: body ? "half" : undefined\n    });\n  }\n}\n\n// ../../node_modules/@whatwg-node/promise-helpers/esm/index.js\nvar kFakePromise = Symbol.for("@whatwg-node/promise-helpers/FakePromise");\nfunction isPromise(value) {\n  return value?.then != null;\n}\nfunction isActualPromise(value) {\n  const maybePromise = value;\n  return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;\n}\nfunction handleMaybePromise(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {\n  let result$ = fakePromise().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);\n  if (finallyFactory) {\n    result$ = result$.finally(finallyFactory);\n  }\n  return unfakePromise(result$);\n}\nfunction fakePromise(value) {\n  if (value && isActualPromise(value)) {\n    return value;\n  }\n  if (isPromise(value)) {\n    return {\n      then: (resolve, reject) => fakePromise(value.then(resolve, reject)),\n      catch: (reject) => fakePromise(value.then((res) => res, reject)),\n      finally: (cb) => fakePromise(cb ? promiseLikeFinally(value, cb) : value),\n      [Symbol.toStringTag]: "Promise"\n    };\n  }\n  return {\n    then(resolve) {\n      if (resolve) {\n        try {\n          return fakePromise(resolve(value));\n        } catch (err) {\n          return fakeRejectPromise(err);\n        }\n      }\n      return this;\n    },\n    catch() {\n      return this;\n    },\n    finally(cb) {\n      if (cb) {\n        try {\n          return fakePromise(cb()).then(() => value, () => value);\n        } catch (err) {\n          return fakeRejectPromise(err);\n        }\n      }\n      return this;\n    },\n    [Symbol.toStringTag]: "Promise",\n    __fakePromiseValue: value,\n    [kFakePromise]: "resolved"\n  };\n}\nfunction createDeferredPromise() {\n  if (Promise.withResolvers) {\n    return Promise.withResolvers();\n  }\n  let resolveFn;\n  let rejectFn;\n  const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {\n    resolveFn = resolve;\n    rejectFn = reject;\n  });\n  return {\n    promise,\n    get resolve() {\n      return resolveFn;\n    },\n    get reject() {\n      return rejectFn;\n    }\n  };\n}\nfunction iterateAsync(iterable, callback, results) {\n  if (iterable?.length === 0) {\n    return;\n  }\n  const iterator = iterable[Symbol.iterator]();\n  let index = 0;\n  function iterate() {\n    const { done: endOfIterator, value } = iterator.next();\n    if (endOfIterator) {\n      return;\n    }\n    let endedEarly = false;\n    function endEarly() {\n      endedEarly = true;\n    }\n    return handleMaybePromise(function handleCallback() {\n      return callback(value, endEarly, index++);\n    }, function handleCallbackResult(result) {\n      if (result) {\n        results?.push(result);\n      }\n      if (endedEarly) {\n        return;\n      }\n      return iterate();\n    });\n  }\n  return iterate();\n}\nfunction fakeRejectPromise(error) {\n  return {\n    then(_resolve, reject) {\n      if (reject) {\n        try {\n          return fakePromise(reject(error));\n        } catch (err) {\n          return fakeRejectPromise(err);\n        }\n      }\n      return this;\n    },\n    catch(reject) {\n      if (reject) {\n        try {\n          return fakePromise(reject(error));\n        } catch (err) {\n          return fakeRejectPromise(err);\n        }\n      }\n      return this;\n    },\n    finally(cb) {\n      if (cb) {\n        try {\n          cb();\n        } catch (err) {\n          return fakeRejectPromise(err);\n        }\n      }\n      return this;\n    },\n    __fakeRejectError: error,\n    [Symbol.toStringTag]: "Promise",\n    [kFakePromise]: "rejected"\n  };\n}\nfunction isFakePromise(value) {\n  return value?.[kFakePromise] === "resolved";\n}\nfunction isFakeRejectPromise(value) {\n  return value?.[kFakePromise] === "rejected";\n}\nfunction promiseLikeFinally(value, onFinally) {\n  if ("finally" in value) {\n    return value.finally(onFinally);\n  }\n  return value.then((res) => {\n    const finallyRes = onFinally();\n    return isPromise(finallyRes) ? finallyRes.then(() => res) : res;\n  }, (err) => {\n    const finallyRes = onFinally();\n    if (isPromise(finallyRes)) {\n      return finallyRes.then(() => {\n        throw err;\n      });\n    } else {\n      throw err;\n    }\n  });\n}\nfunction unfakePromise(promise) {\n  if (isFakePromise(promise)) {\n    return promise.__fakePromiseValue;\n  }\n  if (isFakeRejectPromise(promise)) {\n    throw promise.__fakeRejectError;\n  }\n  return promise;\n}\n\n// ../../node_modules/@envelop/instrumentation/esm/instrumentation.js\nfunction chain(first, next) {\n  const merged = { ...next, ...first };\n  for (const key of Object.keys(merged)) {\n    if (key in first && key in next) {\n      merged[key] = (payload, wrapped) => first[key](payload, () => next[key](payload, wrapped));\n    }\n  }\n  return merged;\n}\nvar getInstrumented = (payload) => ({\n  fn(instrument, wrapped) {\n    if (!instrument) {\n      return wrapped;\n    }\n    return (...args) => {\n      let result;\n      instrument(payload, () => {\n        result = wrapped(...args);\n      });\n      return result;\n    };\n  },\n  asyncFn(instrument, wrapped) {\n    if (!instrument) {\n      return wrapped;\n    }\n    return (...args) => {\n      let result;\n      return handleMaybePromise(() => instrument(payload, () => {\n        result = wrapped(...args);\n        return isPromise(result) ? result.then(() => {\n          return;\n        }) : undefined;\n      }), () => {\n        return result;\n      });\n    };\n  }\n});\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/SupressedError.js\nclass PonyfillSuppressedError extends Error {\n  error;\n  suppressed;\n  constructor(error, suppressed, message) {\n    super(message);\n    this.error = error;\n    this.suppressed = suppressed;\n    this.name = "SuppressedError";\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/symbols.js\nvar DisposableSymbols = {\n  get dispose() {\n    return Symbol.dispose || Symbol.for("dispose");\n  },\n  get asyncDispose() {\n    return Symbol.asyncDispose || Symbol.for("asyncDispose");\n  }\n};\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/utils.js\nfunction isSyncDisposable(obj) {\n  return obj?.[DisposableSymbols.dispose] != null;\n}\nfunction isAsyncDisposable(obj) {\n  return obj?.[DisposableSymbols.asyncDispose] != null;\n}\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/AsyncDisposableStack.js\nvar SuppressedError2 = globalThis.SuppressedError || PonyfillSuppressedError;\n\nclass PonyfillAsyncDisposableStack {\n  callbacks = [];\n  get disposed() {\n    return this.callbacks.length === 0;\n  }\n  use(value) {\n    if (isAsyncDisposable(value)) {\n      this.callbacks.push(() => value[DisposableSymbols.asyncDispose]());\n    } else if (isSyncDisposable(value)) {\n      this.callbacks.push(() => value[DisposableSymbols.dispose]());\n    }\n    return value;\n  }\n  adopt(value, onDisposeAsync) {\n    if (onDisposeAsync) {\n      this.callbacks.push(() => onDisposeAsync(value));\n    }\n    return value;\n  }\n  defer(onDisposeAsync) {\n    if (onDisposeAsync) {\n      this.callbacks.push(onDisposeAsync);\n    }\n  }\n  move() {\n    const stack = new PonyfillAsyncDisposableStack;\n    stack.callbacks = this.callbacks;\n    this.callbacks = [];\n    return stack;\n  }\n  disposeAsync() {\n    return this[DisposableSymbols.asyncDispose]();\n  }\n  _error;\n  _iterateCallbacks() {\n    const cb = this.callbacks.pop();\n    if (cb) {\n      return handleMaybePromise(cb, () => this._iterateCallbacks(), (error) => {\n        this._error = this._error ? new SuppressedError2(error, this._error) : error;\n        return this._iterateCallbacks();\n      });\n    }\n  }\n  [DisposableSymbols.asyncDispose]() {\n    const res$ = this._iterateCallbacks();\n    if (res$?.then) {\n      return res$.then(() => {\n        if (this._error) {\n          const error = this._error;\n          this._error = undefined;\n          throw error;\n        }\n      });\n    }\n    if (this._error) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n    return;\n  }\n  [Symbol.toStringTag] = "AsyncDisposableStack";\n}\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/DisposableStack.js\nvar SuppressedError3 = globalThis.SuppressedError || PonyfillSuppressedError;\n\nclass PonyfillDisposableStack {\n  callbacks = [];\n  get disposed() {\n    return this.callbacks.length === 0;\n  }\n  use(value) {\n    if (isSyncDisposable(value)) {\n      this.callbacks.push(() => value[DisposableSymbols.dispose]());\n    }\n    return value;\n  }\n  adopt(value, onDispose) {\n    if (onDispose) {\n      this.callbacks.push(() => onDispose(value));\n    }\n    return value;\n  }\n  defer(onDispose) {\n    if (onDispose) {\n      this.callbacks.push(onDispose);\n    }\n  }\n  move() {\n    const stack = new PonyfillDisposableStack;\n    stack.callbacks = this.callbacks;\n    this.callbacks = [];\n    return stack;\n  }\n  dispose() {\n    return this[DisposableSymbols.dispose]();\n  }\n  _error;\n  _iterateCallbacks() {\n    const cb = this.callbacks.pop();\n    if (cb) {\n      try {\n        cb();\n      } catch (error) {\n        this._error = this._error ? new SuppressedError3(error, this._error) : error;\n      }\n      return this._iterateCallbacks();\n    }\n  }\n  [DisposableSymbols.dispose]() {\n    this._iterateCallbacks();\n    if (this._error) {\n      const error = this._error;\n      this._error = undefined;\n      throw error;\n    }\n  }\n  [Symbol.toStringTag] = "DisposableStack";\n}\n\n// ../../node_modules/@whatwg-node/disposablestack/esm/index.js\nvar DisposableStack = globalThis.DisposableStack || PonyfillDisposableStack;\nvar AsyncDisposableStack = globalThis.AsyncDisposableStack || PonyfillAsyncDisposableStack;\nvar SuppressedError4 = globalThis.SuppressedError || PonyfillSuppressedError;\n\n// ../../node_modules/@whatwg-node/fetch/dist/node-ponyfill.js\nvar exports_node_ponyfill = {};\n__export(exports_node_ponyfill, {\n  fetch: () => $fetch,\n  crypto: () => $crypto,\n  createFetch: () => $createFetch,\n  btoa: () => $btoa,\n  WritableStream: () => $WritableStream,\n  URLSearchParams: () => $URLSearchParams,\n  URLPattern: () => $URLPattern,\n  URL: () => $URL,\n  TransformStream: () => $TransformStream,\n  TextEncoderStream: () => $TextEncoderStream,\n  TextEncoder: () => $TextEncoder,\n  TextDecoderStream: () => $TextDecoderStream,\n  TextDecoder: () => $TextDecoder,\n  Response: () => $Response,\n  Request: () => $Request,\n  ReadableStream: () => $ReadableStream,\n  Headers: () => $Headers,\n  FormData: () => $FormData,\n  File: () => $File,\n  DecompressionStream: () => $DecompressionStream,\n  CompressionStream: () => $CompressionStream,\n  Blob: () => $Blob\n});\nvar createNodePonyfill = require_create_node_ponyfill();\nvar shouldSkipPonyfill = require_shouldSkipPonyfill();\nvar ponyfills = createNodePonyfill();\nif (!shouldSkipPonyfill()) {\n  try {\n    const nodelibcurlName = "node-libcurl";\n    globalThis.libcurl = globalThis.libcurl || __require(nodelibcurlName);\n  } catch (e2) {}\n}\nvar $fetch = ponyfills.fetch;\nvar $Headers = ponyfills.Headers;\nvar $Request = ponyfills.Request;\nvar $Response = ponyfills.Response;\nvar $FormData = ponyfills.FormData;\nvar $ReadableStream = ponyfills.ReadableStream;\nvar $WritableStream = ponyfills.WritableStream;\nvar $TransformStream = ponyfills.TransformStream;\nvar $CompressionStream = ponyfills.CompressionStream;\nvar $DecompressionStream = ponyfills.DecompressionStream;\nvar $TextDecoderStream = ponyfills.TextDecoderStream;\nvar $TextEncoderStream = ponyfills.TextEncoderStream;\nvar $Blob = ponyfills.Blob;\nvar $File = ponyfills.File;\nvar $crypto = ponyfills.crypto;\nvar $btoa = ponyfills.btoa;\nvar $TextEncoder = ponyfills.TextEncoder;\nvar $TextDecoder = ponyfills.TextDecoder;\nvar $URLPattern = ponyfills.URLPattern;\nvar $URL = ponyfills.URL;\nvar $URLSearchParams = ponyfills.URLSearchParams;\nvar $createFetch = createNodePonyfill;\n// ../../node_modules/@whatwg-node/server/esm/utils.js\nfunction isAsyncIterable(body) {\n  return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";\n}\nfunction getPort(nodeRequest) {\n  if (nodeRequest.socket?.localPort) {\n    return nodeRequest.socket?.localPort;\n  }\n  const hostInHeader = nodeRequest.headers?.[":authority"] || nodeRequest.headers?.host;\n  const portInHeader = hostInHeader?.split(":")?.[1];\n  if (portInHeader) {\n    return portInHeader;\n  }\n  return 80;\n}\nfunction getHostnameWithPort(nodeRequest) {\n  if (nodeRequest.headers?.[":authority"]) {\n    return nodeRequest.headers?.[":authority"];\n  }\n  if (nodeRequest.headers?.host) {\n    return nodeRequest.headers?.host;\n  }\n  const port = getPort(nodeRequest);\n  if (nodeRequest.hostname) {\n    return nodeRequest.hostname + ":" + port;\n  }\n  const localIp = nodeRequest.socket?.localAddress;\n  if (localIp && !localIp?.includes("::") && !localIp?.includes("ffff")) {\n    return `${localIp}:${port}`;\n  }\n  return "localhost";\n}\nfunction buildFullUrl(nodeRequest) {\n  const hostnameWithPort = getHostnameWithPort(nodeRequest);\n  const protocol = nodeRequest.protocol || (nodeRequest.socket?.encrypted ? "https" : "http");\n  const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";\n  return `${protocol}://${hostnameWithPort}${endpoint}`;\n}\nfunction isRequestBody(body) {\n  const stringTag = body[Symbol.toStringTag];\n  if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable(body)) {\n    return true;\n  }\n  return false;\n}\nfunction normalizeNodeRequest(nodeRequest, fetchAPI, nodeResponse, __useCustomAbortCtrl) {\n  const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;\n  let fullUrl = buildFullUrl(rawRequest);\n  if (nodeRequest.query) {\n    const url = new fetchAPI.URL(fullUrl);\n    for (const key in nodeRequest.query) {\n      url.searchParams.set(key, nodeRequest.query[key]);\n    }\n    fullUrl = url.toString();\n  }\n  let normalizedHeaders = nodeRequest.headers;\n  if (nodeRequest.headers?.[":method"]) {\n    normalizedHeaders = {};\n    for (const key in nodeRequest.headers) {\n      if (!key.startsWith(":")) {\n        normalizedHeaders[key] = nodeRequest.headers[key];\n      }\n    }\n  }\n  const controller = __useCustomAbortCtrl ? createCustomAbortControllerSignal() : new AbortController;\n  if (nodeResponse?.once) {\n    const closeEventListener = () => {\n      if (!controller.signal.aborted) {\n        Object.defineProperty(rawRequest, "aborted", { value: true });\n        controller.abort(nodeResponse.errored ?? undefined);\n      }\n    };\n    nodeResponse.once("error", closeEventListener);\n    nodeResponse.once("close", closeEventListener);\n    nodeResponse.once("finish", () => {\n      nodeResponse.removeListener("close", closeEventListener);\n    });\n  }\n  if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {\n    return new fetchAPI.Request(fullUrl, {\n      method: nodeRequest.method,\n      headers: normalizedHeaders,\n      signal: controller.signal\n    });\n  }\n  const maybeParsedBody = nodeRequest.body;\n  if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {\n    if (isRequestBody(maybeParsedBody)) {\n      return new fetchAPI.Request(fullUrl, {\n        method: nodeRequest.method || "GET",\n        headers: normalizedHeaders,\n        body: maybeParsedBody,\n        signal: controller.signal\n      });\n    }\n    const request = new fetchAPI.Request(fullUrl, {\n      method: nodeRequest.method || "GET",\n      headers: normalizedHeaders,\n      signal: controller.signal\n    });\n    if (!request.headers.get("content-type")?.includes("json")) {\n      request.headers.set("content-type", "application/json; charset=utf-8");\n    }\n    return new Proxy(request, {\n      get: (target, prop, receiver) => {\n        switch (prop) {\n          case "json":\n            return () => fakePromise(maybeParsedBody);\n          case "text":\n            return () => fakePromise(JSON.stringify(maybeParsedBody));\n          default:\n            if (globalThis.Bun) {\n              return Reflect.get(target, prop);\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n      }\n    });\n  }\n  return new fetchAPI.Request(fullUrl, {\n    method: nodeRequest.method,\n    headers: normalizedHeaders,\n    signal: controller.signal,\n    body: rawRequest,\n    duplex: "half"\n  });\n}\nfunction isReadable(stream) {\n  return stream.read != null;\n}\nfunction isNodeRequest(request) {\n  return isReadable(request);\n}\nfunction isServerResponse(stream) {\n  return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;\n}\nfunction isReadableStream(stream) {\n  return stream != null && stream.getReader != null;\n}\nfunction isFetchEvent(event) {\n  return event != null && event.request != null && event.respondWith != null;\n}\nfunction configureSocket(rawRequest) {\n  rawRequest?.socket?.setTimeout?.(0);\n  rawRequest?.socket?.setNoDelay?.(true);\n  rawRequest?.socket?.setKeepAlive?.(true);\n}\nfunction endResponse(serverResponse) {\n  serverResponse.end(null, null, null);\n}\nfunction sendAsyncIterable(serverResponse, asyncIterable) {\n  let closed = false;\n  const closeEventListener = () => {\n    closed = true;\n  };\n  serverResponse.once("error", closeEventListener);\n  serverResponse.once("close", closeEventListener);\n  serverResponse.once("finish", () => {\n    serverResponse.removeListener("close", closeEventListener);\n    serverResponse.removeListener("error", closeEventListener);\n  });\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  const pump = () => iterator.next().then(({ done, value }) => {\n    if (closed || done) {\n      return;\n    }\n    return handleMaybePromise(() => safeWrite(value, serverResponse), () => closed ? endResponse(serverResponse) : pump());\n  });\n  return pump();\n}\nfunction safeWrite(chunk, serverResponse) {\n  const result = serverResponse.write(chunk);\n  if (!result) {\n    return new Promise((resolve) => serverResponse.once("drain", resolve));\n  }\n}\nfunction sendNodeResponse(fetchResponse, serverResponse, nodeRequest, __useSingleWriteHead) {\n  if (serverResponse.closed || serverResponse.destroyed || serverResponse.writableEnded) {\n    return;\n  }\n  if (!fetchResponse) {\n    serverResponse.statusCode = 404;\n    endResponse(serverResponse);\n    return;\n  }\n  if (__useSingleWriteHead && fetchResponse.headers?.headersInit && !Array.isArray(fetchResponse.headers.headersInit) && !fetchResponse.headers.headersInit.get && !fetchResponse.headers._map && !fetchResponse.headers._setCookies?.length) {\n    serverResponse.writeHead(fetchResponse.status, fetchResponse.statusText, fetchResponse.headers.headersInit);\n  } else {\n    if (serverResponse.setHeaders) {\n      serverResponse.setHeaders(fetchResponse.headers);\n    } else {\n      let setCookiesSet = false;\n      fetchResponse.headers.forEach((value, key) => {\n        if (key === "set-cookie") {\n          if (setCookiesSet) {\n            return;\n          }\n          setCookiesSet = true;\n          const setCookies = fetchResponse.headers.getSetCookie?.();\n          if (setCookies) {\n            serverResponse.setHeader("set-cookie", setCookies);\n            return;\n          }\n        }\n        serverResponse.setHeader(key, value);\n      });\n    }\n    serverResponse.writeHead(fetchResponse.status, fetchResponse.statusText);\n  }\n  if (fetchResponse["bodyType"] === "String") {\n    return handleMaybePromise(() => safeWrite(fetchResponse.bodyInit, serverResponse), () => endResponse(serverResponse));\n  }\n  const bufOfRes = fetchResponse._buffer;\n  if (bufOfRes) {\n    return handleMaybePromise(() => safeWrite(bufOfRes, serverResponse), () => endResponse(serverResponse));\n  }\n  const fetchBody = fetchResponse.body;\n  if (fetchBody == null) {\n    endResponse(serverResponse);\n    return;\n  }\n  if (fetchBody[Symbol.toStringTag] === "Uint8Array") {\n    return handleMaybePromise(() => safeWrite(fetchBody, serverResponse), () => endResponse(serverResponse));\n  }\n  configureSocket(nodeRequest);\n  if (isReadable(fetchBody)) {\n    serverResponse.once("close", () => {\n      fetchBody.destroy();\n    });\n    fetchBody.pipe(serverResponse, {\n      end: true\n    });\n    return;\n  }\n  if (isReadableStream(fetchBody)) {\n    return sendReadableStream(nodeRequest, serverResponse, fetchBody);\n  }\n  if (isAsyncIterable(fetchBody)) {\n    return sendAsyncIterable(serverResponse, fetchBody);\n  }\n}\nfunction sendReadableStream(nodeRequest, serverResponse, readableStream) {\n  const reader = readableStream.getReader();\n  nodeRequest?.once?.("error", (err) => {\n    reader.cancel(err);\n  });\n  function pump() {\n    return reader.read().then(({ done, value }) => done ? endResponse(serverResponse) : handleMaybePromise(() => safeWrite(value, serverResponse), pump));\n  }\n  return pump();\n}\nfunction isRequestInit(val) {\n  return val != null && typeof val === "object" && (("body" in val) || ("cache" in val) || ("credentials" in val) || ("headers" in val) || ("integrity" in val) || ("keepalive" in val) || ("method" in val) || ("mode" in val) || ("redirect" in val) || ("referrer" in val) || ("referrerPolicy" in val) || ("signal" in val) || ("window" in val));\n}\nfunction completeAssign(...args) {\n  const [target, ...sources] = args.filter((arg) => arg != null && typeof arg === "object");\n  sources.forEach((source) => {\n    const descriptors = Object.getOwnPropertyNames(source).reduce((descriptors2, key) => {\n      const descriptor = Object.getOwnPropertyDescriptor(source, key);\n      if (descriptor) {\n        descriptors2[key] = Object.getOwnPropertyDescriptor(source, key);\n      }\n      return descriptors2;\n    }, {});\n    Object.getOwnPropertySymbols(source).forEach((sym) => {\n      const descriptor = Object.getOwnPropertyDescriptor(source, sym);\n      if (descriptor?.enumerable) {\n        descriptors[sym] = descriptor;\n      }\n    });\n    Object.defineProperties(target, descriptors);\n  });\n  return target;\n}\nfunction handleErrorFromRequestHandler(error, ResponseCtor) {\n  return new ResponseCtor(error.stack || error.message || error.toString(), {\n    status: error.status || 500\n  });\n}\nfunction isolateObject(originalCtx, waitUntilFn) {\n  if (originalCtx == null) {\n    if (waitUntilFn == null) {\n      return {};\n    }\n    return {\n      waitUntil: waitUntilFn\n    };\n  }\n  return completeAssign(Object.create(originalCtx), {\n    waitUntil: waitUntilFn\n  }, originalCtx);\n}\nfunction handleAbortSignalAndPromiseResponse(response$, abortSignal) {\n  if (abortSignal?.aborted) {\n    throw abortSignal.reason;\n  }\n  if (isPromise(response$) && abortSignal) {\n    let abortSignalFetchErrorHandler = function() {\n      deferred$.reject(abortSignal.reason);\n    };\n    const deferred$ = createDeferredPromise();\n    abortSignal.addEventListener("abort", abortSignalFetchErrorHandler, { once: true });\n    response$.then(function fetchSuccessHandler(res) {\n      deferred$.resolve(res);\n    }).catch(function fetchErrorHandler(err) {\n      deferred$.reject(err);\n    }).finally(() => {\n      abortSignal.removeEventListener("abort", abortSignalFetchErrorHandler);\n    });\n    return deferred$.promise;\n  }\n  return response$;\n}\nvar decompressedResponseMap = new WeakMap;\nvar supportedEncodingsByFetchAPI = new WeakMap;\nvar terminateEvents = ["SIGINT", "exit", "SIGTERM"];\nvar disposableStacks = new Set;\nvar eventListenerRegistered = false;\nfunction ensureEventListenerForDisposableStacks() {\n  if (eventListenerRegistered) {\n    return;\n  }\n  eventListenerRegistered = true;\n  for (const event of terminateEvents) {\n    globalThis.process.once(event, function terminateHandler() {\n      return Promise.allSettled([...disposableStacks].map((stack) => !stack.disposed && stack.disposeAsync()));\n    });\n  }\n}\nfunction ensureDisposableStackRegisteredForTerminateEvents(disposableStack) {\n  if (globalThis.process) {\n    ensureEventListenerForDisposableStacks();\n    if (!disposableStacks.has(disposableStack)) {\n      disposableStacks.add(disposableStack);\n      disposableStack.defer(() => {\n        disposableStacks.delete(disposableStack);\n      });\n    }\n  }\n}\n\nclass CustomAbortControllerSignal extends EventTarget {\n  aborted = false;\n  _onabort = null;\n  _reason;\n  constructor() {\n    super();\n    const nodeEvents = globalThis.process?.getBuiltinModule?.("node:events");\n    if (nodeEvents?.kMaxEventTargetListeners) {\n      this[nodeEvents.kMaxEventTargetListeners] = 0;\n    }\n  }\n  throwIfAborted() {\n    if (this._nativeCtrl?.signal?.throwIfAborted) {\n      return this._nativeCtrl.signal.throwIfAborted();\n    }\n    if (this.aborted) {\n      throw this._reason;\n    }\n  }\n  _nativeCtrl;\n  ensureNativeCtrl() {\n    if (!this._nativeCtrl) {\n      const isAborted = this.aborted;\n      this._nativeCtrl = new AbortController;\n      if (isAborted) {\n        this._nativeCtrl.abort(this._reason);\n      }\n    }\n    return this._nativeCtrl;\n  }\n  abort(reason) {\n    if (this._nativeCtrl?.abort) {\n      return this._nativeCtrl?.abort(reason);\n    }\n    this._reason = reason || new DOMException("This operation was aborted", "AbortError");\n    this.aborted = true;\n    this.dispatchEvent(new Event("abort"));\n  }\n  get signal() {\n    if (this._nativeCtrl?.signal) {\n      return this._nativeCtrl.signal;\n    }\n    return this;\n  }\n  get reason() {\n    if (this._nativeCtrl?.signal) {\n      return this._nativeCtrl.signal.reason;\n    }\n    return this._reason;\n  }\n  get onabort() {\n    if (this._onabort) {\n      return this._onabort;\n    }\n    return this._onabort;\n  }\n  set onabort(value) {\n    if (this._nativeCtrl?.signal) {\n      this._nativeCtrl.signal.onabort = value;\n      return;\n    }\n    if (this._onabort) {\n      this.removeEventListener("abort", this._onabort);\n    }\n    this._onabort = value;\n    if (value) {\n      this.addEventListener("abort", value);\n    }\n  }\n}\nfunction createCustomAbortControllerSignal() {\n  if (globalThis.Bun || globalThis.Deno) {\n    return new AbortController;\n  }\n  return new Proxy(new CustomAbortControllerSignal, {\n    get(target, prop, receiver) {\n      if (prop.toString().includes("kDependantSignals")) {\n        const nativeCtrl = target.ensureNativeCtrl();\n        return Reflect.get(nativeCtrl.signal, prop, nativeCtrl.signal);\n      }\n      return Reflect.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n      if (prop.toString().includes("kDependantSignals")) {\n        const nativeCtrl = target.ensureNativeCtrl();\n        return Reflect.set(nativeCtrl.signal, prop, value, nativeCtrl.signal);\n      }\n      return Reflect.set(target, prop, value, receiver);\n    },\n    getPrototypeOf() {\n      return AbortSignal.prototype;\n    }\n  });\n}\n\n// ../../node_modules/@whatwg-node/server/esm/uwebsockets.js\nfunction isUWSResponse(res) {\n  return !!res.onData;\n}\nfunction getRequestFromUWSRequest({ req, res, fetchAPI, controller }) {\n  const method = req.getMethod();\n  let duplex;\n  const chunks = [];\n  const pushFns = [\n    (chunk) => {\n      chunks.push(chunk);\n    }\n  ];\n  const push = (chunk) => {\n    for (const pushFn of pushFns) {\n      pushFn(chunk);\n    }\n  };\n  let stopped = false;\n  const stopFns = [\n    () => {\n      stopped = true;\n    }\n  ];\n  const stop = () => {\n    for (const stopFn of stopFns) {\n      stopFn();\n    }\n  };\n  res.onData(function(ab, isLast) {\n    push(Buffer.from(Buffer.from(ab, 0, ab.byteLength)));\n    if (isLast) {\n      stop();\n    }\n  });\n  let getReadableStream;\n  if (method !== "get" && method !== "head") {\n    duplex = "half";\n    controller.signal.addEventListener("abort", () => {\n      stop();\n    }, { once: true });\n    let readableStream;\n    getReadableStream = () => {\n      if (!readableStream) {\n        readableStream = new fetchAPI.ReadableStream({\n          start(streamCtrl) {\n            for (const chunk of chunks) {\n              streamCtrl.enqueue(chunk);\n            }\n            if (stopped) {\n              streamCtrl.close();\n              return;\n            }\n            pushFns.push((chunk) => {\n              streamCtrl.enqueue(chunk);\n            });\n            stopFns.push(() => {\n              if (controller.signal.reason) {\n                streamCtrl.error(controller.signal.reason);\n                return;\n              }\n              if (streamCtrl.desiredSize) {\n                streamCtrl.close();\n              }\n            });\n          }\n        });\n      }\n      return readableStream;\n    };\n  }\n  const headers = new fetchAPI.Headers;\n  req.forEach((key, value) => {\n    headers.append(key, value);\n  });\n  let url = `http://localhost${req.getUrl()}`;\n  const query = req.getQuery();\n  if (query) {\n    url += `?${query}`;\n  }\n  let buffer;\n  function getBody() {\n    if (!getReadableStream) {\n      return null;\n    }\n    if (stopped) {\n      return getBufferFromChunks();\n    }\n    return getReadableStream();\n  }\n  const request = new fetchAPI.Request(url, {\n    method,\n    headers,\n    get body() {\n      return getBody();\n    },\n    signal: controller.signal,\n    duplex\n  });\n  function getBufferFromChunks() {\n    if (!buffer) {\n      buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks);\n    }\n    return buffer;\n  }\n  function collectBuffer() {\n    if (stopped) {\n      return fakePromise(getBufferFromChunks());\n    }\n    return new Promise((resolve, reject) => {\n      try {\n        stopFns.push(() => {\n          resolve(getBufferFromChunks());\n        });\n      } catch (e2) {\n        reject(e2);\n      }\n    });\n  }\n  Object.defineProperties(request, {\n    body: {\n      get() {\n        return getBody();\n      },\n      configurable: true,\n      enumerable: true\n    },\n    json: {\n      value() {\n        return collectBuffer().then((b) => b.toString("utf8")).then((t2) => JSON.parse(t2));\n      },\n      configurable: true,\n      enumerable: true\n    },\n    text: {\n      value() {\n        return collectBuffer().then((b) => b.toString("utf8"));\n      },\n      configurable: true,\n      enumerable: true\n    },\n    arrayBuffer: {\n      value() {\n        return collectBuffer();\n      },\n      configurable: true,\n      enumerable: true\n    }\n  });\n  return request;\n}\nfunction createWritableFromUWS(uwsResponse, fetchAPI) {\n  return new fetchAPI.WritableStream({\n    write(chunk) {\n      uwsResponse.cork(() => {\n        uwsResponse.write(chunk);\n      });\n    },\n    close() {\n      uwsResponse.cork(() => {\n        uwsResponse.end();\n      });\n    }\n  });\n}\nfunction sendResponseToUwsOpts(uwsResponse, fetchResponse, controller, fetchAPI) {\n  if (!fetchResponse) {\n    uwsResponse.writeStatus("404 Not Found");\n    uwsResponse.end();\n    return;\n  }\n  const bufferOfRes = fetchResponse._buffer;\n  const strBody = fetchResponse["bodyType"] === "String" ? fetchResponse.bodyInit : undefined;\n  if (controller.signal.aborted) {\n    return;\n  }\n  uwsResponse.cork(() => {\n    uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);\n    for (const [key, value] of fetchResponse.headers) {\n      if (key !== "content-length") {\n        if (key === "set-cookie") {\n          const setCookies = fetchResponse.headers.getSetCookie?.();\n          if (setCookies) {\n            for (const setCookie of setCookies) {\n              uwsResponse.writeHeader(key, setCookie);\n            }\n            continue;\n          }\n        }\n        uwsResponse.writeHeader(key, value);\n      }\n    }\n    if (strBody) {\n      uwsResponse.end(strBody);\n    } else if (bufferOfRes) {\n      uwsResponse.end(bufferOfRes);\n    } else if (!fetchResponse.body) {\n      uwsResponse.end();\n    }\n  });\n  if (strBody || bufferOfRes || !fetchResponse.body) {\n    return;\n  }\n  controller.signal.addEventListener("abort", () => {\n    if (!fetchResponse.body?.locked) {\n      fetchResponse.body?.cancel(controller.signal.reason);\n    }\n  }, { once: true });\n  return fetchResponse.body.pipeTo(createWritableFromUWS(uwsResponse, fetchAPI), {\n    signal: controller.signal\n  }).catch((err) => {\n    if (controller.signal.aborted) {\n      return;\n    }\n    throw err;\n  });\n}\n\n// ../../node_modules/@whatwg-node/server/esm/createServerAdapter.js\nfunction isRequestAccessible(serverContext) {\n  try {\n    return !!serverContext?.request;\n  } catch {\n    return false;\n  }\n}\nvar EMPTY_OBJECT = {};\nfunction createServerAdapter(serverAdapterBaseObject, options) {\n  const useSingleWriteHead = options?.__useSingleWriteHead == null ? true : options.__useSingleWriteHead;\n  const fetchAPI = {\n    ...exports_node_ponyfill,\n    ...options?.fetchAPI\n  };\n  const useCustomAbortCtrl = options?.__useCustomAbortCtrl == null ? fetchAPI.Request !== globalThis.Request : options.__useCustomAbortCtrl;\n  const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;\n  const onRequestHooks = [];\n  const onResponseHooks = [];\n  let instrumentation;\n  const waitUntilPromises = new Set;\n  let _disposableStack;\n  function ensureDisposableStack() {\n    if (!_disposableStack) {\n      _disposableStack = new AsyncDisposableStack;\n      if (options?.disposeOnProcessTerminate) {\n        ensureDisposableStackRegisteredForTerminateEvents(_disposableStack);\n      }\n      _disposableStack.defer(() => {\n        if (waitUntilPromises.size > 0) {\n          return Promise.allSettled(waitUntilPromises).then(() => {\n            waitUntilPromises.clear();\n          }, () => {\n            waitUntilPromises.clear();\n          });\n        }\n      });\n    }\n    return _disposableStack;\n  }\n  function waitUntil(maybePromise) {\n    if (isPromise(maybePromise)) {\n      ensureDisposableStack();\n      waitUntilPromises.add(maybePromise);\n      maybePromise.then(() => {\n        waitUntilPromises.delete(maybePromise);\n      }, (err) => {\n        console.error(`Unexpected error while waiting: ${err.message || err}`);\n        waitUntilPromises.delete(maybePromise);\n      });\n    }\n  }\n  if (options?.plugins != null) {\n    for (const plugin of options.plugins) {\n      if (plugin.instrumentation) {\n        instrumentation = instrumentation ? chain(instrumentation, plugin.instrumentation) : plugin.instrumentation;\n      }\n      if (plugin.onRequest) {\n        onRequestHooks.push(plugin.onRequest);\n      }\n      if (plugin.onResponse) {\n        onResponseHooks.push(plugin.onResponse);\n      }\n      const disposeFn = plugin[DisposableSymbols.dispose];\n      if (disposeFn) {\n        ensureDisposableStack().defer(disposeFn);\n      }\n      const asyncDisposeFn = plugin[DisposableSymbols.asyncDispose];\n      if (asyncDisposeFn) {\n        ensureDisposableStack().defer(asyncDisposeFn);\n      }\n      if (plugin.onDispose) {\n        ensureDisposableStack().defer(plugin.onDispose);\n      }\n    }\n  }\n  let handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0 ? function handleRequest(request, serverContext) {\n    let requestHandler = givenHandleRequest;\n    let response;\n    if (onRequestHooks.length === 0) {\n      return handleEarlyResponse();\n    }\n    let url = request["parsedUrl"] || new Proxy(EMPTY_OBJECT, {\n      get(_target, prop, _receiver) {\n        url = new fetchAPI.URL(request.url, "http://localhost");\n        return Reflect.get(url, prop, url);\n      }\n    });\n    function handleResponse(response2) {\n      if (onResponseHooks.length === 0) {\n        return response2;\n      }\n      return handleMaybePromise(() => iterateAsync(onResponseHooks, (onResponseHook) => onResponseHook({\n        request,\n        response: response2,\n        serverContext,\n        setResponse(newResponse) {\n          response2 = newResponse;\n        },\n        fetchAPI\n      })), () => response2);\n    }\n    function handleEarlyResponse() {\n      if (!response) {\n        return handleMaybePromise(() => requestHandler(request, serverContext), handleResponse);\n      }\n      return handleResponse(response);\n    }\n    return handleMaybePromise(() => iterateAsync(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({\n      request,\n      setRequest(newRequest) {\n        request = newRequest;\n      },\n      serverContext,\n      fetchAPI,\n      url,\n      requestHandler,\n      setRequestHandler(newRequestHandler) {\n        requestHandler = newRequestHandler;\n      },\n      endResponse(newResponse) {\n        response = newResponse;\n        if (newResponse) {\n          stopEarly();\n        }\n      }\n    })), handleEarlyResponse);\n  } : givenHandleRequest;\n  if (instrumentation?.request) {\n    const originalRequestHandler = handleRequest;\n    handleRequest = (request, initialContext) => {\n      return getInstrumented({ request }).asyncFn(instrumentation.request, originalRequestHandler)(request, initialContext);\n    };\n  }\n  function handleNodeRequest(nodeRequest, ...ctx) {\n    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};\n    if (!serverContext.waitUntil) {\n      serverContext.waitUntil = waitUntil;\n    }\n    const request = normalizeNodeRequest(nodeRequest, fetchAPI, undefined, useCustomAbortCtrl);\n    return handleRequest(request, serverContext);\n  }\n  function handleNodeRequestAndResponse(nodeRequest, nodeResponseOrContainer, ...ctx) {\n    const nodeResponse = nodeResponseOrContainer.raw || nodeResponseOrContainer;\n    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};\n    if (!serverContext.waitUntil) {\n      serverContext.waitUntil = waitUntil;\n    }\n    const request = normalizeNodeRequest(nodeRequest, fetchAPI, nodeResponse, useCustomAbortCtrl);\n    return handleRequest(request, serverContext);\n  }\n  function requestListener(nodeRequest, nodeResponse, ...ctx) {\n    const defaultServerContext = {\n      req: nodeRequest,\n      res: nodeResponse,\n      waitUntil\n    };\n    return unfakePromise(fakePromise().then(() => handleNodeRequestAndResponse(nodeRequest, nodeResponse, defaultServerContext, ...ctx)).catch((err) => handleErrorFromRequestHandler(err, fetchAPI.Response)).then((response) => sendNodeResponse(response, nodeResponse, nodeRequest, useSingleWriteHead)).catch((err) => console.error(`Unexpected error while handling request: ${err.message || err}`)));\n  }\n  function handleUWS(res, req, ...ctx) {\n    const defaultServerContext = {\n      res,\n      req,\n      waitUntil\n    };\n    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);\n    const serverContext = filteredCtxParts.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;\n    const controller = useCustomAbortCtrl ? createCustomAbortControllerSignal() : new AbortController;\n    const originalResEnd = res.end.bind(res);\n    let resEnded = false;\n    res.end = function(data) {\n      resEnded = true;\n      return originalResEnd(data);\n    };\n    const originalOnAborted = res.onAborted.bind(res);\n    originalOnAborted(function() {\n      controller.abort();\n    });\n    res.onAborted = function(cb) {\n      controller.signal.addEventListener("abort", cb, { once: true });\n    };\n    const request = getRequestFromUWSRequest({\n      req,\n      res,\n      fetchAPI,\n      controller\n    });\n    return handleMaybePromise(() => handleMaybePromise(() => handleRequest(request, serverContext), (response) => response, (err) => handleErrorFromRequestHandler(err, fetchAPI.Response)), (response) => {\n      if (!controller.signal.aborted && !resEnded) {\n        return handleMaybePromise(() => sendResponseToUwsOpts(res, response, controller, fetchAPI), (r2) => r2, (err) => {\n          console.error(`Unexpected error while handling request: ${err.message || err}`);\n        });\n      }\n    });\n  }\n  function handleEvent(event, ...ctx) {\n    if (!event.respondWith || !event.request) {\n      throw new TypeError(`Expected FetchEvent, got ${event}`);\n    }\n    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);\n    const serverContext = filteredCtxParts.length > 0 ? completeAssign({}, event, ...filteredCtxParts) : isolateObject(event);\n    const response$ = handleRequest(event.request, serverContext);\n    event.respondWith(response$);\n  }\n  function handleRequestWithWaitUntil(request, ...ctx) {\n    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);\n    const serverContext = filteredCtxParts.length > 1 ? completeAssign({}, ...filteredCtxParts) : isolateObject(filteredCtxParts[0], filteredCtxParts[0] == null || filteredCtxParts[0].waitUntil == null ? waitUntil : undefined);\n    return handleRequest(request, serverContext);\n  }\n  const fetchFn = (input, ...maybeCtx) => {\n    if (typeof input === "string" || "href" in input) {\n      const [initOrCtx, ...restOfCtx] = maybeCtx;\n      if (isRequestInit(initOrCtx)) {\n        const request2 = new fetchAPI.Request(input, initOrCtx);\n        const res$2 = handleRequestWithWaitUntil(request2, ...restOfCtx);\n        const signal = initOrCtx.signal;\n        if (signal) {\n          return handleAbortSignalAndPromiseResponse(res$2, signal);\n        }\n        return res$2;\n      }\n      const request = new fetchAPI.Request(input);\n      return handleRequestWithWaitUntil(request, ...maybeCtx);\n    }\n    const res$ = handleRequestWithWaitUntil(input, ...maybeCtx);\n    return handleAbortSignalAndPromiseResponse(res$, input.signal);\n  };\n  const genericRequestHandler = (input, ...maybeCtx) => {\n    const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;\n    if (isNodeRequest(input)) {\n      if (!isServerResponse(initOrCtxOrRes)) {\n        throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);\n      }\n      return requestListener(input, initOrCtxOrRes, ...restOfCtx);\n    }\n    if (isUWSResponse(input)) {\n      return handleUWS(input, initOrCtxOrRes, ...restOfCtx);\n    }\n    if (isServerResponse(initOrCtxOrRes)) {\n      throw new TypeError("Got Node response without Node request");\n    }\n    if (isRequestAccessible(input)) {\n      if (isFetchEvent(input)) {\n        return handleEvent(input, ...maybeCtx);\n      }\n      return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);\n    }\n    return fetchFn(input, ...maybeCtx);\n  };\n  const adapterObj = {\n    handleRequest: handleRequestWithWaitUntil,\n    fetch: fetchFn,\n    handleNodeRequest,\n    handleNodeRequestAndResponse,\n    requestListener,\n    handleEvent,\n    handleUWS,\n    handle: genericRequestHandler,\n    get disposableStack() {\n      return ensureDisposableStack();\n    },\n    [DisposableSymbols.asyncDispose]() {\n      if (_disposableStack && !_disposableStack.disposed) {\n        return _disposableStack.disposeAsync();\n      }\n      return fakePromise();\n    },\n    dispose() {\n      if (_disposableStack && !_disposableStack.disposed) {\n        return _disposableStack.disposeAsync();\n      }\n      return fakePromise();\n    },\n    waitUntil\n  };\n  const serverAdapter = new Proxy(genericRequestHandler, {\n    has: (_, prop) => {\n      return prop in adapterObj || prop in genericRequestHandler || serverAdapterBaseObject && prop in serverAdapterBaseObject;\n    },\n    get: (_, prop) => {\n      if (globalThis.Deno || prop === Symbol.asyncDispose || prop === Symbol.dispose) {\n        const adapterProp2 = Reflect.get(adapterObj, prop, adapterObj);\n        if (adapterProp2) {\n          return adapterProp2;\n        }\n      }\n      const adapterProp = adapterObj[prop];\n      if (adapterProp) {\n        if (adapterProp.bind) {\n          return adapterProp.bind(adapterObj);\n        }\n        return adapterProp;\n      }\n      const handleProp = genericRequestHandler[prop];\n      if (handleProp) {\n        if (handleProp.bind) {\n          return handleProp.bind(genericRequestHandler);\n        }\n        return handleProp;\n      }\n      if (serverAdapterBaseObject) {\n        const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];\n        if (serverAdapterBaseObjectProp) {\n          if (serverAdapterBaseObjectProp.bind) {\n            return function(...args) {\n              const returnedVal = serverAdapterBaseObject[prop](...args);\n              if (returnedVal === serverAdapterBaseObject) {\n                return serverAdapter;\n              }\n              return returnedVal;\n            };\n          }\n          return serverAdapterBaseObjectProp;\n        }\n      }\n    },\n    apply(_, __, args) {\n      return genericRequestHandler(...args);\n    }\n  });\n  return serverAdapter;\n}\n\n// ../../node_modules/@ai-sdk/provider/dist/index.mjs\nvar marker = "vercel.ai.error";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError2 extends Error {\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  static isInstance(error) {\n    return _AISDKError2.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\nvar name = "AI_APICallError";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\n_a2 = symbol2;\nvar name2 = "AI_EmptyResponseBodyError";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\n_a3 = symbol3;\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return "unknown error";\n  }\n  if (typeof error === "string") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\nvar name3 = "AI_InvalidArgumentError";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\nvar name4 = "AI_InvalidPromptError";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\n_a5 = symbol5;\nvar name5 = "AI_InvalidResponseDataError";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\n_a6 = symbol6;\nvar name6 = "AI_JSONParseError";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\nvar name7 = "AI_LoadAPIKeyError";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\n_a8 = symbol8;\nvar name8 = "AI_LoadSettingError";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\n_a9 = symbol9;\nvar name9 = "AI_NoContentGeneratedError";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\n_a10 = symbol10;\nvar name10 = "AI_NoSuchModelError";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\n_a11 = symbol11;\nvar name11 = "AI_TooManyEmbeddingValuesForCallError";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\n_a12 = symbol12;\nvar name12 = "AI_TypeValidationError";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError2 extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\nvar name13 = "AI_UnsupportedFunctionalityError";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\n_a14 = symbol14;\n\n// ../../node_modules/zod/v4/classic/external.js\nvar exports_external = {};\n__export(exports_external, {\n  xor: () => xor,\n  xid: () => xid2,\n  void: () => _void2,\n  uuidv7: () => uuidv7,\n  uuidv6: () => uuidv6,\n  uuidv4: () => uuidv4,\n  uuid: () => uuid2,\n  util: () => exports_util,\n  url: () => url,\n  uppercase: () => _uppercase,\n  unknown: () => unknown,\n  union: () => union,\n  undefined: () => _undefined3,\n  ulid: () => ulid2,\n  uint64: () => uint64,\n  uint32: () => uint32,\n  tuple: () => tuple,\n  trim: () => _trim,\n  treeifyError: () => treeifyError,\n  transform: () => transform,\n  toUpperCase: () => _toUpperCase,\n  toLowerCase: () => _toLowerCase,\n  toJSONSchema: () => toJSONSchema,\n  templateLiteral: () => templateLiteral,\n  symbol: () => symbol15,\n  superRefine: () => superRefine,\n  success: () => success,\n  stringbool: () => stringbool,\n  stringFormat: () => stringFormat,\n  string: () => string2,\n  strictObject: () => strictObject,\n  startsWith: () => _startsWith,\n  slugify: () => _slugify,\n  size: () => _size,\n  setErrorMap: () => setErrorMap,\n  set: () => set,\n  safeParseAsync: () => safeParseAsync2,\n  safeParse: () => safeParse2,\n  safeEncodeAsync: () => safeEncodeAsync2,\n  safeEncode: () => safeEncode2,\n  safeDecodeAsync: () => safeDecodeAsync2,\n  safeDecode: () => safeDecode2,\n  registry: () => registry,\n  regexes: () => exports_regexes,\n  regex: () => _regex,\n  refine: () => refine,\n  record: () => record,\n  readonly: () => readonly,\n  property: () => _property,\n  promise: () => promise,\n  prettifyError: () => prettifyError,\n  preprocess: () => preprocess,\n  prefault: () => prefault,\n  positive: () => _positive,\n  pipe: () => pipe,\n  partialRecord: () => partialRecord,\n  parseAsync: () => parseAsync2,\n  parse: () => parse3,\n  overwrite: () => _overwrite,\n  optional: () => optional,\n  object: () => object,\n  number: () => number2,\n  nullish: () => nullish2,\n  nullable: () => nullable,\n  null: () => _null3,\n  normalize: () => _normalize,\n  nonpositive: () => _nonpositive,\n  nonoptional: () => nonoptional,\n  nonnegative: () => _nonnegative,\n  never: () => never,\n  negative: () => _negative,\n  nativeEnum: () => nativeEnum,\n  nanoid: () => nanoid2,\n  nan: () => nan,\n  multipleOf: () => _multipleOf,\n  minSize: () => _minSize,\n  minLength: () => _minLength,\n  mime: () => _mime,\n  meta: () => meta2,\n  maxSize: () => _maxSize,\n  maxLength: () => _maxLength,\n  map: () => map,\n  mac: () => mac2,\n  lte: () => _lte,\n  lt: () => _lt,\n  lowercase: () => _lowercase,\n  looseRecord: () => looseRecord,\n  looseObject: () => looseObject,\n  locales: () => exports_locales,\n  literal: () => literal,\n  length: () => _length,\n  lazy: () => lazy,\n  ksuid: () => ksuid2,\n  keyof: () => keyof,\n  jwt: () => jwt,\n  json: () => json,\n  iso: () => exports_iso,\n  ipv6: () => ipv62,\n  ipv4: () => ipv42,\n  intersection: () => intersection,\n  int64: () => int64,\n  int32: () => int32,\n  int: () => int,\n  instanceof: () => _instanceof,\n  includes: () => _includes,\n  httpUrl: () => httpUrl,\n  hostname: () => hostname2,\n  hex: () => hex2,\n  hash: () => hash,\n  guid: () => guid2,\n  gte: () => _gte,\n  gt: () => _gt,\n  globalRegistry: () => globalRegistry,\n  getErrorMap: () => getErrorMap,\n  function: () => _function,\n  fromJSONSchema: () => fromJSONSchema,\n  formatError: () => formatError,\n  float64: () => float64,\n  float32: () => float32,\n  flattenError: () => flattenError,\n  file: () => file,\n  exactOptional: () => exactOptional,\n  enum: () => _enum2,\n  endsWith: () => _endsWith,\n  encodeAsync: () => encodeAsync2,\n  encode: () => encode2,\n  emoji: () => emoji2,\n  email: () => email2,\n  e164: () => e1642,\n  discriminatedUnion: () => discriminatedUnion,\n  describe: () => describe2,\n  decodeAsync: () => decodeAsync2,\n  decode: () => decode2,\n  date: () => date3,\n  custom: () => custom,\n  cuid2: () => cuid22,\n  cuid: () => cuid3,\n  core: () => exports_core2,\n  config: () => config,\n  coerce: () => exports_coerce,\n  codec: () => codec,\n  clone: () => clone,\n  cidrv6: () => cidrv62,\n  cidrv4: () => cidrv42,\n  check: () => check,\n  catch: () => _catch2,\n  boolean: () => boolean2,\n  bigint: () => bigint2,\n  base64url: () => base64url2,\n  base64: () => base642,\n  array: () => array,\n  any: () => any,\n  _function: () => _function,\n  _default: () => _default2,\n  _ZodString: () => _ZodString,\n  ZodXor: () => ZodXor,\n  ZodXID: () => ZodXID,\n  ZodVoid: () => ZodVoid,\n  ZodUnknown: () => ZodUnknown,\n  ZodUnion: () => ZodUnion,\n  ZodUndefined: () => ZodUndefined,\n  ZodUUID: () => ZodUUID,\n  ZodURL: () => ZodURL,\n  ZodULID: () => ZodULID,\n  ZodType: () => ZodType,\n  ZodTuple: () => ZodTuple,\n  ZodTransform: () => ZodTransform,\n  ZodTemplateLiteral: () => ZodTemplateLiteral,\n  ZodSymbol: () => ZodSymbol,\n  ZodSuccess: () => ZodSuccess,\n  ZodStringFormat: () => ZodStringFormat,\n  ZodString: () => ZodString,\n  ZodSet: () => ZodSet,\n  ZodRecord: () => ZodRecord,\n  ZodRealError: () => ZodRealError,\n  ZodReadonly: () => ZodReadonly,\n  ZodPromise: () => ZodPromise,\n  ZodPrefault: () => ZodPrefault,\n  ZodPipe: () => ZodPipe,\n  ZodOptional: () => ZodOptional,\n  ZodObject: () => ZodObject,\n  ZodNumberFormat: () => ZodNumberFormat,\n  ZodNumber: () => ZodNumber,\n  ZodNullable: () => ZodNullable,\n  ZodNull: () => ZodNull,\n  ZodNonOptional: () => ZodNonOptional,\n  ZodNever: () => ZodNever,\n  ZodNanoID: () => ZodNanoID,\n  ZodNaN: () => ZodNaN,\n  ZodMap: () => ZodMap,\n  ZodMAC: () => ZodMAC,\n  ZodLiteral: () => ZodLiteral,\n  ZodLazy: () => ZodLazy,\n  ZodKSUID: () => ZodKSUID,\n  ZodJWT: () => ZodJWT,\n  ZodIssueCode: () => ZodIssueCode,\n  ZodIntersection: () => ZodIntersection,\n  ZodISOTime: () => ZodISOTime,\n  ZodISODuration: () => ZodISODuration,\n  ZodISODateTime: () => ZodISODateTime,\n  ZodISODate: () => ZodISODate,\n  ZodIPv6: () => ZodIPv6,\n  ZodIPv4: () => ZodIPv4,\n  ZodGUID: () => ZodGUID,\n  ZodFunction: () => ZodFunction,\n  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,\n  ZodFile: () => ZodFile,\n  ZodExactOptional: () => ZodExactOptional,\n  ZodError: () => ZodError,\n  ZodEnum: () => ZodEnum,\n  ZodEmoji: () => ZodEmoji,\n  ZodEmail: () => ZodEmail,\n  ZodE164: () => ZodE164,\n  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,\n  ZodDefault: () => ZodDefault,\n  ZodDate: () => ZodDate,\n  ZodCustomStringFormat: () => ZodCustomStringFormat,\n  ZodCustom: () => ZodCustom,\n  ZodCodec: () => ZodCodec,\n  ZodCatch: () => ZodCatch,\n  ZodCUID2: () => ZodCUID2,\n  ZodCUID: () => ZodCUID,\n  ZodCIDRv6: () => ZodCIDRv6,\n  ZodCIDRv4: () => ZodCIDRv4,\n  ZodBoolean: () => ZodBoolean,\n  ZodBigIntFormat: () => ZodBigIntFormat,\n  ZodBigInt: () => ZodBigInt,\n  ZodBase64URL: () => ZodBase64URL,\n  ZodBase64: () => ZodBase64,\n  ZodArray: () => ZodArray,\n  ZodAny: () => ZodAny,\n  TimePrecision: () => TimePrecision,\n  NEVER: () => NEVER,\n  $output: () => $output,\n  $input: () => $input,\n  $brand: () => $brand\n});\n\n// ../../node_modules/zod/v4/core/index.js\nvar exports_core2 = {};\n__export(exports_core2, {\n  version: () => version,\n  util: () => exports_util,\n  treeifyError: () => treeifyError,\n  toJSONSchema: () => toJSONSchema,\n  toDotPath: () => toDotPath,\n  safeParseAsync: () => safeParseAsync,\n  safeParse: () => safeParse,\n  safeEncodeAsync: () => safeEncodeAsync,\n  safeEncode: () => safeEncode,\n  safeDecodeAsync: () => safeDecodeAsync,\n  safeDecode: () => safeDecode,\n  registry: () => registry,\n  regexes: () => exports_regexes,\n  process: () => process2,\n  prettifyError: () => prettifyError,\n  parseAsync: () => parseAsync,\n  parse: () => parse,\n  meta: () => meta,\n  locales: () => exports_locales,\n  isValidJWT: () => isValidJWT,\n  isValidBase64URL: () => isValidBase64URL,\n  isValidBase64: () => isValidBase64,\n  initializeContext: () => initializeContext,\n  globalRegistry: () => globalRegistry,\n  globalConfig: () => globalConfig,\n  formatError: () => formatError,\n  flattenError: () => flattenError,\n  finalize: () => finalize,\n  extractDefs: () => extractDefs,\n  encodeAsync: () => encodeAsync,\n  encode: () => encode,\n  describe: () => describe,\n  decodeAsync: () => decodeAsync,\n  decode: () => decode,\n  createToJSONSchemaMethod: () => createToJSONSchemaMethod,\n  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,\n  config: () => config,\n  clone: () => clone,\n  _xor: () => _xor,\n  _xid: () => _xid,\n  _void: () => _void,\n  _uuidv7: () => _uuidv7,\n  _uuidv6: () => _uuidv6,\n  _uuidv4: () => _uuidv4,\n  _uuid: () => _uuid,\n  _url: () => _url,\n  _uppercase: () => _uppercase,\n  _unknown: () => _unknown,\n  _union: () => _union,\n  _undefined: () => _undefined2,\n  _ulid: () => _ulid,\n  _uint64: () => _uint64,\n  _uint32: () => _uint32,\n  _tuple: () => _tuple,\n  _trim: () => _trim,\n  _transform: () => _transform,\n  _toUpperCase: () => _toUpperCase,\n  _toLowerCase: () => _toLowerCase,\n  _templateLiteral: () => _templateLiteral,\n  _symbol: () => _symbol,\n  _superRefine: () => _superRefine,\n  _success: () => _success,\n  _stringbool: () => _stringbool,\n  _stringFormat: () => _stringFormat,\n  _string: () => _string,\n  _startsWith: () => _startsWith,\n  _slugify: () => _slugify,\n  _size: () => _size,\n  _set: () => _set,\n  _safeParseAsync: () => _safeParseAsync,\n  _safeParse: () => _safeParse,\n  _safeEncodeAsync: () => _safeEncodeAsync,\n  _safeEncode: () => _safeEncode,\n  _safeDecodeAsync: () => _safeDecodeAsync,\n  _safeDecode: () => _safeDecode,\n  _regex: () => _regex,\n  _refine: () => _refine,\n  _record: () => _record,\n  _readonly: () => _readonly,\n  _property: () => _property,\n  _promise: () => _promise,\n  _positive: () => _positive,\n  _pipe: () => _pipe,\n  _parseAsync: () => _parseAsync,\n  _parse: () => _parse,\n  _overwrite: () => _overwrite,\n  _optional: () => _optional,\n  _number: () => _number,\n  _nullable: () => _nullable,\n  _null: () => _null2,\n  _normalize: () => _normalize,\n  _nonpositive: () => _nonpositive,\n  _nonoptional: () => _nonoptional,\n  _nonnegative: () => _nonnegative,\n  _never: () => _never,\n  _negative: () => _negative,\n  _nativeEnum: () => _nativeEnum,\n  _nanoid: () => _nanoid,\n  _nan: () => _nan,\n  _multipleOf: () => _multipleOf,\n  _minSize: () => _minSize,\n  _minLength: () => _minLength,\n  _min: () => _gte,\n  _mime: () => _mime,\n  _maxSize: () => _maxSize,\n  _maxLength: () => _maxLength,\n  _max: () => _lte,\n  _map: () => _map,\n  _mac: () => _mac,\n  _lte: () => _lte,\n  _lt: () => _lt,\n  _lowercase: () => _lowercase,\n  _literal: () => _literal,\n  _length: () => _length,\n  _lazy: () => _lazy,\n  _ksuid: () => _ksuid,\n  _jwt: () => _jwt,\n  _isoTime: () => _isoTime,\n  _isoDuration: () => _isoDuration,\n  _isoDateTime: () => _isoDateTime,\n  _isoDate: () => _isoDate,\n  _ipv6: () => _ipv6,\n  _ipv4: () => _ipv4,\n  _intersection: () => _intersection,\n  _int64: () => _int64,\n  _int32: () => _int32,\n  _int: () => _int,\n  _includes: () => _includes,\n  _guid: () => _guid,\n  _gte: () => _gte,\n  _gt: () => _gt,\n  _float64: () => _float64,\n  _float32: () => _float32,\n  _file: () => _file,\n  _enum: () => _enum,\n  _endsWith: () => _endsWith,\n  _encodeAsync: () => _encodeAsync,\n  _encode: () => _encode,\n  _emoji: () => _emoji2,\n  _email: () => _email,\n  _e164: () => _e164,\n  _discriminatedUnion: () => _discriminatedUnion,\n  _default: () => _default,\n  _decodeAsync: () => _decodeAsync,\n  _decode: () => _decode,\n  _date: () => _date,\n  _custom: () => _custom,\n  _cuid2: () => _cuid2,\n  _cuid: () => _cuid,\n  _coercedString: () => _coercedString,\n  _coercedNumber: () => _coercedNumber,\n  _coercedDate: () => _coercedDate,\n  _coercedBoolean: () => _coercedBoolean,\n  _coercedBigint: () => _coercedBigint,\n  _cidrv6: () => _cidrv6,\n  _cidrv4: () => _cidrv4,\n  _check: () => _check,\n  _catch: () => _catch,\n  _boolean: () => _boolean,\n  _bigint: () => _bigint,\n  _base64url: () => _base64url,\n  _base64: () => _base64,\n  _array: () => _array,\n  _any: () => _any,\n  TimePrecision: () => TimePrecision,\n  NEVER: () => NEVER,\n  JSONSchemaGenerator: () => JSONSchemaGenerator,\n  JSONSchema: () => exports_json_schema,\n  Doc: () => Doc,\n  $output: () => $output,\n  $input: () => $input,\n  $constructor: () => $constructor,\n  $brand: () => $brand,\n  $ZodXor: () => $ZodXor,\n  $ZodXID: () => $ZodXID,\n  $ZodVoid: () => $ZodVoid,\n  $ZodUnknown: () => $ZodUnknown,\n  $ZodUnion: () => $ZodUnion,\n  $ZodUndefined: () => $ZodUndefined,\n  $ZodUUID: () => $ZodUUID,\n  $ZodURL: () => $ZodURL,\n  $ZodULID: () => $ZodULID,\n  $ZodType: () => $ZodType,\n  $ZodTuple: () => $ZodTuple,\n  $ZodTransform: () => $ZodTransform,\n  $ZodTemplateLiteral: () => $ZodTemplateLiteral,\n  $ZodSymbol: () => $ZodSymbol,\n  $ZodSuccess: () => $ZodSuccess,\n  $ZodStringFormat: () => $ZodStringFormat,\n  $ZodString: () => $ZodString,\n  $ZodSet: () => $ZodSet,\n  $ZodRegistry: () => $ZodRegistry,\n  $ZodRecord: () => $ZodRecord,\n  $ZodRealError: () => $ZodRealError,\n  $ZodReadonly: () => $ZodReadonly,\n  $ZodPromise: () => $ZodPromise,\n  $ZodPrefault: () => $ZodPrefault,\n  $ZodPipe: () => $ZodPipe,\n  $ZodOptional: () => $ZodOptional,\n  $ZodObjectJIT: () => $ZodObjectJIT,\n  $ZodObject: () => $ZodObject,\n  $ZodNumberFormat: () => $ZodNumberFormat,\n  $ZodNumber: () => $ZodNumber,\n  $ZodNullable: () => $ZodNullable,\n  $ZodNull: () => $ZodNull,\n  $ZodNonOptional: () => $ZodNonOptional,\n  $ZodNever: () => $ZodNever,\n  $ZodNanoID: () => $ZodNanoID,\n  $ZodNaN: () => $ZodNaN,\n  $ZodMap: () => $ZodMap,\n  $ZodMAC: () => $ZodMAC,\n  $ZodLiteral: () => $ZodLiteral,\n  $ZodLazy: () => $ZodLazy,\n  $ZodKSUID: () => $ZodKSUID,\n  $ZodJWT: () => $ZodJWT,\n  $ZodIntersection: () => $ZodIntersection,\n  $ZodISOTime: () => $ZodISOTime,\n  $ZodISODuration: () => $ZodISODuration,\n  $ZodISODateTime: () => $ZodISODateTime,\n  $ZodISODate: () => $ZodISODate,\n  $ZodIPv6: () => $ZodIPv6,\n  $ZodIPv4: () => $ZodIPv4,\n  $ZodGUID: () => $ZodGUID,\n  $ZodFunction: () => $ZodFunction,\n  $ZodFile: () => $ZodFile,\n  $ZodExactOptional: () => $ZodExactOptional,\n  $ZodError: () => $ZodError,\n  $ZodEnum: () => $ZodEnum,\n  $ZodEncodeError: () => $ZodEncodeError,\n  $ZodEmoji: () => $ZodEmoji,\n  $ZodEmail: () => $ZodEmail,\n  $ZodE164: () => $ZodE164,\n  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,\n  $ZodDefault: () => $ZodDefault,\n  $ZodDate: () => $ZodDate,\n  $ZodCustomStringFormat: () => $ZodCustomStringFormat,\n  $ZodCustom: () => $ZodCustom,\n  $ZodCodec: () => $ZodCodec,\n  $ZodCheckUpperCase: () => $ZodCheckUpperCase,\n  $ZodCheckStringFormat: () => $ZodCheckStringFormat,\n  $ZodCheckStartsWith: () => $ZodCheckStartsWith,\n  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,\n  $ZodCheckRegex: () => $ZodCheckRegex,\n  $ZodCheckProperty: () => $ZodCheckProperty,\n  $ZodCheckOverwrite: () => $ZodCheckOverwrite,\n  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,\n  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,\n  $ZodCheckMinSize: () => $ZodCheckMinSize,\n  $ZodCheckMinLength: () => $ZodCheckMinLength,\n  $ZodCheckMimeType: () => $ZodCheckMimeType,\n  $ZodCheckMaxSize: () => $ZodCheckMaxSize,\n  $ZodCheckMaxLength: () => $ZodCheckMaxLength,\n  $ZodCheckLowerCase: () => $ZodCheckLowerCase,\n  $ZodCheckLessThan: () => $ZodCheckLessThan,\n  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,\n  $ZodCheckIncludes: () => $ZodCheckIncludes,\n  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,\n  $ZodCheckEndsWith: () => $ZodCheckEndsWith,\n  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,\n  $ZodCheck: () => $ZodCheck,\n  $ZodCatch: () => $ZodCatch,\n  $ZodCUID2: () => $ZodCUID2,\n  $ZodCUID: () => $ZodCUID,\n  $ZodCIDRv6: () => $ZodCIDRv6,\n  $ZodCIDRv4: () => $ZodCIDRv4,\n  $ZodBoolean: () => $ZodBoolean,\n  $ZodBigIntFormat: () => $ZodBigIntFormat,\n  $ZodBigInt: () => $ZodBigInt,\n  $ZodBase64URL: () => $ZodBase64URL,\n  $ZodBase64: () => $ZodBase64,\n  $ZodAsyncError: () => $ZodAsyncError,\n  $ZodArray: () => $ZodArray,\n  $ZodAny: () => $ZodAny\n});\n\n// ../../node_modules/zod/v4/core/core.js\nvar NEVER = Object.freeze({\n  status: "aborted"\n});\nfunction $constructor(name14, initializer, params) {\n  function init(inst, def) {\n    if (!inst._zod) {\n      Object.defineProperty(inst, "_zod", {\n        value: {\n          def,\n          constr: _,\n          traits: new Set\n        },\n        enumerable: false\n      });\n    }\n    if (inst._zod.traits.has(name14)) {\n      return;\n    }\n    inst._zod.traits.add(name14);\n    initializer(inst, def);\n    const proto = _.prototype;\n    const keys = Object.keys(proto);\n    for (let i2 = 0;i2 < keys.length; i2++) {\n      const k = keys[i2];\n      if (!(k in inst)) {\n        inst[k] = proto[k].bind(inst);\n      }\n    }\n  }\n  const Parent = params?.Parent ?? Object;\n\n  class Definition extends Parent {\n  }\n  Object.defineProperty(Definition, "name", { value: name14 });\n  function _(def) {\n    var _a15;\n    const inst = params?.Parent ? new Definition : this;\n    init(inst, def);\n    (_a15 = inst._zod).deferred ?? (_a15.deferred = []);\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n  Object.defineProperty(_, "init", { value: init });\n  Object.defineProperty(_, Symbol.hasInstance, {\n    value: (inst) => {\n      if (params?.Parent && inst instanceof params.Parent)\n        return true;\n      return inst?._zod?.traits?.has(name14);\n    }\n  });\n  Object.defineProperty(_, "name", { value: name14 });\n  return _;\n}\nvar $brand = Symbol("zod_brand");\n\nclass $ZodAsyncError extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n}\n\nclass $ZodEncodeError extends Error {\n  constructor(name14) {\n    super(`Encountered unidirectional transform during encode: ${name14}`);\n    this.name = "ZodEncodeError";\n  }\n}\nvar globalConfig = {};\nfunction config(newConfig) {\n  if (newConfig)\n    Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}\n// ../../node_modules/zod/v4/core/util.js\nvar exports_util = {};\n__export(exports_util, {\n  unwrapMessage: () => unwrapMessage,\n  uint8ArrayToHex: () => uint8ArrayToHex,\n  uint8ArrayToBase64url: () => uint8ArrayToBase64url,\n  uint8ArrayToBase64: () => uint8ArrayToBase64,\n  stringifyPrimitive: () => stringifyPrimitive,\n  slugify: () => slugify,\n  shallowClone: () => shallowClone,\n  safeExtend: () => safeExtend,\n  required: () => required,\n  randomString: () => randomString,\n  propertyKeyTypes: () => propertyKeyTypes,\n  promiseAllObject: () => promiseAllObject,\n  primitiveTypes: () => primitiveTypes,\n  prefixIssues: () => prefixIssues,\n  pick: () => pick,\n  partial: () => partial,\n  parsedType: () => parsedType,\n  optionalKeys: () => optionalKeys,\n  omit: () => omit,\n  objectClone: () => objectClone,\n  numKeys: () => numKeys,\n  nullish: () => nullish,\n  normalizeParams: () => normalizeParams,\n  mergeDefs: () => mergeDefs,\n  merge: () => merge,\n  jsonStringifyReplacer: () => jsonStringifyReplacer,\n  joinValues: () => joinValues,\n  issue: () => issue,\n  isPlainObject: () => isPlainObject,\n  isObject: () => isObject,\n  hexToUint8Array: () => hexToUint8Array,\n  getSizableOrigin: () => getSizableOrigin,\n  getParsedType: () => getParsedType,\n  getLengthableOrigin: () => getLengthableOrigin,\n  getEnumValues: () => getEnumValues,\n  getElementAtPath: () => getElementAtPath,\n  floatSafeRemainder: () => floatSafeRemainder,\n  finalizeIssue: () => finalizeIssue,\n  extend: () => extend,\n  escapeRegex: () => escapeRegex,\n  esc: () => esc,\n  defineLazy: () => defineLazy,\n  createTransparentProxy: () => createTransparentProxy,\n  cloneDef: () => cloneDef,\n  clone: () => clone,\n  cleanRegex: () => cleanRegex,\n  cleanEnum: () => cleanEnum,\n  captureStackTrace: () => captureStackTrace,\n  cached: () => cached,\n  base64urlToUint8Array: () => base64urlToUint8Array,\n  base64ToUint8Array: () => base64ToUint8Array,\n  assignProp: () => assignProp,\n  assertNotEqual: () => assertNotEqual,\n  assertNever: () => assertNever,\n  assertIs: () => assertIs,\n  assertEqual: () => assertEqual,\n  assert: () => assert,\n  allowsEval: () => allowsEval,\n  aborted: () => aborted,\n  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,\n  Class: () => Class,\n  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES\n});\nfunction assertEqual(val) {\n  return val;\n}\nfunction assertNotEqual(val) {\n  return val;\n}\nfunction assertIs(_arg) {}\nfunction assertNever(_x) {\n  throw new Error("Unexpected value in exhaustive check");\n}\nfunction assert(_) {}\nfunction getEnumValues(entries) {\n  const numericValues = Object.values(entries).filter((v) => typeof v === "number");\n  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);\n  return values;\n}\nfunction joinValues(array, separator = "|") {\n  return array.map((val) => stringifyPrimitive(val)).join(separator);\n}\nfunction jsonStringifyReplacer(_, value) {\n  if (typeof value === "bigint")\n    return value.toString();\n  return value;\n}\nfunction cached(getter) {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, "value", { value });\n        return value;\n      }\n      throw new Error("cached value already set");\n    }\n  };\n}\nfunction nullish(input) {\n  return input === null || input === undefined;\n}\nfunction cleanRegex(source) {\n  const start = source.startsWith("^") ? 1 : 0;\n  const end = source.endsWith("$") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(".")[1] || "").length;\n  const stepString = step.toString();\n  let stepDecCount = (stepString.split(".")[1] || "").length;\n  if (stepDecCount === 0 && /\\d?e-\\d?/.test(stepString)) {\n    const match = stepString.match(/\\d?e-(\\d?)/);\n    if (match?.[1]) {\n      stepDecCount = Number.parseInt(match[1]);\n    }\n  }\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));\n  return valInt % stepInt / 10 ** decCount;\n}\nvar EVALUATING = Symbol("evaluating");\nfunction defineLazy(object, key, getter) {\n  let value = undefined;\n  Object.defineProperty(object, key, {\n    get() {\n      if (value === EVALUATING) {\n        return;\n      }\n      if (value === undefined) {\n        value = EVALUATING;\n        value = getter();\n      }\n      return value;\n    },\n    set(v) {\n      Object.defineProperty(object, key, {\n        value: v\n      });\n    },\n    configurable: true\n  });\n}\nfunction objectClone(obj) {\n  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n}\nfunction assignProp(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction mergeDefs(...defs) {\n  const mergedDescriptors = {};\n  for (const def of defs) {\n    const descriptors = Object.getOwnPropertyDescriptors(def);\n    Object.assign(mergedDescriptors, descriptors);\n  }\n  return Object.defineProperties({}, mergedDescriptors);\n}\nfunction cloneDef(schema) {\n  return mergeDefs(schema._zod.def);\n}\nfunction getElementAtPath(obj, path) {\n  if (!path)\n    return obj;\n  return path.reduce((acc, key) => acc?.[key], obj);\n}\nfunction promiseAllObject(promisesObj) {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map((key) => promisesObj[key]);\n  return Promise.all(promises).then((results) => {\n    const resolvedObj = {};\n    for (let i2 = 0;i2 < keys.length; i2++) {\n      resolvedObj[keys[i2]] = results[i2];\n    }\n    return resolvedObj;\n  });\n}\nfunction randomString(length = 10) {\n  const chars = "abcdefghijklmnopqrstuvwxyz";\n  let str = "";\n  for (let i2 = 0;i2 < length; i2++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\nfunction esc(str) {\n  return JSON.stringify(str);\n}\nfunction slugify(input) {\n  return input.toLowerCase().trim().replace(/[^\\w\\s-]/g, "").replace(/[\\s_-]+/g, "-").replace(/^-+|-+$/g, "");\n}\nvar captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};\nfunction isObject(data) {\n  return typeof data === "object" && data !== null && !Array.isArray(data);\n}\nvar allowsEval = cached(() => {\n  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {\n    return false;\n  }\n  try {\n    const F = Function;\n    new F("");\n    return true;\n  } catch (_) {\n    return false;\n  }\n});\nfunction isPlainObject(o) {\n  if (isObject(o) === false)\n    return false;\n  const ctor = o.constructor;\n  if (ctor === undefined)\n    return true;\n  if (typeof ctor !== "function")\n    return true;\n  const prot = ctor.prototype;\n  if (isObject(prot) === false)\n    return false;\n  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {\n    return false;\n  }\n  return true;\n}\nfunction shallowClone(o) {\n  if (isPlainObject(o))\n    return { ...o };\n  if (Array.isArray(o))\n    return [...o];\n  return o;\n}\nfunction numKeys(data) {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\nvar getParsedType = (data) => {\n  const t2 = typeof data;\n  switch (t2) {\n    case "undefined":\n      return "undefined";\n    case "string":\n      return "string";\n    case "number":\n      return Number.isNaN(data) ? "nan" : "number";\n    case "boolean":\n      return "boolean";\n    case "function":\n      return "function";\n    case "bigint":\n      return "bigint";\n    case "symbol":\n      return "symbol";\n    case "object":\n      if (Array.isArray(data)) {\n        return "array";\n      }\n      if (data === null) {\n        return "null";\n      }\n      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {\n        return "promise";\n      }\n      if (typeof Map !== "undefined" && data instanceof Map) {\n        return "map";\n      }\n      if (typeof Set !== "undefined" && data instanceof Set) {\n        return "set";\n      }\n      if (typeof Date !== "undefined" && data instanceof Date) {\n        return "date";\n      }\n      if (typeof File !== "undefined" && data instanceof File) {\n        return "file";\n      }\n      return "object";\n    default:\n      throw new Error(`Unknown data type: ${t2}`);\n  }\n};\nvar propertyKeyTypes = new Set(["string", "number", "symbol"]);\nvar primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);\nfunction escapeRegex(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction clone(inst, def, params) {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent)\n    cl._zod.parent = inst;\n  return cl;\n}\nfunction normalizeParams(_params) {\n  const params = _params;\n  if (!params)\n    return {};\n  if (typeof params === "string")\n    return { error: () => params };\n  if (params?.message !== undefined) {\n    if (params?.error !== undefined)\n      throw new Error("Cannot specify both `message` and `error` params");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === "string")\n    return { ...params, error: () => params.error };\n  return params;\n}\nfunction createTransparentProxy(getter) {\n  let target;\n  return new Proxy({}, {\n    get(_, prop, receiver) {\n      target ?? (target = getter());\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_, prop, value, receiver) {\n      target ?? (target = getter());\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_, prop) {\n      target ?? (target = getter());\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_, prop) {\n      target ?? (target = getter());\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_) {\n      target ?? (target = getter());\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_, prop) {\n      target ?? (target = getter());\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_, prop, descriptor) {\n      target ?? (target = getter());\n      return Reflect.defineProperty(target, prop, descriptor);\n    }\n  });\n}\nfunction stringifyPrimitive(value) {\n  if (typeof value === "bigint")\n    return value.toString() + "n";\n  if (typeof value === "string")\n    return `"${value}"`;\n  return `${value}`;\n}\nfunction optionalKeys(shape) {\n  return Object.keys(shape).filter((k) => {\n    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";\n  });\n}\nvar NUMBER_FORMAT_RANGES = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nvar BIGINT_FORMAT_RANGES = {\n  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],\n  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]\n};\nfunction pick(schema, mask) {\n  const currDef = schema._zod.def;\n  const checks = currDef.checks;\n  const hasChecks = checks && checks.length > 0;\n  if (hasChecks) {\n    throw new Error(".pick() cannot be used on object schemas containing refinements");\n  }\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const newShape = {};\n      for (const key in mask) {\n        if (!(key in currDef.shape)) {\n          throw new Error(`Unrecognized key: "${key}"`);\n        }\n        if (!mask[key])\n          continue;\n        newShape[key] = currDef.shape[key];\n      }\n      assignProp(this, "shape", newShape);\n      return newShape;\n    },\n    checks: []\n  });\n  return clone(schema, def);\n}\nfunction omit(schema, mask) {\n  const currDef = schema._zod.def;\n  const checks = currDef.checks;\n  const hasChecks = checks && checks.length > 0;\n  if (hasChecks) {\n    throw new Error(".omit() cannot be used on object schemas containing refinements");\n  }\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const newShape = { ...schema._zod.def.shape };\n      for (const key in mask) {\n        if (!(key in currDef.shape)) {\n          throw new Error(`Unrecognized key: "${key}"`);\n        }\n        if (!mask[key])\n          continue;\n        delete newShape[key];\n      }\n      assignProp(this, "shape", newShape);\n      return newShape;\n    },\n    checks: []\n  });\n  return clone(schema, def);\n}\nfunction extend(schema, shape) {\n  if (!isPlainObject(shape)) {\n    throw new Error("Invalid input to extend: expected a plain object");\n  }\n  const checks = schema._zod.def.checks;\n  const hasChecks = checks && checks.length > 0;\n  if (hasChecks) {\n    const existingShape = schema._zod.def.shape;\n    for (const key in shape) {\n      if (Object.getOwnPropertyDescriptor(existingShape, key) !== undefined) {\n        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");\n      }\n    }\n  }\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, "shape", _shape);\n      return _shape;\n    }\n  });\n  return clone(schema, def);\n}\nfunction safeExtend(schema, shape) {\n  if (!isPlainObject(shape)) {\n    throw new Error("Invalid input to safeExtend: expected a plain object");\n  }\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, "shape", _shape);\n      return _shape;\n    }\n  });\n  return clone(schema, def);\n}\nfunction merge(a2, b) {\n  const def = mergeDefs(a2._zod.def, {\n    get shape() {\n      const _shape = { ...a2._zod.def.shape, ...b._zod.def.shape };\n      assignProp(this, "shape", _shape);\n      return _shape;\n    },\n    get catchall() {\n      return b._zod.def.catchall;\n    },\n    checks: []\n  });\n  return clone(a2, def);\n}\nfunction partial(Class, schema, mask) {\n  const currDef = schema._zod.def;\n  const checks = currDef.checks;\n  const hasChecks = checks && checks.length > 0;\n  if (hasChecks) {\n    throw new Error(".partial() cannot be used on object schemas containing refinements");\n  }\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const oldShape = schema._zod.def.shape;\n      const shape = { ...oldShape };\n      if (mask) {\n        for (const key in mask) {\n          if (!(key in oldShape)) {\n            throw new Error(`Unrecognized key: "${key}"`);\n          }\n          if (!mask[key])\n            continue;\n          shape[key] = Class ? new Class({\n            type: "optional",\n            innerType: oldShape[key]\n          }) : oldShape[key];\n        }\n      } else {\n        for (const key in oldShape) {\n          shape[key] = Class ? new Class({\n            type: "optional",\n            innerType: oldShape[key]\n          }) : oldShape[key];\n        }\n      }\n      assignProp(this, "shape", shape);\n      return shape;\n    },\n    checks: []\n  });\n  return clone(schema, def);\n}\nfunction required(Class, schema, mask) {\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const oldShape = schema._zod.def.shape;\n      const shape = { ...oldShape };\n      if (mask) {\n        for (const key in mask) {\n          if (!(key in shape)) {\n            throw new Error(`Unrecognized key: "${key}"`);\n          }\n          if (!mask[key])\n            continue;\n          shape[key] = new Class({\n            type: "nonoptional",\n            innerType: oldShape[key]\n          });\n        }\n      } else {\n        for (const key in oldShape) {\n          shape[key] = new Class({\n            type: "nonoptional",\n            innerType: oldShape[key]\n          });\n        }\n      }\n      assignProp(this, "shape", shape);\n      return shape;\n    }\n  });\n  return clone(schema, def);\n}\nfunction aborted(x, startIndex = 0) {\n  if (x.aborted === true)\n    return true;\n  for (let i2 = startIndex;i2 < x.issues.length; i2++) {\n    if (x.issues[i2]?.continue !== true) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction prefixIssues(path, issues) {\n  return issues.map((iss) => {\n    var _a15;\n    (_a15 = iss).path ?? (_a15.path = []);\n    iss.path.unshift(path);\n    return iss;\n  });\n}\nfunction unwrapMessage(message) {\n  return typeof message === "string" ? message : message?.message;\n}\nfunction finalizeIssue(iss, ctx, config2) {\n  const full = { ...iss, path: iss.path ?? [] };\n  if (!iss.message) {\n    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";\n    full.message = message;\n  }\n  delete full.inst;\n  delete full.continue;\n  if (!ctx?.reportInput) {\n    delete full.input;\n  }\n  return full;\n}\nfunction getSizableOrigin(input) {\n  if (input instanceof Set)\n    return "set";\n  if (input instanceof Map)\n    return "map";\n  if (input instanceof File)\n    return "file";\n  return "unknown";\n}\nfunction getLengthableOrigin(input) {\n  if (Array.isArray(input))\n    return "array";\n  if (typeof input === "string")\n    return "string";\n  return "unknown";\n}\nfunction parsedType(data) {\n  const t2 = typeof data;\n  switch (t2) {\n    case "number": {\n      return Number.isNaN(data) ? "nan" : "number";\n    }\n    case "object": {\n      if (data === null) {\n        return "null";\n      }\n      if (Array.isArray(data)) {\n        return "array";\n      }\n      const obj = data;\n      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {\n        return obj.constructor.name;\n      }\n    }\n  }\n  return t2;\n}\nfunction issue(...args) {\n  const [iss, input, inst] = args;\n  if (typeof iss === "string") {\n    return {\n      message: iss,\n      code: "custom",\n      input,\n      inst\n    };\n  }\n  return { ...iss };\n}\nfunction cleanEnum(obj) {\n  return Object.entries(obj).filter(([k, _]) => {\n    return Number.isNaN(Number.parseInt(k, 10));\n  }).map((el) => el[1]);\n}\nfunction base64ToUint8Array(base64) {\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i2 = 0;i2 < binaryString.length; i2++) {\n    bytes[i2] = binaryString.charCodeAt(i2);\n  }\n  return bytes;\n}\nfunction uint8ArrayToBase64(bytes) {\n  let binaryString = "";\n  for (let i2 = 0;i2 < bytes.length; i2++) {\n    binaryString += String.fromCharCode(bytes[i2]);\n  }\n  return btoa(binaryString);\n}\nfunction base64urlToUint8Array(base64url) {\n  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");\n  const padding = "=".repeat((4 - base64.length % 4) % 4);\n  return base64ToUint8Array(base64 + padding);\n}\nfunction uint8ArrayToBase64url(bytes) {\n  return uint8ArrayToBase64(bytes).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=/g, "");\n}\nfunction hexToUint8Array(hex) {\n  const cleanHex = hex.replace(/^0x/, "");\n  if (cleanHex.length % 2 !== 0) {\n    throw new Error("Invalid hex string length");\n  }\n  const bytes = new Uint8Array(cleanHex.length / 2);\n  for (let i2 = 0;i2 < cleanHex.length; i2 += 2) {\n    bytes[i2 / 2] = Number.parseInt(cleanHex.slice(i2, i2 + 2), 16);\n  }\n  return bytes;\n}\nfunction uint8ArrayToHex(bytes) {\n  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");\n}\n\nclass Class {\n  constructor(..._args) {}\n}\n\n// ../../node_modules/zod/v4/core/errors.js\nvar initializer = (inst, def) => {\n  inst.name = "$ZodError";\n  Object.defineProperty(inst, "_zod", {\n    value: inst._zod,\n    enumerable: false\n  });\n  Object.defineProperty(inst, "issues", {\n    value: def,\n    enumerable: false\n  });\n  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);\n  Object.defineProperty(inst, "toString", {\n    value: () => inst.message,\n    enumerable: false\n  });\n};\nvar $ZodError = $constructor("$ZodError", initializer);\nvar $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });\nfunction flattenError(error, mapper = (issue2) => issue2.message) {\n  const fieldErrors = {};\n  const formErrors = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n      fieldErrors[sub.path[0]].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return { formErrors, fieldErrors };\n}\nfunction formatError(error, mapper = (issue2) => issue2.message) {\n  const fieldErrors = { _errors: [] };\n  const processError = (error2) => {\n    for (const issue2 of error2.issues) {\n      if (issue2.code === "invalid_union" && issue2.errors.length) {\n        issue2.errors.map((issues) => processError({ issues }));\n      } else if (issue2.code === "invalid_key") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.code === "invalid_element") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.path.length === 0) {\n        fieldErrors._errors.push(mapper(issue2));\n      } else {\n        let curr = fieldErrors;\n        let i2 = 0;\n        while (i2 < issue2.path.length) {\n          const el = issue2.path[i2];\n          const terminal = i2 === issue2.path.length - 1;\n          if (!terminal) {\n            curr[el] = curr[el] || { _errors: [] };\n          } else {\n            curr[el] = curr[el] || { _errors: [] };\n            curr[el]._errors.push(mapper(issue2));\n          }\n          curr = curr[el];\n          i2++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}\nfunction treeifyError(error, mapper = (issue2) => issue2.message) {\n  const result = { errors: [] };\n  const processError = (error2, path = []) => {\n    var _a15, _b;\n    for (const issue2 of error2.issues) {\n      if (issue2.code === "invalid_union" && issue2.errors.length) {\n        issue2.errors.map((issues) => processError({ issues }, issue2.path));\n      } else if (issue2.code === "invalid_key") {\n        processError({ issues: issue2.issues }, issue2.path);\n      } else if (issue2.code === "invalid_element") {\n        processError({ issues: issue2.issues }, issue2.path);\n      } else {\n        const fullpath = [...path, ...issue2.path];\n        if (fullpath.length === 0) {\n          result.errors.push(mapper(issue2));\n          continue;\n        }\n        let curr = result;\n        let i2 = 0;\n        while (i2 < fullpath.length) {\n          const el = fullpath[i2];\n          const terminal = i2 === fullpath.length - 1;\n          if (typeof el === "string") {\n            curr.properties ?? (curr.properties = {});\n            (_a15 = curr.properties)[el] ?? (_a15[el] = { errors: [] });\n            curr = curr.properties[el];\n          } else {\n            curr.items ?? (curr.items = []);\n            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });\n            curr = curr.items[el];\n          }\n          if (terminal) {\n            curr.errors.push(mapper(issue2));\n          }\n          i2++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return result;\n}\nfunction toDotPath(_path) {\n  const segs = [];\n  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);\n  for (const seg of path) {\n    if (typeof seg === "number")\n      segs.push(`[${seg}]`);\n    else if (typeof seg === "symbol")\n      segs.push(`[${JSON.stringify(String(seg))}]`);\n    else if (/[^\\w$]/.test(seg))\n      segs.push(`[${JSON.stringify(seg)}]`);\n    else {\n      if (segs.length)\n        segs.push(".");\n      segs.push(seg);\n    }\n  }\n  return segs.join("");\n}\nfunction prettifyError(error) {\n  const lines = [];\n  const issues = [...error.issues].sort((a2, b) => (a2.path ?? []).length - (b.path ?? []).length);\n  for (const issue2 of issues) {\n    lines.push(` ${issue2.message}`);\n    if (issue2.path?.length)\n      lines.push(`   at ${toDotPath(issue2.path)}`);\n  }\n  return lines.join(`\n`);\n}\n\n// ../../node_modules/zod/v4/core/parse.js\nvar _parse = (_Err) => (schema, value, _ctx, _params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError;\n  }\n  if (result.issues.length) {\n    const e2 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e2, _params?.callee);\n    throw e2;\n  }\n  return result.value;\n};\nvar parse = /* @__PURE__ */ _parse($ZodRealError);\nvar _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  if (result.issues.length) {\n    const e2 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e2, params?.callee);\n    throw e2;\n  }\n  return result.value;\n};\nvar parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);\nvar _safeParse = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError;\n  }\n  return result.issues.length ? {\n    success: false,\n    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParse = /* @__PURE__ */ _safeParse($ZodRealError);\nvar _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  return result.issues.length ? {\n    success: false,\n    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);\nvar _encode = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };\n  return _parse(_Err)(schema, value, ctx);\n};\nvar encode = /* @__PURE__ */ _encode($ZodRealError);\nvar _decode = (_Err) => (schema, value, _ctx) => {\n  return _parse(_Err)(schema, value, _ctx);\n};\nvar decode = /* @__PURE__ */ _decode($ZodRealError);\nvar _encodeAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };\n  return _parseAsync(_Err)(schema, value, ctx);\n};\nvar encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);\nvar _decodeAsync = (_Err) => async (schema, value, _ctx) => {\n  return _parseAsync(_Err)(schema, value, _ctx);\n};\nvar decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);\nvar _safeEncode = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };\n  return _safeParse(_Err)(schema, value, ctx);\n};\nvar safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);\nvar _safeDecode = (_Err) => (schema, value, _ctx) => {\n  return _safeParse(_Err)(schema, value, _ctx);\n};\nvar safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);\nvar _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };\n  return _safeParseAsync(_Err)(schema, value, ctx);\n};\nvar safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);\nvar _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {\n  return _safeParseAsync(_Err)(schema, value, _ctx);\n};\nvar safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);\n// ../../node_modules/zod/v4/core/regexes.js\nvar exports_regexes = {};\n__export(exports_regexes, {\n  xid: () => xid,\n  uuid7: () => uuid7,\n  uuid6: () => uuid6,\n  uuid4: () => uuid4,\n  uuid: () => uuid,\n  uppercase: () => uppercase,\n  unicodeEmail: () => unicodeEmail,\n  undefined: () => _undefined,\n  ulid: () => ulid,\n  time: () => time,\n  string: () => string,\n  sha512_hex: () => sha512_hex,\n  sha512_base64url: () => sha512_base64url,\n  sha512_base64: () => sha512_base64,\n  sha384_hex: () => sha384_hex,\n  sha384_base64url: () => sha384_base64url,\n  sha384_base64: () => sha384_base64,\n  sha256_hex: () => sha256_hex,\n  sha256_base64url: () => sha256_base64url,\n  sha256_base64: () => sha256_base64,\n  sha1_hex: () => sha1_hex,\n  sha1_base64url: () => sha1_base64url,\n  sha1_base64: () => sha1_base64,\n  rfc5322Email: () => rfc5322Email,\n  number: () => number,\n  null: () => _null,\n  nanoid: () => nanoid,\n  md5_hex: () => md5_hex,\n  md5_base64url: () => md5_base64url,\n  md5_base64: () => md5_base64,\n  mac: () => mac,\n  lowercase: () => lowercase,\n  ksuid: () => ksuid,\n  ipv6: () => ipv6,\n  ipv4: () => ipv4,\n  integer: () => integer,\n  idnEmail: () => idnEmail,\n  html5Email: () => html5Email,\n  hostname: () => hostname,\n  hex: () => hex,\n  guid: () => guid,\n  extendedDuration: () => extendedDuration,\n  emoji: () => emoji,\n  email: () => email,\n  e164: () => e164,\n  duration: () => duration,\n  domain: () => domain,\n  datetime: () => datetime,\n  date: () => date,\n  cuid2: () => cuid2,\n  cuid: () => cuid,\n  cidrv6: () => cidrv6,\n  cidrv4: () => cidrv4,\n  browserEmail: () => browserEmail,\n  boolean: () => boolean,\n  bigint: () => bigint,\n  base64url: () => base64url,\n  base64: () => base64\n});\nvar cuid = /^[cC][^\\s-]{8,}$/;\nvar cuid2 = /^[0-9a-z]+$/;\nvar ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;\nvar xid = /^[0-9a-vA-V]{20}$/;\nvar ksuid = /^[A-Za-z0-9]{27}$/;\nvar nanoid = /^[a-zA-Z0-9_-]{21}$/;\nvar duration = /^P(?:(\\d+W)|(?!.*W)(?=\\d|T\\d)(\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+([.,]\\d+)?S)?)?)$/;\nvar extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;\nvar uuid = (version) => {\n  if (!version)\n    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;\n  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);\n};\nvar uuid4 = /* @__PURE__ */ uuid(4);\nvar uuid6 = /* @__PURE__ */ uuid(6);\nvar uuid7 = /* @__PURE__ */ uuid(7);\nvar email = /^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_\'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$/;\nvar html5Email = /^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nvar rfc5322Email = /^(([^<>()\\[\\]\\\\.,;:\\s@"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@"]+)*)|(".+"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\nvar unicodeEmail = /^[^\\s@"]{1,64}@[^\\s@]{1,255}$/u;\nvar idnEmail = unicodeEmail;\nvar browserEmail = /^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nvar _emoji = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nfunction emoji() {\n  return new RegExp(_emoji, "u");\n}\nvar ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;\nvar mac = (delimiter) => {\n  const escapedDelim = escapeRegex(delimiter ?? ":");\n  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);\n};\nvar cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/([0-9]|[1-2][0-9]|3[0-2])$/;\nvar cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\nvar base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;\nvar base64url = /^[A-Za-z0-9_-]*$/;\nvar hostname = /^(?=.{1,253}\\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\\.?$/;\nvar domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/;\nvar e164 = /^\\+[1-9]\\d{6,14}$/;\nvar dateSource = `(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))`;\nvar date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);\nfunction timeSource(args) {\n  const hhmm = `(?:[01]\\\\d|2[0-3]):[0-5]\\\\d`;\n  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\\\d` : `${hhmm}:[0-5]\\\\d\\\\.\\\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?`;\n  return regex;\n}\nfunction time(args) {\n  return new RegExp(`^${timeSource(args)}$`);\n}\nfunction datetime(args) {\n  const time2 = timeSource({ precision: args.precision });\n  const opts = ["Z"];\n  if (args.local)\n    opts.push("");\n  if (args.offset)\n    opts.push(`([+-](?:[01]\\\\d|2[0-3]):[0-5]\\\\d)`);\n  const timeRegex = `${time2}(?:${opts.join("|")})`;\n  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);\n}\nvar string = (params) => {\n  const regex = params ? `[\\\\s\\\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\\\s\\\\S]*`;\n  return new RegExp(`^${regex}$`);\n};\nvar bigint = /^-?\\d+n?$/;\nvar integer = /^-?\\d+$/;\nvar number = /^-?\\d+(?:\\.\\d+)?$/;\nvar boolean = /^(?:true|false)$/i;\nvar _null = /^null$/i;\nvar _undefined = /^undefined$/i;\nvar lowercase = /^[^A-Z]*$/;\nvar uppercase = /^[^a-z]*$/;\nvar hex = /^[0-9a-fA-F]*$/;\nfunction fixedBase64(bodyLength, padding) {\n  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);\n}\nfunction fixedBase64url(length) {\n  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);\n}\nvar md5_hex = /^[0-9a-fA-F]{32}$/;\nvar md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");\nvar md5_base64url = /* @__PURE__ */ fixedBase64url(22);\nvar sha1_hex = /^[0-9a-fA-F]{40}$/;\nvar sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");\nvar sha1_base64url = /* @__PURE__ */ fixedBase64url(27);\nvar sha256_hex = /^[0-9a-fA-F]{64}$/;\nvar sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");\nvar sha256_base64url = /* @__PURE__ */ fixedBase64url(43);\nvar sha384_hex = /^[0-9a-fA-F]{96}$/;\nvar sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");\nvar sha384_base64url = /* @__PURE__ */ fixedBase64url(64);\nvar sha512_hex = /^[0-9a-fA-F]{128}$/;\nvar sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");\nvar sha512_base64url = /* @__PURE__ */ fixedBase64url(86);\n\n// ../../node_modules/zod/v4/core/checks.js\nvar $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {\n  var _a15;\n  inst._zod ?? (inst._zod = {});\n  inst._zod.def = def;\n  (_a15 = inst._zod).onattach ?? (_a15.onattach = []);\n});\nvar numericOriginMap = {\n  number: "number",\n  bigint: "bigint",\n  object: "date"\n};\nvar $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const origin = numericOriginMap[typeof def.value];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;\n    if (def.value < curr) {\n      if (def.inclusive)\n        bag.maximum = def.value;\n      else\n        bag.exclusiveMaximum = def.value;\n    }\n  });\n  inst._zod.check = (payload) => {\n    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {\n      return;\n    }\n    payload.issues.push({\n      origin,\n      code: "too_big",\n      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,\n      input: payload.value,\n      inclusive: def.inclusive,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const origin = numericOriginMap[typeof def.value];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;\n    if (def.value > curr) {\n      if (def.inclusive)\n        bag.minimum = def.value;\n      else\n        bag.exclusiveMinimum = def.value;\n    }\n  });\n  inst._zod.check = (payload) => {\n    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {\n      return;\n    }\n    payload.issues.push({\n      origin,\n      code: "too_small",\n      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,\n      input: payload.value,\n      inclusive: def.inclusive,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    var _a15;\n    (_a15 = inst2._zod.bag).multipleOf ?? (_a15.multipleOf = def.value);\n  });\n  inst._zod.check = (payload) => {\n    if (typeof payload.value !== typeof def.value)\n      throw new Error("Cannot mix number and bigint in multiple_of check.");\n    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;\n    if (isMultiple)\n      return;\n    payload.issues.push({\n      origin: typeof payload.value,\n      code: "not_multiple_of",\n      divisor: def.value,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  def.format = def.format || "float64";\n  const isInt = def.format?.includes("int");\n  const origin = isInt ? "int" : "number";\n  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    bag.minimum = minimum;\n    bag.maximum = maximum;\n    if (isInt)\n      bag.pattern = integer;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    if (isInt) {\n      if (!Number.isInteger(input)) {\n        payload.issues.push({\n          expected: origin,\n          format: def.format,\n          code: "invalid_type",\n          continue: false,\n          input,\n          inst\n        });\n        return;\n      }\n      if (!Number.isSafeInteger(input)) {\n        if (input > 0) {\n          payload.issues.push({\n            input,\n            code: "too_big",\n            maximum: Number.MAX_SAFE_INTEGER,\n            note: "Integers must be within the safe integer range.",\n            inst,\n            origin,\n            inclusive: true,\n            continue: !def.abort\n          });\n        } else {\n          payload.issues.push({\n            input,\n            code: "too_small",\n            minimum: Number.MIN_SAFE_INTEGER,\n            note: "Integers must be within the safe integer range.",\n            inst,\n            origin,\n            inclusive: true,\n            continue: !def.abort\n          });\n        }\n        return;\n      }\n    }\n    if (input < minimum) {\n      payload.issues.push({\n        origin: "number",\n        input,\n        code: "too_small",\n        minimum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n    if (input > maximum) {\n      payload.issues.push({\n        origin: "number",\n        input,\n        code: "too_big",\n        maximum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nvar $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    bag.minimum = minimum;\n    bag.maximum = maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    if (input < minimum) {\n      payload.issues.push({\n        origin: "bigint",\n        input,\n        code: "too_small",\n        minimum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n    if (input > maximum) {\n      payload.issues.push({\n        origin: "bigint",\n        input,\n        code: "too_big",\n        maximum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nvar $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {\n  var _a15;\n  $ZodCheck.init(inst, def);\n  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.size !== undefined;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr)\n      inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const size = input.size;\n    if (size <= def.maximum)\n      return;\n    payload.issues.push({\n      origin: getSizableOrigin(input),\n      code: "too_big",\n      maximum: def.maximum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {\n  var _a15;\n  $ZodCheck.init(inst, def);\n  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.size !== undefined;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr)\n      inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const size = input.size;\n    if (size >= def.minimum)\n      return;\n    payload.issues.push({\n      origin: getSizableOrigin(input),\n      code: "too_small",\n      minimum: def.minimum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {\n  var _a15;\n  $ZodCheck.init(inst, def);\n  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.size !== undefined;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.size;\n    bag.maximum = def.size;\n    bag.size = def.size;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const size = input.size;\n    if (size === def.size)\n      return;\n    const tooBig = size > def.size;\n    payload.issues.push({\n      origin: getSizableOrigin(input),\n      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {\n  var _a15;\n  $ZodCheck.init(inst, def);\n  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== undefined;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr)\n      inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length <= def.maximum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: "too_big",\n      maximum: def.maximum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {\n  var _a15;\n  $ZodCheck.init(inst, def);\n  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== undefined;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr)\n      inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length >= def.minimum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: "too_small",\n      minimum: def.minimum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {\n  var _a15;\n  $ZodCheck.init(inst, def);\n  (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== undefined;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.length;\n    bag.maximum = def.length;\n    bag.length = def.length;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length === def.length)\n      return;\n    const origin = getLengthableOrigin(input);\n    const tooBig = length > def.length;\n    payload.issues.push({\n      origin,\n      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {\n  var _a15, _b;\n  $ZodCheck.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    if (def.pattern) {\n      bag.patterns ?? (bag.patterns = new Set);\n      bag.patterns.add(def.pattern);\n    }\n  });\n  if (def.pattern)\n    (_a15 = inst._zod).check ?? (_a15.check = (payload) => {\n      def.pattern.lastIndex = 0;\n      if (def.pattern.test(payload.value))\n        return;\n      payload.issues.push({\n        origin: "string",\n        code: "invalid_format",\n        format: def.format,\n        input: payload.value,\n        ...def.pattern ? { pattern: def.pattern.toString() } : {},\n        inst,\n        continue: !def.abort\n      });\n    });\n  else\n    (_b = inst._zod).check ?? (_b.check = () => {});\n});\nvar $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {\n  $ZodCheckStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    def.pattern.lastIndex = 0;\n    if (def.pattern.test(payload.value))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "regex",\n      input: payload.value,\n      pattern: def.pattern.toString(),\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {\n  def.pattern ?? (def.pattern = lowercase);\n  $ZodCheckStringFormat.init(inst, def);\n});\nvar $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {\n  def.pattern ?? (def.pattern = uppercase);\n  $ZodCheckStringFormat.init(inst, def);\n});\nvar $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const escapedRegex = escapeRegex(def.includes);\n  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);\n  def.pattern = pattern;\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = new Set);\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = (payload) => {\n    if (payload.value.includes(def.includes, def.position))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "includes",\n      includes: def.includes,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);\n  def.pattern ?? (def.pattern = pattern);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = new Set);\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = (payload) => {\n    if (payload.value.startsWith(def.prefix))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "starts_with",\n      prefix: def.prefix,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);\n  def.pattern ?? (def.pattern = pattern);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = new Set);\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = (payload) => {\n    if (payload.value.endsWith(def.suffix))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "ends_with",\n      suffix: def.suffix,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nfunction handleCheckPropertyResult(result, payload, property) {\n  if (result.issues.length) {\n    payload.issues.push(...prefixIssues(property, result.issues));\n  }\n}\nvar $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = (payload) => {\n    const result = def.schema._zod.run({\n      value: payload.value[def.property],\n      issues: []\n    }, {});\n    if (result instanceof Promise) {\n      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));\n    }\n    handleCheckPropertyResult(result, payload, def.property);\n    return;\n  };\n});\nvar $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const mimeSet = new Set(def.mime);\n  inst._zod.onattach.push((inst2) => {\n    inst2._zod.bag.mime = def.mime;\n  });\n  inst._zod.check = (payload) => {\n    if (mimeSet.has(payload.value.type))\n      return;\n    payload.issues.push({\n      code: "invalid_value",\n      values: def.mime,\n      input: payload.value.type,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = (payload) => {\n    payload.value = def.tx(payload.value);\n  };\n});\n\n// ../../node_modules/zod/v4/core/doc.js\nclass Doc {\n  constructor(args = []) {\n    this.content = [];\n    this.indent = 0;\n    if (this)\n      this.args = args;\n  }\n  indented(fn) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n  write(arg) {\n    if (typeof arg === "function") {\n      arg(this, { execution: "sync" });\n      arg(this, { execution: "async" });\n      return;\n    }\n    const content = arg;\n    const lines = content.split(`\n`).filter((x) => x);\n    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x) => `  ${x}`)];\n    return new F(...args, lines.join(`\n`));\n  }\n}\n\n// ../../node_modules/zod/v4/core/versions.js\nvar version = {\n  major: 4,\n  minor: 3,\n  patch: 5\n};\n\n// ../../node_modules/zod/v4/core/schemas.js\nvar $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {\n  var _a15;\n  inst ?? (inst = {});\n  inst._zod.def = def;\n  inst._zod.bag = inst._zod.bag || {};\n  inst._zod.version = version;\n  const checks = [...inst._zod.def.checks ?? []];\n  if (inst._zod.traits.has("$ZodCheck")) {\n    checks.unshift(inst);\n  }\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n  if (checks.length === 0) {\n    (_a15 = inst._zod).deferred ?? (_a15.deferred = []);\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (payload, checks2, ctx) => {\n      let isAborted = aborted(payload);\n      let asyncResult;\n      for (const ch of checks2) {\n        if (ch._zod.def.when) {\n          const shouldRun = ch._zod.def.when(payload);\n          if (!shouldRun)\n            continue;\n        } else if (isAborted) {\n          continue;\n        }\n        const currLen = payload.issues.length;\n        const _ = ch._zod.check(payload);\n        if (_ instanceof Promise && ctx?.async === false) {\n          throw new $ZodAsyncError;\n        }\n        if (asyncResult || _ instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen)\n              return;\n            if (!isAborted)\n              isAborted = aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen)\n            continue;\n          if (!isAborted)\n            isAborted = aborted(payload, currLen);\n        }\n      }\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n    const handleCanaryResult = (canary, payload, ctx) => {\n      if (aborted(canary)) {\n        canary.aborted = true;\n        return canary;\n      }\n      const checkResult = runChecks(payload, checks, ctx);\n      if (checkResult instanceof Promise) {\n        if (ctx.async === false)\n          throw new $ZodAsyncError;\n        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));\n      }\n      return inst._zod.parse(checkResult, ctx);\n    };\n    inst._zod.run = (payload, ctx) => {\n      if (ctx.skipChecks) {\n        return inst._zod.parse(payload, ctx);\n      }\n      if (ctx.direction === "backward") {\n        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });\n        if (canary instanceof Promise) {\n          return canary.then((canary2) => {\n            return handleCanaryResult(canary2, payload, ctx);\n          });\n        }\n        return handleCanaryResult(canary, payload, ctx);\n      }\n      const result = inst._zod.parse(payload, ctx);\n      if (result instanceof Promise) {\n        if (ctx.async === false)\n          throw new $ZodAsyncError;\n        return result.then((result2) => runChecks(result2, checks, ctx));\n      }\n      return runChecks(result, checks, ctx);\n    };\n  }\n  defineLazy(inst, "~standard", () => ({\n    validate: (value) => {\n      try {\n        const r2 = safeParse(inst, value);\n        return r2.success ? { value: r2.data } : { issues: r2.error?.issues };\n      } catch (_) {\n        return safeParseAsync(inst, value).then((r2) => r2.success ? { value: r2.data } : { issues: r2.error?.issues });\n      }\n    },\n    vendor: "zod",\n    version: 1\n  }));\n});\nvar $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);\n  inst._zod.parse = (payload, _) => {\n    if (def.coerce)\n      try {\n        payload.value = String(payload.value);\n      } catch (_2) {}\n    if (typeof payload.value === "string")\n      return payload;\n    payload.issues.push({\n      expected: "string",\n      code: "invalid_type",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {\n  $ZodCheckStringFormat.init(inst, def);\n  $ZodString.init(inst, def);\n});\nvar $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {\n  def.pattern ?? (def.pattern = guid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {\n  if (def.version) {\n    const versionMap = {\n      v1: 1,\n      v2: 2,\n      v3: 3,\n      v4: 4,\n      v5: 5,\n      v6: 6,\n      v7: 7,\n      v8: 8\n    };\n    const v = versionMap[def.version];\n    if (v === undefined)\n      throw new Error(`Invalid UUID version: "${def.version}"`);\n    def.pattern ?? (def.pattern = uuid(v));\n  } else\n    def.pattern ?? (def.pattern = uuid());\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {\n  def.pattern ?? (def.pattern = email);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    try {\n      const trimmed = payload.value.trim();\n      const url = new URL(trimmed);\n      if (def.hostname) {\n        def.hostname.lastIndex = 0;\n        if (!def.hostname.test(url.hostname)) {\n          payload.issues.push({\n            code: "invalid_format",\n            format: "url",\n            note: "Invalid hostname",\n            pattern: def.hostname.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort\n          });\n        }\n      }\n      if (def.protocol) {\n        def.protocol.lastIndex = 0;\n        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {\n          payload.issues.push({\n            code: "invalid_format",\n            format: "url",\n            note: "Invalid protocol",\n            pattern: def.protocol.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort\n          });\n        }\n      }\n      if (def.normalize) {\n        payload.value = url.href;\n      } else {\n        payload.value = trimmed;\n      }\n      return;\n    } catch (_) {\n      payload.issues.push({\n        code: "invalid_format",\n        format: "url",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nvar $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {\n  def.pattern ?? (def.pattern = emoji());\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {\n  def.pattern ?? (def.pattern = nanoid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {\n  def.pattern ?? (def.pattern = cuid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {\n  def.pattern ?? (def.pattern = cuid2);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {\n  def.pattern ?? (def.pattern = ulid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {\n  def.pattern ?? (def.pattern = xid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {\n  def.pattern ?? (def.pattern = ksuid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {\n  def.pattern ?? (def.pattern = datetime(def));\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {\n  def.pattern ?? (def.pattern = date);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {\n  def.pattern ?? (def.pattern = time(def));\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {\n  def.pattern ?? (def.pattern = duration);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {\n  def.pattern ?? (def.pattern = ipv4);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.bag.format = `ipv4`;\n});\nvar $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {\n  def.pattern ?? (def.pattern = ipv6);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.bag.format = `ipv6`;\n  inst._zod.check = (payload) => {\n    try {\n      new URL(`http://[${payload.value}]`);\n    } catch {\n      payload.issues.push({\n        code: "invalid_format",\n        format: "ipv6",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nvar $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {\n  def.pattern ?? (def.pattern = mac(def.delimiter));\n  $ZodStringFormat.init(inst, def);\n  inst._zod.bag.format = `mac`;\n});\nvar $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {\n  def.pattern ?? (def.pattern = cidrv4);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {\n  def.pattern ?? (def.pattern = cidrv6);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    const parts = payload.value.split("/");\n    try {\n      if (parts.length !== 2)\n        throw new Error;\n      const [address, prefix] = parts;\n      if (!prefix)\n        throw new Error;\n      const prefixNum = Number(prefix);\n      if (`${prefixNum}` !== prefix)\n        throw new Error;\n      if (prefixNum < 0 || prefixNum > 128)\n        throw new Error;\n      new URL(`http://[${address}]`);\n    } catch {\n      payload.issues.push({\n        code: "invalid_format",\n        format: "cidrv6",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nfunction isValidBase64(data) {\n  if (data === "")\n    return true;\n  if (data.length % 4 !== 0)\n    return false;\n  try {\n    atob(data);\n    return true;\n  } catch {\n    return false;\n  }\n}\nvar $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {\n  def.pattern ?? (def.pattern = base64);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.bag.contentEncoding = "base64";\n  inst._zod.check = (payload) => {\n    if (isValidBase64(payload.value))\n      return;\n    payload.issues.push({\n      code: "invalid_format",\n      format: "base64",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nfunction isValidBase64URL(data) {\n  if (!base64url.test(data))\n    return false;\n  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");\n  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");\n  return isValidBase64(padded);\n}\nvar $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {\n  def.pattern ?? (def.pattern = base64url);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.bag.contentEncoding = "base64url";\n  inst._zod.check = (payload) => {\n    if (isValidBase64URL(payload.value))\n      return;\n    payload.issues.push({\n      code: "invalid_format",\n      format: "base64url",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {\n  def.pattern ?? (def.pattern = e164);\n  $ZodStringFormat.init(inst, def);\n});\nfunction isValidJWT(token, algorithm = null) {\n  try {\n    const tokensParts = token.split(".");\n    if (tokensParts.length !== 3)\n      return false;\n    const [header] = tokensParts;\n    if (!header)\n      return false;\n    const parsedHeader = JSON.parse(atob(header));\n    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")\n      return false;\n    if (!parsedHeader.alg)\n      return false;\n    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))\n      return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nvar $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    if (isValidJWT(payload.value, def.alg))\n      return;\n    payload.issues.push({\n      code: "invalid_format",\n      format: "jwt",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    if (def.fn(payload.value))\n      return;\n    payload.issues.push({\n      code: "invalid_format",\n      format: def.format,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = inst._zod.bag.pattern ?? number;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce)\n      try {\n        payload.value = Number(payload.value);\n      } catch (_) {}\n    const input = payload.value;\n    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {\n      return payload;\n    }\n    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;\n    payload.issues.push({\n      expected: "number",\n      code: "invalid_type",\n      input,\n      inst,\n      ...received ? { received } : {}\n    });\n    return payload;\n  };\n});\nvar $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {\n  $ZodCheckNumberFormat.init(inst, def);\n  $ZodNumber.init(inst, def);\n});\nvar $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = boolean;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce)\n      try {\n        payload.value = Boolean(payload.value);\n      } catch (_) {}\n    const input = payload.value;\n    if (typeof input === "boolean")\n      return payload;\n    payload.issues.push({\n      expected: "boolean",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = bigint;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce)\n      try {\n        payload.value = BigInt(payload.value);\n      } catch (_) {}\n    if (typeof payload.value === "bigint")\n      return payload;\n    payload.issues.push({\n      expected: "bigint",\n      code: "invalid_type",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {\n  $ZodCheckBigIntFormat.init(inst, def);\n  $ZodBigInt.init(inst, def);\n});\nvar $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === "symbol")\n      return payload;\n    payload.issues.push({\n      expected: "symbol",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = _undefined;\n  inst._zod.values = new Set([undefined]);\n  inst._zod.optin = "optional";\n  inst._zod.optout = "optional";\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === "undefined")\n      return payload;\n    payload.issues.push({\n      expected: "undefined",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = _null;\n  inst._zod.values = new Set([null]);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input === null)\n      return payload;\n    payload.issues.push({\n      expected: "null",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload) => payload;\n});\nvar $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload) => payload;\n});\nvar $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: "never",\n      code: "invalid_type",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === "undefined")\n      return payload;\n    payload.issues.push({\n      expected: "void",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) {\n      try {\n        payload.value = new Date(payload.value);\n      } catch (_err) {}\n    }\n    const input = payload.value;\n    const isDate = input instanceof Date;\n    const isValidDate = isDate && !Number.isNaN(input.getTime());\n    if (isValidDate)\n      return payload;\n    payload.issues.push({\n      expected: "date",\n      code: "invalid_type",\n      input,\n      ...isDate ? { received: "Invalid Date" } : {},\n      inst\n    });\n    return payload;\n  };\n});\nfunction handleArrayResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: "array",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = Array(input.length);\n    const proms = [];\n    for (let i2 = 0;i2 < input.length; i2++) {\n      const item = input[i2];\n      const result = def.element._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));\n      } else {\n        handleArrayResult(result, payload, i2);\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nfunction handlePropertyResult(result, final, key, input, isOptionalOut) {\n  if (result.issues.length) {\n    if (isOptionalOut && !(key in input)) {\n      return;\n    }\n    final.issues.push(...prefixIssues(key, result.issues));\n  }\n  if (result.value === undefined) {\n    if (key in input) {\n      final.value[key] = undefined;\n    }\n  } else {\n    final.value[key] = result.value;\n  }\n}\nfunction normalizeDef(def) {\n  const keys = Object.keys(def.shape);\n  for (const k of keys) {\n    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {\n      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);\n    }\n  }\n  const okeys = optionalKeys(def.shape);\n  return {\n    ...def,\n    keys,\n    keySet: new Set(keys),\n    numKeys: keys.length,\n    optionalKeys: new Set(okeys)\n  };\n}\nfunction handleCatchall(proms, input, payload, ctx, def, inst) {\n  const unrecognized = [];\n  const keySet = def.keySet;\n  const _catchall = def.catchall._zod;\n  const t2 = _catchall.def.type;\n  const isOptionalOut = _catchall.optout === "optional";\n  for (const key in input) {\n    if (keySet.has(key))\n      continue;\n    if (t2 === "never") {\n      unrecognized.push(key);\n      continue;\n    }\n    const r2 = _catchall.run({ value: input[key], issues: [] }, ctx);\n    if (r2 instanceof Promise) {\n      proms.push(r2.then((r3) => handlePropertyResult(r3, payload, key, input, isOptionalOut)));\n    } else {\n      handlePropertyResult(r2, payload, key, input, isOptionalOut);\n    }\n  }\n  if (unrecognized.length) {\n    payload.issues.push({\n      code: "unrecognized_keys",\n      keys: unrecognized,\n      input,\n      inst\n    });\n  }\n  if (!proms.length)\n    return payload;\n  return Promise.all(proms).then(() => {\n    return payload;\n  });\n}\nvar $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {\n  $ZodType.init(inst, def);\n  const desc = Object.getOwnPropertyDescriptor(def, "shape");\n  if (!desc?.get) {\n    const sh = def.shape;\n    Object.defineProperty(def, "shape", {\n      get: () => {\n        const newSh = { ...sh };\n        Object.defineProperty(def, "shape", {\n          value: newSh\n        });\n        return newSh;\n      }\n    });\n  }\n  const _normalized = cached(() => normalizeDef(def));\n  defineLazy(inst._zod, "propValues", () => {\n    const shape = def.shape;\n    const propValues = {};\n    for (const key in shape) {\n      const field = shape[key]._zod;\n      if (field.values) {\n        propValues[key] ?? (propValues[key] = new Set);\n        for (const v of field.values)\n          propValues[key].add(v);\n      }\n    }\n    return propValues;\n  });\n  const isObject2 = isObject;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject2(input)) {\n      payload.issues.push({\n        expected: "object",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = {};\n    const proms = [];\n    const shape = value.shape;\n    for (const key of value.keys) {\n      const el = shape[key];\n      const isOptionalOut = el._zod.optout === "optional";\n      const r2 = el._zod.run({ value: input[key], issues: [] }, ctx);\n      if (r2 instanceof Promise) {\n        proms.push(r2.then((r3) => handlePropertyResult(r3, payload, key, input, isOptionalOut)));\n      } else {\n        handlePropertyResult(r2, payload, key, input, isOptionalOut);\n      }\n    }\n    if (!catchall) {\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);\n  };\n});\nvar $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {\n  $ZodObject.init(inst, def);\n  const superParse = inst._zod.parse;\n  const _normalized = cached(() => normalizeDef(def));\n  const generateFastpass = (shape) => {\n    const doc = new Doc(["shape", "payload", "ctx"]);\n    const normalized = _normalized.value;\n    const parseStr = (key) => {\n      const k = esc(key);\n      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n    };\n    doc.write(`const input = payload.value;`);\n    const ids = Object.create(null);\n    let counter = 0;\n    for (const key of normalized.keys) {\n      ids[key] = `key_${counter++}`;\n    }\n    doc.write(`const newResult = {};`);\n    for (const key of normalized.keys) {\n      const id = ids[key];\n      const k = esc(key);\n      const schema = shape[key];\n      const isOptionalOut = schema?._zod?.optout === "optional";\n      doc.write(`const ${id} = ${parseStr(key)};`);\n      if (isOptionalOut) {\n        doc.write(`\n        if (${id}.issues.length) {\n          if (${k} in input) {\n            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n              ...iss,\n              path: iss.path ? [${k}, ...iss.path] : [${k}]\n            })));\n          }\n        }\n        \n        if (${id}.value === undefined) {\n          if (${k} in input) {\n            newResult[${k}] = undefined;\n          }\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        \n      `);\n      } else {\n        doc.write(`\n        if (${id}.issues.length) {\n          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${k}, ...iss.path] : [${k}]\n          })));\n        }\n        \n        if (${id}.value === undefined) {\n          if (${k} in input) {\n            newResult[${k}] = undefined;\n          }\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        \n      `);\n      }\n    }\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload, ctx) => fn(shape, payload, ctx);\n  };\n  let fastpass;\n  const isObject2 = isObject;\n  const jit = !globalConfig.jitless;\n  const allowsEval2 = allowsEval;\n  const fastEnabled = jit && allowsEval2.value;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject2(input)) {\n      payload.issues.push({\n        expected: "object",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      if (!fastpass)\n        fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n      if (!catchall)\n        return payload;\n      return handleCatchall([], input, payload, ctx, value, inst);\n    }\n    return superParse(payload, ctx);\n  };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n  const nonaborted = results.filter((r2) => !aborted(r2));\n  if (nonaborted.length === 1) {\n    final.value = nonaborted[0].value;\n    return nonaborted[0];\n  }\n  final.issues.push({\n    code: "invalid_union",\n    input: final.value,\n    inst,\n    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  });\n  return final;\n}\nvar $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);\n  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);\n  defineLazy(inst._zod, "values", () => {\n    if (def.options.every((o) => o._zod.values)) {\n      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n    }\n    return;\n  });\n  defineLazy(inst._zod, "pattern", () => {\n    if (def.options.every((o) => o._zod.pattern)) {\n      const patterns = def.options.map((o) => o._zod.pattern);\n      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);\n    }\n    return;\n  });\n  const single = def.options.length === 1;\n  const first = def.options[0]._zod.run;\n  inst._zod.parse = (payload, ctx) => {\n    if (single) {\n      return first(payload, ctx);\n    }\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0)\n          return result;\n        results.push(result);\n      }\n    }\n    if (!async)\n      return handleUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then((results2) => {\n      return handleUnionResults(results2, payload, inst, ctx);\n    });\n  };\n});\nfunction handleExclusiveUnionResults(results, final, inst, ctx) {\n  const successes = results.filter((r2) => r2.issues.length === 0);\n  if (successes.length === 1) {\n    final.value = successes[0].value;\n    return final;\n  }\n  if (successes.length === 0) {\n    final.issues.push({\n      code: "invalid_union",\n      input: final.value,\n      inst,\n      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n    });\n  } else {\n    final.issues.push({\n      code: "invalid_union",\n      input: final.value,\n      inst,\n      errors: [],\n      inclusive: false\n    });\n  }\n  return final;\n}\nvar $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  def.inclusive = false;\n  const single = def.options.length === 1;\n  const first = def.options[0]._zod.run;\n  inst._zod.parse = (payload, ctx) => {\n    if (single) {\n      return first(payload, ctx);\n    }\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        results.push(result);\n      }\n    }\n    if (!async)\n      return handleExclusiveUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then((results2) => {\n      return handleExclusiveUnionResults(results2, payload, inst, ctx);\n    });\n  };\n});\nvar $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {\n  def.inclusive = false;\n  $ZodUnion.init(inst, def);\n  const _super = inst._zod.parse;\n  defineLazy(inst._zod, "propValues", () => {\n    const propValues = {};\n    for (const option of def.options) {\n      const pv = option._zod.propValues;\n      if (!pv || Object.keys(pv).length === 0)\n        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);\n      for (const [k, v] of Object.entries(pv)) {\n        if (!propValues[k])\n          propValues[k] = new Set;\n        for (const val of v) {\n          propValues[k].add(val);\n        }\n      }\n    }\n    return propValues;\n  });\n  const disc = cached(() => {\n    const opts = def.options;\n    const map = new Map;\n    for (const o of opts) {\n      const values = o._zod.propValues?.[def.discriminator];\n      if (!values || values.size === 0)\n        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);\n      for (const v of values) {\n        if (map.has(v)) {\n          throw new Error(`Duplicate discriminator value "${String(v)}"`);\n        }\n        map.set(v, o);\n      }\n    }\n    return map;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!isObject(input)) {\n      payload.issues.push({\n        code: "invalid_type",\n        expected: "object",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const opt = disc.value.get(input?.[def.discriminator]);\n    if (opt) {\n      return opt._zod.run(payload, ctx);\n    }\n    if (def.unionFallback) {\n      return _super(payload, ctx);\n    }\n    payload.issues.push({\n      code: "invalid_union",\n      errors: [],\n      note: "No matching discriminator",\n      discriminator: def.discriminator,\n      input,\n      path: [def.discriminator],\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n    const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n    const async = left instanceof Promise || right instanceof Promise;\n    if (async) {\n      return Promise.all([left, right]).then(([left2, right2]) => {\n        return handleIntersectionResults(payload, left2, right2);\n      });\n    }\n    return handleIntersectionResults(payload, left, right);\n  };\n});\nfunction mergeValues(a2, b) {\n  if (a2 === b) {\n    return { valid: true, data: a2 };\n  }\n  if (a2 instanceof Date && b instanceof Date && +a2 === +b) {\n    return { valid: true, data: a2 };\n  }\n  if (isPlainObject(a2) && isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a2).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a2, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a2[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  }\n  if (Array.isArray(a2) && Array.isArray(b)) {\n    if (a2.length !== b.length) {\n      return { valid: false, mergeErrorPath: [] };\n    }\n    const newArray = [];\n    for (let index = 0;index < a2.length; index++) {\n      const itemA = a2[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  }\n  return { valid: false, mergeErrorPath: [] };\n}\nfunction handleIntersectionResults(result, left, right) {\n  const unrecKeys = new Map;\n  let unrecIssue;\n  for (const iss of left.issues) {\n    if (iss.code === "unrecognized_keys") {\n      unrecIssue ?? (unrecIssue = iss);\n      for (const k of iss.keys) {\n        if (!unrecKeys.has(k))\n          unrecKeys.set(k, {});\n        unrecKeys.get(k).l = true;\n      }\n    } else {\n      result.issues.push(iss);\n    }\n  }\n  for (const iss of right.issues) {\n    if (iss.code === "unrecognized_keys") {\n      for (const k of iss.keys) {\n        if (!unrecKeys.has(k))\n          unrecKeys.set(k, {});\n        unrecKeys.get(k).r = true;\n      }\n    } else {\n      result.issues.push(iss);\n    }\n  }\n  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);\n  if (bothKeys.length && unrecIssue) {\n    result.issues.push({ ...unrecIssue, keys: bothKeys });\n  }\n  if (aborted(result))\n    return result;\n  const merged = mergeValues(left.value, right.value);\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n  result.value = merged.data;\n  return result;\n}\nvar $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {\n  $ZodType.init(inst, def);\n  const items = def.items;\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: "tuple",\n        code: "invalid_type"\n      });\n      return payload;\n    }\n    payload.value = [];\n    const proms = [];\n    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");\n    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;\n    if (!def.rest) {\n      const tooBig = input.length > items.length;\n      const tooSmall = input.length < optStart - 1;\n      if (tooBig || tooSmall) {\n        payload.issues.push({\n          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },\n          input,\n          inst,\n          origin: "array"\n        });\n        return payload;\n      }\n    }\n    let i2 = -1;\n    for (const item of items) {\n      i2++;\n      if (i2 >= input.length) {\n        if (i2 >= optStart)\n          continue;\n      }\n      const result = item._zod.run({\n        value: input[i2],\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));\n      } else {\n        handleTupleResult(result, payload, i2);\n      }\n    }\n    if (def.rest) {\n      const rest = input.slice(items.length);\n      for (const el of rest) {\n        i2++;\n        const result = def.rest._zod.run({\n          value: el,\n          issues: []\n        }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));\n        } else {\n          handleTupleResult(result, payload, i2);\n        }\n      }\n    }\n    if (proms.length)\n      return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleTupleResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!isPlainObject(input)) {\n      payload.issues.push({\n        expected: "record",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    const values = def.keyType._zod.values;\n    if (values) {\n      payload.value = {};\n      const recordKeys = new Set;\n      for (const key of values) {\n        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {\n          recordKeys.add(typeof key === "number" ? key.toString() : key);\n          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n          if (result instanceof Promise) {\n            proms.push(result.then((result2) => {\n              if (result2.issues.length) {\n                payload.issues.push(...prefixIssues(key, result2.issues));\n              }\n              payload.value[key] = result2.value;\n            }));\n          } else {\n            if (result.issues.length) {\n              payload.issues.push(...prefixIssues(key, result.issues));\n            }\n            payload.value[key] = result.value;\n          }\n        }\n      }\n      let unrecognized;\n      for (const key in input) {\n        if (!recordKeys.has(key)) {\n          unrecognized = unrecognized ?? [];\n          unrecognized.push(key);\n        }\n      }\n      if (unrecognized && unrecognized.length > 0) {\n        payload.issues.push({\n          code: "unrecognized_keys",\n          input,\n          inst,\n          keys: unrecognized\n        });\n      }\n    } else {\n      payload.value = {};\n      for (const key of Reflect.ownKeys(input)) {\n        if (key === "__proto__")\n          continue;\n        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n        if (keyResult instanceof Promise) {\n          throw new Error("Async schemas not supported in object keys currently");\n        }\n        const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length && keyResult.issues.some((iss) => iss.code === "invalid_type" && iss.expected === "number");\n        if (checkNumericKey) {\n          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);\n          if (retryResult instanceof Promise) {\n            throw new Error("Async schemas not supported in object keys currently");\n          }\n          if (retryResult.issues.length === 0) {\n            keyResult = retryResult;\n          }\n        }\n        if (keyResult.issues.length) {\n          if (def.mode === "loose") {\n            payload.value[key] = input[key];\n          } else {\n            payload.issues.push({\n              code: "invalid_key",\n              origin: "record",\n              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),\n              input: key,\n              path: [key],\n              inst\n            });\n          }\n          continue;\n        }\n        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then((result2) => {\n            if (result2.issues.length) {\n              payload.issues.push(...prefixIssues(key, result2.issues));\n            }\n            payload.value[keyResult.value] = result2.value;\n          }));\n        } else {\n          if (result.issues.length) {\n            payload.issues.push(...prefixIssues(key, result.issues));\n          }\n          payload.value[keyResult.value] = result.value;\n        }\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nvar $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Map)) {\n      payload.issues.push({\n        expected: "map",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    payload.value = new Map;\n    for (const [key, value] of input) {\n      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);\n      if (keyResult instanceof Promise || valueResult instanceof Promise) {\n        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {\n          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);\n        }));\n      } else {\n        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n      }\n    }\n    if (proms.length)\n      return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {\n  if (keyResult.issues.length) {\n    if (propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...prefixIssues(key, keyResult.issues));\n    } else {\n      final.issues.push({\n        code: "invalid_key",\n        origin: "map",\n        input,\n        inst,\n        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n      });\n    }\n  }\n  if (valueResult.issues.length) {\n    if (propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...prefixIssues(key, valueResult.issues));\n    } else {\n      final.issues.push({\n        origin: "map",\n        code: "invalid_element",\n        input,\n        inst,\n        key,\n        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n      });\n    }\n  }\n  final.value.set(keyResult.value, valueResult.value);\n}\nvar $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Set)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: "set",\n        code: "invalid_type"\n      });\n      return payload;\n    }\n    const proms = [];\n    payload.value = new Set;\n    for (const item of input) {\n      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleSetResult(result2, payload)));\n      } else\n        handleSetResult(result, payload);\n    }\n    if (proms.length)\n      return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleSetResult(result, final) {\n  if (result.issues.length) {\n    final.issues.push(...result.issues);\n  }\n  final.value.add(result.value);\n}\nvar $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {\n  $ZodType.init(inst, def);\n  const values = getEnumValues(def.entries);\n  const valuesSet = new Set(values);\n  inst._zod.values = valuesSet;\n  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (valuesSet.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: "invalid_value",\n      values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {\n  $ZodType.init(inst, def);\n  if (def.values.length === 0) {\n    throw new Error("Cannot create literal schema with no valid values");\n  }\n  const values = new Set(def.values);\n  inst._zod.values = values;\n  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: "invalid_value",\n      values: def.values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input instanceof File)\n      return payload;\n    payload.issues.push({\n      expected: "file",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      throw new $ZodEncodeError(inst.constructor.name);\n    }\n    const _out = def.transform(payload.value, payload);\n    if (ctx.async) {\n      const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    if (_out instanceof Promise) {\n      throw new $ZodAsyncError;\n    }\n    payload.value = _out;\n    return payload;\n  };\n});\nfunction handleOptionalResult(result, input) {\n  if (result.issues.length && input === undefined) {\n    return { issues: [], value: undefined };\n  }\n  return result;\n}\nvar $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = "optional";\n  inst._zod.optout = "optional";\n  defineLazy(inst._zod, "values", () => {\n    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;\n  });\n  defineLazy(inst._zod, "pattern", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (def.innerType._zod.optin === "optional") {\n      const result = def.innerType._zod.run(payload, ctx);\n      if (result instanceof Promise)\n        return result.then((r2) => handleOptionalResult(r2, payload.value));\n      return handleOptionalResult(result, payload.value);\n    }\n    if (payload.value === undefined) {\n      return payload;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {\n  $ZodOptional.init(inst, def);\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);\n  inst._zod.parse = (payload, ctx) => {\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, "pattern", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;\n  });\n  defineLazy(inst._zod, "values", () => {\n    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === null)\n      return payload;\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = "optional";\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    if (payload.value === undefined) {\n      payload.value = def.defaultValue;\n      return payload;\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleDefaultResult(result2, def));\n    }\n    return handleDefaultResult(result, def);\n  };\n});\nfunction handleDefaultResult(payload, def) {\n  if (payload.value === undefined) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\nvar $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = "optional";\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    if (payload.value === undefined) {\n      payload.value = def.defaultValue;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "values", () => {\n    const v = def.innerType._zod.values;\n    return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleNonOptionalResult(result2, inst));\n    }\n    return handleNonOptionalResult(result, inst);\n  };\n});\nfunction handleNonOptionalResult(payload, inst) {\n  if (!payload.issues.length && payload.value === undefined) {\n    payload.issues.push({\n      code: "invalid_type",\n      expected: "nonoptional",\n      input: payload.value,\n      inst\n    });\n  }\n  return payload;\n}\nvar $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      throw new $ZodEncodeError("ZodSuccess");\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => {\n        payload.value = result2.issues.length === 0;\n        return payload;\n      });\n    }\n    payload.value = result.issues.length === 0;\n    return payload;\n  };\n});\nvar $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => {\n        payload.value = result2.value;\n        if (result2.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n            },\n            input: payload.value\n          });\n          payload.issues = [];\n        }\n        return payload;\n      });\n    }\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n        },\n        input: payload.value\n      });\n      payload.issues = [];\n    }\n    return payload;\n  };\n});\nvar $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: "nan",\n        code: "invalid_type"\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\nvar $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "values", () => def.in._zod.values);\n  defineLazy(inst._zod, "optin", () => def.in._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.out._zod.optout);\n  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      const right = def.out._zod.run(payload, ctx);\n      if (right instanceof Promise) {\n        return right.then((right2) => handlePipeResult(right2, def.in, ctx));\n      }\n      return handlePipeResult(right, def.in, ctx);\n    }\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then((left2) => handlePipeResult(left2, def.out, ctx));\n    }\n    return handlePipeResult(left, def.out, ctx);\n  };\n});\nfunction handlePipeResult(left, next, ctx) {\n  if (left.issues.length) {\n    left.aborted = true;\n    return left;\n  }\n  return next._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\nvar $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "values", () => def.in._zod.values);\n  defineLazy(inst._zod, "optin", () => def.in._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.out._zod.optout);\n  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);\n  inst._zod.parse = (payload, ctx) => {\n    const direction = ctx.direction || "forward";\n    if (direction === "forward") {\n      const left = def.in._zod.run(payload, ctx);\n      if (left instanceof Promise) {\n        return left.then((left2) => handleCodecAResult(left2, def, ctx));\n      }\n      return handleCodecAResult(left, def, ctx);\n    } else {\n      const right = def.out._zod.run(payload, ctx);\n      if (right instanceof Promise) {\n        return right.then((right2) => handleCodecAResult(right2, def, ctx));\n      }\n      return handleCodecAResult(right, def, ctx);\n    }\n  };\n});\nfunction handleCodecAResult(result, def, ctx) {\n  if (result.issues.length) {\n    result.aborted = true;\n    return result;\n  }\n  const direction = ctx.direction || "forward";\n  if (direction === "forward") {\n    const transformed = def.transform(result.value, result);\n    if (transformed instanceof Promise) {\n      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));\n    }\n    return handleCodecTxResult(result, transformed, def.out, ctx);\n  } else {\n    const transformed = def.reverseTransform(result.value, result);\n    if (transformed instanceof Promise) {\n      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));\n    }\n    return handleCodecTxResult(result, transformed, def.in, ctx);\n  }\n}\nfunction handleCodecTxResult(left, value, nextSchema, ctx) {\n  if (left.issues.length) {\n    left.aborted = true;\n    return left;\n  }\n  return nextSchema._zod.run({ value, issues: left.issues }, ctx);\n}\nvar $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);\n  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(handleReadonlyResult);\n    }\n    return handleReadonlyResult(result);\n  };\n});\nfunction handleReadonlyResult(payload) {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\nvar $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {\n  $ZodType.init(inst, def);\n  const regexParts = [];\n  for (const part of def.parts) {\n    if (typeof part === "object" && part !== null) {\n      if (!part._zod.pattern) {\n        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);\n      }\n      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;\n      if (!source)\n        throw new Error(`Invalid template literal part: ${part._zod.traits}`);\n      const start = source.startsWith("^") ? 1 : 0;\n      const end = source.endsWith("$") ? source.length - 1 : source.length;\n      regexParts.push(source.slice(start, end));\n    } else if (part === null || primitiveTypes.has(typeof part)) {\n      regexParts.push(escapeRegex(`${part}`));\n    } else {\n      throw new Error(`Invalid template literal part: ${part}`);\n    }\n  }\n  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== "string") {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: "string",\n        code: "invalid_type"\n      });\n      return payload;\n    }\n    inst._zod.pattern.lastIndex = 0;\n    if (!inst._zod.pattern.test(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        code: "invalid_format",\n        format: def.format ?? "template_literal",\n        pattern: inst._zod.pattern.source\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\nvar $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._def = def;\n  inst._zod.def = def;\n  inst.implement = (func) => {\n    if (typeof func !== "function") {\n      throw new Error("implement() must be called with a function");\n    }\n    return function(...args) {\n      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;\n      const result = Reflect.apply(func, this, parsedArgs);\n      if (inst._def.output) {\n        return parse(inst._def.output, result);\n      }\n      return result;\n    };\n  };\n  inst.implementAsync = (func) => {\n    if (typeof func !== "function") {\n      throw new Error("implementAsync() must be called with a function");\n    }\n    return async function(...args) {\n      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;\n      const result = await Reflect.apply(func, this, parsedArgs);\n      if (inst._def.output) {\n        return await parseAsync(inst._def.output, result);\n      }\n      return result;\n    };\n  };\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== "function") {\n      payload.issues.push({\n        code: "invalid_type",\n        expected: "function",\n        input: payload.value,\n        inst\n      });\n      return payload;\n    }\n    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";\n    if (hasPromiseOutput) {\n      payload.value = inst.implementAsync(payload.value);\n    } else {\n      payload.value = inst.implement(payload.value);\n    }\n    return payload;\n  };\n  inst.input = (...args) => {\n    const F = inst.constructor;\n    if (Array.isArray(args[0])) {\n      return new F({\n        type: "function",\n        input: new $ZodTuple({\n          type: "tuple",\n          items: args[0],\n          rest: args[1]\n        }),\n        output: inst._def.output\n      });\n    }\n    return new F({\n      type: "function",\n      input: args[0],\n      output: inst._def.output\n    });\n  };\n  inst.output = (output) => {\n    const F = inst.constructor;\n    return new F({\n      type: "function",\n      input: inst._def.input,\n      output\n    });\n  };\n  return inst;\n});\nvar $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));\n  };\n});\nvar $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "innerType", () => def.getter());\n  defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);\n  defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);\n  defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? undefined);\n  defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? undefined);\n  inst._zod.parse = (payload, ctx) => {\n    const inner = inst._zod.innerType;\n    return inner._zod.run(payload, ctx);\n  };\n});\nvar $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _) => {\n    return payload;\n  };\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const r2 = def.fn(input);\n    if (r2 instanceof Promise) {\n      return r2.then((r3) => handleRefineResult(r3, payload, input, inst));\n    }\n    handleRefineResult(r2, payload, input, inst);\n    return;\n  };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n  if (!result) {\n    const _iss = {\n      code: "custom",\n      input,\n      inst,\n      path: [...inst._zod.def.path ?? []],\n      continue: !inst._zod.def.abort\n    };\n    if (inst._zod.def.params)\n      _iss.params = inst._zod.def.params;\n    payload.issues.push(issue(_iss));\n  }\n}\n// ../../node_modules/zod/v4/locales/index.js\nvar exports_locales = {};\n__export(exports_locales, {\n  zhTW: () => zh_TW_default,\n  zhCN: () => zh_CN_default,\n  yo: () => yo_default,\n  vi: () => vi_default,\n  uz: () => uz_default,\n  ur: () => ur_default,\n  uk: () => uk_default,\n  ua: () => ua_default,\n  tr: () => tr_default,\n  th: () => th_default,\n  ta: () => ta_default,\n  sv: () => sv_default,\n  sl: () => sl_default,\n  ru: () => ru_default,\n  pt: () => pt_default,\n  ps: () => ps_default,\n  pl: () => pl_default,\n  ota: () => ota_default,\n  no: () => no_default,\n  nl: () => nl_default,\n  ms: () => ms_default,\n  mk: () => mk_default,\n  lt: () => lt_default,\n  ko: () => ko_default,\n  km: () => km_default,\n  kh: () => kh_default,\n  ka: () => ka_default,\n  ja: () => ja_default,\n  it: () => it_default,\n  is: () => is_default,\n  id: () => id_default,\n  hy: () => hy_default,\n  hu: () => hu_default,\n  he: () => he_default,\n  frCA: () => fr_CA_default,\n  fr: () => fr_default,\n  fi: () => fi_default,\n  fa: () => fa_default,\n  es: () => es_default,\n  eo: () => eo_default,\n  en: () => en_default,\n  de: () => de_default,\n  da: () => da_default,\n  cs: () => cs_default,\n  ca: () => ca_default,\n  bg: () => bg_default,\n  be: () => be_default,\n  az: () => az_default,\n  ar: () => ar_default\n});\n\n// ../../node_modules/zod/v4/locales/ar.js\nvar error = () => {\n  const Sizable = {\n    string: { unit: "", verb: " " },\n    file: { unit: "", verb: " " },\n    array: { unit: "", verb: " " },\n    set: { unit: "", verb: " " }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: " ",\n    url: "",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "   ISO",\n    date: "  ISO",\n    time: "  ISO",\n    duration: "  ISO",\n    ipv4: " IPv4",\n    ipv6: " IPv6",\n    cidrv4: "   IPv4",\n    cidrv6: "   IPv6",\n    base64: "  base64-encoded",\n    base64url: "  base64url-encoded",\n    json_string: "   JSON",\n    e164: "   E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `  :   instanceof ${issue2.expected}    ${received}`;\n        }\n        return `  :   ${expected}    ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `  :   ${stringifyPrimitive(issue2.values[0])}`;\n        return `  :     : ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `   :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return `  :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `  :     "${issue2.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `  :     "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `  :    "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `  :     ${_issue.pattern}`;\n        return `${FormatDictionary[_issue.format] ?? issue2.format}  `;\n      }\n      case "not_multiple_of":\n        return `  :      ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;\n      case "invalid_key":\n        return `    ${issue2.origin}`;\n      case "invalid_union":\n        return "  ";\n      case "invalid_element":\n        return `    ${issue2.origin}`;\n      default:\n        return "  ";\n    }\n  };\n};\nfunction ar_default() {\n  return {\n    localeError: error()\n  };\n}\n// ../../node_modules/zod/v4/locales/az.js\nvar error2 = () => {\n  const Sizable = {\n    string: { unit: "simvol", verb: "olmaldr" },\n    file: { unit: "bayt", verb: "olmaldr" },\n    array: { unit: "element", verb: "olmaldr" },\n    set: { unit: "element", verb: "olmaldr" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "input",\n    email: "email address",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO datetime",\n    date: "ISO date",\n    time: "ISO time",\n    duration: "ISO duration",\n    ipv4: "IPv4 address",\n    ipv6: "IPv6 address",\n    cidrv4: "IPv4 range",\n    cidrv6: "IPv6 range",\n    base64: "base64-encoded string",\n    base64url: "base64url-encoded string",\n    json_string: "JSON string",\n    e164: "E.164 number",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Yanl dyr: gzlniln instanceof ${issue2.expected}, daxil olan ${received}`;\n        }\n        return `Yanl dyr: gzlniln ${expected}, daxil olan ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Yanl dyr: gzlniln ${stringifyPrimitive(issue2.values[0])}`;\n        return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;\n        return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Yanl mtn: "${_issue.prefix}" il balamaldr`;\n        if (_issue.format === "ends_with")\n          return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;\n        if (_issue.format === "includes")\n          return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;\n        if (_issue.format === "regex")\n          return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;\n        return `Yanl ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Yanl dd: ${issue2.divisor} il bln biln olmaldr`;\n      case "unrecognized_keys":\n        return `Tannmayan aar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin} daxilind yanl aar`;\n      case "invalid_union":\n        return "Yanl dyr";\n      case "invalid_element":\n        return `${issue2.origin} daxilind yanl dyr`;\n      default:\n        return `Yanl dyr`;\n    }\n  };\n};\nfunction az_default() {\n  return {\n    localeError: error2()\n  };\n}\n// ../../node_modules/zod/v4/locales/be.js\nfunction getBelarusianPlural(count, one, few, many) {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n  if (lastDigit === 1) {\n    return one;\n  }\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n  return many;\n}\nvar error3 = () => {\n  const Sizable = {\n    string: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    array: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    set: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    file: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: "email ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO   ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "   base64",\n    base64url: "   base64url",\n    json_string: "JSON ",\n    e164: " E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` :  instanceof ${issue2.expected},  ${received}`;\n        }\n        return ` :  ${expected},  ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` :  ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :    ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          const maxValue = Number(issue2.maximum);\n          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return ` : ,  ${issue2.origin ?? ""}  ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;\n        }\n        return ` : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          const minValue = Number(issue2.minimum);\n          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return ` : ,  ${issue2.origin}  ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;\n        }\n        return ` : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return ` :    "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return ` :    "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return ` :   "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` :    ${_issue.pattern}`;\n        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` :    ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return " ";\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction be_default() {\n  return {\n    localeError: error3()\n  };\n}\n// ../../node_modules/zod/v4/locales/bg.js\nvar error4 = () => {\n  const Sizable = {\n    string: { unit: "", verb: " " },\n    file: { unit: "", verb: " " },\n    array: { unit: "", verb: " " },\n    set: { unit: "", verb: " " }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: " ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64- ",\n    base64url: "base64url- ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` :  instanceof ${issue2.expected},  ${received}`;\n        }\n        return ` :  ${expected},  ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` :  ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :    ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` :     "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return ` :     "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return ` :    "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` :     ${_issue.pattern}`;\n        let invalid_adj = "";\n        if (_issue.format === "emoji")\n          invalid_adj = "";\n        if (_issue.format === "datetime")\n          invalid_adj = "";\n        if (_issue.format === "date")\n          invalid_adj = "";\n        if (_issue.format === "time")\n          invalid_adj = "";\n        if (_issue.format === "duration")\n          invalid_adj = "";\n        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` :      ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return " ";\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction bg_default() {\n  return {\n    localeError: error4()\n  };\n}\n// ../../node_modules/zod/v4/locales/ca.js\nvar error5 = () => {\n  const Sizable = {\n    string: { unit: "carcters", verb: "contenir" },\n    file: { unit: "bytes", verb: "contenir" },\n    array: { unit: "elements", verb: "contenir" },\n    set: { unit: "elements", verb: "contenir" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "entrada",\n    email: "adrea electrnica",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "data i hora ISO",\n    date: "data ISO",\n    time: "hora ISO",\n    duration: "durada ISO",\n    ipv4: "adrea IPv4",\n    ipv6: "adrea IPv6",\n    cidrv4: "rang IPv4",\n    cidrv6: "rang IPv6",\n    base64: "cadena codificada en base64",\n    base64url: "cadena codificada en base64url",\n    json_string: "cadena JSON",\n    e164: "nmero E.164",\n    jwt: "JWT",\n    template_literal: "entrada"\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Tipus invlid: s\'esperava instanceof ${issue2.expected}, s\'ha rebut ${received}`;\n        }\n        return `Tipus invlid: s\'esperava ${expected}, s\'ha rebut ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Valor invlid: s\'esperava ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opci invlida: s\'esperava una de ${joinValues(issue2.values, " o ")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "com a mxim" : "menys de";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Massa gran: s\'esperava que ${issue2.origin ?? "el valor"} contingus ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;\n        return `Massa gran: s\'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? "com a mnim" : "ms de";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Massa petit: s\'esperava que ${issue2.origin} contingus ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Massa petit: s\'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Format invlid: ha de comenar amb "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Format invlid: ha d\'acabar amb "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Format invlid: ha d\'incloure "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;\n        return `Format invlid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Nmero invlid: ha de ser mltiple de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Clau invlida a ${issue2.origin}`;\n      case "invalid_union":\n        return "Entrada invlida";\n      case "invalid_element":\n        return `Element invlid a ${issue2.origin}`;\n      default:\n        return `Entrada invlida`;\n    }\n  };\n};\nfunction ca_default() {\n  return {\n    localeError: error5()\n  };\n}\n// ../../node_modules/zod/v4/locales/cs.js\nvar error6 = () => {\n  const Sizable = {\n    string: { unit: "znak", verb: "mt" },\n    file: { unit: "bajt", verb: "mt" },\n    array: { unit: "prvk", verb: "mt" },\n    set: { unit: "prvk", verb: "mt" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "regulrn vraz",\n    email: "e-mailov adresa",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "datum a as ve formtu ISO",\n    date: "datum ve formtu ISO",\n    time: "as ve formtu ISO",\n    duration: "doba trvn ISO",\n    ipv4: "IPv4 adresa",\n    ipv6: "IPv6 adresa",\n    cidrv4: "rozsah IPv4",\n    cidrv6: "rozsah IPv6",\n    base64: "etzec zakdovan ve formtu base64",\n    base64url: "etzec zakdovan ve formtu base64url",\n    json_string: "etzec ve formtu JSON",\n    e164: "slo E.164",\n    jwt: "JWT",\n    template_literal: "vstup"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "slo",\n    string: "etzec",\n    function: "funkce",\n    array: "pole"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Neplatn vstup: oekvno instanceof ${issue2.expected}, obdreno ${received}`;\n        }\n        return `Neplatn vstup: oekvno ${expected}, obdreno ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Neplatn vstup: oekvno ${stringifyPrimitive(issue2.values[0])}`;\n        return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk"}`;\n        }\n        return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk"}`;\n        }\n        return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Neplatn etzec: mus konit na "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;\n        return `Neplatn formt ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Neplatn slo: mus bt nsobkem ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Neznm kle: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Neplatn kl v ${issue2.origin}`;\n      case "invalid_union":\n        return "Neplatn vstup";\n      case "invalid_element":\n        return `Neplatn hodnota v ${issue2.origin}`;\n      default:\n        return `Neplatn vstup`;\n    }\n  };\n};\nfunction cs_default() {\n  return {\n    localeError: error6()\n  };\n}\n// ../../node_modules/zod/v4/locales/da.js\nvar error7 = () => {\n  const Sizable = {\n    string: { unit: "tegn", verb: "havde" },\n    file: { unit: "bytes", verb: "havde" },\n    array: { unit: "elementer", verb: "indeholdt" },\n    set: { unit: "elementer", verb: "indeholdt" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "input",\n    email: "e-mailadresse",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO dato- og klokkeslt",\n    date: "ISO-dato",\n    time: "ISO-klokkeslt",\n    duration: "ISO-varighed",\n    ipv4: "IPv4-omrde",\n    ipv6: "IPv6-omrde",\n    cidrv4: "IPv4-spektrum",\n    cidrv6: "IPv6-spektrum",\n    base64: "base64-kodet streng",\n    base64url: "base64url-kodet streng",\n    json_string: "JSON-streng",\n    e164: "E.164-nummer",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    string: "streng",\n    number: "tal",\n    boolean: "boolean",\n    array: "liste",\n    object: "objekt",\n    set: "st",\n    file: "fil"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;\n        }\n        return `Ugyldigt input: forventede ${expected}, fik ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Ugyldig vrdi: forventede ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ugyldigt valg: forventede en af flgende ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;\n        if (sizing)\n          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;\n        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;\n        if (sizing) {\n          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;\n        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Ugyldigt tal: skal vre deleligt med ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Ugyldig ngle i ${issue2.origin}`;\n      case "invalid_union":\n        return "Ugyldigt input: matcher ingen af de tilladte typer";\n      case "invalid_element":\n        return `Ugyldig vrdi i ${issue2.origin}`;\n      default:\n        return `Ugyldigt input`;\n    }\n  };\n};\nfunction da_default() {\n  return {\n    localeError: error7()\n  };\n}\n// ../../node_modules/zod/v4/locales/de.js\nvar error8 = () => {\n  const Sizable = {\n    string: { unit: "Zeichen", verb: "zu haben" },\n    file: { unit: "Bytes", verb: "zu haben" },\n    array: { unit: "Elemente", verb: "zu haben" },\n    set: { unit: "Elemente", verb: "zu haben" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "Eingabe",\n    email: "E-Mail-Adresse",\n    url: "URL",\n    emoji: "Emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO-Datum und -Uhrzeit",\n    date: "ISO-Datum",\n    time: "ISO-Uhrzeit",\n    duration: "ISO-Dauer",\n    ipv4: "IPv4-Adresse",\n    ipv6: "IPv6-Adresse",\n    cidrv4: "IPv4-Bereich",\n    cidrv6: "IPv6-Bereich",\n    base64: "Base64-codierter String",\n    base64url: "Base64-URL-codierter String",\n    json_string: "JSON-String",\n    e164: "E.164-Nummer",\n    jwt: "JWT",\n    template_literal: "Eingabe"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "Zahl",\n    array: "Array"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Ungltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;\n        }\n        return `Ungltige Eingabe: erwartet ${expected}, erhalten ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ungltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;\n        return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;\n        }\n        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;\n        if (_issue.format === "ends_with")\n          return `Ungltiger String: muss mit "${_issue.suffix}" enden`;\n        if (_issue.format === "includes")\n          return `Ungltiger String: muss "${_issue.includes}" enthalten`;\n        if (_issue.format === "regex")\n          return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;\n        return `Ungltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Ungltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Ungltiger Schlssel in ${issue2.origin}`;\n      case "invalid_union":\n        return "Ungltige Eingabe";\n      case "invalid_element":\n        return `Ungltiger Wert in ${issue2.origin}`;\n      default:\n        return `Ungltige Eingabe`;\n    }\n  };\n};\nfunction de_default() {\n  return {\n    localeError: error8()\n  };\n}\n// ../../node_modules/zod/v4/locales/en.js\nvar error9 = () => {\n  const Sizable = {\n    string: { unit: "characters", verb: "to have" },\n    file: { unit: "bytes", verb: "to have" },\n    array: { unit: "items", verb: "to have" },\n    set: { unit: "items", verb: "to have" },\n    map: { unit: "entries", verb: "to have" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "input",\n    email: "email address",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO datetime",\n    date: "ISO date",\n    time: "ISO time",\n    duration: "ISO duration",\n    ipv4: "IPv4 address",\n    ipv6: "IPv6 address",\n    mac: "MAC address",\n    cidrv4: "IPv4 range",\n    cidrv6: "IPv6 range",\n    base64: "base64-encoded string",\n    base64url: "base64url-encoded string",\n    json_string: "JSON string",\n    e164: "E.164 number",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        return `Invalid input: expected ${expected}, received ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;\n        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;\n        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Invalid string: must start with "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Invalid string: must end with "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Invalid string: must include "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Invalid string: must match pattern ${_issue.pattern}`;\n        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Invalid number: must be a multiple of ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Invalid key in ${issue2.origin}`;\n      case "invalid_union":\n        return "Invalid input";\n      case "invalid_element":\n        return `Invalid value in ${issue2.origin}`;\n      default:\n        return `Invalid input`;\n    }\n  };\n};\nfunction en_default() {\n  return {\n    localeError: error9()\n  };\n}\n// ../../node_modules/zod/v4/locales/eo.js\nvar error10 = () => {\n  const Sizable = {\n    string: { unit: "karaktrojn", verb: "havi" },\n    file: { unit: "bajtojn", verb: "havi" },\n    array: { unit: "elementojn", verb: "havi" },\n    set: { unit: "elementojn", verb: "havi" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "enigo",\n    email: "retadreso",\n    url: "URL",\n    emoji: "emoio",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO-datotempo",\n    date: "ISO-dato",\n    time: "ISO-tempo",\n    duration: "ISO-daro",\n    ipv4: "IPv4-adreso",\n    ipv6: "IPv6-adreso",\n    cidrv4: "IPv4-rango",\n    cidrv6: "IPv6-rango",\n    base64: "64-ume kodita karaktraro",\n    base64url: "URL-64-ume kodita karaktraro",\n    json_string: "JSON-karaktraro",\n    e164: "E.164-nombro",\n    jwt: "JWT",\n    template_literal: "enigo"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "nombro",\n    array: "tabelo",\n    null: "senvalora"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Nevalida enigo: atendiis instanceof ${issue2.expected}, riceviis ${received}`;\n        }\n        return `Nevalida enigo: atendiis ${expected}, riceviis ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Nevalida enigo: atendiis ${stringifyPrimitive(issue2.values[0])}`;\n        return `Nevalida opcio: atendiis unu el ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;\n        return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Tro malgranda: atendiis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Tro malgranda: atendiis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;\n        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} losilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Nevalida losilo en ${issue2.origin}`;\n      case "invalid_union":\n        return "Nevalida enigo";\n      case "invalid_element":\n        return `Nevalida valoro en ${issue2.origin}`;\n      default:\n        return `Nevalida enigo`;\n    }\n  };\n};\nfunction eo_default() {\n  return {\n    localeError: error10()\n  };\n}\n// ../../node_modules/zod/v4/locales/es.js\nvar error11 = () => {\n  const Sizable = {\n    string: { unit: "caracteres", verb: "tener" },\n    file: { unit: "bytes", verb: "tener" },\n    array: { unit: "elementos", verb: "tener" },\n    set: { unit: "elementos", verb: "tener" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "entrada",\n    email: "direccin de correo electrnico",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "fecha y hora ISO",\n    date: "fecha ISO",\n    time: "hora ISO",\n    duration: "duracin ISO",\n    ipv4: "direccin IPv4",\n    ipv6: "direccin IPv6",\n    cidrv4: "rango IPv4",\n    cidrv6: "rango IPv6",\n    base64: "cadena codificada en base64",\n    base64url: "URL codificada en base64",\n    json_string: "cadena JSON",\n    e164: "nmero E.164",\n    jwt: "JWT",\n    template_literal: "entrada"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    string: "texto",\n    number: "nmero",\n    boolean: "booleano",\n    array: "arreglo",\n    object: "objeto",\n    set: "conjunto",\n    file: "archivo",\n    date: "fecha",\n    bigint: "nmero grande",\n    symbol: "smbolo",\n    undefined: "indefinido",\n    null: "nulo",\n    function: "funcin",\n    map: "mapa",\n    record: "registro",\n    tuple: "tupla",\n    enum: "enumeracin",\n    union: "unin",\n    literal: "literal",\n    promise: "promesa",\n    void: "vaco",\n    never: "nunca",\n    unknown: "desconocido",\n    any: "cualquiera"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Entrada invlida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;\n        }\n        return `Entrada invlida: se esperaba ${expected}, recibido ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Entrada invlida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opcin invlida: se esperaba una de ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;\n        if (sizing)\n          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;\n        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;\n        if (sizing) {\n          return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Cadena invlida: debe terminar en "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Cadena invlida: debe incluir "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;\n        return `Invlido ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Nmero invlido: debe ser mltiplo de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Llave invlida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;\n      case "invalid_union":\n        return "Entrada invlida";\n      case "invalid_element":\n        return `Valor invlido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;\n      default:\n        return `Entrada invlida`;\n    }\n  };\n};\nfunction es_default() {\n  return {\n    localeError: error11()\n  };\n}\n// ../../node_modules/zod/v4/locales/fa.js\nvar error12 = () => {\n  const Sizable = {\n    string: { unit: "", verb: " " },\n    file: { unit: "", verb: " " },\n    array: { unit: "", verb: " " },\n    set: { unit: "", verb: " " }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: " ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "   ",\n    date: " ",\n    time: " ",\n    duration: "  ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64-encoded ",\n    base64url: "base64url-encoded ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` :  instanceof ${issue2.expected}  ${received}  `;\n        }\n        return ` :  ${expected}  ${received}  `;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1) {\n          return ` :  ${stringifyPrimitive(issue2.values[0])} `;\n        }\n        return ` :    ${joinValues(issue2.values, "|")} `;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;\n        }\n        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;\n        }\n        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` :   "${_issue.prefix}"  `;\n        }\n        if (_issue.format === "ends_with") {\n          return ` :   "${_issue.suffix}"  `;\n        }\n        if (_issue.format === "includes") {\n          return ` :   "${_issue.includes}" `;\n        }\n        if (_issue.format === "regex") {\n          return ` :    ${_issue.pattern}   `;\n        }\n        return `${FormatDictionary[_issue.format] ?? issue2.format} `;\n      }\n      case "not_multiple_of":\n        return ` :   ${issue2.divisor} `;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""} : ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return ` `;\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction fa_default() {\n  return {\n    localeError: error12()\n  };\n}\n// ../../node_modules/zod/v4/locales/fi.js\nvar error13 = () => {\n  const Sizable = {\n    string: { unit: "merkki", subject: "merkkijonon" },\n    file: { unit: "tavua", subject: "tiedoston" },\n    array: { unit: "alkiota", subject: "listan" },\n    set: { unit: "alkiota", subject: "joukon" },\n    number: { unit: "", subject: "luvun" },\n    bigint: { unit: "", subject: "suuren kokonaisluvun" },\n    int: { unit: "", subject: "kokonaisluvun" },\n    date: { unit: "", subject: "pivmrn" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "snnllinen lauseke",\n    email: "shkpostiosoite",\n    url: "URL-osoite",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO-aikaleima",\n    date: "ISO-pivmr",\n    time: "ISO-aika",\n    duration: "ISO-kesto",\n    ipv4: "IPv4-osoite",\n    ipv6: "IPv6-osoite",\n    cidrv4: "IPv4-alue",\n    cidrv6: "IPv6-alue",\n    base64: "base64-koodattu merkkijono",\n    base64url: "base64url-koodattu merkkijono",\n    json_string: "JSON-merkkijono",\n    e164: "E.164-luku",\n    jwt: "JWT",\n    template_literal: "templaattimerkkijono"\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;\n        }\n        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue2.values[0])}`;\n        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();\n        }\n        return `Liian suuri: arvon tytyy olla ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();\n        }\n        return `Liian pieni: arvon tytyy olla ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;\n        if (_issue.format === "regex") {\n          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;\n        }\n        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Virheellinen luku: tytyy olla luvun ${issue2.divisor} monikerta`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return "Virheellinen avain tietueessa";\n      case "invalid_union":\n        return "Virheellinen unioni";\n      case "invalid_element":\n        return "Virheellinen arvo joukossa";\n      default:\n        return `Virheellinen syte`;\n    }\n  };\n};\nfunction fi_default() {\n  return {\n    localeError: error13()\n  };\n}\n// ../../node_modules/zod/v4/locales/fr.js\nvar error14 = () => {\n  const Sizable = {\n    string: { unit: "caractres", verb: "avoir" },\n    file: { unit: "octets", verb: "avoir" },\n    array: { unit: "lments", verb: "avoir" },\n    set: { unit: "lments", verb: "avoir" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "entre",\n    email: "adresse e-mail",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "date et heure ISO",\n    date: "date ISO",\n    time: "heure ISO",\n    duration: "dure ISO",\n    ipv4: "adresse IPv4",\n    ipv6: "adresse IPv6",\n    cidrv4: "plage IPv4",\n    cidrv6: "plage IPv6",\n    base64: "chane encode en base64",\n    base64url: "chane encode en base64url",\n    json_string: "chane JSON",\n    e164: "numro E.164",\n    jwt: "JWT",\n    template_literal: "entre"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "nombre",\n    array: "tableau"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Entre invalide : instanceof ${issue2.expected} attendu, ${received} reu`;\n        }\n        return `Entre invalide : ${expected} attendu, ${received} reu`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Entre invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;\n        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;\n        return `Trop grand : ${issue2.origin ?? "valeur"} doit tre ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Trop petit : ${issue2.origin} doit tre ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Chane invalide : doit commencer par "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Chane invalide : doit inclure "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;\n        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;\n      }\n      case "not_multiple_of":\n        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Cl invalide dans ${issue2.origin}`;\n      case "invalid_union":\n        return "Entre invalide";\n      case "invalid_element":\n        return `Valeur invalide dans ${issue2.origin}`;\n      default:\n        return `Entre invalide`;\n    }\n  };\n};\nfunction fr_default() {\n  return {\n    localeError: error14()\n  };\n}\n// ../../node_modules/zod/v4/locales/fr-CA.js\nvar error15 = () => {\n  const Sizable = {\n    string: { unit: "caractres", verb: "avoir" },\n    file: { unit: "octets", verb: "avoir" },\n    array: { unit: "lments", verb: "avoir" },\n    set: { unit: "lments", verb: "avoir" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "entre",\n    email: "adresse courriel",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "date-heure ISO",\n    date: "date ISO",\n    time: "heure ISO",\n    duration: "dure ISO",\n    ipv4: "adresse IPv4",\n    ipv6: "adresse IPv6",\n    cidrv4: "plage IPv4",\n    cidrv6: "plage IPv6",\n    base64: "chane encode en base64",\n    base64url: "chane encode en base64url",\n    json_string: "chane JSON",\n    e164: "numro E.164",\n    jwt: "JWT",\n    template_literal: "entre"\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Entre invalide : attendu instanceof ${issue2.expected}, reu ${received}`;\n        }\n        return `Entre invalide : attendu ${expected}, reu ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Entre invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;\n        return `Option invalide : attendu l\'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;\n        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? "" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Chane invalide : doit commencer par "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Chane invalide : doit inclure "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;\n        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;\n      }\n      case "not_multiple_of":\n        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Cl invalide dans ${issue2.origin}`;\n      case "invalid_union":\n        return "Entre invalide";\n      case "invalid_element":\n        return `Valeur invalide dans ${issue2.origin}`;\n      default:\n        return `Entre invalide`;\n    }\n  };\n};\nfunction fr_CA_default() {\n  return {\n    localeError: error15()\n  };\n}\n// ../../node_modules/zod/v4/locales/he.js\nvar error16 = () => {\n  const TypeNames = {\n    string: { label: "", gender: "f" },\n    number: { label: "", gender: "m" },\n    boolean: { label: " ", gender: "m" },\n    bigint: { label: "BigInt", gender: "m" },\n    date: { label: "", gender: "m" },\n    array: { label: "", gender: "m" },\n    object: { label: "", gender: "m" },\n    null: { label: "  (null)", gender: "m" },\n    undefined: { label: "   (undefined)", gender: "m" },\n    symbol: { label: " (Symbol)", gender: "m" },\n    function: { label: "", gender: "f" },\n    map: { label: " (Map)", gender: "f" },\n    set: { label: " (Set)", gender: "f" },\n    file: { label: "", gender: "m" },\n    promise: { label: "Promise", gender: "m" },\n    NaN: { label: "NaN", gender: "m" },\n    unknown: { label: "  ", gender: "m" },\n    value: { label: "", gender: "m" }\n  };\n  const Sizable = {\n    string: { unit: "", shortLabel: "", longLabel: "" },\n    file: { unit: "", shortLabel: "", longLabel: "" },\n    array: { unit: "", shortLabel: "", longLabel: "" },\n    set: { unit: "", shortLabel: "", longLabel: "" },\n    number: { unit: "", shortLabel: "", longLabel: "" }\n  };\n  const typeEntry = (t2) => t2 ? TypeNames[t2] : undefined;\n  const typeLabel = (t2) => {\n    const e2 = typeEntry(t2);\n    if (e2)\n      return e2.label;\n    return t2 ?? TypeNames.unknown.label;\n  };\n  const withDefinite = (t2) => `${typeLabel(t2)}`;\n  const verbFor = (t2) => {\n    const e2 = typeEntry(t2);\n    const gender = e2?.gender ?? "m";\n    return gender === "f" ? " " : " ";\n  };\n  const getSizing = (origin) => {\n    if (!origin)\n      return null;\n    return Sizable[origin] ?? null;\n  };\n  const FormatDictionary = {\n    regex: { label: "", gender: "m" },\n    email: { label: " ", gender: "f" },\n    url: { label: " ", gender: "f" },\n    emoji: { label: "\'", gender: "m" },\n    uuid: { label: "UUID", gender: "m" },\n    nanoid: { label: "nanoid", gender: "m" },\n    guid: { label: "GUID", gender: "m" },\n    cuid: { label: "cuid", gender: "m" },\n    cuid2: { label: "cuid2", gender: "m" },\n    ulid: { label: "ULID", gender: "m" },\n    xid: { label: "XID", gender: "m" },\n    ksuid: { label: "KSUID", gender: "m" },\n    datetime: { label: "  ISO", gender: "m" },\n    date: { label: " ISO", gender: "m" },\n    time: { label: " ISO", gender: "m" },\n    duration: { label: "  ISO", gender: "m" },\n    ipv4: { label: " IPv4", gender: "f" },\n    ipv6: { label: " IPv6", gender: "f" },\n    cidrv4: { label: " IPv4", gender: "m" },\n    cidrv6: { label: " IPv6", gender: "m" },\n    base64: { label: "  64", gender: "f" },\n    base64url: { label: "  64  ", gender: "f" },\n    json_string: { label: " JSON", gender: "f" },\n    e164: { label: " E.164", gender: "m" },\n    jwt: { label: "JWT", gender: "m" },\n    ends_with: { label: "", gender: "m" },\n    includes: { label: "", gender: "m" },\n    lowercase: { label: "", gender: "m" },\n    starts_with: { label: "", gender: "m" },\n    uppercase: { label: "", gender: "m" }\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expectedKey = issue2.expected;\n        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `  :   instanceof ${issue2.expected},  ${received}`;\n        }\n        return `  :   ${expected},  ${received}`;\n      }\n      case "invalid_value": {\n        if (issue2.values.length === 1) {\n          return `  :    ${stringifyPrimitive(issue2.values[0])}`;\n        }\n        const stringified = issue2.values.map((v) => stringifyPrimitive(v));\n        if (issue2.values.length === 2) {\n          return `  :    ${stringified[0]}  ${stringified[1]}`;\n        }\n        const lastValue = stringified[stringified.length - 1];\n        const restValues = stringified.slice(0, -1).join(", ");\n        return `  :    ${restValues}  ${lastValue}`;\n      }\n      case "too_big": {\n        const sizing = getSizing(issue2.origin);\n        const subject = withDefinite(issue2.origin ?? "value");\n        if (issue2.origin === "string") {\n          return `${sizing?.longLabel ?? ""} : ${subject}   ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? " " : " "}`.trim();\n        }\n        if (issue2.origin === "number") {\n          const comparison = issue2.inclusive ? `   -${issue2.maximum}` : ` -${issue2.maximum}`;\n          return ` : ${subject}   ${comparison}`;\n        }\n        if (issue2.origin === "array" || issue2.origin === "set") {\n          const verb = issue2.origin === "set" ? "" : "";\n          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""}  ` : ` -${issue2.maximum} ${sizing?.unit ?? ""}`;\n          return ` : ${subject} ${verb}  ${comparison}`.trim();\n        }\n        const adj = issue2.inclusive ? "<=" : "<";\n        const be = verbFor(issue2.origin ?? "value");\n        if (sizing?.unit) {\n          return `${sizing.longLabel} : ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;\n        }\n        return `${sizing?.longLabel ?? ""} : ${subject} ${be} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const sizing = getSizing(issue2.origin);\n        const subject = withDefinite(issue2.origin ?? "value");\n        if (issue2.origin === "string") {\n          return `${sizing?.shortLabel ?? ""} : ${subject}   ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? " " : ""}`.trim();\n        }\n        if (issue2.origin === "number") {\n          const comparison = issue2.inclusive ? `   -${issue2.minimum}` : ` -${issue2.minimum}`;\n          return ` : ${subject}   ${comparison}`;\n        }\n        if (issue2.origin === "array" || issue2.origin === "set") {\n          const verb = issue2.origin === "set" ? "" : "";\n          if (issue2.minimum === 1 && issue2.inclusive) {\n            const singularPhrase = issue2.origin === "set" ? "  " : "  ";\n            return ` : ${subject} ${verb}  ${singularPhrase}`;\n          }\n          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""}  ` : ` -${issue2.minimum} ${sizing?.unit ?? ""}`;\n          return ` : ${subject} ${verb}  ${comparison}`.trim();\n        }\n        const adj = issue2.inclusive ? ">=" : ">";\n        const be = verbFor(issue2.origin ?? "value");\n        if (sizing?.unit) {\n          return `${sizing.shortLabel} : ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `${sizing?.shortLabel ?? ""} : ${subject} ${be} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `    "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `    "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `   "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `    ${_issue.pattern}`;\n        const nounEntry = FormatDictionary[_issue.format];\n        const noun = nounEntry?.label ?? _issue.format;\n        const gender = nounEntry?.gender ?? "m";\n        const adjective = gender === "f" ? "" : "";\n        return `${noun}  ${adjective}`;\n      }\n      case "not_multiple_of":\n        return `  :     ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""}  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key": {\n        return `   `;\n      }\n      case "invalid_union":\n        return "  ";\n      case "invalid_element": {\n        const place = withDefinite(issue2.origin ?? "array");\n        return `   ${place}`;\n      }\n      default:\n        return `  `;\n    }\n  };\n};\nfunction he_default() {\n  return {\n    localeError: error16()\n  };\n}\n// ../../node_modules/zod/v4/locales/hu.js\nvar error17 = () => {\n  const Sizable = {\n    string: { unit: "karakter", verb: "legyen" },\n    file: { unit: "byte", verb: "legyen" },\n    array: { unit: "elem", verb: "legyen" },\n    set: { unit: "elem", verb: "legyen" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "bemenet",\n    email: "email cm",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO idblyeg",\n    date: "ISO dtum",\n    time: "ISO id",\n    duration: "ISO idintervallum",\n    ipv4: "IPv4 cm",\n    ipv6: "IPv6 cm",\n    cidrv4: "IPv4 tartomny",\n    cidrv6: "IPv6 tartomny",\n    base64: "base64-kdolt string",\n    base64url: "base64url-kdolt string",\n    json_string: "JSON string",\n    e164: "E.164 szm",\n    jwt: "JWT",\n    template_literal: "bemenet"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "szm",\n    array: "tmb"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `rvnytelen bemenet: a vrt rtk instanceof ${issue2.expected}, a kapott rtk ${received}`;\n        }\n        return `rvnytelen bemenet: a vrt rtk ${expected}, a kapott rtk ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue2.values[0])}`;\n        return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Tl nagy: ${issue2.origin ?? "rtk"} mrete tl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;\n        return `Tl nagy: a bemeneti rtk ${issue2.origin ?? "rtk"} tl nagy: ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Tl kicsi: a bemeneti rtk ${issue2.origin} mrete tl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Tl kicsi: a bemeneti rtk ${issue2.origin} tl kicsi ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;\n        if (_issue.format === "ends_with")\n          return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;\n        if (_issue.format === "includes")\n          return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;\n        if (_issue.format === "regex")\n          return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;\n        return `rvnytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `rvnytelen szm: ${issue2.divisor} tbbszrsnek kell lennie`;\n      case "unrecognized_keys":\n        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `rvnytelen kulcs ${issue2.origin}`;\n      case "invalid_union":\n        return "rvnytelen bemenet";\n      case "invalid_element":\n        return `rvnytelen rtk: ${issue2.origin}`;\n      default:\n        return `rvnytelen bemenet`;\n    }\n  };\n};\nfunction hu_default() {\n  return {\n    localeError: error17()\n  };\n}\n// ../../node_modules/zod/v4/locales/hy.js\nfunction getArmenianPlural(count, one, many) {\n  return Math.abs(count) === 1 ? one : many;\n}\nfunction withDefiniteArticle(word) {\n  if (!word)\n    return "";\n  const vowels = ["", "", "", "", "", "", ""];\n  const lastChar = word[word.length - 1];\n  return word + (vowels.includes(lastChar) ? "" : "");\n}\nvar error18 = () => {\n  const Sizable = {\n    string: {\n      unit: {\n        one: "",\n        many: ""\n      },\n      verb: ""\n    },\n    file: {\n      unit: {\n        one: "",\n        many: ""\n      },\n      verb: ""\n    },\n    array: {\n      unit: {\n        one: "",\n        many: ""\n      },\n      verb: ""\n    },\n    set: {\n      unit: {\n        one: "",\n        many: ""\n      },\n      verb: ""\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: ". ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO   ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64  ",\n    base64url: "base64url  ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `    instanceof ${issue2.expected},   ${received}`;\n        }\n        return `    ${expected},   ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `    ${stringifyPrimitive(issue2.values[1])}`;\n        return `      ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          const maxValue = Number(issue2.maximum);\n          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);\n          return `    ,  ${withDefiniteArticle(issue2.origin ?? "")}  ${adj}${issue2.maximum.toString()} ${unit}`;\n        }\n        return `    ,  ${withDefiniteArticle(issue2.origin ?? "")}  ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          const minValue = Number(issue2.minimum);\n          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);\n          return `    ,  ${withDefiniteArticle(issue2.origin)}  ${adj}${issue2.minimum.toString()} ${unit}`;\n        }\n        return `    ,  ${withDefiniteArticle(issue2.origin)}  ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `     "${_issue.prefix}"-`;\n        if (_issue.format === "ends_with")\n          return `     "${_issue.suffix}"-`;\n        if (_issue.format === "includes")\n          return `     "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `     ${_issue.pattern} `;\n        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `      ${issue2.divisor}-`;\n      case "unrecognized_keys":\n        return ` ${issue2.keys.length > 1 ? "" : ""}. ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `  ${withDefiniteArticle(issue2.origin)}-`;\n      case "invalid_union":\n        return " ";\n      case "invalid_element":\n        return `  ${withDefiniteArticle(issue2.origin)}-`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction hy_default() {\n  return {\n    localeError: error18()\n  };\n}\n// ../../node_modules/zod/v4/locales/id.js\nvar error19 = () => {\n  const Sizable = {\n    string: { unit: "karakter", verb: "memiliki" },\n    file: { unit: "byte", verb: "memiliki" },\n    array: { unit: "item", verb: "memiliki" },\n    set: { unit: "item", verb: "memiliki" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "input",\n    email: "alamat email",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "tanggal dan waktu format ISO",\n    date: "tanggal format ISO",\n    time: "jam format ISO",\n    duration: "durasi format ISO",\n    ipv4: "alamat IPv4",\n    ipv6: "alamat IPv6",\n    cidrv4: "rentang alamat IPv4",\n    cidrv6: "rentang alamat IPv6",\n    base64: "string dengan enkode base64",\n    base64url: "string dengan enkode base64url",\n    json_string: "string JSON",\n    e164: "angka E.164",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;\n        }\n        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;\n        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;\n        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `String tidak valid: harus menyertakan "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;\n        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;\n      }\n      case "not_multiple_of":\n        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Kunci tidak valid di ${issue2.origin}`;\n      case "invalid_union":\n        return "Input tidak valid";\n      case "invalid_element":\n        return `Nilai tidak valid di ${issue2.origin}`;\n      default:\n        return `Input tidak valid`;\n    }\n  };\n};\nfunction id_default() {\n  return {\n    localeError: error19()\n  };\n}\n// ../../node_modules/zod/v4/locales/is.js\nvar error20 = () => {\n  const Sizable = {\n    string: { unit: "stafi", verb: "a hafa" },\n    file: { unit: "bti", verb: "a hafa" },\n    array: { unit: "hluti", verb: "a hafa" },\n    set: { unit: "hluti", verb: "a hafa" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "gildi",\n    email: "netfang",\n    url: "vefsl",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO dagsetning og tmi",\n    date: "ISO dagsetning",\n    time: "ISO tmi",\n    duration: "ISO tmalengd",\n    ipv4: "IPv4 address",\n    ipv6: "IPv6 address",\n    cidrv4: "IPv4 range",\n    cidrv6: "IPv6 range",\n    base64: "base64-encoded strengur",\n    base64url: "base64url-encoded strengur",\n    json_string: "JSON strengur",\n    e164: "E.164 tlugildi",\n    jwt: "JWT",\n    template_literal: "gildi"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "nmer",\n    array: "fylki"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Rangt gildi:  slst inn ${received} ar sem  a vera instanceof ${issue2.expected}`;\n        }\n        return `Rangt gildi:  slst inn ${received} ar sem  a vera ${expected}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Rangt gildi: gert r fyrir ${stringifyPrimitive(issue2.values[0])}`;\n        return `gilt val: m vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;\n        return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} s ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Of lti: gert er r fyrir a ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Of lti: gert er r fyrir a ${issue2.origin} s ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `gildur strengur: verur a byrja  "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `gildur strengur: verur a enda  "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `gildur strengur: verur a innihalda "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;\n        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Rng tala: verur a vera margfeldi af ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `ekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Rangur lykill  ${issue2.origin}`;\n      case "invalid_union":\n        return "Rangt gildi";\n      case "invalid_element":\n        return `Rangt gildi  ${issue2.origin}`;\n      default:\n        return `Rangt gildi`;\n    }\n  };\n};\nfunction is_default() {\n  return {\n    localeError: error20()\n  };\n}\n// ../../node_modules/zod/v4/locales/it.js\nvar error21 = () => {\n  const Sizable = {\n    string: { unit: "caratteri", verb: "avere" },\n    file: { unit: "byte", verb: "avere" },\n    array: { unit: "elementi", verb: "avere" },\n    set: { unit: "elementi", verb: "avere" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "input",\n    email: "indirizzo email",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "data e ora ISO",\n    date: "data ISO",\n    time: "ora ISO",\n    duration: "durata ISO",\n    ipv4: "indirizzo IPv4",\n    ipv6: "indirizzo IPv6",\n    cidrv4: "intervallo IPv4",\n    cidrv6: "intervallo IPv6",\n    base64: "stringa codificata in base64",\n    base64url: "URL codificata in base64",\n    json_string: "stringa JSON",\n    e164: "numero E.164",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "numero",\n    array: "vettore"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;\n        }\n        return `Input non valido: atteso ${expected}, ricevuto ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;\n        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Stringa non valida: deve includere "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;\n        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Chiave non valida in ${issue2.origin}`;\n      case "invalid_union":\n        return "Input non valido";\n      case "invalid_element":\n        return `Valore non valido in ${issue2.origin}`;\n      default:\n        return `Input non valido`;\n    }\n  };\n};\nfunction it_default() {\n  return {\n    localeError: error21()\n  };\n}\n// ../../node_modules/zod/v4/locales/ja.js\nvar error22 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: "",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO",\n    date: "ISO",\n    time: "ISO",\n    duration: "ISO",\n    ipv4: "IPv4",\n    ipv6: "IPv6",\n    cidrv4: "IPv4",\n    cidrv6: "IPv6",\n    base64: "base64",\n    base64url: "base64url",\n    json_string: "JSON",\n    e164: "E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `: instanceof ${issue2.expected}${received}`;\n        }\n        return `: ${expected}${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `: ${stringifyPrimitive(issue2.values[0])}`;\n        return `: ${joinValues(issue2.values, "")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "" : "";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${sizing.unit ?? ""}${adj}`;\n        return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${adj}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? "" : "";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `: ${issue2.origin}${issue2.minimum.toString()}${sizing.unit}${adj}`;\n        return `: ${issue2.origin}${issue2.minimum.toString()}${adj}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `: "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `: "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `: "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `: ${_issue.pattern}`;\n        return `${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `: ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, "")}`;\n      case "invalid_key":\n        return `${issue2.origin}`;\n      case "invalid_union":\n        return "";\n      case "invalid_element":\n        return `${issue2.origin}`;\n      default:\n        return ``;\n    }\n  };\n};\nfunction ja_default() {\n  return {\n    localeError: error22()\n  };\n}\n// ../../node_modules/zod/v4/locales/ka.js\nvar error23 = () => {\n  const Sizable = {\n    string: { unit: "", verb: " " },\n    file: { unit: "", verb: " " },\n    array: { unit: "", verb: " " },\n    set: { unit: "", verb: " " }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: "- ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "-",\n    date: "",\n    time: "",\n    duration: "",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64- ",\n    base64url: "base64url- ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    string: "",\n    boolean: "",\n    function: "",\n    array: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` :  instanceof ${issue2.expected},  ${received}`;\n        }\n        return ` :  ${expected},  ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` :  ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :  - ${joinValues(issue2.values, "|")}-`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` :  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;\n        return ` :  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` :  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` :  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` :   "${_issue.prefix}"-`;\n        }\n        if (_issue.format === "ends_with")\n          return ` :   "${_issue.suffix}"-`;\n        if (_issue.format === "includes")\n          return ` :   "${_issue.includes}"-`;\n        if (_issue.format === "regex")\n          return ` :    ${_issue.pattern}`;\n        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` :   ${issue2.divisor}- `;\n      case "unrecognized_keys":\n        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `  ${issue2.origin}-`;\n      case "invalid_union":\n        return " ";\n      case "invalid_element":\n        return `  ${issue2.origin}-`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction ka_default() {\n  return {\n    localeError: error23()\n  };\n}\n// ../../node_modules/zod/v4/locales/km.js\nvar error24 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: "",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "  ISO",\n    date: " ISO",\n    time: " ISO",\n    duration: " ISO",\n    ipv4: " IPv4",\n    ipv6: " IPv6",\n    cidrv4: " IPv4",\n    cidrv6: " IPv6",\n    base64: " base64",\n    base64url: " base64url",\n    json_string: " JSON",\n    e164: " E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: " (Array)",\n    null: " (null)"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `  instanceof ${issue2.expected}  ${received}`;\n        }\n        return `  ${expected}  ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `  ${stringifyPrimitive(issue2.values[0])}`;\n        return `  ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `  "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `  "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `  "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `  ${_issue.pattern}`;\n        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `  ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return ` ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return ` ${issue2.origin}`;\n      case "invalid_union":\n        return ``;\n      case "invalid_element":\n        return ` ${issue2.origin}`;\n      default:\n        return ``;\n    }\n  };\n};\nfunction km_default() {\n  return {\n    localeError: error24()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/kh.js\nfunction kh_default() {\n  return km_default();\n}\n// ../../node_modules/zod/v4/locales/ko.js\nvar error25 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "to have" },\n    file: { unit: "", verb: "to have" },\n    array: { unit: "", verb: "to have" },\n    set: { unit: "", verb: "to have" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: " ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64  ",\n    base64url: "base64url  ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` :   instanceof ${issue2.expected},   ${received}`;\n        }\n        return ` :   ${expected},   ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` :  ${stringifyPrimitive(issue2.values[0])}  `;\n        return ` : ${joinValues(issue2.values, " ")}   `;\n      case "too_big": {\n        const adj = issue2.inclusive ? "" : "";\n        const suffix = adj === "" ? " " : " ";\n        const sizing = getSizing(issue2.origin);\n        const unit = sizing?.unit ?? "";\n        if (sizing)\n          return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;\n        return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()} ${adj}${suffix}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? "" : "";\n        const suffix = adj === "" ? " " : " ";\n        const sizing = getSizing(issue2.origin);\n        const unit = sizing?.unit ?? "";\n        if (sizing) {\n          return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;\n        }\n        return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()} ${adj}${suffix}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` : "${_issue.prefix}"()  `;\n        }\n        if (_issue.format === "ends_with")\n          return ` : "${_issue.suffix}"()  `;\n        if (_issue.format === "includes")\n          return ` : "${_issue.includes}"()  `;\n        if (_issue.format === "regex")\n          return ` :  ${_issue.pattern}   `;\n        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` : ${issue2.divisor}  `;\n      case "unrecognized_keys":\n        return `   : ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return ` : ${issue2.origin}`;\n      case "invalid_union":\n        return ` `;\n      case "invalid_element":\n        return ` : ${issue2.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction ko_default() {\n  return {\n    localeError: error25()\n  };\n}\n// ../../node_modules/zod/v4/locales/lt.js\nvar capitalizeFirstCharacter = (text) => {\n  return text.charAt(0).toUpperCase() + text.slice(1);\n};\nfunction getUnitTypeFromNumber(number2) {\n  const abs = Math.abs(number2);\n  const last = abs % 10;\n  const last2 = abs % 100;\n  if (last2 >= 11 && last2 <= 19 || last === 0)\n    return "many";\n  if (last === 1)\n    return "one";\n  return "few";\n}\nvar error26 = () => {\n  const Sizable = {\n    string: {\n      unit: {\n        one: "simbolis",\n        few: "simboliai",\n        many: "simboli"\n      },\n      verb: {\n        smaller: {\n          inclusive: "turi bti ne ilgesn kaip",\n          notInclusive: "turi bti trumpesn kaip"\n        },\n        bigger: {\n          inclusive: "turi bti ne trumpesn kaip",\n          notInclusive: "turi bti ilgesn kaip"\n        }\n      }\n    },\n    file: {\n      unit: {\n        one: "baitas",\n        few: "baitai",\n        many: "bait"\n      },\n      verb: {\n        smaller: {\n          inclusive: "turi bti ne didesnis kaip",\n          notInclusive: "turi bti maesnis kaip"\n        },\n        bigger: {\n          inclusive: "turi bti ne maesnis kaip",\n          notInclusive: "turi bti didesnis kaip"\n        }\n      }\n    },\n    array: {\n      unit: {\n        one: "element",\n        few: "elementus",\n        many: "element"\n      },\n      verb: {\n        smaller: {\n          inclusive: "turi turti ne daugiau kaip",\n          notInclusive: "turi turti maiau kaip"\n        },\n        bigger: {\n          inclusive: "turi turti ne maiau kaip",\n          notInclusive: "turi turti daugiau kaip"\n        }\n      }\n    },\n    set: {\n      unit: {\n        one: "element",\n        few: "elementus",\n        many: "element"\n      },\n      verb: {\n        smaller: {\n          inclusive: "turi turti ne daugiau kaip",\n          notInclusive: "turi turti maiau kaip"\n        },\n        bigger: {\n          inclusive: "turi turti ne maiau kaip",\n          notInclusive: "turi turti daugiau kaip"\n        }\n      }\n    }\n  };\n  function getSizing(origin, unitType, inclusive, targetShouldBe) {\n    const result = Sizable[origin] ?? null;\n    if (result === null)\n      return result;\n    return {\n      unit: result.unit[unitType],\n      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]\n    };\n  }\n  const FormatDictionary = {\n    regex: "vestis",\n    email: "el. pato adresas",\n    url: "URL",\n    emoji: "jaustukas",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO data ir laikas",\n    date: "ISO data",\n    time: "ISO laikas",\n    duration: "ISO trukm",\n    ipv4: "IPv4 adresas",\n    ipv6: "IPv6 adresas",\n    cidrv4: "IPv4 tinklo prefiksas (CIDR)",\n    cidrv6: "IPv6 tinklo prefiksas (CIDR)",\n    base64: "base64 ukoduota eilut",\n    base64url: "base64url ukoduota eilut",\n    json_string: "JSON eilut",\n    e164: "E.164 numeris",\n    jwt: "JWT",\n    template_literal: "vestis"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "skaiius",\n    bigint: "sveikasis skaiius",\n    string: "eilut",\n    boolean: "login reikm",\n    undefined: "neapibrta reikm",\n    function: "funkcija",\n    symbol: "simbolis",\n    array: "masyvas",\n    object: "objektas",\n    null: "nulin reikm"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Gautas tipas ${received}, o tiktasi - instanceof ${issue2.expected}`;\n        }\n        return `Gautas tipas ${received}, o tiktasi - ${expected}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Privalo bti ${stringifyPrimitive(issue2.values[0])}`;\n        return `Privalo bti vienas i ${joinValues(issue2.values, "|")} pasirinkim`;\n      case "too_big": {\n        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;\n        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");\n        if (sizing?.verb)\n          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;\n        const adj = issue2.inclusive ? "ne didesnis kaip" : "maesnis kaip";\n        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;\n      }\n      case "too_small": {\n        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;\n        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");\n        if (sizing?.verb)\n          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element"}`;\n        const adj = issue2.inclusive ? "ne maesnis kaip" : "didesnis kaip";\n        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Eilut privalo prasidti "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Eilut privalo pasibaigti "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Eilut privalo traukti "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Eilut privalo atitikti ${_issue.pattern}`;\n        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Skaiius privalo bti ${issue2.divisor} kartotinis.`;\n      case "unrecognized_keys":\n        return `Neatpaint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return "Rastas klaidingas raktas";\n      case "invalid_union":\n        return "Klaidinga vestis";\n      case "invalid_element": {\n        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;\n        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi klaiding vest`;\n      }\n      default:\n        return "Klaidinga vestis";\n    }\n  };\n};\nfunction lt_default() {\n  return {\n    localeError: error26()\n  };\n}\n// ../../node_modules/zod/v4/locales/mk.js\nvar error27 = () => {\n  const Sizable = {\n    string: { unit: "", verb: " " },\n    file: { unit: "", verb: " " },\n    array: { unit: "", verb: " " },\n    set: { unit: "", verb: " " }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: "  -",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO   ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64- ",\n    base64url: "base64url- ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` :   instanceof ${issue2.expected},  ${received}`;\n        }\n        return ` :   ${expected},  ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :    ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` :     "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return ` :     "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return ` :    "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` :      ${_issue.pattern}`;\n        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` :      ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? " " : " "}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return " ";\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction mk_default() {\n  return {\n    localeError: error27()\n  };\n}\n// ../../node_modules/zod/v4/locales/ms.js\nvar error28 = () => {\n  const Sizable = {\n    string: { unit: "aksara", verb: "mempunyai" },\n    file: { unit: "bait", verb: "mempunyai" },\n    array: { unit: "elemen", verb: "mempunyai" },\n    set: { unit: "elemen", verb: "mempunyai" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "input",\n    email: "alamat e-mel",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "tarikh masa ISO",\n    date: "tarikh ISO",\n    time: "masa ISO",\n    duration: "tempoh ISO",\n    ipv4: "alamat IPv4",\n    ipv6: "alamat IPv6",\n    cidrv4: "julat IPv4",\n    cidrv6: "julat IPv6",\n    base64: "string dikodkan base64",\n    base64url: "string dikodkan base64url",\n    json_string: "string JSON",\n    e164: "nombor E.164",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "nombor"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;\n        }\n        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;\n        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;\n        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;\n        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;\n      }\n      case "not_multiple_of":\n        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Kunci tidak sah dalam ${issue2.origin}`;\n      case "invalid_union":\n        return "Input tidak sah";\n      case "invalid_element":\n        return `Nilai tidak sah dalam ${issue2.origin}`;\n      default:\n        return `Input tidak sah`;\n    }\n  };\n};\nfunction ms_default() {\n  return {\n    localeError: error28()\n  };\n}\n// ../../node_modules/zod/v4/locales/nl.js\nvar error29 = () => {\n  const Sizable = {\n    string: { unit: "tekens", verb: "heeft" },\n    file: { unit: "bytes", verb: "heeft" },\n    array: { unit: "elementen", verb: "heeft" },\n    set: { unit: "elementen", verb: "heeft" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "invoer",\n    email: "emailadres",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO datum en tijd",\n    date: "ISO datum",\n    time: "ISO tijd",\n    duration: "ISO duur",\n    ipv4: "IPv4-adres",\n    ipv6: "IPv6-adres",\n    cidrv4: "IPv4-bereik",\n    cidrv6: "IPv6-bereik",\n    base64: "base64-gecodeerde tekst",\n    base64url: "base64 URL-gecodeerde tekst",\n    json_string: "JSON string",\n    e164: "E.164-nummer",\n    jwt: "JWT",\n    template_literal: "invoer"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "getal"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;\n        }\n        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ongeldige optie: verwacht n van ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";\n        if (sizing)\n          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;\n        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";\n        if (sizing) {\n          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;\n        }\n        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;\n        }\n        if (_issue.format === "ends_with")\n          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;\n        if (_issue.format === "includes")\n          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;\n        if (_issue.format === "regex")\n          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;\n        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;\n      case "unrecognized_keys":\n        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Ongeldige key in ${issue2.origin}`;\n      case "invalid_union":\n        return "Ongeldige invoer";\n      case "invalid_element":\n        return `Ongeldige waarde in ${issue2.origin}`;\n      default:\n        return `Ongeldige invoer`;\n    }\n  };\n};\nfunction nl_default() {\n  return {\n    localeError: error29()\n  };\n}\n// ../../node_modules/zod/v4/locales/no.js\nvar error30 = () => {\n  const Sizable = {\n    string: { unit: "tegn", verb: " ha" },\n    file: { unit: "bytes", verb: " ha" },\n    array: { unit: "elementer", verb: " inneholde" },\n    set: { unit: "elementer", verb: " inneholde" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "input",\n    email: "e-postadresse",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO dato- og klokkeslett",\n    date: "ISO-dato",\n    time: "ISO-klokkeslett",\n    duration: "ISO-varighet",\n    ipv4: "IPv4-omrde",\n    ipv6: "IPv6-omrde",\n    cidrv4: "IPv4-spekter",\n    cidrv6: "IPv6-spekter",\n    base64: "base64-enkodet streng",\n    base64url: "base64url-enkodet streng",\n    json_string: "JSON-streng",\n    e164: "E.164-nummer",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "tall",\n    array: "liste"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;\n        }\n        return `Ugyldig input: forventet ${expected}, fikk ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;\n        return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Ugyldig streng: m starte med "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Ugyldig streng: m ende med "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Ugyldig streng: m inneholde "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;\n        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Ugyldig tall: m vre et multiplum av ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Ugyldig nkkel i ${issue2.origin}`;\n      case "invalid_union":\n        return "Ugyldig input";\n      case "invalid_element":\n        return `Ugyldig verdi i ${issue2.origin}`;\n      default:\n        return `Ugyldig input`;\n    }\n  };\n};\nfunction no_default() {\n  return {\n    localeError: error30()\n  };\n}\n// ../../node_modules/zod/v4/locales/ota.js\nvar error31 = () => {\n  const Sizable = {\n    string: { unit: "harf", verb: "olmaldr" },\n    file: { unit: "bayt", verb: "olmaldr" },\n    array: { unit: "unsur", verb: "olmaldr" },\n    set: { unit: "unsur", verb: "olmaldr" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "giren",\n    email: "epostagh",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO hengm",\n    date: "ISO tarihi",\n    time: "ISO zaman",\n    duration: "ISO mddeti",\n    ipv4: "IPv4 nin",\n    ipv6: "IPv6 nin",\n    cidrv4: "IPv4 menzili",\n    cidrv6: "IPv6 menzili",\n    base64: "base64-ifreli metin",\n    base64url: "base64url-ifreli metin",\n    json_string: "JSON metin",\n    e164: "E.164 says",\n    jwt: "JWT",\n    template_literal: "giren"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "numara",\n    array: "saf",\n    null: "gayb"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Fsit giren: umulan instanceof ${issue2.expected}, alnan ${received}`;\n        }\n        return `Fsit giren: umulan ${expected}, alnan ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Fsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;\n        return `Fsit tercih: mteberler ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;\n        return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalyd.`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalyd.`;\n        }\n        return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalyd.`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Fsit metin: "${_issue.prefix}" ile balamal.`;\n        if (_issue.format === "ends_with")\n          return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;\n        if (_issue.format === "includes")\n          return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;\n        if (_issue.format === "regex")\n          return `Fsit metin: ${_issue.pattern} nakna uymal.`;\n        return `Fsit ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Fsit say: ${issue2.divisor} kat olmalyd.`;\n      case "unrecognized_keys":\n        return `Tannmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin} iin tannmayan anahtar var.`;\n      case "invalid_union":\n        return "Giren tannamad.";\n      case "invalid_element":\n        return `${issue2.origin} iin tannmayan kymet var.`;\n      default:\n        return `Kymet tannamad.`;\n    }\n  };\n};\nfunction ota_default() {\n  return {\n    localeError: error31()\n  };\n}\n// ../../node_modules/zod/v4/locales/ps.js\nvar error32 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: "",\n    url: "  ",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "  ",\n    date: "",\n    time: "",\n    duration: "",\n    ipv4: " IPv4 ",\n    ipv6: " IPv6 ",\n    cidrv4: " IPv4 ",\n    cidrv6: " IPv6 ",\n    base64: "base64-encoded ",\n    base64url: "base64url-encoded ",\n    json_string: "JSON ",\n    e164: " E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` :  instanceof ${issue2.expected} ,  ${received}  `;\n        }\n        return ` :  ${expected} ,  ${received}  `;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1) {\n          return ` :  ${stringifyPrimitive(issue2.values[0])} `;\n        }\n        return ` :    ${joinValues(issue2.values, "|")}  `;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;\n        }\n        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;\n        }\n        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` :   "${_issue.prefix}"   `;\n        }\n        if (_issue.format === "ends_with") {\n          return ` :   "${_issue.suffix}"    `;\n        }\n        if (_issue.format === "includes") {\n          return ` :  "${_issue.includes}" `;\n        }\n        if (_issue.format === "regex") {\n          return ` :   ${_issue.pattern}   `;\n        }\n        return `${FormatDictionary[_issue.format] ?? issue2.format}  `;\n      }\n      case "not_multiple_of":\n        return ` :   ${issue2.divisor}  `;\n      case "unrecognized_keys":\n        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin} `;\n      case "invalid_union":\n        return ` `;\n      case "invalid_element":\n        return `   ${issue2.origin} `;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction ps_default() {\n  return {\n    localeError: error32()\n  };\n}\n// ../../node_modules/zod/v4/locales/pl.js\nvar error33 = () => {\n  const Sizable = {\n    string: { unit: "znakw", verb: "mie" },\n    file: { unit: "bajtw", verb: "mie" },\n    array: { unit: "elementw", verb: "mie" },\n    set: { unit: "elementw", verb: "mie" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "wyraenie",\n    email: "adres email",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "data i godzina w formacie ISO",\n    date: "data w formacie ISO",\n    time: "godzina w formacie ISO",\n    duration: "czas trwania ISO",\n    ipv4: "adres IPv4",\n    ipv6: "adres IPv6",\n    cidrv4: "zakres IPv4",\n    cidrv6: "zakres IPv6",\n    base64: "cig znakw zakodowany w formacie base64",\n    base64url: "cig znakw zakodowany w formacie base64url",\n    json_string: "cig znakw w formacie JSON",\n    e164: "liczba E.164",\n    jwt: "JWT",\n    template_literal: "wejcie"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "liczba",\n    array: "tablica"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Nieprawidowe dane wejciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;\n        }\n        return `Nieprawidowe dane wejciowe: oczekiwano ${expected}, otrzymano ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;\n        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Za dua warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementw"}`;\n        }\n        return `Zbyt du(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Za maa warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementw"}`;\n        }\n        return `Zbyt ma(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;\n        return `Nieprawidow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Nieprawidowy klucz w ${issue2.origin}`;\n      case "invalid_union":\n        return "Nieprawidowe dane wejciowe";\n      case "invalid_element":\n        return `Nieprawidowa warto w ${issue2.origin}`;\n      default:\n        return `Nieprawidowe dane wejciowe`;\n    }\n  };\n};\nfunction pl_default() {\n  return {\n    localeError: error33()\n  };\n}\n// ../../node_modules/zod/v4/locales/pt.js\nvar error34 = () => {\n  const Sizable = {\n    string: { unit: "caracteres", verb: "ter" },\n    file: { unit: "bytes", verb: "ter" },\n    array: { unit: "itens", verb: "ter" },\n    set: { unit: "itens", verb: "ter" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "padro",\n    email: "endereo de e-mail",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "data e hora ISO",\n    date: "data ISO",\n    time: "hora ISO",\n    duration: "durao ISO",\n    ipv4: "endereo IPv4",\n    ipv6: "endereo IPv6",\n    cidrv4: "faixa de IPv4",\n    cidrv6: "faixa de IPv6",\n    base64: "texto codificado em base64",\n    base64url: "URL codificada em base64",\n    json_string: "texto JSON",\n    e164: "nmero E.164",\n    jwt: "JWT",\n    template_literal: "entrada"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "nmero",\n    null: "nulo"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Tipo invlido: esperado instanceof ${issue2.expected}, recebido ${received}`;\n        }\n        return `Tipo invlido: esperado ${expected}, recebido ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Entrada invlida: esperado ${stringifyPrimitive(issue2.values[0])}`;\n        return `Opo invlida: esperada uma das ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;\n        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Texto invlido: deve comear com "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Texto invlido: deve terminar com "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Texto invlido: deve incluir "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;\n        return `${FormatDictionary[_issue.format] ?? issue2.format} invlido`;\n      }\n      case "not_multiple_of":\n        return `Nmero invlido: deve ser mltiplo de ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Chave invlida em ${issue2.origin}`;\n      case "invalid_union":\n        return "Entrada invlida";\n      case "invalid_element":\n        return `Valor invlido em ${issue2.origin}`;\n      default:\n        return `Campo invlido`;\n    }\n  };\n};\nfunction pt_default() {\n  return {\n    localeError: error34()\n  };\n}\n// ../../node_modules/zod/v4/locales/ru.js\nfunction getRussianPlural(count, one, few, many) {\n  const absCount = Math.abs(count);\n  const lastDigit = absCount % 10;\n  const lastTwoDigits = absCount % 100;\n  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n    return many;\n  }\n  if (lastDigit === 1) {\n    return one;\n  }\n  if (lastDigit >= 2 && lastDigit <= 4) {\n    return few;\n  }\n  return many;\n}\nvar error35 = () => {\n  const Sizable = {\n    string: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    file: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    array: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    },\n    set: {\n      unit: {\n        one: "",\n        few: "",\n        many: ""\n      },\n      verb: ""\n    }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: "email ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO   ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "   base64",\n    base64url: "   base64url",\n    json_string: "JSON ",\n    e164: " E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` :  instanceof ${issue2.expected},  ${received}`;\n        }\n        return ` :  ${expected},  ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` :  ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :    ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          const maxValue = Number(issue2.maximum);\n          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return `  : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${unit}`;\n        }\n        return `  : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          const minValue = Number(issue2.minimum);\n          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n          return `  : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${unit}`;\n        }\n        return `  : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return ` :    "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return ` :    "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return ` :   "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` :    ${_issue.pattern}`;\n        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` :    ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return "  ";\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return `  `;\n    }\n  };\n};\nfunction ru_default() {\n  return {\n    localeError: error35()\n  };\n}\n// ../../node_modules/zod/v4/locales/sl.js\nvar error36 = () => {\n  const Sizable = {\n    string: { unit: "znakov", verb: "imeti" },\n    file: { unit: "bajtov", verb: "imeti" },\n    array: { unit: "elementov", verb: "imeti" },\n    set: { unit: "elementov", verb: "imeti" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "vnos",\n    email: "e-potni naslov",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO datum in as",\n    date: "ISO datum",\n    time: "ISO as",\n    duration: "ISO trajanje",\n    ipv4: "IPv4 naslov",\n    ipv6: "IPv6 naslov",\n    cidrv4: "obseg IPv4",\n    cidrv6: "obseg IPv6",\n    base64: "base64 kodiran niz",\n    base64url: "base64url kodiran niz",\n    json_string: "JSON niz",\n    e164: "E.164 tevilka",\n    jwt: "JWT",\n    template_literal: "vnos"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "tevilo",\n    array: "tabela"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Neveljaven vnos: priakovano instanceof ${issue2.expected}, prejeto ${received}`;\n        }\n        return `Neveljaven vnos: priakovano ${expected}, prejeto ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue2.values[0])}`;\n        return `Neveljavna monost: priakovano eno izmed ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;\n        return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Premajhno: priakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Premajhno: priakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;\n        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Neveljavno tevilo: mora biti vekratnik ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Neprepoznan${issue2.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Neveljaven klju v ${issue2.origin}`;\n      case "invalid_union":\n        return "Neveljaven vnos";\n      case "invalid_element":\n        return `Neveljavna vrednost v ${issue2.origin}`;\n      default:\n        return "Neveljaven vnos";\n    }\n  };\n};\nfunction sl_default() {\n  return {\n    localeError: error36()\n  };\n}\n// ../../node_modules/zod/v4/locales/sv.js\nvar error37 = () => {\n  const Sizable = {\n    string: { unit: "tecken", verb: "att ha" },\n    file: { unit: "bytes", verb: "att ha" },\n    array: { unit: "objekt", verb: "att innehlla" },\n    set: { unit: "objekt", verb: "att innehlla" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "reguljrt uttryck",\n    email: "e-postadress",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO-datum och tid",\n    date: "ISO-datum",\n    time: "ISO-tid",\n    duration: "ISO-varaktighet",\n    ipv4: "IPv4-intervall",\n    ipv6: "IPv6-intervall",\n    cidrv4: "IPv4-spektrum",\n    cidrv6: "IPv6-spektrum",\n    base64: "base64-kodad strng",\n    base64url: "base64url-kodad strng",\n    json_string: "JSON-strng",\n    e164: "E.164-nummer",\n    jwt: "JWT",\n    template_literal: "mall-literal"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "antal",\n    array: "lista"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Ogiltig inmatning: frvntat instanceof ${issue2.expected}, fick ${received}`;\n        }\n        return `Ogiltig inmatning: frvntat ${expected}, fick ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ogiltigt val: frvntade en av ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Fr stor(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;\n        }\n        return `Fr stor(t): frvntat ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Ogiltig strng: mste brja med "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Ogiltig strng: mste innehlla "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;\n        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Ogiltigt tal: mste vara en multipel av ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Ogiltig nyckel i ${issue2.origin ?? "vrdet"}`;\n      case "invalid_union":\n        return "Ogiltig input";\n      case "invalid_element":\n        return `Ogiltigt vrde i ${issue2.origin ?? "vrdet"}`;\n      default:\n        return `Ogiltig input`;\n    }\n  };\n};\nfunction sv_default() {\n  return {\n    localeError: error37()\n  };\n}\n// ../../node_modules/zod/v4/locales/ta.js\nvar error38 = () => {\n  const Sizable = {\n    string: { unit: "", verb: " " },\n    file: { unit: "", verb: " " },\n    array: { unit: "", verb: " " },\n    set: { unit: "", verb: " " }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: " ",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO  ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO  ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64-encoded ",\n    base64url: "base64url-encoded ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: "",\n    null: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` :  instanceof ${issue2.expected},  ${received}`;\n        }\n        return ` :  ${expected},  ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` :  ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :  ${joinValues(issue2.values, "|")}  `;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;\n        }\n        return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}   `;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;\n        }\n        return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()}   `;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return ` : "${_issue.prefix}"   `;\n        if (_issue.format === "ends_with")\n          return ` : "${_issue.suffix}"   `;\n        if (_issue.format === "includes")\n          return ` : "${_issue.includes}"   `;\n        if (_issue.format === "regex")\n          return ` : ${_issue.pattern}   `;\n        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` : ${issue2.divisor}    `;\n      case "unrecognized_keys":\n        return `  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin}   `;\n      case "invalid_union":\n        return " ";\n      case "invalid_element":\n        return `${issue2.origin}   `;\n      default:\n        return ` `;\n    }\n  };\n};\nfunction ta_default() {\n  return {\n    localeError: error38()\n  };\n}\n// ../../node_modules/zod/v4/locales/th.js\nvar error39 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: "",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: " ISO",\n    date: " ISO",\n    time: " ISO",\n    duration: " ISO",\n    ipv4: " IPv4",\n    ipv6: " IPv6",\n    cidrv4: " IP  IPv4",\n    cidrv6: " IP  IPv6",\n    base64: " Base64",\n    base64url: " Base64  URL",\n    json_string: " JSON",\n    e164: " (E.164)",\n    jwt: " JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: " (Array)",\n    null: " (null)"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `:  instanceof ${issue2.expected}  ${received}`;\n        }\n        return `:  ${expected}  ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `:  ${stringifyPrimitive(issue2.values[0])}`;\n        return `:  ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "" : "";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? "" : "";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `:  "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `:  "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `:  "${_issue.includes}" `;\n        if (_issue.format === "regex")\n          return `:  ${_issue.pattern}`;\n        return `: ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `:  ${issue2.divisor} `;\n      case "unrecognized_keys":\n        return `: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return ` ${issue2.origin}`;\n      case "invalid_union":\n        return ": ";\n      case "invalid_element":\n        return ` ${issue2.origin}`;\n      default:\n        return ``;\n    }\n  };\n};\nfunction th_default() {\n  return {\n    localeError: error39()\n  };\n}\n// ../../node_modules/zod/v4/locales/tr.js\nvar error40 = () => {\n  const Sizable = {\n    string: { unit: "karakter", verb: "olmal" },\n    file: { unit: "bayt", verb: "olmal" },\n    array: { unit: "e", verb: "olmal" },\n    set: { unit: "e", verb: "olmal" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "girdi",\n    email: "e-posta adresi",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO tarih ve saat",\n    date: "ISO tarih",\n    time: "ISO saat",\n    duration: "ISO sre",\n    ipv4: "IPv4 adresi",\n    ipv6: "IPv6 adresi",\n    cidrv4: "IPv4 aral",\n    cidrv6: "IPv6 aral",\n    base64: "base64 ile ifrelenmi metin",\n    base64url: "base64url ile ifrelenmi metin",\n    json_string: "JSON dizesi",\n    e164: "E.164 says",\n    jwt: "JWT",\n    template_literal: "ablon dizesi"\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Geersiz deer: beklenen instanceof ${issue2.expected}, alnan ${received}`;\n        }\n        return `Geersiz deer: beklenen ${expected}, alnan ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Geersiz deer: beklenen ${stringifyPrimitive(issue2.values[0])}`;\n        return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "e"}`;\n        return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Geersiz metin: "${_issue.prefix}" ile balamal`;\n        if (_issue.format === "ends_with")\n          return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;\n        if (_issue.format === "includes")\n          return `Geersiz metin: "${_issue.includes}" iermeli`;\n        if (_issue.format === "regex")\n          return `Geersiz metin: ${_issue.pattern} desenine uymal`;\n        return `Geersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Geersiz say: ${issue2.divisor} ile tam blnebilmeli`;\n      case "unrecognized_keys":\n        return `Tannmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin} iinde geersiz anahtar`;\n      case "invalid_union":\n        return "Geersiz deer";\n      case "invalid_element":\n        return `${issue2.origin} iinde geersiz deer`;\n      default:\n        return `Geersiz deer`;\n    }\n  };\n};\nfunction tr_default() {\n  return {\n    localeError: error40()\n  };\n}\n// ../../node_modules/zod/v4/locales/uk.js\nvar error41 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: " ",\n    email: "  ",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "   ISO",\n    date: " ISO",\n    time: " ISO",\n    duration: " ISO",\n    ipv4: " IPv4",\n    ipv6: " IPv6",\n    cidrv4: " IPv4",\n    cidrv6: " IPv6",\n    base64: "   base64",\n    base64url: "   base64url",\n    json_string: " JSON",\n    e164: " E.164",\n    jwt: "JWT",\n    template_literal: " "\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `  :  instanceof ${issue2.expected},  ${received}`;\n        }\n        return `  :  ${expected},  ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `  :  ${stringifyPrimitive(issue2.values[0])}`;\n        return ` :    ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` : ,  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return ` : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ,  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return ` :    "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return ` :    "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return ` :   "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` :    ${_issue.pattern}`;\n        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` :    ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `   ${issue2.origin}`;\n      case "invalid_union":\n        return "  ";\n      case "invalid_element":\n        return `   ${issue2.origin}`;\n      default:\n        return `  `;\n    }\n  };\n};\nfunction uk_default() {\n  return {\n    localeError: error41()\n  };\n}\n\n// ../../node_modules/zod/v4/locales/ua.js\nfunction ua_default() {\n  return uk_default();\n}\n// ../../node_modules/zod/v4/locales/ur.js\nvar error42 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: " ",\n    email: "  ",\n    url: "  ",\n    emoji: "",\n    uuid: "   ",\n    uuidv4: "     4",\n    uuidv6: "     6",\n    nanoid: "  ",\n    guid: "   ",\n    cuid: "   ",\n    cuid2: "    2",\n    ulid: "   ",\n    xid: "  ",\n    ksuid: "    ",\n    datetime: "    ",\n    date: "   ",\n    time: "   ",\n    duration: "   ",\n    ipv4: "   4 ",\n    ipv6: "   6 ",\n    cidrv4: "   4 ",\n    cidrv6: "   6 ",\n    base64: " 64   ",\n    base64url: " 64      ",\n    json_string: "    ",\n    e164: " 164 ",\n    jwt: "  ",\n    template_literal: " "\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: "",\n    null: ""\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `  : instanceof ${issue2.expected}   ${received}  `;\n        }\n        return `  : ${expected}   ${received}  `;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `  : ${stringifyPrimitive(issue2.values[0])}  `;\n        return ` : ${joinValues(issue2.values, "|")}     `;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;\n        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}   `;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;\n        }\n        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()}   `;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` : "${_issue.prefix}"    `;\n        }\n        if (_issue.format === "ends_with")\n          return ` : "${_issue.suffix}"    `;\n        if (_issue.format === "includes")\n          return ` : "${_issue.includes}"   `;\n        if (_issue.format === "regex")\n          return ` :  ${_issue.pattern}    `;\n        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` : ${issue2.divisor}    `;\n      case "unrecognized_keys":\n        return `   ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;\n      case "invalid_key":\n        return `${issue2.origin}   `;\n      case "invalid_union":\n        return "  ";\n      case "invalid_element":\n        return `${issue2.origin}   `;\n      default:\n        return `  `;\n    }\n  };\n};\nfunction ur_default() {\n  return {\n    localeError: error42()\n  };\n}\n// ../../node_modules/zod/v4/locales/uz.js\nvar error43 = () => {\n  const Sizable = {\n    string: { unit: "belgi", verb: "bolishi kerak" },\n    file: { unit: "bayt", verb: "bolishi kerak" },\n    array: { unit: "element", verb: "bolishi kerak" },\n    set: { unit: "element", verb: "bolishi kerak" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "kirish",\n    email: "elektron pochta manzili",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO sana va vaqti",\n    date: "ISO sana",\n    time: "ISO vaqt",\n    duration: "ISO davomiylik",\n    ipv4: "IPv4 manzil",\n    ipv6: "IPv6 manzil",\n    mac: "MAC manzil",\n    cidrv4: "IPv4 diapazon",\n    cidrv6: "IPv6 diapazon",\n    base64: "base64 kodlangan satr",\n    base64url: "base64url kodlangan satr",\n    json_string: "JSON satr",\n    e164: "E.164 raqam",\n    jwt: "JWT",\n    template_literal: "kirish"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "raqam",\n    array: "massiv"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `Notogri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;\n        }\n        return `Notogri kirish: kutilgan ${expected}, qabul qilingan ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Notogri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;\n        return `Notogri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;\n        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;\n        }\n        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Notogri satr: "${_issue.prefix}" bilan boshlanishi kerak`;\n        if (_issue.format === "ends_with")\n          return `Notogri satr: "${_issue.suffix}" bilan tugashi kerak`;\n        if (_issue.format === "includes")\n          return `Notogri satr: "${_issue.includes}" ni oz ichiga olishi kerak`;\n        if (_issue.format === "regex")\n          return `Notogri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;\n        return `Notogri ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Notogri raqam: ${issue2.divisor} ning karralisi bolishi kerak`;\n      case "unrecognized_keys":\n        return `Nomalum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin} dagi kalit notogri`;\n      case "invalid_union":\n        return "Notogri kirish";\n      case "invalid_element":\n        return `${issue2.origin} da notogri qiymat`;\n      default:\n        return `Notogri kirish`;\n    }\n  };\n};\nfunction uz_default() {\n  return {\n    localeError: error43()\n  };\n}\n// ../../node_modules/zod/v4/locales/vi.js\nvar error44 = () => {\n  const Sizable = {\n    string: { unit: "k t", verb: "c" },\n    file: { unit: "byte", verb: "c" },\n    array: { unit: "phn t", verb: "c" },\n    set: { unit: "phn t", verb: "c" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "u vo",\n    email: "a ch email",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ngy gi ISO",\n    date: "ngy ISO",\n    time: "gi ISO",\n    duration: "khong thi gian ISO",\n    ipv4: "a ch IPv4",\n    ipv6: "a ch IPv6",\n    cidrv4: "di IPv4",\n    cidrv6: "di IPv6",\n    base64: "chui m ha base64",\n    base64url: "chui m ha base64url",\n    json_string: "chui JSON",\n    e164: "s E.164",\n    jwt: "JWT",\n    template_literal: "u vo"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "s",\n    array: "mng"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `u vo khng hp l: mong i instanceof ${issue2.expected}, nhn c ${received}`;\n        }\n        return `u vo khng hp l: mong i ${expected}, nhn c ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `u vo khng hp l: mong i ${stringifyPrimitive(issue2.values[0])}`;\n        return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phn t"}`;\n        return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Qu nh: mong i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Qu nh: mong i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Chui khng hp l: phi bao gm "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;\n        return `${FormatDictionary[_issue.format] ?? issue2.format} khng hp l`;\n      }\n      case "not_multiple_of":\n        return `S khng hp l: phi l bi s ca ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Kha khng c nhn dng: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Kha khng hp l trong ${issue2.origin}`;\n      case "invalid_union":\n        return "u vo khng hp l";\n      case "invalid_element":\n        return `Gi tr khng hp l trong ${issue2.origin}`;\n      default:\n        return `u vo khng hp l`;\n    }\n  };\n};\nfunction vi_default() {\n  return {\n    localeError: error44()\n  };\n}\n// ../../node_modules/zod/v4/locales/zh-CN.js\nvar error45 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: "",\n    url: "URL",\n    emoji: "",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO",\n    date: "ISO",\n    time: "ISO",\n    duration: "ISO",\n    ipv4: "IPv4",\n    ipv6: "IPv6",\n    cidrv4: "IPv4",\n    cidrv6: "IPv6",\n    base64: "base64",\n    base64url: "base64url",\n    json_string: "JSON",\n    e164: "E.164",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "",\n    array: "",\n    null: "(null)"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` instanceof ${issue2.expected} ${received}`;\n        }\n        return ` ${expected} ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` ${stringifyPrimitive(issue2.values[0])}`;\n        return ` ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` ${issue2.origin} ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return ` "${_issue.prefix}" `;\n        if (_issue.format === "ends_with")\n          return ` "${_issue.suffix}" `;\n        if (_issue.format === "includes")\n          return ` "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` ${_issue.pattern}`;\n        return `${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` ${issue2.divisor} `;\n      case "unrecognized_keys":\n        return `(key): ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `${issue2.origin} (key)`;\n      case "invalid_union":\n        return "";\n      case "invalid_element":\n        return `${issue2.origin} (value)`;\n      default:\n        return ``;\n    }\n  };\n};\nfunction zh_CN_default() {\n  return {\n    localeError: error45()\n  };\n}\n// ../../node_modules/zod/v4/locales/zh-TW.js\nvar error46 = () => {\n  const Sizable = {\n    string: { unit: "", verb: "" },\n    file: { unit: "", verb: "" },\n    array: { unit: "", verb: "" },\n    set: { unit: "", verb: "" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "",\n    email: "",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO ",\n    date: "ISO ",\n    time: "ISO ",\n    duration: "ISO ",\n    ipv4: "IPv4 ",\n    ipv6: "IPv6 ",\n    cidrv4: "IPv4 ",\n    cidrv6: "IPv6 ",\n    base64: "base64 ",\n    base64url: "base64url ",\n    json_string: "JSON ",\n    e164: "E.164 ",\n    jwt: "JWT",\n    template_literal: ""\n  };\n  const TypeDictionary = {\n    nan: "NaN"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return ` instanceof ${issue2.expected} ${received}`;\n        }\n        return ` ${expected} ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return ` ${stringifyPrimitive(issue2.values[0])}`;\n        return ` ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;\n        return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return ` "${_issue.prefix}" `;\n        }\n        if (_issue.format === "ends_with")\n          return ` "${_issue.suffix}" `;\n        if (_issue.format === "includes")\n          return ` "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return ` ${_issue.pattern}`;\n        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return ` ${issue2.divisor} `;\n      case "unrecognized_keys":\n        return `${issue2.keys.length > 1 ? "" : ""}${joinValues(issue2.keys, "")}`;\n      case "invalid_key":\n        return `${issue2.origin} `;\n      case "invalid_union":\n        return "";\n      case "invalid_element":\n        return `${issue2.origin} `;\n      default:\n        return ``;\n    }\n  };\n};\nfunction zh_TW_default() {\n  return {\n    localeError: error46()\n  };\n}\n// ../../node_modules/zod/v4/locales/yo.js\nvar error47 = () => {\n  const Sizable = {\n    string: { unit: "mi", verb: "n" },\n    file: { unit: "bytes", verb: "n" },\n    array: { unit: "nkan", verb: "n" },\n    set: { unit: "nkan", verb: "n" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const FormatDictionary = {\n    regex: "r bwl",\n    email: "drs ml",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "kk ISO",\n    date: "j ISO",\n    time: "kk ISO",\n    duration: "kk t p ISO",\n    ipv4: "drs IPv4",\n    ipv6: "drs IPv6",\n    cidrv4: "gbgb IPv4",\n    cidrv6: "gbgb IPv6",\n    base64: "r t a k n base64",\n    base64url: "r base64url",\n    json_string: "r JSON",\n    e164: "nmb E.164",\n    jwt: "JWT",\n    template_literal: "r bwl"\n  };\n  const TypeDictionary = {\n    nan: "NaN",\n    number: "nmb",\n    array: "akop"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type": {\n        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;\n        const receivedType = parsedType(issue2.input);\n        const received = TypeDictionary[receivedType] ?? receivedType;\n        if (/^[A-Z]/.test(issue2.expected)) {\n          return `bwl ae: a n lti fi instanceof ${issue2.expected}, m a r ${received}`;\n        }\n        return `bwl ae: a n lti fi ${expected}, m a r ${received}`;\n      }\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `bwl ae: a n lti fi ${stringifyPrimitive(issue2.values[0])}`;\n        return `yn ae: yan kan lra ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `T p j: a n lti j p ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;\n        return `T p j: a n lti j ${adj}${issue2.maximum}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Kr ju: a n lti j p ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;\n        return `Kr ju: a n lti j ${adj}${issue2.minimum}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with")\n          return `r ae: gbd br pl "${_issue.prefix}"`;\n        if (_issue.format === "ends_with")\n          return `r ae: gbd par pl "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `r ae: gbd n "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `r ae: gbd b pr mu ${_issue.pattern}`;\n        return `Ae: ${FormatDictionary[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Nmb ae: gbd j y ppn ti ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Btn m: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Btn ae nn ${issue2.origin}`;\n      case "invalid_union":\n        return "bwl ae";\n      case "invalid_element":\n        return `Iye ae nn ${issue2.origin}`;\n      default:\n        return "bwl ae";\n    }\n  };\n};\nfunction yo_default() {\n  return {\n    localeError: error47()\n  };\n}\n// ../../node_modules/zod/v4/core/registries.js\nvar _a15;\nvar $output = Symbol("ZodOutput");\nvar $input = Symbol("ZodInput");\n\nclass $ZodRegistry {\n  constructor() {\n    this._map = new WeakMap;\n    this._idmap = new Map;\n  }\n  add(schema, ..._meta) {\n    const meta = _meta[0];\n    this._map.set(schema, meta);\n    if (meta && typeof meta === "object" && "id" in meta) {\n      this._idmap.set(meta.id, schema);\n    }\n    return this;\n  }\n  clear() {\n    this._map = new WeakMap;\n    this._idmap = new Map;\n    return this;\n  }\n  remove(schema) {\n    const meta = this._map.get(schema);\n    if (meta && typeof meta === "object" && "id" in meta) {\n      this._idmap.delete(meta.id);\n    }\n    this._map.delete(schema);\n    return this;\n  }\n  get(schema) {\n    const p = schema._zod.parent;\n    if (p) {\n      const pm = { ...this.get(p) ?? {} };\n      delete pm.id;\n      const f = { ...pm, ...this._map.get(schema) };\n      return Object.keys(f).length ? f : undefined;\n    }\n    return this._map.get(schema);\n  }\n  has(schema) {\n    return this._map.has(schema);\n  }\n}\nfunction registry() {\n  return new $ZodRegistry;\n}\n(_a15 = globalThis).__zod_globalRegistry ?? (_a15.__zod_globalRegistry = registry());\nvar globalRegistry = globalThis.__zod_globalRegistry;\n// ../../node_modules/zod/v4/core/api.js\nfunction _string(Class2, params) {\n  return new Class2({\n    type: "string",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedString(Class2, params) {\n  return new Class2({\n    type: "string",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _email(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "email",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _guid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "guid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _uuid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv4(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    version: "v4",\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv6(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    version: "v6",\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv7(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    version: "v7",\n    ...normalizeParams(params)\n  });\n}\nfunction _url(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "url",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _emoji2(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "emoji",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _nanoid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "nanoid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cuid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cuid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cuid2(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cuid2",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ulid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ulid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _xid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "xid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ksuid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ksuid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ipv4(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ipv4",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ipv6(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ipv6",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _mac(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "mac",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cidrv4(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cidrv4",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cidrv6(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cidrv6",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _base64(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "base64",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _base64url(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "base64url",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _e164(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "e164",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _jwt(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "jwt",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nvar TimePrecision = {\n  Any: null,\n  Minute: -1,\n  Second: 0,\n  Millisecond: 3,\n  Microsecond: 6\n};\nfunction _isoDateTime(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "datetime",\n    check: "string_format",\n    offset: false,\n    local: false,\n    precision: null,\n    ...normalizeParams(params)\n  });\n}\nfunction _isoDate(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "date",\n    check: "string_format",\n    ...normalizeParams(params)\n  });\n}\nfunction _isoTime(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "time",\n    check: "string_format",\n    precision: null,\n    ...normalizeParams(params)\n  });\n}\nfunction _isoDuration(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "duration",\n    check: "string_format",\n    ...normalizeParams(params)\n  });\n}\nfunction _number(Class2, params) {\n  return new Class2({\n    type: "number",\n    checks: [],\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedNumber(Class2, params) {\n  return new Class2({\n    type: "number",\n    coerce: true,\n    checks: [],\n    ...normalizeParams(params)\n  });\n}\nfunction _int(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "safeint",\n    ...normalizeParams(params)\n  });\n}\nfunction _float32(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "float32",\n    ...normalizeParams(params)\n  });\n}\nfunction _float64(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "float64",\n    ...normalizeParams(params)\n  });\n}\nfunction _int32(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "int32",\n    ...normalizeParams(params)\n  });\n}\nfunction _uint32(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "uint32",\n    ...normalizeParams(params)\n  });\n}\nfunction _boolean(Class2, params) {\n  return new Class2({\n    type: "boolean",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedBoolean(Class2, params) {\n  return new Class2({\n    type: "boolean",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _bigint(Class2, params) {\n  return new Class2({\n    type: "bigint",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedBigint(Class2, params) {\n  return new Class2({\n    type: "bigint",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _int64(Class2, params) {\n  return new Class2({\n    type: "bigint",\n    check: "bigint_format",\n    abort: false,\n    format: "int64",\n    ...normalizeParams(params)\n  });\n}\nfunction _uint64(Class2, params) {\n  return new Class2({\n    type: "bigint",\n    check: "bigint_format",\n    abort: false,\n    format: "uint64",\n    ...normalizeParams(params)\n  });\n}\nfunction _symbol(Class2, params) {\n  return new Class2({\n    type: "symbol",\n    ...normalizeParams(params)\n  });\n}\nfunction _undefined2(Class2, params) {\n  return new Class2({\n    type: "undefined",\n    ...normalizeParams(params)\n  });\n}\nfunction _null2(Class2, params) {\n  return new Class2({\n    type: "null",\n    ...normalizeParams(params)\n  });\n}\nfunction _any(Class2) {\n  return new Class2({\n    type: "any"\n  });\n}\nfunction _unknown(Class2) {\n  return new Class2({\n    type: "unknown"\n  });\n}\nfunction _never(Class2, params) {\n  return new Class2({\n    type: "never",\n    ...normalizeParams(params)\n  });\n}\nfunction _void(Class2, params) {\n  return new Class2({\n    type: "void",\n    ...normalizeParams(params)\n  });\n}\nfunction _date(Class2, params) {\n  return new Class2({\n    type: "date",\n    ...normalizeParams(params)\n  });\n}\nfunction _coercedDate(Class2, params) {\n  return new Class2({\n    type: "date",\n    coerce: true,\n    ...normalizeParams(params)\n  });\n}\nfunction _nan(Class2, params) {\n  return new Class2({\n    type: "nan",\n    ...normalizeParams(params)\n  });\n}\nfunction _lt(value, params) {\n  return new $ZodCheckLessThan({\n    check: "less_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: false\n  });\n}\nfunction _lte(value, params) {\n  return new $ZodCheckLessThan({\n    check: "less_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: true\n  });\n}\nfunction _gt(value, params) {\n  return new $ZodCheckGreaterThan({\n    check: "greater_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: false\n  });\n}\nfunction _gte(value, params) {\n  return new $ZodCheckGreaterThan({\n    check: "greater_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: true\n  });\n}\nfunction _positive(params) {\n  return _gt(0, params);\n}\nfunction _negative(params) {\n  return _lt(0, params);\n}\nfunction _nonpositive(params) {\n  return _lte(0, params);\n}\nfunction _nonnegative(params) {\n  return _gte(0, params);\n}\nfunction _multipleOf(value, params) {\n  return new $ZodCheckMultipleOf({\n    check: "multiple_of",\n    ...normalizeParams(params),\n    value\n  });\n}\nfunction _maxSize(maximum, params) {\n  return new $ZodCheckMaxSize({\n    check: "max_size",\n    ...normalizeParams(params),\n    maximum\n  });\n}\nfunction _minSize(minimum, params) {\n  return new $ZodCheckMinSize({\n    check: "min_size",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _size(size, params) {\n  return new $ZodCheckSizeEquals({\n    check: "size_equals",\n    ...normalizeParams(params),\n    size\n  });\n}\nfunction _maxLength(maximum, params) {\n  const ch = new $ZodCheckMaxLength({\n    check: "max_length",\n    ...normalizeParams(params),\n    maximum\n  });\n  return ch;\n}\nfunction _minLength(minimum, params) {\n  return new $ZodCheckMinLength({\n    check: "min_length",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _length(length, params) {\n  return new $ZodCheckLengthEquals({\n    check: "length_equals",\n    ...normalizeParams(params),\n    length\n  });\n}\nfunction _regex(pattern, params) {\n  return new $ZodCheckRegex({\n    check: "string_format",\n    format: "regex",\n    ...normalizeParams(params),\n    pattern\n  });\n}\nfunction _lowercase(params) {\n  return new $ZodCheckLowerCase({\n    check: "string_format",\n    format: "lowercase",\n    ...normalizeParams(params)\n  });\n}\nfunction _uppercase(params) {\n  return new $ZodCheckUpperCase({\n    check: "string_format",\n    format: "uppercase",\n    ...normalizeParams(params)\n  });\n}\nfunction _includes(includes, params) {\n  return new $ZodCheckIncludes({\n    check: "string_format",\n    format: "includes",\n    ...normalizeParams(params),\n    includes\n  });\n}\nfunction _startsWith(prefix, params) {\n  return new $ZodCheckStartsWith({\n    check: "string_format",\n    format: "starts_with",\n    ...normalizeParams(params),\n    prefix\n  });\n}\nfunction _endsWith(suffix, params) {\n  return new $ZodCheckEndsWith({\n    check: "string_format",\n    format: "ends_with",\n    ...normalizeParams(params),\n    suffix\n  });\n}\nfunction _property(property, schema, params) {\n  return new $ZodCheckProperty({\n    check: "property",\n    property,\n    schema,\n    ...normalizeParams(params)\n  });\n}\nfunction _mime(types, params) {\n  return new $ZodCheckMimeType({\n    check: "mime_type",\n    mime: types,\n    ...normalizeParams(params)\n  });\n}\nfunction _overwrite(tx) {\n  return new $ZodCheckOverwrite({\n    check: "overwrite",\n    tx\n  });\n}\nfunction _normalize(form) {\n  return _overwrite((input) => input.normalize(form));\n}\nfunction _trim() {\n  return _overwrite((input) => input.trim());\n}\nfunction _toLowerCase() {\n  return _overwrite((input) => input.toLowerCase());\n}\nfunction _toUpperCase() {\n  return _overwrite((input) => input.toUpperCase());\n}\nfunction _slugify() {\n  return _overwrite((input) => slugify(input));\n}\nfunction _array(Class2, element, params) {\n  return new Class2({\n    type: "array",\n    element,\n    ...normalizeParams(params)\n  });\n}\nfunction _union(Class2, options, params) {\n  return new Class2({\n    type: "union",\n    options,\n    ...normalizeParams(params)\n  });\n}\nfunction _xor(Class2, options, params) {\n  return new Class2({\n    type: "union",\n    options,\n    inclusive: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _discriminatedUnion(Class2, discriminator, options, params) {\n  return new Class2({\n    type: "union",\n    options,\n    discriminator,\n    ...normalizeParams(params)\n  });\n}\nfunction _intersection(Class2, left, right) {\n  return new Class2({\n    type: "intersection",\n    left,\n    right\n  });\n}\nfunction _tuple(Class2, items, _paramsOrRest, _params) {\n  const hasRest = _paramsOrRest instanceof $ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new Class2({\n    type: "tuple",\n    items,\n    rest,\n    ...normalizeParams(params)\n  });\n}\nfunction _record(Class2, keyType, valueType, params) {\n  return new Class2({\n    type: "record",\n    keyType,\n    valueType,\n    ...normalizeParams(params)\n  });\n}\nfunction _map(Class2, keyType, valueType, params) {\n  return new Class2({\n    type: "map",\n    keyType,\n    valueType,\n    ...normalizeParams(params)\n  });\n}\nfunction _set(Class2, valueType, params) {\n  return new Class2({\n    type: "set",\n    valueType,\n    ...normalizeParams(params)\n  });\n}\nfunction _enum(Class2, values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n  return new Class2({\n    type: "enum",\n    entries,\n    ...normalizeParams(params)\n  });\n}\nfunction _nativeEnum(Class2, entries, params) {\n  return new Class2({\n    type: "enum",\n    entries,\n    ...normalizeParams(params)\n  });\n}\nfunction _literal(Class2, value, params) {\n  return new Class2({\n    type: "literal",\n    values: Array.isArray(value) ? value : [value],\n    ...normalizeParams(params)\n  });\n}\nfunction _file(Class2, params) {\n  return new Class2({\n    type: "file",\n    ...normalizeParams(params)\n  });\n}\nfunction _transform(Class2, fn) {\n  return new Class2({\n    type: "transform",\n    transform: fn\n  });\n}\nfunction _optional(Class2, innerType) {\n  return new Class2({\n    type: "optional",\n    innerType\n  });\n}\nfunction _nullable(Class2, innerType) {\n  return new Class2({\n    type: "nullable",\n    innerType\n  });\n}\nfunction _default(Class2, innerType, defaultValue) {\n  return new Class2({\n    type: "default",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);\n    }\n  });\n}\nfunction _nonoptional(Class2, innerType, params) {\n  return new Class2({\n    type: "nonoptional",\n    innerType,\n    ...normalizeParams(params)\n  });\n}\nfunction _success(Class2, innerType) {\n  return new Class2({\n    type: "success",\n    innerType\n  });\n}\nfunction _catch(Class2, innerType, catchValue) {\n  return new Class2({\n    type: "catch",\n    innerType,\n    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue\n  });\n}\nfunction _pipe(Class2, in_, out) {\n  return new Class2({\n    type: "pipe",\n    in: in_,\n    out\n  });\n}\nfunction _readonly(Class2, innerType) {\n  return new Class2({\n    type: "readonly",\n    innerType\n  });\n}\nfunction _templateLiteral(Class2, parts, params) {\n  return new Class2({\n    type: "template_literal",\n    parts,\n    ...normalizeParams(params)\n  });\n}\nfunction _lazy(Class2, getter) {\n  return new Class2({\n    type: "lazy",\n    getter\n  });\n}\nfunction _promise(Class2, innerType) {\n  return new Class2({\n    type: "promise",\n    innerType\n  });\n}\nfunction _custom(Class2, fn, _params) {\n  const norm = normalizeParams(_params);\n  norm.abort ?? (norm.abort = true);\n  const schema = new Class2({\n    type: "custom",\n    check: "custom",\n    fn,\n    ...norm\n  });\n  return schema;\n}\nfunction _refine(Class2, fn, _params) {\n  const schema = new Class2({\n    type: "custom",\n    check: "custom",\n    fn,\n    ...normalizeParams(_params)\n  });\n  return schema;\n}\nfunction _superRefine(fn) {\n  const ch = _check((payload) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === "string") {\n        payload.issues.push(issue(issue2, payload.value, ch._zod.def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = "custom");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = ch);\n        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);\n        payload.issues.push(issue(_issue));\n      }\n    };\n    return fn(payload.value, payload);\n  });\n  return ch;\n}\nfunction _check(fn, params) {\n  const ch = new $ZodCheck({\n    check: "custom",\n    ...normalizeParams(params)\n  });\n  ch._zod.check = fn;\n  return ch;\n}\nfunction describe(description) {\n  const ch = new $ZodCheck({ check: "describe" });\n  ch._zod.onattach = [\n    (inst) => {\n      const existing = globalRegistry.get(inst) ?? {};\n      globalRegistry.add(inst, { ...existing, description });\n    }\n  ];\n  ch._zod.check = () => {};\n  return ch;\n}\nfunction meta(metadata) {\n  const ch = new $ZodCheck({ check: "meta" });\n  ch._zod.onattach = [\n    (inst) => {\n      const existing = globalRegistry.get(inst) ?? {};\n      globalRegistry.add(inst, { ...existing, ...metadata });\n    }\n  ];\n  ch._zod.check = () => {};\n  return ch;\n}\nfunction _stringbool(Classes, _params) {\n  const params = normalizeParams(_params);\n  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];\n  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];\n  if (params.case !== "sensitive") {\n    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);\n    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);\n  }\n  const truthySet = new Set(truthyArray);\n  const falsySet = new Set(falsyArray);\n  const _Codec = Classes.Codec ?? $ZodCodec;\n  const _Boolean = Classes.Boolean ?? $ZodBoolean;\n  const _String = Classes.String ?? $ZodString;\n  const stringSchema = new _String({ type: "string", error: params.error });\n  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });\n  const codec = new _Codec({\n    type: "pipe",\n    in: stringSchema,\n    out: booleanSchema,\n    transform: (input, payload) => {\n      let data = input;\n      if (params.case !== "sensitive")\n        data = data.toLowerCase();\n      if (truthySet.has(data)) {\n        return true;\n      } else if (falsySet.has(data)) {\n        return false;\n      } else {\n        payload.issues.push({\n          code: "invalid_value",\n          expected: "stringbool",\n          values: [...truthySet, ...falsySet],\n          input: payload.value,\n          inst: codec,\n          continue: false\n        });\n        return {};\n      }\n    },\n    reverseTransform: (input, _payload) => {\n      if (input === true) {\n        return truthyArray[0] || "true";\n      } else {\n        return falsyArray[0] || "false";\n      }\n    },\n    error: params.error\n  });\n  return codec;\n}\nfunction _stringFormat(Class2, format, fnOrRegex, _params = {}) {\n  const params = normalizeParams(_params);\n  const def = {\n    ...normalizeParams(_params),\n    check: "string_format",\n    type: "string",\n    format,\n    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),\n    ...params\n  };\n  if (fnOrRegex instanceof RegExp) {\n    def.pattern = fnOrRegex;\n  }\n  const inst = new Class2(def);\n  return inst;\n}\n// ../../node_modules/zod/v4/core/to-json-schema.js\nfunction initializeContext(params) {\n  let target = params?.target ?? "draft-2020-12";\n  if (target === "draft-4")\n    target = "draft-04";\n  if (target === "draft-7")\n    target = "draft-07";\n  return {\n    processors: params.processors ?? {},\n    metadataRegistry: params?.metadata ?? globalRegistry,\n    target,\n    unrepresentable: params?.unrepresentable ?? "throw",\n    override: params?.override ?? (() => {}),\n    io: params?.io ?? "output",\n    counter: 0,\n    seen: new Map,\n    cycles: params?.cycles ?? "ref",\n    reused: params?.reused ?? "inline",\n    external: params?.external ?? undefined\n  };\n}\nfunction process2(schema, ctx, _params = { path: [], schemaPath: [] }) {\n  var _a16;\n  const def = schema._zod.def;\n  const seen = ctx.seen.get(schema);\n  if (seen) {\n    seen.count++;\n    const isCycle = _params.schemaPath.includes(schema);\n    if (isCycle) {\n      seen.cycle = _params.path;\n    }\n    return seen.schema;\n  }\n  const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };\n  ctx.seen.set(schema, result);\n  const overrideSchema = schema._zod.toJSONSchema?.();\n  if (overrideSchema) {\n    result.schema = overrideSchema;\n  } else {\n    const params = {\n      ..._params,\n      schemaPath: [..._params.schemaPath, schema],\n      path: _params.path\n    };\n    if (schema._zod.processJSONSchema) {\n      schema._zod.processJSONSchema(ctx, result.schema, params);\n    } else {\n      const _json = result.schema;\n      const processor = ctx.processors[def.type];\n      if (!processor) {\n        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);\n      }\n      processor(schema, ctx, _json, params);\n    }\n    const parent = schema._zod.parent;\n    if (parent) {\n      if (!result.ref)\n        result.ref = parent;\n      process2(parent, ctx, params);\n      ctx.seen.get(parent).isParent = true;\n    }\n  }\n  const meta2 = ctx.metadataRegistry.get(schema);\n  if (meta2)\n    Object.assign(result.schema, meta2);\n  if (ctx.io === "input" && isTransforming(schema)) {\n    delete result.schema.examples;\n    delete result.schema.default;\n  }\n  if (ctx.io === "input" && result.schema._prefault)\n    (_a16 = result.schema).default ?? (_a16.default = result.schema._prefault);\n  delete result.schema._prefault;\n  const _result = ctx.seen.get(schema);\n  return _result.schema;\n}\nfunction extractDefs(ctx, schema) {\n  const root = ctx.seen.get(schema);\n  if (!root)\n    throw new Error("Unprocessed schema. This is a bug in Zod.");\n  const idToSchema = new Map;\n  for (const entry of ctx.seen.entries()) {\n    const id = ctx.metadataRegistry.get(entry[0])?.id;\n    if (id) {\n      const existing = idToSchema.get(id);\n      if (existing && existing !== entry[0]) {\n        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);\n      }\n      idToSchema.set(id, entry[0]);\n    }\n  }\n  const makeURI = (entry) => {\n    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";\n    if (ctx.external) {\n      const externalId = ctx.external.registry.get(entry[0])?.id;\n      const uriGenerator = ctx.external.uri ?? ((id2) => id2);\n      if (externalId) {\n        return { ref: uriGenerator(externalId) };\n      }\n      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;\n      entry[1].defId = id;\n      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };\n    }\n    if (entry[1] === root) {\n      return { ref: "#" };\n    }\n    const uriPrefix = `#`;\n    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;\n    return { defId, ref: defUriPrefix + defId };\n  };\n  const extractToDef = (entry) => {\n    if (entry[1].schema.$ref) {\n      return;\n    }\n    const seen = entry[1];\n    const { ref, defId } = makeURI(entry);\n    seen.def = { ...seen.schema };\n    if (defId)\n      seen.defId = defId;\n    const schema2 = seen.schema;\n    for (const key in schema2) {\n      delete schema2[key];\n    }\n    schema2.$ref = ref;\n  };\n  if (ctx.cycles === "throw") {\n    for (const entry of ctx.seen.entries()) {\n      const seen = entry[1];\n      if (seen.cycle) {\n        throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + \'\\n\\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.\');\n      }\n    }\n  }\n  for (const entry of ctx.seen.entries()) {\n    const seen = entry[1];\n    if (schema === entry[0]) {\n      extractToDef(entry);\n      continue;\n    }\n    if (ctx.external) {\n      const ext = ctx.external.registry.get(entry[0])?.id;\n      if (schema !== entry[0] && ext) {\n        extractToDef(entry);\n        continue;\n      }\n    }\n    const id = ctx.metadataRegistry.get(entry[0])?.id;\n    if (id) {\n      extractToDef(entry);\n      continue;\n    }\n    if (seen.cycle) {\n      extractToDef(entry);\n      continue;\n    }\n    if (seen.count > 1) {\n      if (ctx.reused === "ref") {\n        extractToDef(entry);\n        continue;\n      }\n    }\n  }\n}\nfunction finalize(ctx, schema) {\n  const root = ctx.seen.get(schema);\n  if (!root)\n    throw new Error("Unprocessed schema. This is a bug in Zod.");\n  const flattenRef = (zodSchema) => {\n    const seen = ctx.seen.get(zodSchema);\n    if (seen.ref === null)\n      return;\n    const schema2 = seen.def ?? seen.schema;\n    const _cached = { ...schema2 };\n    const ref = seen.ref;\n    seen.ref = null;\n    if (ref) {\n      flattenRef(ref);\n      const refSeen = ctx.seen.get(ref);\n      const refSchema = refSeen.schema;\n      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {\n        schema2.allOf = schema2.allOf ?? [];\n        schema2.allOf.push(refSchema);\n      } else {\n        Object.assign(schema2, refSchema);\n      }\n      Object.assign(schema2, _cached);\n      const isParentRef = zodSchema._zod.parent === ref;\n      if (isParentRef) {\n        for (const key in schema2) {\n          if (key === "$ref" || key === "allOf")\n            continue;\n          if (!(key in _cached)) {\n            delete schema2[key];\n          }\n        }\n      }\n      if (refSchema.$ref) {\n        for (const key in schema2) {\n          if (key === "$ref" || key === "allOf")\n            continue;\n          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {\n            delete schema2[key];\n          }\n        }\n      }\n    }\n    const parent = zodSchema._zod.parent;\n    if (parent && parent !== ref) {\n      flattenRef(parent);\n      const parentSeen = ctx.seen.get(parent);\n      if (parentSeen?.schema.$ref) {\n        schema2.$ref = parentSeen.schema.$ref;\n        if (parentSeen.def) {\n          for (const key in schema2) {\n            if (key === "$ref" || key === "allOf")\n              continue;\n            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {\n              delete schema2[key];\n            }\n          }\n        }\n      }\n    }\n    ctx.override({\n      zodSchema,\n      jsonSchema: schema2,\n      path: seen.path ?? []\n    });\n  };\n  for (const entry of [...ctx.seen.entries()].reverse()) {\n    flattenRef(entry[0]);\n  }\n  const result = {};\n  if (ctx.target === "draft-2020-12") {\n    result.$schema = "https://json-schema.org/draft/2020-12/schema";\n  } else if (ctx.target === "draft-07") {\n    result.$schema = "http://json-schema.org/draft-07/schema#";\n  } else if (ctx.target === "draft-04") {\n    result.$schema = "http://json-schema.org/draft-04/schema#";\n  } else if (ctx.target === "openapi-3.0") {} else {}\n  if (ctx.external?.uri) {\n    const id = ctx.external.registry.get(schema)?.id;\n    if (!id)\n      throw new Error("Schema is missing an `id` property");\n    result.$id = ctx.external.uri(id);\n  }\n  Object.assign(result, root.def ?? root.schema);\n  const defs = ctx.external?.defs ?? {};\n  for (const entry of ctx.seen.entries()) {\n    const seen = entry[1];\n    if (seen.def && seen.defId) {\n      defs[seen.defId] = seen.def;\n    }\n  }\n  if (ctx.external) {} else {\n    if (Object.keys(defs).length > 0) {\n      if (ctx.target === "draft-2020-12") {\n        result.$defs = defs;\n      } else {\n        result.definitions = defs;\n      }\n    }\n  }\n  try {\n    const finalized = JSON.parse(JSON.stringify(result));\n    Object.defineProperty(finalized, "~standard", {\n      value: {\n        ...schema["~standard"],\n        jsonSchema: {\n          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),\n          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)\n        }\n      },\n      enumerable: false,\n      writable: false\n    });\n    return finalized;\n  } catch (_err) {\n    throw new Error("Error converting schema to JSON.");\n  }\n}\nfunction isTransforming(_schema, _ctx) {\n  const ctx = _ctx ?? { seen: new Set };\n  if (ctx.seen.has(_schema))\n    return false;\n  ctx.seen.add(_schema);\n  const def = _schema._zod.def;\n  if (def.type === "transform")\n    return true;\n  if (def.type === "array")\n    return isTransforming(def.element, ctx);\n  if (def.type === "set")\n    return isTransforming(def.valueType, ctx);\n  if (def.type === "lazy")\n    return isTransforming(def.getter(), ctx);\n  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {\n    return isTransforming(def.innerType, ctx);\n  }\n  if (def.type === "intersection") {\n    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n  }\n  if (def.type === "record" || def.type === "map") {\n    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n  }\n  if (def.type === "pipe") {\n    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n  }\n  if (def.type === "object") {\n    for (const key in def.shape) {\n      if (isTransforming(def.shape[key], ctx))\n        return true;\n    }\n    return false;\n  }\n  if (def.type === "union") {\n    for (const option of def.options) {\n      if (isTransforming(option, ctx))\n        return true;\n    }\n    return false;\n  }\n  if (def.type === "tuple") {\n    for (const item of def.items) {\n      if (isTransforming(item, ctx))\n        return true;\n    }\n    if (def.rest && isTransforming(def.rest, ctx))\n      return true;\n    return false;\n  }\n  return false;\n}\nvar createToJSONSchemaMethod = (schema, processors = {}) => (params) => {\n  const ctx = initializeContext({ ...params, processors });\n  process2(schema, ctx);\n  extractDefs(ctx, schema);\n  return finalize(ctx, schema);\n};\nvar createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {\n  const { libraryOptions, target } = params ?? {};\n  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });\n  process2(schema, ctx);\n  extractDefs(ctx, schema);\n  return finalize(ctx, schema);\n};\n// ../../node_modules/zod/v4/core/json-schema-processors.js\nvar formatMap = {\n  guid: "uuid",\n  url: "uri",\n  datetime: "date-time",\n  json_string: "json-string",\n  regex: ""\n};\nvar stringProcessor = (schema, ctx, _json, _params) => {\n  const json = _json;\n  json.type = "string";\n  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;\n  if (typeof minimum === "number")\n    json.minLength = minimum;\n  if (typeof maximum === "number")\n    json.maxLength = maximum;\n  if (format) {\n    json.format = formatMap[format] ?? format;\n    if (json.format === "")\n      delete json.format;\n    if (format === "time") {\n      delete json.format;\n    }\n  }\n  if (contentEncoding)\n    json.contentEncoding = contentEncoding;\n  if (patterns && patterns.size > 0) {\n    const regexes = [...patterns];\n    if (regexes.length === 1)\n      json.pattern = regexes[0].source;\n    else if (regexes.length > 1) {\n      json.allOf = [\n        ...regexes.map((regex) => ({\n          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},\n          pattern: regex.source\n        }))\n      ];\n    }\n  }\n};\nvar numberProcessor = (schema, ctx, _json, _params) => {\n  const json = _json;\n  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n  if (typeof format === "string" && format.includes("int"))\n    json.type = "integer";\n  else\n    json.type = "number";\n  if (typeof exclusiveMinimum === "number") {\n    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {\n      json.minimum = exclusiveMinimum;\n      json.exclusiveMinimum = true;\n    } else {\n      json.exclusiveMinimum = exclusiveMinimum;\n    }\n  }\n  if (typeof minimum === "number") {\n    json.minimum = minimum;\n    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {\n      if (exclusiveMinimum >= minimum)\n        delete json.minimum;\n      else\n        delete json.exclusiveMinimum;\n    }\n  }\n  if (typeof exclusiveMaximum === "number") {\n    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {\n      json.maximum = exclusiveMaximum;\n      json.exclusiveMaximum = true;\n    } else {\n      json.exclusiveMaximum = exclusiveMaximum;\n    }\n  }\n  if (typeof maximum === "number") {\n    json.maximum = maximum;\n    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {\n      if (exclusiveMaximum <= maximum)\n        delete json.maximum;\n      else\n        delete json.exclusiveMaximum;\n    }\n  }\n  if (typeof multipleOf === "number")\n    json.multipleOf = multipleOf;\n};\nvar booleanProcessor = (_schema, _ctx, json, _params) => {\n  json.type = "boolean";\n};\nvar bigintProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("BigInt cannot be represented in JSON Schema");\n  }\n};\nvar symbolProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("Symbols cannot be represented in JSON Schema");\n  }\n};\nvar nullProcessor = (_schema, ctx, json, _params) => {\n  if (ctx.target === "openapi-3.0") {\n    json.type = "string";\n    json.nullable = true;\n    json.enum = [null];\n  } else {\n    json.type = "null";\n  }\n};\nvar undefinedProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("Undefined cannot be represented in JSON Schema");\n  }\n};\nvar voidProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("Void cannot be represented in JSON Schema");\n  }\n};\nvar neverProcessor = (_schema, _ctx, json, _params) => {\n  json.not = {};\n};\nvar anyProcessor = (_schema, _ctx, _json, _params) => {};\nvar unknownProcessor = (_schema, _ctx, _json, _params) => {};\nvar dateProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("Date cannot be represented in JSON Schema");\n  }\n};\nvar enumProcessor = (schema, _ctx, json, _params) => {\n  const def = schema._zod.def;\n  const values = getEnumValues(def.entries);\n  if (values.every((v) => typeof v === "number"))\n    json.type = "number";\n  if (values.every((v) => typeof v === "string"))\n    json.type = "string";\n  json.enum = values;\n};\nvar literalProcessor = (schema, ctx, json, _params) => {\n  const def = schema._zod.def;\n  const vals = [];\n  for (const val of def.values) {\n    if (val === undefined) {\n      if (ctx.unrepresentable === "throw") {\n        throw new Error("Literal `undefined` cannot be represented in JSON Schema");\n      } else {}\n    } else if (typeof val === "bigint") {\n      if (ctx.unrepresentable === "throw") {\n        throw new Error("BigInt literals cannot be represented in JSON Schema");\n      } else {\n        vals.push(Number(val));\n      }\n    } else {\n      vals.push(val);\n    }\n  }\n  if (vals.length === 0) {} else if (vals.length === 1) {\n    const val = vals[0];\n    json.type = val === null ? "null" : typeof val;\n    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {\n      json.enum = [val];\n    } else {\n      json.const = val;\n    }\n  } else {\n    if (vals.every((v) => typeof v === "number"))\n      json.type = "number";\n    if (vals.every((v) => typeof v === "string"))\n      json.type = "string";\n    if (vals.every((v) => typeof v === "boolean"))\n      json.type = "boolean";\n    if (vals.every((v) => v === null))\n      json.type = "null";\n    json.enum = vals;\n  }\n};\nvar nanProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("NaN cannot be represented in JSON Schema");\n  }\n};\nvar templateLiteralProcessor = (schema, _ctx, json, _params) => {\n  const _json = json;\n  const pattern = schema._zod.pattern;\n  if (!pattern)\n    throw new Error("Pattern not found in template literal");\n  _json.type = "string";\n  _json.pattern = pattern.source;\n};\nvar fileProcessor = (schema, _ctx, json, _params) => {\n  const _json = json;\n  const file = {\n    type: "string",\n    format: "binary",\n    contentEncoding: "binary"\n  };\n  const { minimum, maximum, mime } = schema._zod.bag;\n  if (minimum !== undefined)\n    file.minLength = minimum;\n  if (maximum !== undefined)\n    file.maxLength = maximum;\n  if (mime) {\n    if (mime.length === 1) {\n      file.contentMediaType = mime[0];\n      Object.assign(_json, file);\n    } else {\n      Object.assign(_json, file);\n      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));\n    }\n  } else {\n    Object.assign(_json, file);\n  }\n};\nvar successProcessor = (_schema, _ctx, json, _params) => {\n  json.type = "boolean";\n};\nvar customProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("Custom types cannot be represented in JSON Schema");\n  }\n};\nvar functionProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("Function types cannot be represented in JSON Schema");\n  }\n};\nvar transformProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("Transforms cannot be represented in JSON Schema");\n  }\n};\nvar mapProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("Map cannot be represented in JSON Schema");\n  }\n};\nvar setProcessor = (_schema, ctx, _json, _params) => {\n  if (ctx.unrepresentable === "throw") {\n    throw new Error("Set cannot be represented in JSON Schema");\n  }\n};\nvar arrayProcessor = (schema, ctx, _json, params) => {\n  const json = _json;\n  const def = schema._zod.def;\n  const { minimum, maximum } = schema._zod.bag;\n  if (typeof minimum === "number")\n    json.minItems = minimum;\n  if (typeof maximum === "number")\n    json.maxItems = maximum;\n  json.type = "array";\n  json.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });\n};\nvar objectProcessor = (schema, ctx, _json, params) => {\n  const json = _json;\n  const def = schema._zod.def;\n  json.type = "object";\n  json.properties = {};\n  const shape = def.shape;\n  for (const key in shape) {\n    json.properties[key] = process2(shape[key], ctx, {\n      ...params,\n      path: [...params.path, "properties", key]\n    });\n  }\n  const allKeys = new Set(Object.keys(shape));\n  const requiredKeys = new Set([...allKeys].filter((key) => {\n    const v = def.shape[key]._zod;\n    if (ctx.io === "input") {\n      return v.optin === undefined;\n    } else {\n      return v.optout === undefined;\n    }\n  }));\n  if (requiredKeys.size > 0) {\n    json.required = Array.from(requiredKeys);\n  }\n  if (def.catchall?._zod.def.type === "never") {\n    json.additionalProperties = false;\n  } else if (!def.catchall) {\n    if (ctx.io === "output")\n      json.additionalProperties = false;\n  } else if (def.catchall) {\n    json.additionalProperties = process2(def.catchall, ctx, {\n      ...params,\n      path: [...params.path, "additionalProperties"]\n    });\n  }\n};\nvar unionProcessor = (schema, ctx, json, params) => {\n  const def = schema._zod.def;\n  const isExclusive = def.inclusive === false;\n  const options = def.options.map((x, i2) => process2(x, ctx, {\n    ...params,\n    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i2]\n  }));\n  if (isExclusive) {\n    json.oneOf = options;\n  } else {\n    json.anyOf = options;\n  }\n};\nvar intersectionProcessor = (schema, ctx, json, params) => {\n  const def = schema._zod.def;\n  const a2 = process2(def.left, ctx, {\n    ...params,\n    path: [...params.path, "allOf", 0]\n  });\n  const b = process2(def.right, ctx, {\n    ...params,\n    path: [...params.path, "allOf", 1]\n  });\n  const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;\n  const allOf = [\n    ...isSimpleIntersection(a2) ? a2.allOf : [a2],\n    ...isSimpleIntersection(b) ? b.allOf : [b]\n  ];\n  json.allOf = allOf;\n};\nvar tupleProcessor = (schema, ctx, _json, params) => {\n  const json = _json;\n  const def = schema._zod.def;\n  json.type = "array";\n  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";\n  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";\n  const prefixItems = def.items.map((x, i2) => process2(x, ctx, {\n    ...params,\n    path: [...params.path, prefixPath, i2]\n  }));\n  const rest = def.rest ? process2(def.rest, ctx, {\n    ...params,\n    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]\n  }) : null;\n  if (ctx.target === "draft-2020-12") {\n    json.prefixItems = prefixItems;\n    if (rest) {\n      json.items = rest;\n    }\n  } else if (ctx.target === "openapi-3.0") {\n    json.items = {\n      anyOf: prefixItems\n    };\n    if (rest) {\n      json.items.anyOf.push(rest);\n    }\n    json.minItems = prefixItems.length;\n    if (!rest) {\n      json.maxItems = prefixItems.length;\n    }\n  } else {\n    json.items = prefixItems;\n    if (rest) {\n      json.additionalItems = rest;\n    }\n  }\n  const { minimum, maximum } = schema._zod.bag;\n  if (typeof minimum === "number")\n    json.minItems = minimum;\n  if (typeof maximum === "number")\n    json.maxItems = maximum;\n};\nvar recordProcessor = (schema, ctx, _json, params) => {\n  const json = _json;\n  const def = schema._zod.def;\n  json.type = "object";\n  const keyType = def.keyType;\n  const keyBag = keyType._zod.bag;\n  const patterns = keyBag?.patterns;\n  if (def.mode === "loose" && patterns && patterns.size > 0) {\n    const valueSchema = process2(def.valueType, ctx, {\n      ...params,\n      path: [...params.path, "patternProperties", "*"]\n    });\n    json.patternProperties = {};\n    for (const pattern of patterns) {\n      json.patternProperties[pattern.source] = valueSchema;\n    }\n  } else {\n    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {\n      json.propertyNames = process2(def.keyType, ctx, {\n        ...params,\n        path: [...params.path, "propertyNames"]\n      });\n    }\n    json.additionalProperties = process2(def.valueType, ctx, {\n      ...params,\n      path: [...params.path, "additionalProperties"]\n    });\n  }\n  const keyValues = keyType._zod.values;\n  if (keyValues) {\n    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");\n    if (validKeyValues.length > 0) {\n      json.required = validKeyValues;\n    }\n  }\n};\nvar nullableProcessor = (schema, ctx, json, params) => {\n  const def = schema._zod.def;\n  const inner = process2(def.innerType, ctx, params);\n  const seen = ctx.seen.get(schema);\n  if (ctx.target === "openapi-3.0") {\n    seen.ref = def.innerType;\n    json.nullable = true;\n  } else {\n    json.anyOf = [inner, { type: "null" }];\n  }\n};\nvar nonoptionalProcessor = (schema, ctx, _json, params) => {\n  const def = schema._zod.def;\n  process2(def.innerType, ctx, params);\n  const seen = ctx.seen.get(schema);\n  seen.ref = def.innerType;\n};\nvar defaultProcessor = (schema, ctx, json, params) => {\n  const def = schema._zod.def;\n  process2(def.innerType, ctx, params);\n  const seen = ctx.seen.get(schema);\n  seen.ref = def.innerType;\n  json.default = JSON.parse(JSON.stringify(def.defaultValue));\n};\nvar prefaultProcessor = (schema, ctx, json, params) => {\n  const def = schema._zod.def;\n  process2(def.innerType, ctx, params);\n  const seen = ctx.seen.get(schema);\n  seen.ref = def.innerType;\n  if (ctx.io === "input")\n    json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n};\nvar catchProcessor = (schema, ctx, json, params) => {\n  const def = schema._zod.def;\n  process2(def.innerType, ctx, params);\n  const seen = ctx.seen.get(schema);\n  seen.ref = def.innerType;\n  let catchValue;\n  try {\n    catchValue = def.catchValue(undefined);\n  } catch {\n    throw new Error("Dynamic catch values are not supported in JSON Schema");\n  }\n  json.default = catchValue;\n};\nvar pipeProcessor = (schema, ctx, _json, params) => {\n  const def = schema._zod.def;\n  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;\n  process2(innerType, ctx, params);\n  const seen = ctx.seen.get(schema);\n  seen.ref = innerType;\n};\nvar readonlyProcessor = (schema, ctx, json, params) => {\n  const def = schema._zod.def;\n  process2(def.innerType, ctx, params);\n  const seen = ctx.seen.get(schema);\n  seen.ref = def.innerType;\n  json.readOnly = true;\n};\nvar promiseProcessor = (schema, ctx, _json, params) => {\n  const def = schema._zod.def;\n  process2(def.innerType, ctx, params);\n  const seen = ctx.seen.get(schema);\n  seen.ref = def.innerType;\n};\nvar optionalProcessor = (schema, ctx, _json, params) => {\n  const def = schema._zod.def;\n  process2(def.innerType, ctx, params);\n  const seen = ctx.seen.get(schema);\n  seen.ref = def.innerType;\n};\nvar lazyProcessor = (schema, ctx, _json, params) => {\n  const innerType = schema._zod.innerType;\n  process2(innerType, ctx, params);\n  const seen = ctx.seen.get(schema);\n  seen.ref = innerType;\n};\nvar allProcessors = {\n  string: stringProcessor,\n  number: numberProcessor,\n  boolean: booleanProcessor,\n  bigint: bigintProcessor,\n  symbol: symbolProcessor,\n  null: nullProcessor,\n  undefined: undefinedProcessor,\n  void: voidProcessor,\n  never: neverProcessor,\n  any: anyProcessor,\n  unknown: unknownProcessor,\n  date: dateProcessor,\n  enum: enumProcessor,\n  literal: literalProcessor,\n  nan: nanProcessor,\n  template_literal: templateLiteralProcessor,\n  file: fileProcessor,\n  success: successProcessor,\n  custom: customProcessor,\n  function: functionProcessor,\n  transform: transformProcessor,\n  map: mapProcessor,\n  set: setProcessor,\n  array: arrayProcessor,\n  object: objectProcessor,\n  union: unionProcessor,\n  intersection: intersectionProcessor,\n  tuple: tupleProcessor,\n  record: recordProcessor,\n  nullable: nullableProcessor,\n  nonoptional: nonoptionalProcessor,\n  default: defaultProcessor,\n  prefault: prefaultProcessor,\n  catch: catchProcessor,\n  pipe: pipeProcessor,\n  readonly: readonlyProcessor,\n  promise: promiseProcessor,\n  optional: optionalProcessor,\n  lazy: lazyProcessor\n};\nfunction toJSONSchema(input, params) {\n  if ("_idmap" in input) {\n    const registry2 = input;\n    const ctx2 = initializeContext({ ...params, processors: allProcessors });\n    const defs = {};\n    for (const entry of registry2._idmap.entries()) {\n      const [_, schema] = entry;\n      process2(schema, ctx2);\n    }\n    const schemas = {};\n    const external = {\n      registry: registry2,\n      uri: params?.uri,\n      defs\n    };\n    ctx2.external = external;\n    for (const entry of registry2._idmap.entries()) {\n      const [key, schema] = entry;\n      extractDefs(ctx2, schema);\n      schemas[key] = finalize(ctx2, schema);\n    }\n    if (Object.keys(defs).length > 0) {\n      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";\n      schemas.__shared = {\n        [defsSegment]: defs\n      };\n    }\n    return { schemas };\n  }\n  const ctx = initializeContext({ ...params, processors: allProcessors });\n  process2(input, ctx);\n  extractDefs(ctx, input);\n  return finalize(ctx, input);\n}\n// ../../node_modules/zod/v4/core/json-schema-generator.js\nclass JSONSchemaGenerator {\n  get metadataRegistry() {\n    return this.ctx.metadataRegistry;\n  }\n  get target() {\n    return this.ctx.target;\n  }\n  get unrepresentable() {\n    return this.ctx.unrepresentable;\n  }\n  get override() {\n    return this.ctx.override;\n  }\n  get io() {\n    return this.ctx.io;\n  }\n  get counter() {\n    return this.ctx.counter;\n  }\n  set counter(value) {\n    this.ctx.counter = value;\n  }\n  get seen() {\n    return this.ctx.seen;\n  }\n  constructor(params) {\n    let normalizedTarget = params?.target ?? "draft-2020-12";\n    if (normalizedTarget === "draft-4")\n      normalizedTarget = "draft-04";\n    if (normalizedTarget === "draft-7")\n      normalizedTarget = "draft-07";\n    this.ctx = initializeContext({\n      processors: allProcessors,\n      target: normalizedTarget,\n      ...params?.metadata && { metadata: params.metadata },\n      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },\n      ...params?.override && { override: params.override },\n      ...params?.io && { io: params.io }\n    });\n  }\n  process(schema, _params = { path: [], schemaPath: [] }) {\n    return process2(schema, this.ctx, _params);\n  }\n  emit(schema, _params) {\n    if (_params) {\n      if (_params.cycles)\n        this.ctx.cycles = _params.cycles;\n      if (_params.reused)\n        this.ctx.reused = _params.reused;\n      if (_params.external)\n        this.ctx.external = _params.external;\n    }\n    extractDefs(this.ctx, schema);\n    const result = finalize(this.ctx, schema);\n    const { "~standard": _, ...plainResult } = result;\n    return plainResult;\n  }\n}\n// ../../node_modules/zod/v4/core/json-schema.js\nvar exports_json_schema = {};\n// ../../node_modules/zod/v4/classic/schemas.js\nvar exports_schemas2 = {};\n__export(exports_schemas2, {\n  xor: () => xor,\n  xid: () => xid2,\n  void: () => _void2,\n  uuidv7: () => uuidv7,\n  uuidv6: () => uuidv6,\n  uuidv4: () => uuidv4,\n  uuid: () => uuid2,\n  url: () => url,\n  unknown: () => unknown,\n  union: () => union,\n  undefined: () => _undefined3,\n  ulid: () => ulid2,\n  uint64: () => uint64,\n  uint32: () => uint32,\n  tuple: () => tuple,\n  transform: () => transform,\n  templateLiteral: () => templateLiteral,\n  symbol: () => symbol15,\n  superRefine: () => superRefine,\n  success: () => success,\n  stringbool: () => stringbool,\n  stringFormat: () => stringFormat,\n  string: () => string2,\n  strictObject: () => strictObject,\n  set: () => set,\n  refine: () => refine,\n  record: () => record,\n  readonly: () => readonly,\n  promise: () => promise,\n  preprocess: () => preprocess,\n  prefault: () => prefault,\n  pipe: () => pipe,\n  partialRecord: () => partialRecord,\n  optional: () => optional,\n  object: () => object,\n  number: () => number2,\n  nullish: () => nullish2,\n  nullable: () => nullable,\n  null: () => _null3,\n  nonoptional: () => nonoptional,\n  never: () => never,\n  nativeEnum: () => nativeEnum,\n  nanoid: () => nanoid2,\n  nan: () => nan,\n  meta: () => meta2,\n  map: () => map,\n  mac: () => mac2,\n  looseRecord: () => looseRecord,\n  looseObject: () => looseObject,\n  literal: () => literal,\n  lazy: () => lazy,\n  ksuid: () => ksuid2,\n  keyof: () => keyof,\n  jwt: () => jwt,\n  json: () => json,\n  ipv6: () => ipv62,\n  ipv4: () => ipv42,\n  intersection: () => intersection,\n  int64: () => int64,\n  int32: () => int32,\n  int: () => int,\n  instanceof: () => _instanceof,\n  httpUrl: () => httpUrl,\n  hostname: () => hostname2,\n  hex: () => hex2,\n  hash: () => hash,\n  guid: () => guid2,\n  function: () => _function,\n  float64: () => float64,\n  float32: () => float32,\n  file: () => file,\n  exactOptional: () => exactOptional,\n  enum: () => _enum2,\n  emoji: () => emoji2,\n  email: () => email2,\n  e164: () => e1642,\n  discriminatedUnion: () => discriminatedUnion,\n  describe: () => describe2,\n  date: () => date3,\n  custom: () => custom,\n  cuid2: () => cuid22,\n  cuid: () => cuid3,\n  codec: () => codec,\n  cidrv6: () => cidrv62,\n  cidrv4: () => cidrv42,\n  check: () => check,\n  catch: () => _catch2,\n  boolean: () => boolean2,\n  bigint: () => bigint2,\n  base64url: () => base64url2,\n  base64: () => base642,\n  array: () => array,\n  any: () => any,\n  _function: () => _function,\n  _default: () => _default2,\n  _ZodString: () => _ZodString,\n  ZodXor: () => ZodXor,\n  ZodXID: () => ZodXID,\n  ZodVoid: () => ZodVoid,\n  ZodUnknown: () => ZodUnknown,\n  ZodUnion: () => ZodUnion,\n  ZodUndefined: () => ZodUndefined,\n  ZodUUID: () => ZodUUID,\n  ZodURL: () => ZodURL,\n  ZodULID: () => ZodULID,\n  ZodType: () => ZodType,\n  ZodTuple: () => ZodTuple,\n  ZodTransform: () => ZodTransform,\n  ZodTemplateLiteral: () => ZodTemplateLiteral,\n  ZodSymbol: () => ZodSymbol,\n  ZodSuccess: () => ZodSuccess,\n  ZodStringFormat: () => ZodStringFormat,\n  ZodString: () => ZodString,\n  ZodSet: () => ZodSet,\n  ZodRecord: () => ZodRecord,\n  ZodReadonly: () => ZodReadonly,\n  ZodPromise: () => ZodPromise,\n  ZodPrefault: () => ZodPrefault,\n  ZodPipe: () => ZodPipe,\n  ZodOptional: () => ZodOptional,\n  ZodObject: () => ZodObject,\n  ZodNumberFormat: () => ZodNumberFormat,\n  ZodNumber: () => ZodNumber,\n  ZodNullable: () => ZodNullable,\n  ZodNull: () => ZodNull,\n  ZodNonOptional: () => ZodNonOptional,\n  ZodNever: () => ZodNever,\n  ZodNanoID: () => ZodNanoID,\n  ZodNaN: () => ZodNaN,\n  ZodMap: () => ZodMap,\n  ZodMAC: () => ZodMAC,\n  ZodLiteral: () => ZodLiteral,\n  ZodLazy: () => ZodLazy,\n  ZodKSUID: () => ZodKSUID,\n  ZodJWT: () => ZodJWT,\n  ZodIntersection: () => ZodIntersection,\n  ZodIPv6: () => ZodIPv6,\n  ZodIPv4: () => ZodIPv4,\n  ZodGUID: () => ZodGUID,\n  ZodFunction: () => ZodFunction,\n  ZodFile: () => ZodFile,\n  ZodExactOptional: () => ZodExactOptional,\n  ZodEnum: () => ZodEnum,\n  ZodEmoji: () => ZodEmoji,\n  ZodEmail: () => ZodEmail,\n  ZodE164: () => ZodE164,\n  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,\n  ZodDefault: () => ZodDefault,\n  ZodDate: () => ZodDate,\n  ZodCustomStringFormat: () => ZodCustomStringFormat,\n  ZodCustom: () => ZodCustom,\n  ZodCodec: () => ZodCodec,\n  ZodCatch: () => ZodCatch,\n  ZodCUID2: () => ZodCUID2,\n  ZodCUID: () => ZodCUID,\n  ZodCIDRv6: () => ZodCIDRv6,\n  ZodCIDRv4: () => ZodCIDRv4,\n  ZodBoolean: () => ZodBoolean,\n  ZodBigIntFormat: () => ZodBigIntFormat,\n  ZodBigInt: () => ZodBigInt,\n  ZodBase64URL: () => ZodBase64URL,\n  ZodBase64: () => ZodBase64,\n  ZodArray: () => ZodArray,\n  ZodAny: () => ZodAny\n});\n\n// ../../node_modules/zod/v4/classic/checks.js\nvar exports_checks2 = {};\n__export(exports_checks2, {\n  uppercase: () => _uppercase,\n  trim: () => _trim,\n  toUpperCase: () => _toUpperCase,\n  toLowerCase: () => _toLowerCase,\n  startsWith: () => _startsWith,\n  slugify: () => _slugify,\n  size: () => _size,\n  regex: () => _regex,\n  property: () => _property,\n  positive: () => _positive,\n  overwrite: () => _overwrite,\n  normalize: () => _normalize,\n  nonpositive: () => _nonpositive,\n  nonnegative: () => _nonnegative,\n  negative: () => _negative,\n  multipleOf: () => _multipleOf,\n  minSize: () => _minSize,\n  minLength: () => _minLength,\n  mime: () => _mime,\n  maxSize: () => _maxSize,\n  maxLength: () => _maxLength,\n  lte: () => _lte,\n  lt: () => _lt,\n  lowercase: () => _lowercase,\n  length: () => _length,\n  includes: () => _includes,\n  gte: () => _gte,\n  gt: () => _gt,\n  endsWith: () => _endsWith\n});\n\n// ../../node_modules/zod/v4/classic/iso.js\nvar exports_iso = {};\n__export(exports_iso, {\n  time: () => time2,\n  duration: () => duration2,\n  datetime: () => datetime2,\n  date: () => date2,\n  ZodISOTime: () => ZodISOTime,\n  ZodISODuration: () => ZodISODuration,\n  ZodISODateTime: () => ZodISODateTime,\n  ZodISODate: () => ZodISODate\n});\nvar ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {\n  $ZodISODateTime.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction datetime2(params) {\n  return _isoDateTime(ZodISODateTime, params);\n}\nvar ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {\n  $ZodISODate.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction date2(params) {\n  return _isoDate(ZodISODate, params);\n}\nvar ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {\n  $ZodISOTime.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction time2(params) {\n  return _isoTime(ZodISOTime, params);\n}\nvar ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {\n  $ZodISODuration.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction duration2(params) {\n  return _isoDuration(ZodISODuration, params);\n}\n\n// ../../node_modules/zod/v4/classic/errors.js\nvar initializer2 = (inst, issues) => {\n  $ZodError.init(inst, issues);\n  inst.name = "ZodError";\n  Object.defineProperties(inst, {\n    format: {\n      value: (mapper) => formatError(inst, mapper)\n    },\n    flatten: {\n      value: (mapper) => flattenError(inst, mapper)\n    },\n    addIssue: {\n      value: (issue2) => {\n        inst.issues.push(issue2);\n        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);\n      }\n    },\n    addIssues: {\n      value: (issues2) => {\n        inst.issues.push(...issues2);\n        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);\n      }\n    },\n    isEmpty: {\n      get() {\n        return inst.issues.length === 0;\n      }\n    }\n  });\n};\nvar ZodError = $constructor("ZodError", initializer2);\nvar ZodRealError = $constructor("ZodError", initializer2, {\n  Parent: Error\n});\n\n// ../../node_modules/zod/v4/classic/parse.js\nvar parse3 = /* @__PURE__ */ _parse(ZodRealError);\nvar parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);\nvar safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);\nvar safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);\nvar encode2 = /* @__PURE__ */ _encode(ZodRealError);\nvar decode2 = /* @__PURE__ */ _decode(ZodRealError);\nvar encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);\nvar decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);\nvar safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);\nvar safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);\nvar safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);\nvar safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);\n\n// ../../node_modules/zod/v4/classic/schemas.js\nvar ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {\n  $ZodType.init(inst, def);\n  Object.assign(inst["~standard"], {\n    jsonSchema: {\n      input: createStandardJSONSchemaMethod(inst, "input"),\n      output: createStandardJSONSchemaMethod(inst, "output")\n    }\n  });\n  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});\n  inst.def = def;\n  inst.type = def.type;\n  Object.defineProperty(inst, "_def", { value: def });\n  inst.check = (...checks2) => {\n    return inst.clone(exports_util.mergeDefs(def, {\n      checks: [\n        ...def.checks ?? [],\n        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)\n      ]\n    }), {\n      parent: true\n    });\n  };\n  inst.with = inst.check;\n  inst.clone = (def2, params) => clone(inst, def2, params);\n  inst.brand = () => inst;\n  inst.register = (reg, meta2) => {\n    reg.add(inst, meta2);\n    return inst;\n  };\n  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });\n  inst.safeParse = (data, params) => safeParse2(inst, data, params);\n  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });\n  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);\n  inst.spa = inst.safeParseAsync;\n  inst.encode = (data, params) => encode2(inst, data, params);\n  inst.decode = (data, params) => decode2(inst, data, params);\n  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);\n  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);\n  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);\n  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);\n  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);\n  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);\n  inst.refine = (check, params) => inst.check(refine(check, params));\n  inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n  inst.overwrite = (fn) => inst.check(_overwrite(fn));\n  inst.optional = () => optional(inst);\n  inst.exactOptional = () => exactOptional(inst);\n  inst.nullable = () => nullable(inst);\n  inst.nullish = () => optional(nullable(inst));\n  inst.nonoptional = (params) => nonoptional(inst, params);\n  inst.array = () => array(inst);\n  inst.or = (arg) => union([inst, arg]);\n  inst.and = (arg) => intersection(inst, arg);\n  inst.transform = (tx) => pipe(inst, transform(tx));\n  inst.default = (def2) => _default2(inst, def2);\n  inst.prefault = (def2) => prefault(inst, def2);\n  inst.catch = (params) => _catch2(inst, params);\n  inst.pipe = (target) => pipe(inst, target);\n  inst.readonly = () => readonly(inst);\n  inst.describe = (description) => {\n    const cl = inst.clone();\n    globalRegistry.add(cl, { description });\n    return cl;\n  };\n  Object.defineProperty(inst, "description", {\n    get() {\n      return globalRegistry.get(inst)?.description;\n    },\n    configurable: true\n  });\n  inst.meta = (...args) => {\n    if (args.length === 0) {\n      return globalRegistry.get(inst);\n    }\n    const cl = inst.clone();\n    globalRegistry.add(cl, args[0]);\n    return cl;\n  };\n  inst.isOptional = () => inst.safeParse(undefined).success;\n  inst.isNullable = () => inst.safeParse(null).success;\n  inst.apply = (fn) => fn(inst);\n  return inst;\n});\nvar _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {\n  $ZodString.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => stringProcessor(inst, ctx, json, params);\n  const bag = inst._zod.bag;\n  inst.format = bag.format ?? null;\n  inst.minLength = bag.minimum ?? null;\n  inst.maxLength = bag.maximum ?? null;\n  inst.regex = (...args) => inst.check(_regex(...args));\n  inst.includes = (...args) => inst.check(_includes(...args));\n  inst.startsWith = (...args) => inst.check(_startsWith(...args));\n  inst.endsWith = (...args) => inst.check(_endsWith(...args));\n  inst.min = (...args) => inst.check(_minLength(...args));\n  inst.max = (...args) => inst.check(_maxLength(...args));\n  inst.length = (...args) => inst.check(_length(...args));\n  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));\n  inst.lowercase = (params) => inst.check(_lowercase(params));\n  inst.uppercase = (params) => inst.check(_uppercase(params));\n  inst.trim = () => inst.check(_trim());\n  inst.normalize = (...args) => inst.check(_normalize(...args));\n  inst.toLowerCase = () => inst.check(_toLowerCase());\n  inst.toUpperCase = () => inst.check(_toUpperCase());\n  inst.slugify = () => inst.check(_slugify());\n});\nvar ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {\n  $ZodString.init(inst, def);\n  _ZodString.init(inst, def);\n  inst.email = (params) => inst.check(_email(ZodEmail, params));\n  inst.url = (params) => inst.check(_url(ZodURL, params));\n  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));\n  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));\n  inst.guid = (params) => inst.check(_guid(ZodGUID, params));\n  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));\n  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));\n  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));\n  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));\n  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));\n  inst.guid = (params) => inst.check(_guid(ZodGUID, params));\n  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));\n  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));\n  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));\n  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));\n  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));\n  inst.xid = (params) => inst.check(_xid(ZodXID, params));\n  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));\n  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));\n  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));\n  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));\n  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));\n  inst.e164 = (params) => inst.check(_e164(ZodE164, params));\n  inst.datetime = (params) => inst.check(datetime2(params));\n  inst.date = (params) => inst.check(date2(params));\n  inst.time = (params) => inst.check(time2(params));\n  inst.duration = (params) => inst.check(duration2(params));\n});\nfunction string2(params) {\n  return _string(ZodString, params);\n}\nvar ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  _ZodString.init(inst, def);\n});\nvar ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {\n  $ZodEmail.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction email2(params) {\n  return _email(ZodEmail, params);\n}\nvar ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {\n  $ZodGUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction guid2(params) {\n  return _guid(ZodGUID, params);\n}\nvar ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {\n  $ZodUUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction uuid2(params) {\n  return _uuid(ZodUUID, params);\n}\nfunction uuidv4(params) {\n  return _uuidv4(ZodUUID, params);\n}\nfunction uuidv6(params) {\n  return _uuidv6(ZodUUID, params);\n}\nfunction uuidv7(params) {\n  return _uuidv7(ZodUUID, params);\n}\nvar ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {\n  $ZodURL.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction url(params) {\n  return _url(ZodURL, params);\n}\nfunction httpUrl(params) {\n  return _url(ZodURL, {\n    protocol: /^https?$/,\n    hostname: exports_regexes.domain,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {\n  $ZodEmoji.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction emoji2(params) {\n  return _emoji2(ZodEmoji, params);\n}\nvar ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {\n  $ZodNanoID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction nanoid2(params) {\n  return _nanoid(ZodNanoID, params);\n}\nvar ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {\n  $ZodCUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cuid3(params) {\n  return _cuid(ZodCUID, params);\n}\nvar ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {\n  $ZodCUID2.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cuid22(params) {\n  return _cuid2(ZodCUID2, params);\n}\nvar ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {\n  $ZodULID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ulid2(params) {\n  return _ulid(ZodULID, params);\n}\nvar ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {\n  $ZodXID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction xid2(params) {\n  return _xid(ZodXID, params);\n}\nvar ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {\n  $ZodKSUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ksuid2(params) {\n  return _ksuid(ZodKSUID, params);\n}\nvar ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {\n  $ZodIPv4.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ipv42(params) {\n  return _ipv4(ZodIPv4, params);\n}\nvar ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {\n  $ZodMAC.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction mac2(params) {\n  return _mac(ZodMAC, params);\n}\nvar ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {\n  $ZodIPv6.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction ipv62(params) {\n  return _ipv6(ZodIPv6, params);\n}\nvar ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {\n  $ZodCIDRv4.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cidrv42(params) {\n  return _cidrv4(ZodCIDRv4, params);\n}\nvar ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {\n  $ZodCIDRv6.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction cidrv62(params) {\n  return _cidrv6(ZodCIDRv6, params);\n}\nvar ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {\n  $ZodBase64.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction base642(params) {\n  return _base64(ZodBase64, params);\n}\nvar ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {\n  $ZodBase64URL.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction base64url2(params) {\n  return _base64url(ZodBase64URL, params);\n}\nvar ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {\n  $ZodE164.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction e1642(params) {\n  return _e164(ZodE164, params);\n}\nvar ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {\n  $ZodJWT.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction jwt(params) {\n  return _jwt(ZodJWT, params);\n}\nvar ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {\n  $ZodCustomStringFormat.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction stringFormat(format, fnOrRegex, _params = {}) {\n  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);\n}\nfunction hostname2(_params) {\n  return _stringFormat(ZodCustomStringFormat, "hostname", exports_regexes.hostname, _params);\n}\nfunction hex2(_params) {\n  return _stringFormat(ZodCustomStringFormat, "hex", exports_regexes.hex, _params);\n}\nfunction hash(alg, params) {\n  const enc = params?.enc ?? "hex";\n  const format = `${alg}_${enc}`;\n  const regex = exports_regexes[format];\n  if (!regex)\n    throw new Error(`Unrecognized hash format: ${format}`);\n  return _stringFormat(ZodCustomStringFormat, format, regex, params);\n}\nvar ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {\n  $ZodNumber.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => numberProcessor(inst, ctx, json, params);\n  inst.gt = (value, params) => inst.check(_gt(value, params));\n  inst.gte = (value, params) => inst.check(_gte(value, params));\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.lt = (value, params) => inst.check(_lt(value, params));\n  inst.lte = (value, params) => inst.check(_lte(value, params));\n  inst.max = (value, params) => inst.check(_lte(value, params));\n  inst.int = (params) => inst.check(int(params));\n  inst.safe = (params) => inst.check(int(params));\n  inst.positive = (params) => inst.check(_gt(0, params));\n  inst.nonnegative = (params) => inst.check(_gte(0, params));\n  inst.negative = (params) => inst.check(_lt(0, params));\n  inst.nonpositive = (params) => inst.check(_lte(0, params));\n  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));\n  inst.step = (value, params) => inst.check(_multipleOf(value, params));\n  inst.finite = () => inst;\n  const bag = inst._zod.bag;\n  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;\n  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;\n  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);\n  inst.isFinite = true;\n  inst.format = bag.format ?? null;\n});\nfunction number2(params) {\n  return _number(ZodNumber, params);\n}\nvar ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {\n  $ZodNumberFormat.init(inst, def);\n  ZodNumber.init(inst, def);\n});\nfunction int(params) {\n  return _int(ZodNumberFormat, params);\n}\nfunction float32(params) {\n  return _float32(ZodNumberFormat, params);\n}\nfunction float64(params) {\n  return _float64(ZodNumberFormat, params);\n}\nfunction int32(params) {\n  return _int32(ZodNumberFormat, params);\n}\nfunction uint32(params) {\n  return _uint32(ZodNumberFormat, params);\n}\nvar ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {\n  $ZodBoolean.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => booleanProcessor(inst, ctx, json, params);\n});\nfunction boolean2(params) {\n  return _boolean(ZodBoolean, params);\n}\nvar ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {\n  $ZodBigInt.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => bigintProcessor(inst, ctx, json, params);\n  inst.gte = (value, params) => inst.check(_gte(value, params));\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.gt = (value, params) => inst.check(_gt(value, params));\n  inst.gte = (value, params) => inst.check(_gte(value, params));\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.lt = (value, params) => inst.check(_lt(value, params));\n  inst.lte = (value, params) => inst.check(_lte(value, params));\n  inst.max = (value, params) => inst.check(_lte(value, params));\n  inst.positive = (params) => inst.check(_gt(BigInt(0), params));\n  inst.negative = (params) => inst.check(_lt(BigInt(0), params));\n  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));\n  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));\n  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));\n  const bag = inst._zod.bag;\n  inst.minValue = bag.minimum ?? null;\n  inst.maxValue = bag.maximum ?? null;\n  inst.format = bag.format ?? null;\n});\nfunction bigint2(params) {\n  return _bigint(ZodBigInt, params);\n}\nvar ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {\n  $ZodBigIntFormat.init(inst, def);\n  ZodBigInt.init(inst, def);\n});\nfunction int64(params) {\n  return _int64(ZodBigIntFormat, params);\n}\nfunction uint64(params) {\n  return _uint64(ZodBigIntFormat, params);\n}\nvar ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {\n  $ZodSymbol.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => symbolProcessor(inst, ctx, json, params);\n});\nfunction symbol15(params) {\n  return _symbol(ZodSymbol, params);\n}\nvar ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {\n  $ZodUndefined.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => undefinedProcessor(inst, ctx, json, params);\n});\nfunction _undefined3(params) {\n  return _undefined2(ZodUndefined, params);\n}\nvar ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {\n  $ZodNull.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => nullProcessor(inst, ctx, json, params);\n});\nfunction _null3(params) {\n  return _null2(ZodNull, params);\n}\nvar ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {\n  $ZodAny.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => anyProcessor(inst, ctx, json, params);\n});\nfunction any() {\n  return _any(ZodAny);\n}\nvar ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {\n  $ZodUnknown.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => unknownProcessor(inst, ctx, json, params);\n});\nfunction unknown() {\n  return _unknown(ZodUnknown);\n}\nvar ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {\n  $ZodNever.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => neverProcessor(inst, ctx, json, params);\n});\nfunction never(params) {\n  return _never(ZodNever, params);\n}\nvar ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {\n  $ZodVoid.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => voidProcessor(inst, ctx, json, params);\n});\nfunction _void2(params) {\n  return _void(ZodVoid, params);\n}\nvar ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {\n  $ZodDate.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => dateProcessor(inst, ctx, json, params);\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.max = (value, params) => inst.check(_lte(value, params));\n  const c = inst._zod.bag;\n  inst.minDate = c.minimum ? new Date(c.minimum) : null;\n  inst.maxDate = c.maximum ? new Date(c.maximum) : null;\n});\nfunction date3(params) {\n  return _date(ZodDate, params);\n}\nvar ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {\n  $ZodArray.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => arrayProcessor(inst, ctx, json, params);\n  inst.element = def.element;\n  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));\n  inst.nonempty = (params) => inst.check(_minLength(1, params));\n  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));\n  inst.length = (len, params) => inst.check(_length(len, params));\n  inst.unwrap = () => inst.element;\n});\nfunction array(element, params) {\n  return _array(ZodArray, element, params);\n}\nfunction keyof(schema) {\n  const shape = schema._zod.def.shape;\n  return _enum2(Object.keys(shape));\n}\nvar ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {\n  $ZodObjectJIT.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => objectProcessor(inst, ctx, json, params);\n  exports_util.defineLazy(inst, "shape", () => {\n    return def.shape;\n  });\n  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));\n  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });\n  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });\n  inst.extend = (incoming) => {\n    return exports_util.extend(inst, incoming);\n  };\n  inst.safeExtend = (incoming) => {\n    return exports_util.safeExtend(inst, incoming);\n  };\n  inst.merge = (other) => exports_util.merge(inst, other);\n  inst.pick = (mask) => exports_util.pick(inst, mask);\n  inst.omit = (mask) => exports_util.omit(inst, mask);\n  inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);\n  inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);\n});\nfunction object(shape, params) {\n  const def = {\n    type: "object",\n    shape: shape ?? {},\n    ...exports_util.normalizeParams(params)\n  };\n  return new ZodObject(def);\n}\nfunction strictObject(shape, params) {\n  return new ZodObject({\n    type: "object",\n    shape,\n    catchall: never(),\n    ...exports_util.normalizeParams(params)\n  });\n}\nfunction looseObject(shape, params) {\n  return new ZodObject({\n    type: "object",\n    shape,\n    catchall: unknown(),\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);\n  inst.options = def.options;\n});\nfunction union(options, params) {\n  return new ZodUnion({\n    type: "union",\n    options,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {\n  ZodUnion.init(inst, def);\n  $ZodXor.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params);\n  inst.options = def.options;\n});\nfunction xor(options, params) {\n  return new ZodXor({\n    type: "union",\n    options,\n    inclusive: false,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {\n  ZodUnion.init(inst, def);\n  $ZodDiscriminatedUnion.init(inst, def);\n});\nfunction discriminatedUnion(discriminator, options, params) {\n  return new ZodDiscriminatedUnion({\n    type: "union",\n    options,\n    discriminator,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {\n  $ZodIntersection.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => intersectionProcessor(inst, ctx, json, params);\n});\nfunction intersection(left, right) {\n  return new ZodIntersection({\n    type: "intersection",\n    left,\n    right\n  });\n}\nvar ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {\n  $ZodTuple.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => tupleProcessor(inst, ctx, json, params);\n  inst.rest = (rest) => inst.clone({\n    ...inst._zod.def,\n    rest\n  });\n});\nfunction tuple(items, _paramsOrRest, _params) {\n  const hasRest = _paramsOrRest instanceof $ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new ZodTuple({\n    type: "tuple",\n    items,\n    rest,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {\n  $ZodRecord.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => recordProcessor(inst, ctx, json, params);\n  inst.keyType = def.keyType;\n  inst.valueType = def.valueType;\n});\nfunction record(keyType, valueType, params) {\n  return new ZodRecord({\n    type: "record",\n    keyType,\n    valueType,\n    ...exports_util.normalizeParams(params)\n  });\n}\nfunction partialRecord(keyType, valueType, params) {\n  const k = clone(keyType);\n  k._zod.values = undefined;\n  return new ZodRecord({\n    type: "record",\n    keyType: k,\n    valueType,\n    ...exports_util.normalizeParams(params)\n  });\n}\nfunction looseRecord(keyType, valueType, params) {\n  return new ZodRecord({\n    type: "record",\n    keyType,\n    valueType,\n    mode: "loose",\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {\n  $ZodMap.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => mapProcessor(inst, ctx, json, params);\n  inst.keyType = def.keyType;\n  inst.valueType = def.valueType;\n  inst.min = (...args) => inst.check(_minSize(...args));\n  inst.nonempty = (params) => inst.check(_minSize(1, params));\n  inst.max = (...args) => inst.check(_maxSize(...args));\n  inst.size = (...args) => inst.check(_size(...args));\n});\nfunction map(keyType, valueType, params) {\n  return new ZodMap({\n    type: "map",\n    keyType,\n    valueType,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {\n  $ZodSet.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => setProcessor(inst, ctx, json, params);\n  inst.min = (...args) => inst.check(_minSize(...args));\n  inst.nonempty = (params) => inst.check(_minSize(1, params));\n  inst.max = (...args) => inst.check(_maxSize(...args));\n  inst.size = (...args) => inst.check(_size(...args));\n});\nfunction set(valueType, params) {\n  return new ZodSet({\n    type: "set",\n    valueType,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {\n  $ZodEnum.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => enumProcessor(inst, ctx, json, params);\n  inst.enum = def.entries;\n  inst.options = Object.values(def.entries);\n  const keys = new Set(Object.keys(def.entries));\n  inst.extract = (values, params) => {\n    const newEntries = {};\n    for (const value of values) {\n      if (keys.has(value)) {\n        newEntries[value] = def.entries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...exports_util.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n  inst.exclude = (values, params) => {\n    const newEntries = { ...def.entries };\n    for (const value of values) {\n      if (keys.has(value)) {\n        delete newEntries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...exports_util.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n});\nfunction _enum2(values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n  return new ZodEnum({\n    type: "enum",\n    entries,\n    ...exports_util.normalizeParams(params)\n  });\n}\nfunction nativeEnum(entries, params) {\n  return new ZodEnum({\n    type: "enum",\n    entries,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {\n  $ZodLiteral.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => literalProcessor(inst, ctx, json, params);\n  inst.values = new Set(def.values);\n  Object.defineProperty(inst, "value", {\n    get() {\n      if (def.values.length > 1) {\n        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");\n      }\n      return def.values[0];\n    }\n  });\n});\nfunction literal(value, params) {\n  return new ZodLiteral({\n    type: "literal",\n    values: Array.isArray(value) ? value : [value],\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {\n  $ZodFile.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => fileProcessor(inst, ctx, json, params);\n  inst.min = (size, params) => inst.check(_minSize(size, params));\n  inst.max = (size, params) => inst.check(_maxSize(size, params));\n  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));\n});\nfunction file(params) {\n  return _file(ZodFile, params);\n}\nvar ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {\n  $ZodTransform.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => transformProcessor(inst, ctx, json, params);\n  inst._zod.parse = (payload, _ctx) => {\n    if (_ctx.direction === "backward") {\n      throw new $ZodEncodeError(inst.constructor.name);\n    }\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === "string") {\n        payload.issues.push(exports_util.issue(issue2, payload.value, def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = "custom");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = inst);\n        payload.issues.push(exports_util.issue(_issue));\n      }\n    };\n    const output = def.transform(payload.value, payload);\n    if (output instanceof Promise) {\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    payload.value = output;\n    return payload;\n  };\n});\nfunction transform(fn) {\n  return new ZodTransform({\n    type: "transform",\n    transform: fn\n  });\n}\nvar ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {\n  $ZodOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction optional(innerType) {\n  return new ZodOptional({\n    type: "optional",\n    innerType\n  });\n}\nvar ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {\n  $ZodExactOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction exactOptional(innerType) {\n  return new ZodExactOptional({\n    type: "optional",\n    innerType\n  });\n}\nvar ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {\n  $ZodNullable.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => nullableProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nullable(innerType) {\n  return new ZodNullable({\n    type: "nullable",\n    innerType\n  });\n}\nfunction nullish2(innerType) {\n  return optional(nullable(innerType));\n}\nvar ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {\n  $ZodDefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => defaultProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeDefault = inst.unwrap;\n});\nfunction _default2(innerType, defaultValue) {\n  return new ZodDefault({\n    type: "default",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);\n    }\n  });\n}\nvar ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {\n  $ZodPrefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => prefaultProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction prefault(innerType, defaultValue) {\n  return new ZodPrefault({\n    type: "prefault",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);\n    }\n  });\n}\nvar ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {\n  $ZodNonOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => nonoptionalProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nonoptional(innerType, params) {\n  return new ZodNonOptional({\n    type: "nonoptional",\n    innerType,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {\n  $ZodSuccess.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => successProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction success(innerType) {\n  return new ZodSuccess({\n    type: "success",\n    innerType\n  });\n}\nvar ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {\n  $ZodCatch.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => catchProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeCatch = inst.unwrap;\n});\nfunction _catch2(innerType, catchValue) {\n  return new ZodCatch({\n    type: "catch",\n    innerType,\n    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue\n  });\n}\nvar ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {\n  $ZodNaN.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => nanProcessor(inst, ctx, json, params);\n});\nfunction nan(params) {\n  return _nan(ZodNaN, params);\n}\nvar ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {\n  $ZodPipe.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => pipeProcessor(inst, ctx, json, params);\n  inst.in = def.in;\n  inst.out = def.out;\n});\nfunction pipe(in_, out) {\n  return new ZodPipe({\n    type: "pipe",\n    in: in_,\n    out\n  });\n}\nvar ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {\n  ZodPipe.init(inst, def);\n  $ZodCodec.init(inst, def);\n});\nfunction codec(in_, out, params) {\n  return new ZodCodec({\n    type: "pipe",\n    in: in_,\n    out,\n    transform: params.decode,\n    reverseTransform: params.encode\n  });\n}\nvar ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {\n  $ZodReadonly.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => readonlyProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction readonly(innerType) {\n  return new ZodReadonly({\n    type: "readonly",\n    innerType\n  });\n}\nvar ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {\n  $ZodTemplateLiteral.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => templateLiteralProcessor(inst, ctx, json, params);\n});\nfunction templateLiteral(parts, params) {\n  return new ZodTemplateLiteral({\n    type: "template_literal",\n    parts,\n    ...exports_util.normalizeParams(params)\n  });\n}\nvar ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {\n  $ZodLazy.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => lazyProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.getter();\n});\nfunction lazy(getter) {\n  return new ZodLazy({\n    type: "lazy",\n    getter\n  });\n}\nvar ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {\n  $ZodPromise.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => promiseProcessor(inst, ctx, json, params);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction promise(innerType) {\n  return new ZodPromise({\n    type: "promise",\n    innerType\n  });\n}\nvar ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {\n  $ZodFunction.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => functionProcessor(inst, ctx, json, params);\n});\nfunction _function(params) {\n  return new ZodFunction({\n    type: "function",\n    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),\n    output: params?.output ?? unknown()\n  });\n}\nvar ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {\n  $ZodCustom.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.processJSONSchema = (ctx, json, params) => customProcessor(inst, ctx, json, params);\n});\nfunction check(fn) {\n  const ch = new $ZodCheck({\n    check: "custom"\n  });\n  ch._zod.check = fn;\n  return ch;\n}\nfunction custom(fn, _params) {\n  return _custom(ZodCustom, fn ?? (() => true), _params);\n}\nfunction refine(fn, _params = {}) {\n  return _refine(ZodCustom, fn, _params);\n}\nfunction superRefine(fn) {\n  return _superRefine(fn);\n}\nvar describe2 = describe;\nvar meta2 = meta;\nfunction _instanceof(cls, params = {}) {\n  const inst = new ZodCustom({\n    type: "custom",\n    check: "custom",\n    fn: (data) => data instanceof cls,\n    abort: true,\n    ...exports_util.normalizeParams(params)\n  });\n  inst._zod.bag.Class = cls;\n  inst._zod.check = (payload) => {\n    if (!(payload.value instanceof cls)) {\n      payload.issues.push({\n        code: "invalid_type",\n        expected: cls.name,\n        input: payload.value,\n        inst,\n        path: [...inst._zod.def.path ?? []]\n      });\n    }\n  };\n  return inst;\n}\nvar stringbool = (...args) => _stringbool({\n  Codec: ZodCodec,\n  Boolean: ZodBoolean,\n  String: ZodString\n}, ...args);\nfunction json(params) {\n  const jsonSchema = lazy(() => {\n    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);\n  });\n  return jsonSchema;\n}\nfunction preprocess(fn, schema) {\n  return pipe(transform(fn), schema);\n}\n// ../../node_modules/zod/v4/classic/compat.js\nvar ZodIssueCode = {\n  invalid_type: "invalid_type",\n  too_big: "too_big",\n  too_small: "too_small",\n  invalid_format: "invalid_format",\n  not_multiple_of: "not_multiple_of",\n  unrecognized_keys: "unrecognized_keys",\n  invalid_union: "invalid_union",\n  invalid_key: "invalid_key",\n  invalid_element: "invalid_element",\n  invalid_value: "invalid_value",\n  custom: "custom"\n};\nfunction setErrorMap(map2) {\n  config({\n    customError: map2\n  });\n}\nfunction getErrorMap() {\n  return config().customError;\n}\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// ../../node_modules/zod/v4/classic/from-json-schema.js\nvar z = {\n  ...exports_schemas2,\n  ...exports_checks2,\n  iso: exports_iso\n};\nvar RECOGNIZED_KEYS = new Set([\n  "$schema",\n  "$ref",\n  "$defs",\n  "definitions",\n  "$id",\n  "id",\n  "$comment",\n  "$anchor",\n  "$vocabulary",\n  "$dynamicRef",\n  "$dynamicAnchor",\n  "type",\n  "enum",\n  "const",\n  "anyOf",\n  "oneOf",\n  "allOf",\n  "not",\n  "properties",\n  "required",\n  "additionalProperties",\n  "patternProperties",\n  "propertyNames",\n  "minProperties",\n  "maxProperties",\n  "items",\n  "prefixItems",\n  "additionalItems",\n  "minItems",\n  "maxItems",\n  "uniqueItems",\n  "contains",\n  "minContains",\n  "maxContains",\n  "minLength",\n  "maxLength",\n  "pattern",\n  "format",\n  "minimum",\n  "maximum",\n  "exclusiveMinimum",\n  "exclusiveMaximum",\n  "multipleOf",\n  "description",\n  "default",\n  "contentEncoding",\n  "contentMediaType",\n  "contentSchema",\n  "unevaluatedItems",\n  "unevaluatedProperties",\n  "if",\n  "then",\n  "else",\n  "dependentSchemas",\n  "dependentRequired",\n  "nullable",\n  "readOnly"\n]);\nfunction detectVersion(schema, defaultTarget) {\n  const $schema = schema.$schema;\n  if ($schema === "https://json-schema.org/draft/2020-12/schema") {\n    return "draft-2020-12";\n  }\n  if ($schema === "http://json-schema.org/draft-07/schema#") {\n    return "draft-7";\n  }\n  if ($schema === "http://json-schema.org/draft-04/schema#") {\n    return "draft-4";\n  }\n  return defaultTarget ?? "draft-2020-12";\n}\nfunction resolveRef(ref, ctx) {\n  if (!ref.startsWith("#")) {\n    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");\n  }\n  const path = ref.slice(1).split("/").filter(Boolean);\n  if (path.length === 0) {\n    return ctx.rootSchema;\n  }\n  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";\n  if (path[0] === defsKey) {\n    const key = path[1];\n    if (!key || !ctx.defs[key]) {\n      throw new Error(`Reference not found: ${ref}`);\n    }\n    return ctx.defs[key];\n  }\n  throw new Error(`Reference not found: ${ref}`);\n}\nfunction convertBaseSchema(schema, ctx) {\n  if (schema.not !== undefined) {\n    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {\n      return z.never();\n    }\n    throw new Error("not is not supported in Zod (except { not: {} } for never)");\n  }\n  if (schema.unevaluatedItems !== undefined) {\n    throw new Error("unevaluatedItems is not supported");\n  }\n  if (schema.unevaluatedProperties !== undefined) {\n    throw new Error("unevaluatedProperties is not supported");\n  }\n  if (schema.if !== undefined || schema.then !== undefined || schema.else !== undefined) {\n    throw new Error("Conditional schemas (if/then/else) are not supported");\n  }\n  if (schema.dependentSchemas !== undefined || schema.dependentRequired !== undefined) {\n    throw new Error("dependentSchemas and dependentRequired are not supported");\n  }\n  if (schema.$ref) {\n    const refPath = schema.$ref;\n    if (ctx.refs.has(refPath)) {\n      return ctx.refs.get(refPath);\n    }\n    if (ctx.processing.has(refPath)) {\n      return z.lazy(() => {\n        if (!ctx.refs.has(refPath)) {\n          throw new Error(`Circular reference not resolved: ${refPath}`);\n        }\n        return ctx.refs.get(refPath);\n      });\n    }\n    ctx.processing.add(refPath);\n    const resolved = resolveRef(refPath, ctx);\n    const zodSchema2 = convertSchema(resolved, ctx);\n    ctx.refs.set(refPath, zodSchema2);\n    ctx.processing.delete(refPath);\n    return zodSchema2;\n  }\n  if (schema.enum !== undefined) {\n    const enumValues = schema.enum;\n    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {\n      return z.null();\n    }\n    if (enumValues.length === 0) {\n      return z.never();\n    }\n    if (enumValues.length === 1) {\n      return z.literal(enumValues[0]);\n    }\n    if (enumValues.every((v) => typeof v === "string")) {\n      return z.enum(enumValues);\n    }\n    const literalSchemas = enumValues.map((v) => z.literal(v));\n    if (literalSchemas.length < 2) {\n      return literalSchemas[0];\n    }\n    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);\n  }\n  if (schema.const !== undefined) {\n    return z.literal(schema.const);\n  }\n  const type = schema.type;\n  if (Array.isArray(type)) {\n    const typeSchemas = type.map((t2) => {\n      const typeSchema = { ...schema, type: t2 };\n      return convertBaseSchema(typeSchema, ctx);\n    });\n    if (typeSchemas.length === 0) {\n      return z.never();\n    }\n    if (typeSchemas.length === 1) {\n      return typeSchemas[0];\n    }\n    return z.union(typeSchemas);\n  }\n  if (!type) {\n    return z.any();\n  }\n  let zodSchema;\n  switch (type) {\n    case "string": {\n      let stringSchema = z.string();\n      if (schema.format) {\n        const format = schema.format;\n        if (format === "email") {\n          stringSchema = stringSchema.check(z.email());\n        } else if (format === "uri" || format === "uri-reference") {\n          stringSchema = stringSchema.check(z.url());\n        } else if (format === "uuid" || format === "guid") {\n          stringSchema = stringSchema.check(z.uuid());\n        } else if (format === "date-time") {\n          stringSchema = stringSchema.check(z.iso.datetime());\n        } else if (format === "date") {\n          stringSchema = stringSchema.check(z.iso.date());\n        } else if (format === "time") {\n          stringSchema = stringSchema.check(z.iso.time());\n        } else if (format === "duration") {\n          stringSchema = stringSchema.check(z.iso.duration());\n        } else if (format === "ipv4") {\n          stringSchema = stringSchema.check(z.ipv4());\n        } else if (format === "ipv6") {\n          stringSchema = stringSchema.check(z.ipv6());\n        } else if (format === "mac") {\n          stringSchema = stringSchema.check(z.mac());\n        } else if (format === "cidr") {\n          stringSchema = stringSchema.check(z.cidrv4());\n        } else if (format === "cidr-v6") {\n          stringSchema = stringSchema.check(z.cidrv6());\n        } else if (format === "base64") {\n          stringSchema = stringSchema.check(z.base64());\n        } else if (format === "base64url") {\n          stringSchema = stringSchema.check(z.base64url());\n        } else if (format === "e164") {\n          stringSchema = stringSchema.check(z.e164());\n        } else if (format === "jwt") {\n          stringSchema = stringSchema.check(z.jwt());\n        } else if (format === "emoji") {\n          stringSchema = stringSchema.check(z.emoji());\n        } else if (format === "nanoid") {\n          stringSchema = stringSchema.check(z.nanoid());\n        } else if (format === "cuid") {\n          stringSchema = stringSchema.check(z.cuid());\n        } else if (format === "cuid2") {\n          stringSchema = stringSchema.check(z.cuid2());\n        } else if (format === "ulid") {\n          stringSchema = stringSchema.check(z.ulid());\n        } else if (format === "xid") {\n          stringSchema = stringSchema.check(z.xid());\n        } else if (format === "ksuid") {\n          stringSchema = stringSchema.check(z.ksuid());\n        }\n      }\n      if (typeof schema.minLength === "number") {\n        stringSchema = stringSchema.min(schema.minLength);\n      }\n      if (typeof schema.maxLength === "number") {\n        stringSchema = stringSchema.max(schema.maxLength);\n      }\n      if (schema.pattern) {\n        stringSchema = stringSchema.regex(new RegExp(schema.pattern));\n      }\n      zodSchema = stringSchema;\n      break;\n    }\n    case "number":\n    case "integer": {\n      let numberSchema = type === "integer" ? z.number().int() : z.number();\n      if (typeof schema.minimum === "number") {\n        numberSchema = numberSchema.min(schema.minimum);\n      }\n      if (typeof schema.maximum === "number") {\n        numberSchema = numberSchema.max(schema.maximum);\n      }\n      if (typeof schema.exclusiveMinimum === "number") {\n        numberSchema = numberSchema.gt(schema.exclusiveMinimum);\n      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {\n        numberSchema = numberSchema.gt(schema.minimum);\n      }\n      if (typeof schema.exclusiveMaximum === "number") {\n        numberSchema = numberSchema.lt(schema.exclusiveMaximum);\n      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {\n        numberSchema = numberSchema.lt(schema.maximum);\n      }\n      if (typeof schema.multipleOf === "number") {\n        numberSchema = numberSchema.multipleOf(schema.multipleOf);\n      }\n      zodSchema = numberSchema;\n      break;\n    }\n    case "boolean": {\n      zodSchema = z.boolean();\n      break;\n    }\n    case "null": {\n      zodSchema = z.null();\n      break;\n    }\n    case "object": {\n      const shape = {};\n      const properties = schema.properties || {};\n      const requiredSet = new Set(schema.required || []);\n      for (const [key, propSchema] of Object.entries(properties)) {\n        const propZodSchema = convertSchema(propSchema, ctx);\n        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();\n      }\n      if (schema.propertyNames) {\n        const keySchema = convertSchema(schema.propertyNames, ctx);\n        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();\n        if (Object.keys(shape).length === 0) {\n          zodSchema = z.record(keySchema, valueSchema);\n          break;\n        }\n        const objectSchema2 = z.object(shape).passthrough();\n        const recordSchema = z.looseRecord(keySchema, valueSchema);\n        zodSchema = z.intersection(objectSchema2, recordSchema);\n        break;\n      }\n      if (schema.patternProperties) {\n        const patternProps = schema.patternProperties;\n        const patternKeys = Object.keys(patternProps);\n        const looseRecords = [];\n        for (const pattern of patternKeys) {\n          const patternValue = convertSchema(patternProps[pattern], ctx);\n          const keySchema = z.string().regex(new RegExp(pattern));\n          looseRecords.push(z.looseRecord(keySchema, patternValue));\n        }\n        const schemasToIntersect = [];\n        if (Object.keys(shape).length > 0) {\n          schemasToIntersect.push(z.object(shape).passthrough());\n        }\n        schemasToIntersect.push(...looseRecords);\n        if (schemasToIntersect.length === 0) {\n          zodSchema = z.object({}).passthrough();\n        } else if (schemasToIntersect.length === 1) {\n          zodSchema = schemasToIntersect[0];\n        } else {\n          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);\n          for (let i2 = 2;i2 < schemasToIntersect.length; i2++) {\n            result = z.intersection(result, schemasToIntersect[i2]);\n          }\n          zodSchema = result;\n        }\n        break;\n      }\n      const objectSchema = z.object(shape);\n      if (schema.additionalProperties === false) {\n        zodSchema = objectSchema.strict();\n      } else if (typeof schema.additionalProperties === "object") {\n        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));\n      } else {\n        zodSchema = objectSchema.passthrough();\n      }\n      break;\n    }\n    case "array": {\n      const prefixItems = schema.prefixItems;\n      const items = schema.items;\n      if (prefixItems && Array.isArray(prefixItems)) {\n        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));\n        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : undefined;\n        if (rest) {\n          zodSchema = z.tuple(tupleItems).rest(rest);\n        } else {\n          zodSchema = z.tuple(tupleItems);\n        }\n        if (typeof schema.minItems === "number") {\n          zodSchema = zodSchema.check(z.minLength(schema.minItems));\n        }\n        if (typeof schema.maxItems === "number") {\n          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));\n        }\n      } else if (Array.isArray(items)) {\n        const tupleItems = items.map((item) => convertSchema(item, ctx));\n        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : undefined;\n        if (rest) {\n          zodSchema = z.tuple(tupleItems).rest(rest);\n        } else {\n          zodSchema = z.tuple(tupleItems);\n        }\n        if (typeof schema.minItems === "number") {\n          zodSchema = zodSchema.check(z.minLength(schema.minItems));\n        }\n        if (typeof schema.maxItems === "number") {\n          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));\n        }\n      } else if (items !== undefined) {\n        const element = convertSchema(items, ctx);\n        let arraySchema = z.array(element);\n        if (typeof schema.minItems === "number") {\n          arraySchema = arraySchema.min(schema.minItems);\n        }\n        if (typeof schema.maxItems === "number") {\n          arraySchema = arraySchema.max(schema.maxItems);\n        }\n        zodSchema = arraySchema;\n      } else {\n        zodSchema = z.array(z.any());\n      }\n      break;\n    }\n    default:\n      throw new Error(`Unsupported type: ${type}`);\n  }\n  if (schema.description) {\n    zodSchema = zodSchema.describe(schema.description);\n  }\n  if (schema.default !== undefined) {\n    zodSchema = zodSchema.default(schema.default);\n  }\n  return zodSchema;\n}\nfunction convertSchema(schema, ctx) {\n  if (typeof schema === "boolean") {\n    return schema ? z.any() : z.never();\n  }\n  let baseSchema = convertBaseSchema(schema, ctx);\n  const hasExplicitType = schema.type || schema.enum !== undefined || schema.const !== undefined;\n  if (schema.anyOf && Array.isArray(schema.anyOf)) {\n    const options = schema.anyOf.map((s) => convertSchema(s, ctx));\n    const anyOfUnion = z.union(options);\n    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;\n  }\n  if (schema.oneOf && Array.isArray(schema.oneOf)) {\n    const options = schema.oneOf.map((s) => convertSchema(s, ctx));\n    const oneOfUnion = z.xor(options);\n    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;\n  }\n  if (schema.allOf && Array.isArray(schema.allOf)) {\n    if (schema.allOf.length === 0) {\n      baseSchema = hasExplicitType ? baseSchema : z.any();\n    } else {\n      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);\n      const startIdx = hasExplicitType ? 0 : 1;\n      for (let i2 = startIdx;i2 < schema.allOf.length; i2++) {\n        result = z.intersection(result, convertSchema(schema.allOf[i2], ctx));\n      }\n      baseSchema = result;\n    }\n  }\n  if (schema.nullable === true && ctx.version === "openapi-3.0") {\n    baseSchema = z.nullable(baseSchema);\n  }\n  if (schema.readOnly === true) {\n    baseSchema = z.readonly(baseSchema);\n  }\n  const extraMeta = {};\n  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];\n  for (const key of coreMetadataKeys) {\n    if (key in schema) {\n      extraMeta[key] = schema[key];\n    }\n  }\n  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];\n  for (const key of contentMetadataKeys) {\n    if (key in schema) {\n      extraMeta[key] = schema[key];\n    }\n  }\n  for (const key of Object.keys(schema)) {\n    if (!RECOGNIZED_KEYS.has(key)) {\n      extraMeta[key] = schema[key];\n    }\n  }\n  if (Object.keys(extraMeta).length > 0) {\n    ctx.registry.add(baseSchema, extraMeta);\n  }\n  return baseSchema;\n}\nfunction fromJSONSchema(schema, params) {\n  if (typeof schema === "boolean") {\n    return schema ? z.any() : z.never();\n  }\n  const version2 = detectVersion(schema, params?.defaultTarget);\n  const defs = schema.$defs || schema.definitions || {};\n  const ctx = {\n    version: version2,\n    defs,\n    refs: new Map,\n    processing: new Set,\n    rootSchema: schema,\n    registry: params?.registry ?? globalRegistry\n  };\n  return convertSchema(schema, ctx);\n}\n// ../../node_modules/zod/v4/classic/coerce.js\nvar exports_coerce = {};\n__export(exports_coerce, {\n  string: () => string3,\n  number: () => number3,\n  date: () => date4,\n  boolean: () => boolean3,\n  bigint: () => bigint3\n});\nfunction string3(params) {\n  return _coercedString(ZodString, params);\n}\nfunction number3(params) {\n  return _coercedNumber(ZodNumber, params);\n}\nfunction boolean3(params) {\n  return _coercedBoolean(ZodBoolean, params);\n}\nfunction bigint3(params) {\n  return _coercedBigint(ZodBigInt, params);\n}\nfunction date4(params) {\n  return _coercedDate(ZodDate, params);\n}\n\n// ../../node_modules/zod/v4/classic/external.js\nconfig(en_default());\n// ../../node_modules/zod/v4/classic/index.js\nvar classic_default = exports_external;\n\n// ../../node_modules/zod/v4/index.js\nvar v4_default = classic_default;\n\n// ../../node_modules/zod/v3/helpers/util.js\nvar util;\n(function(util2) {\n  util2.assertEqual = (_) => {};\n  function assertIs2(_arg) {}\n  util2.assertIs = assertIs2;\n  function assertNever2(_x) {\n    throw new Error;\n  }\n  util2.assertNever = assertNever2;\n  util2.arrayToEnum = (items) => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util2.getValidEnumValues = (obj) => {\n    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");\n    const filtered = {};\n    for (const k of validKeys) {\n      filtered[k] = obj[k];\n    }\n    return util2.objectValues(filtered);\n  };\n  util2.objectValues = (obj) => {\n    return util2.objectKeys(obj).map(function(e2) {\n      return obj[e2];\n    });\n  };\n  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {\n    const keys = [];\n    for (const key in object2) {\n      if (Object.prototype.hasOwnProperty.call(object2, key)) {\n        keys.push(key);\n      }\n    }\n    return keys;\n  };\n  util2.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item))\n        return item;\n    }\n    return;\n  };\n  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;\n  function joinValues2(array2, separator = " | ") {\n    return array2.map((val) => typeof val === "string" ? `\'${val}\'` : val).join(separator);\n  }\n  util2.joinValues = joinValues2;\n  util2.jsonStringifyReplacer = (_, value) => {\n    if (typeof value === "bigint") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\n  "string",\n  "nan",\n  "number",\n  "integer",\n  "float",\n  "boolean",\n  "date",\n  "bigint",\n  "symbol",\n  "function",\n  "undefined",\n  "null",\n  "array",\n  "object",\n  "unknown",\n  "promise",\n  "void",\n  "never",\n  "map",\n  "set"\n]);\nvar getParsedType2 = (data) => {\n  const t2 = typeof data;\n  switch (t2) {\n    case "undefined":\n      return ZodParsedType.undefined;\n    case "string":\n      return ZodParsedType.string;\n    case "number":\n      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case "boolean":\n      return ZodParsedType.boolean;\n    case "function":\n      return ZodParsedType.function;\n    case "bigint":\n      return ZodParsedType.bigint;\n    case "symbol":\n      return ZodParsedType.symbol;\n    case "object":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== "undefined" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== "undefined" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== "undefined" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};\n\n// ../../node_modules/zod/v3/ZodError.js\nvar ZodIssueCode2 = util.arrayToEnum([\n  "invalid_type",\n  "invalid_literal",\n  "custom",\n  "invalid_union",\n  "invalid_union_discriminator",\n  "invalid_enum_value",\n  "unrecognized_keys",\n  "invalid_arguments",\n  "invalid_return_type",\n  "invalid_date",\n  "invalid_string",\n  "too_small",\n  "too_big",\n  "invalid_intersection_types",\n  "not_multiple_of",\n  "not_finite"\n]);\nclass ZodError2 extends Error {\n  get errors() {\n    return this.issues;\n  }\n  constructor(issues) {\n    super();\n    this.issues = [];\n    this.addIssue = (sub) => {\n      this.issues = [...this.issues, sub];\n    };\n    this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.name = "ZodError";\n    this.issues = issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function(issue2) {\n      return issue2.message;\n    };\n    const fieldErrors = { _errors: [] };\n    const processError = (error48) => {\n      for (const issue2 of error48.issues) {\n        if (issue2.code === "invalid_union") {\n          issue2.unionErrors.map(processError);\n        } else if (issue2.code === "invalid_return_type") {\n          processError(issue2.returnTypeError);\n        } else if (issue2.code === "invalid_arguments") {\n          processError(issue2.argumentsError);\n        } else if (issue2.path.length === 0) {\n          fieldErrors._errors.push(mapper(issue2));\n        } else {\n          let curr = fieldErrors;\n          let i2 = 0;\n          while (i2 < issue2.path.length) {\n            const el = issue2.path[i2];\n            const terminal = i2 === issue2.path.length - 1;\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue2));\n            }\n            curr = curr[el];\n            i2++;\n          }\n        }\n      }\n    };\n    processError(this);\n    return fieldErrors;\n  }\n  static assert(value) {\n    if (!(value instanceof ZodError2)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = (issue2) => issue2.message) {\n    const fieldErrors = Object.create(null);\n    const formErrors = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        const firstEl = sub.path[0];\n        fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n        fieldErrors[firstEl].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n}\nZodError2.create = (issues) => {\n  const error48 = new ZodError2(issues);\n  return error48;\n};\n\n// ../../node_modules/zod/v3/locales/en.js\nvar errorMap = (issue2, _ctx) => {\n  let message;\n  switch (issue2.code) {\n    case ZodIssueCode2.invalid_type:\n      if (issue2.received === ZodParsedType.undefined) {\n        message = "Required";\n      } else {\n        message = `Expected ${issue2.expected}, received ${issue2.received}`;\n      }\n      break;\n    case ZodIssueCode2.invalid_literal:\n      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode2.unrecognized_keys:\n      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;\n      break;\n    case ZodIssueCode2.invalid_union:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode2.invalid_union_discriminator:\n      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;\n      break;\n    case ZodIssueCode2.invalid_enum_value:\n      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received \'${issue2.received}\'`;\n      break;\n    case ZodIssueCode2.invalid_arguments:\n      message = `Invalid function arguments`;\n      break;\n    case ZodIssueCode2.invalid_return_type:\n      message = `Invalid function return type`;\n      break;\n    case ZodIssueCode2.invalid_date:\n      message = `Invalid date`;\n      break;\n    case ZodIssueCode2.invalid_string:\n      if (typeof issue2.validation === "object") {\n        if ("includes" in issue2.validation) {\n          message = `Invalid input: must include "${issue2.validation.includes}"`;\n          if (typeof issue2.validation.position === "number") {\n            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;\n          }\n        } else if ("startsWith" in issue2.validation) {\n          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;\n        } else if ("endsWith" in issue2.validation) {\n          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;\n        } else {\n          util.assertNever(issue2.validation);\n        }\n      } else if (issue2.validation !== "regex") {\n        message = `Invalid ${issue2.validation}`;\n      } else {\n        message = "Invalid";\n      }\n      break;\n    case ZodIssueCode2.too_small:\n      if (issue2.type === "array")\n        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;\n      else if (issue2.type === "string")\n        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;\n      else if (issue2.type === "number")\n        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;\n      else if (issue2.type === "bigint")\n        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;\n      else if (issue2.type === "date")\n        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;\n      else\n        message = "Invalid input";\n      break;\n    case ZodIssueCode2.too_big:\n      if (issue2.type === "array")\n        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;\n      else if (issue2.type === "string")\n        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;\n      else if (issue2.type === "number")\n        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;\n      else if (issue2.type === "bigint")\n        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;\n      else if (issue2.type === "date")\n        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;\n      else\n        message = "Invalid input";\n      break;\n    case ZodIssueCode2.custom:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode2.invalid_intersection_types:\n      message = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode2.not_multiple_of:\n      message = `Number must be a multiple of ${issue2.multipleOf}`;\n      break;\n    case ZodIssueCode2.not_finite:\n      message = "Number must be finite";\n      break;\n    default:\n      message = _ctx.defaultError;\n      util.assertNever(issue2);\n  }\n  return { message };\n};\nvar en_default2 = errorMap;\n\n// ../../node_modules/zod/v3/errors.js\nvar overrideErrorMap = en_default2;\nfunction getErrorMap2() {\n  return overrideErrorMap;\n}\n\n// ../../node_modules/zod/v3/helpers/parseUtil.js\nvar makeIssue = (params) => {\n  const { data, path, errorMaps, issueData } = params;\n  const fullPath = [...path, ...issueData.path || []];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  if (issueData.message !== undefined) {\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message\n    };\n  }\n  let errorMessage = "";\n  const maps = errorMaps.filter((m) => !!m).slice().reverse();\n  for (const map2 of maps) {\n    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage\n  };\n};\nfunction addIssueToContext(ctx, issueData) {\n  const overrideMap = getErrorMap2();\n  const issue2 = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      ctx.schemaErrorMap,\n      overrideMap,\n      overrideMap === en_default2 ? undefined : en_default2\n    ].filter((x) => !!x)\n  });\n  ctx.common.issues.push(issue2);\n}\n\nclass ParseStatus {\n  constructor() {\n    this.value = "valid";\n  }\n  dirty() {\n    if (this.value === "valid")\n      this.value = "dirty";\n  }\n  abort() {\n    if (this.value !== "aborted")\n      this.value = "aborted";\n  }\n  static mergeArray(status, results) {\n    const arrayValue = [];\n    for (const s of results) {\n      if (s.status === "aborted")\n        return INVALID;\n      if (s.status === "dirty")\n        status.dirty();\n      arrayValue.push(s.value);\n    }\n    return { status: status.value, value: arrayValue };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value\n      });\n    }\n    return ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === "aborted")\n        return INVALID;\n      if (value.status === "aborted")\n        return INVALID;\n      if (key.status === "dirty")\n        status.dirty();\n      if (value.status === "dirty")\n        status.dirty();\n      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return { status: status.value, value: finalObject };\n  }\n}\nvar INVALID = Object.freeze({\n  status: "aborted"\n});\nvar DIRTY = (value) => ({ status: "dirty", value });\nvar OK = (value) => ({ status: "valid", value });\nvar isAborted = (x) => x.status === "aborted";\nvar isDirty = (x) => x.status === "dirty";\nvar isValid = (x) => x.status === "valid";\nvar isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;\n\n// ../../node_modules/zod/v3/helpers/errorUtil.js\nvar errorUtil;\n(function(errorUtil2) {\n  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};\n  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n\n// ../../node_modules/zod/v3/types.js\nclass ParseInputLazyPath {\n  constructor(parent, value, path, key) {\n    this._cachedPath = [];\n    this.parent = parent;\n    this.data = value;\n    this._path = path;\n    this._key = key;\n  }\n  get path() {\n    if (!this._cachedPath.length) {\n      if (Array.isArray(this._key)) {\n        this._cachedPath.push(...this._path, ...this._key);\n      } else {\n        this._cachedPath.push(...this._path, this._key);\n      }\n    }\n    return this._cachedPath;\n  }\n}\nvar handleResult = (ctx, result) => {\n  if (isValid(result)) {\n    return { success: true, data: result.value };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error("Validation failed but no issues detected.");\n    }\n    return {\n      success: false,\n      get error() {\n        if (this._error)\n          return this._error;\n        const error48 = new ZodError2(ctx.common.issues);\n        this._error = error48;\n        return this._error;\n      }\n    };\n  }\n};\nfunction processCreateParams(params) {\n  if (!params)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = (iss, ctx) => {\n    const { message } = params;\n    if (iss.code === "invalid_enum_value") {\n      return { message: message ?? ctx.defaultError };\n    }\n    if (typeof ctx.data === "undefined") {\n      return { message: message ?? required_error ?? ctx.defaultError };\n    }\n    if (iss.code !== "invalid_type")\n      return { message: ctx.defaultError };\n    return { message: message ?? invalid_type_error ?? ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\n\nclass ZodType2 {\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType2(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType2(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus,\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType2(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error("Synchronous parse encountered promise.");\n    }\n    return result;\n  }\n  _parseAsync(input) {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n  parse(data, params) {\n    const result = this.safeParse(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  safeParse(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: params?.async ?? false,\n        contextualErrorMap: params?.errorMap\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType2(data)\n    };\n    const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n    return handleResult(ctx, result);\n  }\n  "~validate"(data) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: !!this["~standard"].async\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType2(data)\n    };\n    if (!this["~standard"].async) {\n      try {\n        const result = this._parseSync({ data, path: [], parent: ctx });\n        return isValid(result) ? {\n          value: result.value\n        } : {\n          issues: ctx.common.issues\n        };\n      } catch (err) {\n        if (err?.message?.toLowerCase()?.includes("encountered")) {\n          this["~standard"].async = true;\n        }\n        ctx.common = {\n          issues: [],\n          async: true\n        };\n      }\n    }\n    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {\n      value: result.value\n    } : {\n      issues: ctx.common.issues\n    });\n  }\n  async parseAsync(data, params) {\n    const result = await this.safeParseAsync(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  async safeParseAsync(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params?.errorMap,\n        async: true\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType2(data)\n    };\n    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n  refine(check2, message) {\n    const getIssueProperties = (val) => {\n      if (typeof message === "string" || typeof message === "undefined") {\n        return { message };\n      } else if (typeof message === "function") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check2(val);\n      const setError = () => ctx.addIssue({\n        code: ZodIssueCode2.custom,\n        ...getIssueProperties(val)\n      });\n      if (typeof Promise !== "undefined" && result instanceof Promise) {\n        return result.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  refinement(check2, refinementData) {\n    return this._refinement((val, ctx) => {\n      if (!check2(val)) {\n        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind2.ZodEffects,\n      effect: { type: "refinement", refinement }\n    });\n  }\n  superRefine(refinement) {\n    return this._refinement(refinement);\n  }\n  constructor(def) {\n    this.spa = this.safeParseAsync;\n    this._def = def;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.brand = this.brand.bind(this);\n    this.default = this.default.bind(this);\n    this.catch = this.catch.bind(this);\n    this.describe = this.describe.bind(this);\n    this.pipe = this.pipe.bind(this);\n    this.readonly = this.readonly.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n    this["~standard"] = {\n      version: 1,\n      vendor: "zod",\n      validate: (data) => this["~validate"](data)\n    };\n  }\n  optional() {\n    return ZodOptional2.create(this, this._def);\n  }\n  nullable() {\n    return ZodNullable2.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return ZodArray2.create(this);\n  }\n  promise() {\n    return ZodPromise2.create(this, this._def);\n  }\n  or(option) {\n    return ZodUnion2.create([this, option], this._def);\n  }\n  and(incoming) {\n    return ZodIntersection2.create(this, incoming, this._def);\n  }\n  transform(transform2) {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind2.ZodEffects,\n      effect: { type: "transform", transform: transform2 }\n    });\n  }\n  default(def) {\n    const defaultValueFunc = typeof def === "function" ? def : () => def;\n    return new ZodDefault2({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind2.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind2.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def)\n    });\n  }\n  catch(def) {\n    const catchValueFunc = typeof def === "function" ? def : () => def;\n    return new ZodCatch2({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind2.ZodCatch\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  pipe(target) {\n    return ZodPipeline.create(this, target);\n  }\n  readonly() {\n    return ZodReadonly2.create(this);\n  }\n  isOptional() {\n    return this.safeParse(undefined).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n}\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar cuid2Regex = /^[0-9a-z]+$/;\nvar ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\nvar uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar nanoidRegex = /^[a-z0-9_-]{21}$/i;\nvar jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nvar durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_\'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nvar emojiRegex;\nvar ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\nvar ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nvar ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\nvar base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\nvar base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\nvar dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nvar dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n  let secondsRegexSource = `[0-5]\\\\d`;\n  if (args.precision) {\n    secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n  }\n  const secondsQuantifier = args.precision ? "+" : "?";\n  return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n  return new RegExp(`^${timeRegexSource(args)}$`);\n}\nfunction datetimeRegex(args) {\n  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n  const opts = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset)\n    opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join("|")})`;\n  return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version2) {\n  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nfunction isValidJWT2(jwt2, alg) {\n  if (!jwtRegex.test(jwt2))\n    return false;\n  try {\n    const [header] = jwt2.split(".");\n    if (!header)\n      return false;\n    const base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");\n    const decoded = JSON.parse(atob(base643));\n    if (typeof decoded !== "object" || decoded === null)\n      return false;\n    if ("typ" in decoded && decoded?.typ !== "JWT")\n      return false;\n    if (!decoded.alg)\n      return false;\n    if (alg && decoded.alg !== alg)\n      return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction isValidCidr(ip, version2) {\n  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {\n    return true;\n  }\n  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {\n    return true;\n  }\n  return false;\n}\n\nclass ZodString2 extends ZodType2 {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus;\n    let ctx = undefined;\n    for (const check2 of this._def.checks) {\n      if (check2.kind === "min") {\n        if (input.data.length < check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_small,\n            minimum: check2.value,\n            type: "string",\n            inclusive: true,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "max") {\n        if (input.data.length > check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_big,\n            maximum: check2.value,\n            type: "string",\n            inclusive: true,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "length") {\n        const tooBig = input.data.length > check2.value;\n        const tooSmall = input.data.length < check2.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode2.too_big,\n              maximum: check2.value,\n              type: "string",\n              inclusive: true,\n              exact: true,\n              message: check2.message\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode2.too_small,\n              minimum: check2.value,\n              type: "string",\n              inclusive: true,\n              exact: true,\n              message: check2.message\n            });\n          }\n          status.dirty();\n        }\n      } else if (check2.kind === "email") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "email",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "emoji") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, "u");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "emoji",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "uuid") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "uuid",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "nanoid") {\n        if (!nanoidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "nanoid",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "cuid") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "cuid",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "cuid2") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "cuid2",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "ulid") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "ulid",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "url") {\n        try {\n          new URL(input.data);\n        } catch {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "url",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "regex") {\n        check2.regex.lastIndex = 0;\n        const testResult = check2.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "regex",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "trim") {\n        input.data = input.data.trim();\n      } else if (check2.kind === "includes") {\n        if (!input.data.includes(check2.value, check2.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: { includes: check2.value, position: check2.position },\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "toLowerCase") {\n        input.data = input.data.toLowerCase();\n      } else if (check2.kind === "toUpperCase") {\n        input.data = input.data.toUpperCase();\n      } else if (check2.kind === "startsWith") {\n        if (!input.data.startsWith(check2.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: { startsWith: check2.value },\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "endsWith") {\n        if (!input.data.endsWith(check2.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: { endsWith: check2.value },\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "datetime") {\n        const regex = datetimeRegex(check2);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: "datetime",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "date") {\n        const regex = dateRegex;\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: "date",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "time") {\n        const regex = timeRegex(check2);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_string,\n            validation: "time",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "duration") {\n        if (!durationRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "duration",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "ip") {\n        if (!isValidIP(input.data, check2.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "ip",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "jwt") {\n        if (!isValidJWT2(input.data, check2.alg)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "jwt",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "cidr") {\n        if (!isValidCidr(input.data, check2.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "cidr",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "base64") {\n        if (!base64Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "base64",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "base64url") {\n        if (!base64urlRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "base64url",\n            code: ZodIssueCode2.invalid_string,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _regex(regex, validation, message) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode2.invalid_string,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  _addCheck(check2) {\n    return new ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  email(message) {\n    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });\n  }\n  url(message) {\n    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });\n  }\n  emoji(message) {\n    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });\n  }\n  uuid(message) {\n    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });\n  }\n  nanoid(message) {\n    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });\n  }\n  cuid(message) {\n    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });\n  }\n  cuid2(message) {\n    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });\n  }\n  ulid(message) {\n    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });\n  }\n  base64(message) {\n    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });\n  }\n  base64url(message) {\n    return this._addCheck({\n      kind: "base64url",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  jwt(options) {\n    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });\n  }\n  ip(options) {\n    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });\n  }\n  cidr(options) {\n    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });\n  }\n  datetime(options) {\n    if (typeof options === "string") {\n      return this._addCheck({\n        kind: "datetime",\n        precision: null,\n        offset: false,\n        local: false,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: "datetime",\n      precision: typeof options?.precision === "undefined" ? null : options?.precision,\n      offset: options?.offset ?? false,\n      local: options?.local ?? false,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  date(message) {\n    return this._addCheck({ kind: "date", message });\n  }\n  time(options) {\n    if (typeof options === "string") {\n      return this._addCheck({\n        kind: "time",\n        precision: null,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: "time",\n      precision: typeof options?.precision === "undefined" ? null : options?.precision,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  duration(message) {\n    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });\n  }\n  regex(regex, message) {\n    return this._addCheck({\n      kind: "regex",\n      regex,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  includes(value, options) {\n    return this._addCheck({\n      kind: "includes",\n      value,\n      position: options?.position,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  startsWith(value, message) {\n    return this._addCheck({\n      kind: "startsWith",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  endsWith(value, message) {\n    return this._addCheck({\n      kind: "endsWith",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  min(minLength, message) {\n    return this._addCheck({\n      kind: "min",\n      value: minLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  max(maxLength, message) {\n    return this._addCheck({\n      kind: "max",\n      value: maxLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  length(len, message) {\n    return this._addCheck({\n      kind: "length",\n      value: len,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  nonempty(message) {\n    return this.min(1, errorUtil.errToObj(message));\n  }\n  trim() {\n    return new ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, { kind: "trim" }]\n    });\n  }\n  toLowerCase() {\n    return new ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, { kind: "toLowerCase" }]\n    });\n  }\n  toUpperCase() {\n    return new ZodString2({\n      ...this._def,\n      checks: [...this._def.checks, { kind: "toUpperCase" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((ch) => ch.kind === "datetime");\n  }\n  get isDate() {\n    return !!this._def.checks.find((ch) => ch.kind === "date");\n  }\n  get isTime() {\n    return !!this._def.checks.find((ch) => ch.kind === "time");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((ch) => ch.kind === "duration");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === "email");\n  }\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === "url");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((ch) => ch.kind === "emoji");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === "uuid");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((ch) => ch.kind === "nanoid");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === "cuid");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((ch) => ch.kind === "cuid2");\n  }\n  get isULID() {\n    return !!this._def.checks.find((ch) => ch.kind === "ulid");\n  }\n  get isIP() {\n    return !!this._def.checks.find((ch) => ch.kind === "ip");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find((ch) => ch.kind === "cidr");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((ch) => ch.kind === "base64");\n  }\n  get isBase64url() {\n    return !!this._def.checks.find((ch) => ch.kind === "base64url");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxLength() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n}\nZodString2.create = (params) => {\n  return new ZodString2({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind2.ZodString,\n    coerce: params?.coerce ?? false,\n    ...processCreateParams(params)\n  });\n};\nfunction floatSafeRemainder2(val, step) {\n  const valDecCount = (val.toString().split(".")[1] || "").length;\n  const stepDecCount = (step.toString().split(".")[1] || "").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));\n  return valInt % stepInt / 10 ** decCount;\n}\n\nclass ZodNumber2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n    this.step = this.multipleOf;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = undefined;\n    const status = new ParseStatus;\n    for (const check2 of this._def.checks) {\n      if (check2.kind === "int") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.invalid_type,\n            expected: "integer",\n            received: "float",\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "min") {\n        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_small,\n            minimum: check2.value,\n            type: "number",\n            inclusive: check2.inclusive,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "max") {\n        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_big,\n            maximum: check2.value,\n            type: "number",\n            inclusive: check2.inclusive,\n            exact: false,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "multipleOf") {\n        if (floatSafeRemainder2(input.data, check2.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.not_multiple_of,\n            multipleOf: check2.value,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "finite") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.not_finite,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message) {\n    return this.setLimit("min", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit("min", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit("max", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit("max", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new ZodNumber2({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check2) {\n    return new ZodNumber2({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  int(message) {\n    return this._addCheck({\n      kind: "int",\n      message: errorUtil.toString(message)\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: "min",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: "max",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: "max",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: "min",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: "multipleOf",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  finite(message) {\n    return this._addCheck({\n      kind: "finite",\n      message: errorUtil.toString(message)\n    });\n  }\n  safe(message) {\n    return this._addCheck({\n      kind: "min",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    })._addCheck({\n      kind: "max",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));\n  }\n  get isFinite() {\n    let max = null;\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {\n        return true;\n      } else if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      } else if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return Number.isFinite(min) && Number.isFinite(max);\n  }\n}\nZodNumber2.create = (params) => {\n  return new ZodNumber2({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind2.ZodNumber,\n    coerce: params?.coerce || false,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodBigInt2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      try {\n        input.data = BigInt(input.data);\n      } catch {\n        return this._getInvalidInput(input);\n      }\n    }\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.bigint) {\n      return this._getInvalidInput(input);\n    }\n    let ctx = undefined;\n    const status = new ParseStatus;\n    for (const check2 of this._def.checks) {\n      if (check2.kind === "min") {\n        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_small,\n            type: "bigint",\n            minimum: check2.value,\n            inclusive: check2.inclusive,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "max") {\n        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_big,\n            type: "bigint",\n            maximum: check2.value,\n            inclusive: check2.inclusive,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "multipleOf") {\n        if (input.data % check2.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.not_multiple_of,\n            multipleOf: check2.value,\n            message: check2.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _getInvalidInput(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode2.invalid_type,\n      expected: ZodParsedType.bigint,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n  gte(value, message) {\n    return this.setLimit("min", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit("min", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit("max", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit("max", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new ZodBigInt2({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check2) {\n    return new ZodBigInt2({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: "min",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: "max",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: "max",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: "min",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: "multipleOf",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n}\nZodBigInt2.create = (params) => {\n  return new ZodBigInt2({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind2.ZodBigInt,\n    coerce: params?.coerce ?? false,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodBoolean2 extends ZodType2 {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n}\nZodBoolean2.create = (params) => {\n  return new ZodBoolean2({\n    typeName: ZodFirstPartyTypeKind2.ZodBoolean,\n    coerce: params?.coerce || false,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodDate2 extends ZodType2 {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    if (Number.isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode2.invalid_date\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus;\n    let ctx = undefined;\n    for (const check2 of this._def.checks) {\n      if (check2.kind === "min") {\n        if (input.data.getTime() < check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_small,\n            message: check2.message,\n            inclusive: true,\n            exact: false,\n            minimum: check2.value,\n            type: "date"\n          });\n          status.dirty();\n        }\n      } else if (check2.kind === "max") {\n        if (input.data.getTime() > check2.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.too_big,\n            message: check2.message,\n            inclusive: true,\n            exact: false,\n            maximum: check2.value,\n            type: "date"\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check2);\n      }\n    }\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check2) {\n    return new ZodDate2({\n      ...this._def,\n      checks: [...this._def.checks, check2]\n    });\n  }\n  min(minDate, message) {\n    return this._addCheck({\n      kind: "min",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  max(maxDate, message) {\n    return this._addCheck({\n      kind: "max",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max != null ? new Date(max) : null;\n  }\n}\nZodDate2.create = (params) => {\n  return new ZodDate2({\n    checks: [],\n    coerce: params?.coerce || false,\n    typeName: ZodFirstPartyTypeKind2.ZodDate,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodSymbol2 extends ZodType2 {\n  _parse(input) {\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n}\nZodSymbol2.create = (params) => {\n  return new ZodSymbol2({\n    typeName: ZodFirstPartyTypeKind2.ZodSymbol,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodUndefined2 extends ZodType2 {\n  _parse(input) {\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n}\nZodUndefined2.create = (params) => {\n  return new ZodUndefined2({\n    typeName: ZodFirstPartyTypeKind2.ZodUndefined,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNull2 extends ZodType2 {\n  _parse(input) {\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n}\nZodNull2.create = (params) => {\n  return new ZodNull2({\n    typeName: ZodFirstPartyTypeKind2.ZodNull,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodAny2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this._any = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n}\nZodAny2.create = (params) => {\n  return new ZodAny2({\n    typeName: ZodFirstPartyTypeKind2.ZodAny,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodUnknown2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this._unknown = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n}\nZodUnknown2.create = (params) => {\n  return new ZodUnknown2({\n    typeName: ZodFirstPartyTypeKind2.ZodUnknown,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNever2 extends ZodType2 {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode2.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n}\nZodNever2.create = (params) => {\n  return new ZodNever2({\n    typeName: ZodFirstPartyTypeKind2.ZodNever,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodVoid2 extends ZodType2 {\n  _parse(input) {\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n}\nZodVoid2.create = (params) => {\n  return new ZodVoid2({\n    typeName: ZodFirstPartyTypeKind2.ZodVoid,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodArray2 extends ZodType2 {\n  _parse(input) {\n    const { ctx, status } = this._processInputParams(input);\n    const def = this._def;\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,\n          minimum: tooSmall ? def.exactLength.value : undefined,\n          maximum: tooBig ? def.exactLength.value : undefined,\n          type: "array",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode2.too_small,\n          minimum: def.minLength.value,\n          type: "array",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode2.too_big,\n          maximum: def.maxLength.value,\n          type: "array",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.all([...ctx.data].map((item, i2) => {\n        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));\n      })).then((result2) => {\n        return ParseStatus.mergeArray(status, result2);\n      });\n    }\n    const result = [...ctx.data].map((item, i2) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));\n    });\n    return ParseStatus.mergeArray(status, result);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message) {\n    return new ZodArray2({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxLength, message) {\n    return new ZodArray2({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) }\n    });\n  }\n  length(len, message) {\n    return new ZodArray2({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message) }\n    });\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n}\nZodArray2.create = (schema, params) => {\n  return new ZodArray2({\n    type: schema,\n    minLength: null,\n    maxLength: null,\n    exactLength: null,\n    typeName: ZodFirstPartyTypeKind2.ZodArray,\n    ...processCreateParams(params)\n  });\n};\nfunction deepPartialify(schema) {\n  if (schema instanceof ZodObject2) {\n    const newShape = {};\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional2.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject2({\n      ...schema._def,\n      shape: () => newShape\n    });\n  } else if (schema instanceof ZodArray2) {\n    return new ZodArray2({\n      ...schema._def,\n      type: deepPartialify(schema.element)\n    });\n  } else if (schema instanceof ZodOptional2) {\n    return ZodOptional2.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable2) {\n    return ZodNullable2.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple2) {\n    return ZodTuple2.create(schema.items.map((item) => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}\n\nclass ZodObject2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this._cached = null;\n    this.nonstrict = this.passthrough;\n    this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const shape = this._def.shape();\n    const keys = util.objectKeys(shape);\n    this._cached = { shape, keys };\n    return this._cached;\n  }\n  _parse(input) {\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const { status, ctx } = this._processInputParams(input);\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key];\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: "valid", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever2) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === "passthrough") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: "valid", value: key },\n            value: { status: "valid", value: ctx.data[key] }\n          });\n        }\n      } else if (unknownKeys === "strict") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode2.unrecognized_keys,\n            keys: extraKeys\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === "strip") {} else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: "valid", value: key },\n          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.resolve().then(async () => {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          syncPairs.push({\n            key,\n            value,\n            alwaysSet: pair.alwaysSet\n          });\n        }\n        return syncPairs;\n      }).then((syncPairs) => {\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n      });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message) {\n    errorUtil.errToObj;\n    return new ZodObject2({\n      ...this._def,\n      unknownKeys: "strict",\n      ...message !== undefined ? {\n        errorMap: (issue2, ctx) => {\n          const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;\n          if (issue2.code === "unrecognized_keys")\n            return {\n              message: errorUtil.errToObj(message).message ?? defaultError\n            };\n          return {\n            message: defaultError\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new ZodObject2({\n      ...this._def,\n      unknownKeys: "strip"\n    });\n  }\n  passthrough() {\n    return new ZodObject2({\n      ...this._def,\n      unknownKeys: "passthrough"\n    });\n  }\n  extend(augmentation) {\n    return new ZodObject2({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation\n      })\n    });\n  }\n  merge(merging) {\n    const merged = new ZodObject2({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape()\n      }),\n      typeName: ZodFirstPartyTypeKind2.ZodObject\n    });\n    return merged;\n  }\n  setKey(key, schema) {\n    return this.augment({ [key]: schema });\n  }\n  catchall(index) {\n    return new ZodObject2({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(mask)) {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n    return new ZodObject2({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n    return new ZodObject2({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      const fieldSchema = this.shape[key];\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    }\n    return new ZodObject2({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n        while (newField instanceof ZodOptional2) {\n          newField = newField._def.innerType;\n        }\n        newShape[key] = newField;\n      }\n    }\n    return new ZodObject2({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n}\nZodObject2.create = (shape, params) => {\n  return new ZodObject2({\n    shape: () => shape,\n    unknownKeys: "strip",\n    catchall: ZodNever2.create(),\n    typeName: ZodFirstPartyTypeKind2.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject2.strictCreate = (shape, params) => {\n  return new ZodObject2({\n    shape: () => shape,\n    unknownKeys: "strict",\n    catchall: ZodNever2.create(),\n    typeName: ZodFirstPartyTypeKind2.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject2.lazycreate = (shape, params) => {\n  return new ZodObject2({\n    shape,\n    unknownKeys: "strip",\n    catchall: ZodNever2.create(),\n    typeName: ZodFirstPartyTypeKind2.ZodObject,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodUnion2 extends ZodType2 {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n    function handleResults(results) {\n      for (const result of results) {\n        if (result.result.status === "valid") {\n          return result.result;\n        }\n      }\n      for (const result of results) {\n        if (result.result.status === "dirty") {\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n      const unionErrors = results.map((result) => new ZodError2(result.ctx.common.issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return Promise.all(options.map(async (option) => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    } else {\n      let dirty = undefined;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result.status === "valid") {\n          return result;\n        } else if (result.status === "dirty" && !dirty) {\n          dirty = { result, ctx: childCtx };\n        }\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n      const unionErrors = issues.map((issues2) => new ZodError2(issues2));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n}\nZodUnion2.create = (types, params) => {\n  return new ZodUnion2({\n    options: types,\n    typeName: ZodFirstPartyTypeKind2.ZodUnion,\n    ...processCreateParams(params)\n  });\n};\nvar getDiscriminator = (type) => {\n  if (type instanceof ZodLazy2) {\n    return getDiscriminator(type.schema);\n  } else if (type instanceof ZodEffects) {\n    return getDiscriminator(type.innerType());\n  } else if (type instanceof ZodLiteral2) {\n    return [type.value];\n  } else if (type instanceof ZodEnum2) {\n    return type.options;\n  } else if (type instanceof ZodNativeEnum) {\n    return util.objectValues(type.enum);\n  } else if (type instanceof ZodDefault2) {\n    return getDiscriminator(type._def.innerType);\n  } else if (type instanceof ZodUndefined2) {\n    return [undefined];\n  } else if (type instanceof ZodNull2) {\n    return [null];\n  } else if (type instanceof ZodOptional2) {\n    return [undefined, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodNullable2) {\n    return [null, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodBranded) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodReadonly2) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodCatch2) {\n    return getDiscriminator(type._def.innerType);\n  } else {\n    return [];\n  }\n};\n\nclass ZodDiscriminatedUnion2 extends ZodType2 {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const discriminator = this.discriminator;\n    const discriminatorValue = ctx.data[discriminator];\n    const option = this.optionsMap.get(discriminatorValue);\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator]\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  static create(discriminator, options, params) {\n    const optionsMap = new Map;\n    for (const type of options) {\n      const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n      if (!discriminatorValues.length) {\n        throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n        optionsMap.set(value, type);\n      }\n    }\n    return new ZodDiscriminatedUnion2({\n      typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params)\n    });\n  }\n}\nfunction mergeValues2(a2, b) {\n  const aType = getParsedType2(a2);\n  const bType = getParsedType2(b);\n  if (a2 === b) {\n    return { valid: true, data: a2 };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b);\n    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a2, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues2(a2[key], b[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a2.length !== b.length) {\n      return { valid: false };\n    }\n    const newArray = [];\n    for (let index = 0;index < a2.length; index++) {\n      const itemA = a2[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues2(itemA, itemB);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {\n    return { valid: true, data: a2 };\n  } else {\n    return { valid: false };\n  }\n}\n\nclass ZodIntersection2 extends ZodType2 {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n      const merged = mergeValues2(parsedLeft.value, parsedRight.value);\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode2.invalid_intersection_types\n        });\n        return INVALID;\n      }\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n      return { status: status.value, value: merged.data };\n    };\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        })\n      ]).then(([left, right]) => handleParsed(left, right));\n    } else {\n      return handleParsed(this._def.left._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }));\n    }\n  }\n}\nZodIntersection2.create = (left, right, params) => {\n  return new ZodIntersection2({\n    left,\n    right,\n    typeName: ZodFirstPartyTypeKind2.ZodIntersection,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodTuple2 extends ZodType2 {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: "array"\n      });\n      return INVALID;\n    }\n    const rest = this._def.rest;\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: "array"\n      });\n      status.dirty();\n    }\n    const items = [...ctx.data].map((item, itemIndex) => {\n      const schema = this._def.items[itemIndex] || this._def.rest;\n      if (!schema)\n        return null;\n      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n    }).filter((x) => !!x);\n    if (ctx.common.async) {\n      return Promise.all(items).then((results) => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items);\n    }\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new ZodTuple2({\n      ...this._def,\n      rest\n    });\n  }\n}\nZodTuple2.create = (schemas3, params) => {\n  if (!Array.isArray(schemas3)) {\n    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");\n  }\n  return new ZodTuple2({\n    items: schemas3,\n    typeName: ZodFirstPartyTypeKind2.ZodTuple,\n    rest: null,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodRecord2 extends ZodType2 {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const pairs = [];\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    if (second instanceof ZodType2) {\n      return new ZodRecord2({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind2.ZodRecord,\n        ...processCreateParams(third)\n      });\n    }\n    return new ZodRecord2({\n      keyType: ZodString2.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind2.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n}\n\nclass ZodMap2 extends ZodType2 {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))\n      };\n    });\n    if (ctx.common.async) {\n      const finalMap = new Map;\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === "aborted" || value.status === "aborted") {\n            return INVALID;\n          }\n          if (key.status === "dirty" || value.status === "dirty") {\n            status.dirty();\n          }\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = new Map;\n      for (const pair of pairs) {\n        const key = pair.key;\n        const value = pair.value;\n        if (key.status === "aborted" || value.status === "aborted") {\n          return INVALID;\n        }\n        if (key.status === "dirty" || value.status === "dirty") {\n          status.dirty();\n        }\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n}\nZodMap2.create = (keyType, valueType, params) => {\n  return new ZodMap2({\n    valueType,\n    keyType,\n    typeName: ZodFirstPartyTypeKind2.ZodMap,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodSet2 extends ZodType2 {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const def = this._def;\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode2.too_small,\n          minimum: def.minSize.value,\n          type: "set",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode2.too_big,\n          maximum: def.maxSize.value,\n          type: "set",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message\n        });\n        status.dirty();\n      }\n    }\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = new Set;\n      for (const element of elements2) {\n        if (element.status === "aborted")\n          return INVALID;\n        if (element.status === "dirty")\n          status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements2) => finalizeSet(elements2));\n    } else {\n      return finalizeSet(elements);\n    }\n  }\n  min(minSize, message) {\n    return new ZodSet2({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxSize, message) {\n    return new ZodSet2({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) }\n    });\n  }\n  size(size, message) {\n    return this.min(size, message).max(size, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n}\nZodSet2.create = (valueType, params) => {\n  return new ZodSet2({\n    valueType,\n    minSize: null,\n    maxSize: null,\n    typeName: ZodFirstPartyTypeKind2.ZodSet,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodFunction2 extends ZodType2 {\n  constructor() {\n    super(...arguments);\n    this.validate = this.implement;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    function makeArgsIssue(args, error48) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode2.invalid_arguments,\n          argumentsError: error48\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error48) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode2.invalid_return_type,\n          returnTypeError: error48\n        }\n      });\n    }\n    const params = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n    if (this._def.returns instanceof ZodPromise2) {\n      const me = this;\n      return OK(async function(...args) {\n        const error48 = new ZodError2([]);\n        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {\n          error48.addIssue(makeArgsIssue(args, e2));\n          throw error48;\n        });\n        const result = await Reflect.apply(fn, this, parsedArgs);\n        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e2) => {\n          error48.addIssue(makeReturnsIssue(result, e2));\n          throw error48;\n        });\n        return parsedReturns;\n      });\n    } else {\n      const me = this;\n      return OK(function(...args) {\n        const parsedArgs = me._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError2([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = Reflect.apply(fn, this, parsedArgs.data);\n        const parsedReturns = me._def.returns.safeParse(result, params);\n        if (!parsedReturns.success) {\n          throw new ZodError2([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new ZodFunction2({\n      ...this._def,\n      args: ZodTuple2.create(items).rest(ZodUnknown2.create())\n    });\n  }\n  returns(returnType) {\n    return new ZodFunction2({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  strictImplement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  static create(args, returns, params) {\n    return new ZodFunction2({\n      args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),\n      returns: returns || ZodUnknown2.create(),\n      typeName: ZodFirstPartyTypeKind2.ZodFunction,\n      ...processCreateParams(params)\n    });\n  }\n}\n\nclass ZodLazy2 extends ZodType2 {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n}\nZodLazy2.create = (getter, params) => {\n  return new ZodLazy2({\n    getter,\n    typeName: ZodFirstPartyTypeKind2.ZodLazy,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodLiteral2 extends ZodType2 {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode2.invalid_literal,\n        expected: this._def.value\n      });\n      return INVALID;\n    }\n    return { status: "valid", value: input.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n}\nZodLiteral2.create = (value, params) => {\n  return new ZodLiteral2({\n    value,\n    typeName: ZodFirstPartyTypeKind2.ZodLiteral,\n    ...processCreateParams(params)\n  });\n};\nfunction createZodEnum(values, params) {\n  return new ZodEnum2({\n    values,\n    typeName: ZodFirstPartyTypeKind2.ZodEnum,\n    ...processCreateParams(params)\n  });\n}\n\nclass ZodEnum2 extends ZodType2 {\n  _parse(input) {\n    if (typeof input.data !== "string") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode2.invalid_type\n      });\n      return INVALID;\n    }\n    if (!this._cache) {\n      this._cache = new Set(this._def.values);\n    }\n    if (!this._cache.has(input.data)) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode2.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  extract(values, newDef = this._def) {\n    return ZodEnum2.create(values, {\n      ...this._def,\n      ...newDef\n    });\n  }\n  exclude(values, newDef = this._def) {\n    return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)), {\n      ...this._def,\n      ...newDef\n    });\n  }\n}\nZodEnum2.create = createZodEnum;\n\nclass ZodNativeEnum extends ZodType2 {\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode2.invalid_type\n      });\n      return INVALID;\n    }\n    if (!this._cache) {\n      this._cache = new Set(util.getValidEnumValues(this._def.values));\n    }\n    if (!this._cache.has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode2.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n}\nZodNativeEnum.create = (values, params) => {\n  return new ZodNativeEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodPromise2 extends ZodType2 {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then((data) => {\n      return this._def.type.parseAsync(data, {\n        path: ctx.path,\n        errorMap: ctx.common.contextualErrorMap\n      });\n    }));\n  }\n}\nZodPromise2.create = (schema, params) => {\n  return new ZodPromise2({\n    type: schema,\n    typeName: ZodFirstPartyTypeKind2.ZodPromise,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodEffects extends ZodType2 {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const effect = this._def.effect || null;\n    const checkCtx = {\n      addIssue: (arg) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n    if (effect.type === "preprocess") {\n      const processed = effect.transform(ctx.data, checkCtx);\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then(async (processed2) => {\n          if (status.value === "aborted")\n            return INVALID;\n          const result = await this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n          if (result.status === "aborted")\n            return INVALID;\n          if (result.status === "dirty")\n            return DIRTY(result.value);\n          if (status.value === "dirty")\n            return DIRTY(result.value);\n          return result;\n        });\n      } else {\n        if (status.value === "aborted")\n          return INVALID;\n        const result = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (result.status === "aborted")\n          return INVALID;\n        if (result.status === "dirty")\n          return DIRTY(result.value);\n        if (status.value === "dirty")\n          return DIRTY(result.value);\n        return result;\n      }\n    }\n    if (effect.type === "refinement") {\n      const executeRefinement = (acc) => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");\n        }\n        return acc;\n      };\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inner.status === "aborted")\n          return INVALID;\n        if (inner.status === "dirty")\n          status.dirty();\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === "aborted")\n            return INVALID;\n          if (inner.status === "dirty")\n            status.dirty();\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n    if (effect.type === "transform") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base))\n          return INVALID;\n        const result = effect.transform(base.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n        }\n        return { status: status.value, value: result };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n          if (!isValid(base))\n            return INVALID;\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n            status: status.value,\n            value: result\n          }));\n        });\n      }\n    }\n    util.assertNever(effect);\n  }\n}\nZodEffects.create = (schema, effect, params) => {\n  return new ZodEffects({\n    schema,\n    typeName: ZodFirstPartyTypeKind2.ZodEffects,\n    effect,\n    ...processCreateParams(params)\n  });\n};\nZodEffects.createWithPreprocess = (preprocess2, schema, params) => {\n  return new ZodEffects({\n    schema,\n    effect: { type: "preprocess", transform: preprocess2 },\n    typeName: ZodFirstPartyTypeKind2.ZodEffects,\n    ...processCreateParams(params)\n  });\n};\nclass ZodOptional2 extends ZodType2 {\n  _parse(input) {\n    const parsedType2 = this._getType(input);\n    if (parsedType2 === ZodParsedType.undefined) {\n      return OK(undefined);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nZodOptional2.create = (type, params) => {\n  return new ZodOptional2({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind2.ZodOptional,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNullable2 extends ZodType2 {\n  _parse(input) {\n    const parsedType2 = this._getType(input);\n    if (parsedType2 === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nZodNullable2.create = (type, params) => {\n  return new ZodNullable2({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind2.ZodNullable,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodDefault2 extends ZodType2 {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n}\nZodDefault2.create = (type, params) => {\n  return new ZodDefault2({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind2.ZodDefault,\n    defaultValue: typeof params.default === "function" ? params.default : () => params.default,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodCatch2 extends ZodType2 {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const newCtx = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: []\n      }\n    };\n    const result = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx\n      }\n    });\n    if (isAsync(result)) {\n      return result.then((result2) => {\n        return {\n          status: "valid",\n          value: result2.status === "valid" ? result2.value : this._def.catchValue({\n            get error() {\n              return new ZodError2(newCtx.common.issues);\n            },\n            input: newCtx.data\n          })\n        };\n      });\n    } else {\n      return {\n        status: "valid",\n        value: result.status === "valid" ? result.value : this._def.catchValue({\n          get error() {\n            return new ZodError2(newCtx.common.issues);\n          },\n          input: newCtx.data\n        })\n      };\n    }\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n}\nZodCatch2.create = (type, params) => {\n  return new ZodCatch2({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind2.ZodCatch,\n    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNaN2 extends ZodType2 {\n  _parse(input) {\n    const parsedType2 = this._getType(input);\n    if (parsedType2 !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode2.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return { status: "valid", value: input.data };\n  }\n}\nZodNaN2.create = (params) => {\n  return new ZodNaN2({\n    typeName: ZodFirstPartyTypeKind2.ZodNaN,\n    ...processCreateParams(params)\n  });\n};\nvar BRAND = Symbol("zod_brand");\n\nclass ZodBranded extends ZodType2 {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n}\n\nclass ZodPipeline extends ZodType2 {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inResult.status === "aborted")\n          return INVALID;\n        if (inResult.status === "dirty") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n      if (inResult.status === "aborted")\n        return INVALID;\n      if (inResult.status === "dirty") {\n        status.dirty();\n        return {\n          status: "dirty",\n          value: inResult.value\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n  }\n  static create(a2, b) {\n    return new ZodPipeline({\n      in: a2,\n      out: b,\n      typeName: ZodFirstPartyTypeKind2.ZodPipeline\n    });\n  }\n}\n\nclass ZodReadonly2 extends ZodType2 {\n  _parse(input) {\n    const result = this._def.innerType._parse(input);\n    const freeze = (data) => {\n      if (isValid(data)) {\n        data.value = Object.freeze(data.value);\n      }\n      return data;\n    };\n    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nZodReadonly2.create = (type, params) => {\n  return new ZodReadonly2({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind2.ZodReadonly,\n    ...processCreateParams(params)\n  });\n};\nvar late = {\n  object: ZodObject2.lazycreate\n};\nvar ZodFirstPartyTypeKind2;\n(function(ZodFirstPartyTypeKind3) {\n  ZodFirstPartyTypeKind3["ZodString"] = "ZodString";\n  ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";\n  ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";\n  ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";\n  ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";\n  ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";\n  ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";\n  ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";\n  ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";\n  ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";\n  ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";\n  ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";\n  ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";\n  ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";\n  ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";\n  ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";\n  ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";\n  ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";\n  ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";\n  ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";\n  ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";\n  ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";\n  ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";\n  ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";\n  ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";\n  ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";\n  ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";\n  ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";\n  ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";\n  ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";\n  ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";\n  ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";\n  ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";\n  ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";\n  ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";\n  ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";\n})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));\nvar stringType = ZodString2.create;\nvar numberType = ZodNumber2.create;\nvar nanType = ZodNaN2.create;\nvar bigIntType = ZodBigInt2.create;\nvar booleanType = ZodBoolean2.create;\nvar dateType = ZodDate2.create;\nvar symbolType = ZodSymbol2.create;\nvar undefinedType = ZodUndefined2.create;\nvar nullType = ZodNull2.create;\nvar anyType = ZodAny2.create;\nvar unknownType = ZodUnknown2.create;\nvar neverType = ZodNever2.create;\nvar voidType = ZodVoid2.create;\nvar arrayType = ZodArray2.create;\nvar objectType = ZodObject2.create;\nvar strictObjectType = ZodObject2.strictCreate;\nvar unionType = ZodUnion2.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion2.create;\nvar intersectionType = ZodIntersection2.create;\nvar tupleType = ZodTuple2.create;\nvar recordType = ZodRecord2.create;\nvar mapType = ZodMap2.create;\nvar setType = ZodSet2.create;\nvar functionType = ZodFunction2.create;\nvar lazyType = ZodLazy2.create;\nvar literalType = ZodLiteral2.create;\nvar enumType = ZodEnum2.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise2.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional2.create;\nvar nullableType = ZodNullable2.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar pipelineType = ZodPipeline.create;\n// ../../node_modules/@ai-sdk/provider-utils/dist/index.mjs\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",\n  separator = "-"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i2 = 0;i2 < size; i2++) {\n      chars[i2] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join("");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: "separator",\n      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\nfunction getErrorMessage2(error48) {\n  if (error48 == null) {\n    return "unknown error";\n  }\n  if (typeof error48 === "string") {\n    return error48;\n  }\n  if (error48 instanceof Error) {\n    return error48.message;\n  }\n  return JSON.stringify(error48);\n}\nvar suspectProtoRx = /"__proto__"\\s*:/;\nvar suspectConstructorRx = /"constructor"\\s*:/;\nfunction _parse2(text) {\n  const obj = JSON.parse(text);\n  if (obj === null || typeof obj !== "object") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {\n        throw new SyntaxError("Object contains forbidden prototype property");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {\n        throw new SyntaxError("Object contains forbidden prototype property");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === "object") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text) {\n  const { stackTraceLimit } = Error;\n  try {\n    Error.stackTraceLimit = 0;\n  } catch (e2) {\n    return _parse2(text);\n  }\n  try {\n    return _parse2(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nvar validatorSymbol = Symbol.for("vercel.ai.validator");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;\n}\nfunction lazyValidator(createValidator) {\n  let validator2;\n  return () => {\n    if (validator2 == null) {\n      validator2 = createValidator();\n    }\n    return validator2;\n  };\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : typeof value === "function" ? value() : standardSchemaValidator(value);\n}\nfunction standardSchemaValidator(standardSchema) {\n  return validator(async (value) => {\n    const result = await standardSchema["~standard"].validate(value);\n    return result.issues == null ? { success: true, value: result.value } : {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\nasync function validateTypes({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes({ value, schema });\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const result = await validator2.validate(value);\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n      rawValue: value\n    };\n  } catch (error48) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error48 }),\n      rawValue: value\n    };\n  }\n}\nasync function safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    return await safeValidateTypes({ value, schema });\n  } catch (error48) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error48) ? error48 : new JSONParseError({ text, cause: error48 }),\n      rawValue: undefined\n    };\n  }\n}\nvar getRelativePath = (pathA, pathB) => {\n  let i2 = 0;\n  for (;i2 < pathA.length && i2 < pathB.length; i2++) {\n    if (pathA[i2] !== pathB[i2])\n      break;\n  }\n  return [(pathA.length - i2).toString(), ...pathB.slice(i2)].join("/");\n};\nvar ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");\nvar defaultOptions = {\n  name: undefined,\n  $refStrategy: "root",\n  basePath: ["#"],\n  effectStrategy: "input",\n  pipeStrategy: "all",\n  dateStrategy: "format:date-time",\n  mapStrategy: "entries",\n  removeAdditionalStrategy: "passthrough",\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: "definitions",\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  patternStrategy: "escape",\n  applyRegexFlags: false,\n  emailStrategy: "format:email",\n  base64Strategy: "contentEncoding:base64",\n  nameStrategy: "ref"\n};\nvar getDefaultOptions = (options) => typeof options === "string" ? {\n  ...defaultOptions,\n  name: options\n} : {\n  ...defaultOptions,\n  ...options\n};\nfunction parseAnyDef() {\n  return {};\n}\nfunction parseArrayDef(def, refs) {\n  var _a16, _b, _c;\n  const res = {\n    type: "array"\n  };\n  if (((_a16 = def.type) == null ? undefined : _a16._def) && ((_c = (_b = def.type) == null ? undefined : _b._def) == null ? undefined : _c.typeName) !== ZodFirstPartyTypeKind2.ZodAny) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "items"]\n    });\n  }\n  if (def.minLength) {\n    res.minItems = def.minLength.value;\n  }\n  if (def.maxLength) {\n    res.maxItems = def.maxLength.value;\n  }\n  if (def.exactLength) {\n    res.minItems = def.exactLength.value;\n    res.maxItems = def.exactLength.value;\n  }\n  return res;\n}\nfunction parseBigintDef(def) {\n  const res = {\n    type: "integer",\n    format: "int64"\n  };\n  if (!def.checks)\n    return res;\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case "min":\n        if (check2.inclusive) {\n          res.minimum = check2.value;\n        } else {\n          res.exclusiveMinimum = check2.value;\n        }\n        break;\n      case "max":\n        if (check2.inclusive) {\n          res.maximum = check2.value;\n        } else {\n          res.exclusiveMaximum = check2.value;\n        }\n        break;\n      case "multipleOf":\n        res.multipleOf = check2.value;\n        break;\n    }\n  }\n  return res;\n}\nfunction parseBooleanDef() {\n  return { type: "boolean" };\n}\nfunction parseBrandedDef(_def, refs) {\n  return parseDef(_def.type._def, refs);\n}\nvar parseCatchDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\nfunction parseDateDef(def, refs, overrideDateStrategy) {\n  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item))\n    };\n  }\n  switch (strategy) {\n    case "string":\n    case "format:date-time":\n      return {\n        type: "string",\n        format: "date-time"\n      };\n    case "format:date":\n      return {\n        type: "string",\n        format: "date"\n      };\n    case "integer":\n      return integerDateParser(def);\n  }\n}\nvar integerDateParser = (def) => {\n  const res = {\n    type: "integer",\n    format: "unix-time"\n  };\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case "min":\n        res.minimum = check2.value;\n        break;\n      case "max":\n        res.maximum = check2.value;\n        break;\n    }\n  }\n  return res;\n};\nfunction parseDefaultDef(_def, refs) {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue()\n  };\n}\nfunction parseEffectsDef(_def, refs) {\n  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();\n}\nfunction parseEnumDef(def) {\n  return {\n    type: "string",\n    enum: Array.from(def.values)\n  };\n}\nvar isJsonSchema7AllOfType = (type) => {\n  if ("type" in type && type.type === "string")\n    return false;\n  return "allOf" in type;\n};\nfunction parseIntersectionDef(def, refs) {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "allOf", "0"]\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "allOf", "1"]\n    })\n  ].filter((x) => !!x);\n  const mergedAllOf = [];\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n    } else {\n      let nestedSchema = schema;\n      if ("additionalProperties" in schema && schema.additionalProperties === false) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? { allOf: mergedAllOf } : undefined;\n}\nfunction parseLiteralDef(def) {\n  const parsedType2 = typeof def.value;\n  if (parsedType2 !== "bigint" && parsedType2 !== "number" && parsedType2 !== "boolean" && parsedType2 !== "string") {\n    return {\n      type: Array.isArray(def.value) ? "array" : "object"\n    };\n  }\n  return {\n    type: parsedType2 === "bigint" ? "integer" : parsedType2,\n    const: def.value\n  };\n}\nvar emojiRegex2 = undefined;\nvar zodPatterns = {\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_\'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  emoji: () => {\n    if (emojiRegex2 === undefined) {\n      emojiRegex2 = RegExp("^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$", "u");\n    }\n    return emojiRegex2;\n  },\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/\n};\nfunction parseStringDef(def, refs) {\n  const res = {\n    type: "string"\n  };\n  if (def.checks) {\n    for (const check2 of def.checks) {\n      switch (check2.kind) {\n        case "min":\n          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;\n          break;\n        case "max":\n          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;\n          break;\n        case "email":\n          switch (refs.emailStrategy) {\n            case "format:email":\n              addFormat(res, "email", check2.message, refs);\n              break;\n            case "format:idn-email":\n              addFormat(res, "idn-email", check2.message, refs);\n              break;\n            case "pattern:zod":\n              addPattern(res, zodPatterns.email, check2.message, refs);\n              break;\n          }\n          break;\n        case "url":\n          addFormat(res, "uri", check2.message, refs);\n          break;\n        case "uuid":\n          addFormat(res, "uuid", check2.message, refs);\n          break;\n        case "regex":\n          addPattern(res, check2.regex, check2.message, refs);\n          break;\n        case "cuid":\n          addPattern(res, zodPatterns.cuid, check2.message, refs);\n          break;\n        case "cuid2":\n          addPattern(res, zodPatterns.cuid2, check2.message, refs);\n          break;\n        case "startsWith":\n          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`), check2.message, refs);\n          break;\n        case "endsWith":\n          addPattern(res, RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`), check2.message, refs);\n          break;\n        case "datetime":\n          addFormat(res, "date-time", check2.message, refs);\n          break;\n        case "date":\n          addFormat(res, "date", check2.message, refs);\n          break;\n        case "time":\n          addFormat(res, "time", check2.message, refs);\n          break;\n        case "duration":\n          addFormat(res, "duration", check2.message, refs);\n          break;\n        case "length":\n          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;\n          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;\n          break;\n        case "includes": {\n          addPattern(res, RegExp(escapeLiteralCheckValue(check2.value, refs)), check2.message, refs);\n          break;\n        }\n        case "ip": {\n          if (check2.version !== "v6") {\n            addFormat(res, "ipv4", check2.message, refs);\n          }\n          if (check2.version !== "v4") {\n            addFormat(res, "ipv6", check2.message, refs);\n          }\n          break;\n        }\n        case "base64url":\n          addPattern(res, zodPatterns.base64url, check2.message, refs);\n          break;\n        case "jwt":\n          addPattern(res, zodPatterns.jwt, check2.message, refs);\n          break;\n        case "cidr": {\n          if (check2.version !== "v6") {\n            addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);\n          }\n          if (check2.version !== "v4") {\n            addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);\n          }\n          break;\n        }\n        case "emoji":\n          addPattern(res, zodPatterns.emoji(), check2.message, refs);\n          break;\n        case "ulid": {\n          addPattern(res, zodPatterns.ulid, check2.message, refs);\n          break;\n        }\n        case "base64": {\n          switch (refs.base64Strategy) {\n            case "format:binary": {\n              addFormat(res, "binary", check2.message, refs);\n              break;\n            }\n            case "contentEncoding:base64": {\n              res.contentEncoding = "base64";\n              break;\n            }\n            case "pattern:zod": {\n              addPattern(res, zodPatterns.base64, check2.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case "nanoid": {\n          addPattern(res, zodPatterns.nanoid, check2.message, refs);\n        }\n        case "toLowerCase":\n        case "toUpperCase":\n        case "trim":\n          break;\n        default:\n      }\n    }\n  }\n  return res;\n}\nfunction escapeLiteralCheckValue(literal2, refs) {\n  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal2) : literal2;\n}\nvar ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");\nfunction escapeNonAlphaNumeric(source) {\n  let result = "";\n  for (let i2 = 0;i2 < source.length; i2++) {\n    if (!ALPHA_NUMERIC.has(source[i2])) {\n      result += "\\\\";\n    }\n    result += source[i2];\n  }\n  return result;\n}\nfunction addFormat(schema, value, message, refs) {\n  var _a16;\n  if (schema.format || ((_a16 = schema.anyOf) == null ? undefined : _a16.some((x) => x.format))) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format\n      });\n      delete schema.format;\n    }\n    schema.anyOf.push({\n      format: value,\n      ...message && refs.errorMessages && { errorMessage: { format: message } }\n    });\n  } else {\n    schema.format = value;\n  }\n}\nfunction addPattern(schema, regex, message, refs) {\n  var _a16;\n  if (schema.pattern || ((_a16 = schema.allOf) == null ? undefined : _a16.some((x) => x.pattern))) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern\n      });\n      delete schema.pattern;\n    }\n    schema.allOf.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...message && refs.errorMessages && { errorMessage: { pattern: message } }\n    });\n  } else {\n    schema.pattern = stringifyRegExpWithFlags(regex, refs);\n  }\n}\nfunction stringifyRegExpWithFlags(regex, refs) {\n  var _a16;\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n  const flags = {\n    i: regex.flags.includes("i"),\n    m: regex.flags.includes("m"),\n    s: regex.flags.includes("s")\n  };\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = "";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i2 = 0;i2 < source.length; i2++) {\n    if (isEscaped) {\n      pattern += source[i2];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i2].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i2];\n            pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i2 + 1] === "-" && ((_a16 = source[i2 + 2]) == null ? undefined : _a16.match(/[a-z]/))) {\n            pattern += source[i2];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i2]}${source[i2].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i2].match(/[a-z]/)) {\n        pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i2] === "^") {\n        pattern += `(^|(?<=[\\r\n]))`;\n        continue;\n      } else if (source[i2] === "$") {\n        pattern += `($|(?=[\\r\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i2] === ".") {\n      pattern += inCharGroup ? `${source[i2]}\\r\n` : `[${source[i2]}\\r\n]`;\n      continue;\n    }\n    pattern += source[i2];\n    if (source[i2] === "\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i2] === "]") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i2] === "[") {\n      inCharGroup = true;\n    }\n  }\n  try {\n    new RegExp(pattern);\n  } catch (e2) {\n    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);\n    return regex.source;\n  }\n  return pattern;\n}\nfunction parseRecordDef(def, refs) {\n  var _a16, _b, _c, _d, _e, _f;\n  const schema = {\n    type: "object",\n    additionalProperties: (_a16 = parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "additionalProperties"]\n    })) != null ? _a16 : refs.allowedAdditionalProperties\n  };\n  if (((_b = def.keyType) == null ? undefined : _b._def.typeName) === ZodFirstPartyTypeKind2.ZodString && ((_c = def.keyType._def.checks) == null ? undefined : _c.length)) {\n    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  } else if (((_d = def.keyType) == null ? undefined : _d._def.typeName) === ZodFirstPartyTypeKind2.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values\n      }\n    };\n  } else if (((_e = def.keyType) == null ? undefined : _e._def.typeName) === ZodFirstPartyTypeKind2.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind2.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? undefined : _f.length)) {\n    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  }\n  return schema;\n}\nfunction parseMapDef(def, refs) {\n  if (refs.mapStrategy === "record") {\n    return parseRecordDef(def, refs);\n  }\n  const keys = parseDef(def.keyType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "items", "items", "0"]\n  }) || parseAnyDef();\n  const values = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "items", "items", "1"]\n  }) || parseAnyDef();\n  return {\n    type: "array",\n    maxItems: 125,\n    items: {\n      type: "array",\n      items: [keys, values],\n      minItems: 2,\n      maxItems: 2\n    }\n  };\n}\nfunction parseNativeEnumDef(def) {\n  const object2 = def.values;\n  const actualKeys = Object.keys(def.values).filter((key) => {\n    return typeof object2[object2[key]] !== "number";\n  });\n  const actualValues = actualKeys.map((key) => object2[key]);\n  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n  return {\n    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],\n    enum: actualValues\n  };\n}\nfunction parseNeverDef() {\n  return { not: parseAnyDef() };\n}\nfunction parseNullDef() {\n  return {\n    type: "null"\n  };\n}\nvar primitiveMappings = {\n  ZodString: "string",\n  ZodNumber: "number",\n  ZodBigInt: "integer",\n  ZodBoolean: "boolean",\n  ZodNull: "null"\n};\nfunction parseUnionDef(def, refs) {\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  if (options.every((x) => (x._def.typeName in primitiveMappings) && (!x._def.checks || !x._def.checks.length))) {\n    const types = options.reduce((types2, x) => {\n      const type = primitiveMappings[x._def.typeName];\n      return type && !types2.includes(type) ? [...types2, type] : types2;\n    }, []);\n    return {\n      type: types.length > 1 ? types : types[0]\n    };\n  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {\n    const types = options.reduce((acc, x) => {\n      const type = typeof x._def.value;\n      switch (type) {\n        case "string":\n        case "number":\n        case "boolean":\n          return [...acc, type];\n        case "bigint":\n          return [...acc, "integer"];\n        case "object":\n          if (x._def.value === null)\n            return [...acc, "null"];\n        case "symbol":\n        case "undefined":\n        case "function":\n        default:\n          return acc;\n      }\n    }, []);\n    if (types.length === options.length) {\n      const uniqueTypes = types.filter((x, i2, a2) => a2.indexOf(x) === i2);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce((acc, x) => {\n          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n        }, [])\n      };\n    }\n  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {\n    return {\n      type: "string",\n      enum: options.reduce((acc, x) => [\n        ...acc,\n        ...x._def.values.filter((x2) => !acc.includes(x2))\n      ], [])\n    };\n  }\n  return asAnyOf(def, refs);\n}\nvar asAnyOf = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i2) => parseDef(x._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "anyOf", `${i2}`]\n  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));\n  return anyOf.length ? { anyOf } : undefined;\n};\nfunction parseNullableDef(def, refs) {\n  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n    return {\n      type: [\n        primitiveMappings[def.innerType._def.typeName],\n        "null"\n      ]\n    };\n  }\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "anyOf", "0"]\n  });\n  return base && { anyOf: [base, { type: "null" }] };\n}\nfunction parseNumberDef(def) {\n  const res = {\n    type: "number"\n  };\n  if (!def.checks)\n    return res;\n  for (const check2 of def.checks) {\n    switch (check2.kind) {\n      case "int":\n        res.type = "integer";\n        break;\n      case "min":\n        if (check2.inclusive) {\n          res.minimum = check2.value;\n        } else {\n          res.exclusiveMinimum = check2.value;\n        }\n        break;\n      case "max":\n        if (check2.inclusive) {\n          res.maximum = check2.value;\n        } else {\n          res.exclusiveMaximum = check2.value;\n        }\n        break;\n      case "multipleOf":\n        res.multipleOf = check2.value;\n        break;\n    }\n  }\n  return res;\n}\nfunction parseObjectDef(def, refs) {\n  const result = {\n    type: "object",\n    properties: {}\n  };\n  const required2 = [];\n  const shape = def.shape();\n  for (const propName in shape) {\n    let propDef = shape[propName];\n    if (propDef === undefined || propDef._def === undefined) {\n      continue;\n    }\n    const propOptional = safeIsOptional(propDef);\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "properties", propName],\n      propertyPath: [...refs.currentPath, "properties", propName]\n    });\n    if (parsedDef === undefined) {\n      continue;\n    }\n    result.properties[propName] = parsedDef;\n    if (!propOptional) {\n      required2.push(propName);\n    }\n  }\n  if (required2.length) {\n    result.required = required2;\n  }\n  const additionalProperties = decideAdditionalProperties(def, refs);\n  if (additionalProperties !== undefined) {\n    result.additionalProperties = additionalProperties;\n  }\n  return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n  if (def.catchall._def.typeName !== "ZodNever") {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, "additionalProperties"]\n    });\n  }\n  switch (def.unknownKeys) {\n    case "passthrough":\n      return refs.allowedAdditionalProperties;\n    case "strict":\n      return refs.rejectedAdditionalProperties;\n    case "strip":\n      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;\n  }\n}\nfunction safeIsOptional(schema) {\n  try {\n    return schema.isOptional();\n  } catch (e2) {\n    return true;\n  }\n}\nvar parseOptionalDef = (def, refs) => {\n  var _a16;\n  if (refs.currentPath.toString() === ((_a16 = refs.propertyPath) == null ? undefined : _a16.toString())) {\n    return parseDef(def.innerType._def, refs);\n  }\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "anyOf", "1"]\n  });\n  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();\n};\nvar parsePipelineDef = (def, refs) => {\n  if (refs.pipeStrategy === "input") {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === "output") {\n    return parseDef(def.out._def, refs);\n  }\n  const a2 = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "allOf", "0"]\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"]\n  });\n  return {\n    allOf: [a2, b].filter((x) => x !== undefined)\n  };\n};\nfunction parsePromiseDef(def, refs) {\n  return parseDef(def.type._def, refs);\n}\nfunction parseSetDef(def, refs) {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, "items"]\n  });\n  const schema = {\n    type: "array",\n    uniqueItems: true,\n    items\n  };\n  if (def.minSize) {\n    schema.minItems = def.minSize.value;\n  }\n  if (def.maxSize) {\n    schema.maxItems = def.maxSize.value;\n  }\n  return schema;\n}\nfunction parseTupleDef(def, refs) {\n  if (def.rest) {\n    return {\n      type: "array",\n      minItems: def.items.length,\n      items: def.items.map((x, i2) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, "items", `${i2}`]\n      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], []),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, "additionalItems"]\n      })\n    };\n  } else {\n    return {\n      type: "array",\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items.map((x, i2) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, "items", `${i2}`]\n      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], [])\n    };\n  }\n}\nfunction parseUndefinedDef() {\n  return {\n    not: parseAnyDef()\n  };\n}\nfunction parseUnknownDef() {\n  return parseAnyDef();\n}\nvar parseReadonlyDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\nvar selectParser = (def, typeName, refs) => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind2.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodNumber:\n      return parseNumberDef(def);\n    case ZodFirstPartyTypeKind2.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodBigInt:\n      return parseBigintDef(def);\n    case ZodFirstPartyTypeKind2.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind2.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodUndefined:\n      return parseUndefinedDef();\n    case ZodFirstPartyTypeKind2.ZodNull:\n      return parseNullDef();\n    case ZodFirstPartyTypeKind2.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodUnion:\n    case ZodFirstPartyTypeKind2.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodLiteral:\n      return parseLiteralDef(def);\n    case ZodFirstPartyTypeKind2.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind2.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind2.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodLazy:\n      return () => def.getter()._def;\n    case ZodFirstPartyTypeKind2.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodNaN:\n    case ZodFirstPartyTypeKind2.ZodNever:\n      return parseNeverDef();\n    case ZodFirstPartyTypeKind2.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodAny:\n      return parseAnyDef();\n    case ZodFirstPartyTypeKind2.ZodUnknown:\n      return parseUnknownDef();\n    case ZodFirstPartyTypeKind2.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind2.ZodFunction:\n    case ZodFirstPartyTypeKind2.ZodVoid:\n    case ZodFirstPartyTypeKind2.ZodSymbol:\n      return;\n    default:\n      return /* @__PURE__ */ ((_) => {\n        return;\n      })(typeName);\n  }\n};\nfunction parseDef(def, refs, forceResolution = false) {\n  var _a16;\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = (_a16 = refs.override) == null ? undefined : _a16.call(refs, def, refs, seenItem, forceResolution);\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== undefined) {\n      return seenSchema;\n    }\n  }\n  const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n  const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema2) {\n    addMeta(def, refs, jsonSchema2);\n  }\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);\n    newItem.jsonSchema = jsonSchema2;\n    return postProcessResult;\n  }\n  newItem.jsonSchema = jsonSchema2;\n  return jsonSchema2;\n}\nvar get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case "root":\n      return { $ref: item.path.join("/") };\n    case "relative":\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case "none":\n    case "seen": {\n      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);\n        return parseAnyDef();\n      }\n      return refs.$refStrategy === "seen" ? parseAnyDef() : undefined;\n    }\n  }\n};\nvar addMeta = (def, refs, jsonSchema2) => {\n  if (def.description) {\n    jsonSchema2.description = def.description;\n  }\n  return jsonSchema2;\n};\nvar getRefs = (options) => {\n  const _options = getDefaultOptions(options);\n  const currentPath = _options.name !== undefined ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;\n  return {\n    ..._options,\n    currentPath,\n    propertyPath: undefined,\n    seen: new Map(Object.entries(_options.definitions).map(([name14, def]) => [\n      def._def,\n      {\n        def: def._def,\n        path: [..._options.basePath, _options.definitionPath, name14],\n        jsonSchema: undefined\n      }\n    ]))\n  };\n};\nvar zodToJsonSchema = (schema, options) => {\n  var _a16;\n  const refs = getRefs(options);\n  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name22, schema2]) => {\n    var _a22;\n    return {\n      ...acc,\n      [name22]: (_a22 = parseDef(schema2._def, {\n        ...refs,\n        currentPath: [...refs.basePath, refs.definitionPath, name22]\n      }, true)) != null ? _a22 : parseAnyDef()\n    };\n  }, {}) : undefined;\n  const name14 = typeof options === "string" ? options : (options == null ? undefined : options.nameStrategy) === "title" ? undefined : options == null ? undefined : options.name;\n  const main = (_a16 = parseDef(schema._def, name14 === undefined ? refs : {\n    ...refs,\n    currentPath: [...refs.basePath, refs.definitionPath, name14]\n  }, false)) != null ? _a16 : parseAnyDef();\n  const title = typeof options === "object" && options.name !== undefined && options.nameStrategy === "title" ? options.name : undefined;\n  if (title !== undefined) {\n    main.title = title;\n  }\n  const combined = name14 === undefined ? definitions ? {\n    ...main,\n    [refs.definitionPath]: definitions\n  } : main : {\n    $ref: [\n      ...refs.$refStrategy === "relative" ? [] : refs.basePath,\n      refs.definitionPath,\n      name14\n    ].join("/"),\n    [refs.definitionPath]: {\n      ...definitions,\n      [name14]: main\n    }\n  };\n  combined.$schema = "http://json-schema.org/draft-07/schema#";\n  return combined;\n};\nvar zod_to_json_schema_default = zodToJsonSchema;\nfunction zod3Schema(zodSchema2, options) {\n  var _a16;\n  const useReferences = (_a16 = options == null ? undefined : options.useReferences) != null ? _a16 : false;\n  return jsonSchema(() => zod_to_json_schema_default(zodSchema2, {\n    $refStrategy: useReferences ? "root" : "none"\n  }), {\n    validate: async (value) => {\n      const result = await zodSchema2.safeParseAsync(value);\n      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n    }\n  });\n}\nfunction zod4Schema(zodSchema2, options) {\n  var _a16;\n  const useReferences = (_a16 = options == null ? undefined : options.useReferences) != null ? _a16 : false;\n  return jsonSchema(() => toJSONSchema(zodSchema2, {\n    target: "draft-7",\n    io: "output",\n    reused: useReferences ? "ref" : "inline"\n  }), {\n    validate: async (value) => {\n      const result = await safeParseAsync2(zodSchema2, value);\n      return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n    }\n  });\n}\nfunction isZod4Schema(zodSchema2) {\n  return "_zod" in zodSchema2;\n}\nfunction zodSchema(zodSchema2, options) {\n  if (isZod4Schema(zodSchema2)) {\n    return zod4Schema(zodSchema2, options);\n  } else {\n    return zod3Schema(zodSchema2, options);\n  }\n}\nvar schemaSymbol = Symbol.for("vercel.ai.schema");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: undefined,\n    [validatorSymbol]: true,\n    get jsonSchema() {\n      if (typeof jsonSchema2 === "function") {\n        jsonSchema2 = jsonSchema2();\n      }\n      return jsonSchema2;\n    },\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;\n}\nfunction asSchema(schema) {\n  return schema == null ? jsonSchema({\n    properties: {},\n    additionalProperties: false\n  }) : isSchema(schema) ? schema : typeof schema === "function" ? schema() : zodSchema(schema);\n}\n\n// ../../node_modules/ai/dist/index.mjs\nvar __defProp2 = Object.defineProperty;\nvar __export2 = (target, all) => {\n  for (var name16 in all)\n    __defProp2(target, name16, { get: all[name16], enumerable: true });\n};\nvar name14 = "AI_NoOutputSpecifiedError";\nvar marker15 = `vercel.ai.error.${name14}`;\nvar symbol17 = Symbol.for(marker15);\nvar _a17;\n_a17 = symbol17;\nvar name22 = "AI_InvalidArgumentError";\nvar marker22 = `vercel.ai.error.${name22}`;\nvar symbol22 = Symbol.for(marker22);\nvar _a22;\n_a22 = symbol22;\nvar name32 = "AI_InvalidStreamPartError";\nvar marker32 = `vercel.ai.error.${name32}`;\nvar symbol32 = Symbol.for(marker32);\nvar _a32;\n_a32 = symbol32;\nvar name42 = "AI_InvalidToolInputError";\nvar marker42 = `vercel.ai.error.${name42}`;\nvar symbol42 = Symbol.for(marker42);\nvar _a42;\n_a42 = symbol42;\nvar name52 = "AI_NoImageGeneratedError";\nvar marker52 = `vercel.ai.error.${name52}`;\nvar symbol52 = Symbol.for(marker52);\nvar _a52;\n_a52 = symbol52;\nvar name62 = "AI_NoObjectGeneratedError";\nvar marker62 = `vercel.ai.error.${name62}`;\nvar symbol62 = Symbol.for(marker62);\nvar _a62;\nvar NoObjectGeneratedError = class extends AISDKError {\n  constructor({\n    message = "No object generated.",\n    cause,\n    text: text2,\n    response,\n    usage,\n    finishReason\n  }) {\n    super({ name: name62, message, cause });\n    this[_a62] = true;\n    this.text = text2;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n  static isInstance(error48) {\n    return AISDKError.hasMarker(error48, marker62);\n  }\n};\n_a62 = symbol62;\nvar name72 = "AI_NoOutputGeneratedError";\nvar marker72 = `vercel.ai.error.${name72}`;\nvar symbol72 = Symbol.for(marker72);\nvar _a72;\n_a72 = symbol72;\nvar name82 = "AI_NoSuchToolError";\nvar marker82 = `vercel.ai.error.${name82}`;\nvar symbol82 = Symbol.for(marker82);\nvar _a82;\n_a82 = symbol82;\nvar name92 = "AI_ToolCallRepairError";\nvar marker92 = `vercel.ai.error.${name92}`;\nvar symbol92 = Symbol.for(marker92);\nvar _a92;\n_a92 = symbol92;\nvar name102 = "AI_InvalidDataContentError";\nvar marker102 = `vercel.ai.error.${name102}`;\nvar symbol102 = Symbol.for(marker102);\nvar _a102;\n_a102 = symbol102;\nvar name112 = "AI_InvalidMessageRoleError";\nvar marker112 = `vercel.ai.error.${name112}`;\nvar symbol112 = Symbol.for(marker112);\nvar _a112;\n_a112 = symbol112;\nvar name122 = "AI_MessageConversionError";\nvar marker122 = `vercel.ai.error.${name122}`;\nvar symbol122 = Symbol.for(marker122);\nvar _a122;\nvar MessageConversionError = class extends AISDKError {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name122, message });\n    this[_a122] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error48) {\n    return AISDKError.hasMarker(error48, marker122);\n  }\n};\n_a122 = symbol122;\nvar name132 = "AI_DownloadError";\nvar marker132 = `vercel.ai.error.${name132}`;\nvar symbol132 = Symbol.for(marker132);\nvar _a132;\n_a132 = symbol132;\nvar name142 = "AI_RetryError";\nvar marker142 = `vercel.ai.error.${name142}`;\nvar symbol142 = Symbol.for(marker142);\nvar _a142;\n_a142 = symbol142;\nvar dataContentSchema = exports_external.union([\n  exports_external.string(),\n  exports_external.instanceof(Uint8Array),\n  exports_external.instanceof(ArrayBuffer),\n  exports_external.custom((value) => {\n    var _a16, _b;\n    return (_b = (_a16 = globalThis.Buffer) == null ? undefined : _a16.isBuffer(value)) != null ? _b : false;\n  }, { message: "Must be a Buffer" })\n]);\nvar jsonValueSchema = exports_external.lazy(() => exports_external.union([\n  exports_external.null(),\n  exports_external.string(),\n  exports_external.number(),\n  exports_external.boolean(),\n  exports_external.record(exports_external.string(), jsonValueSchema),\n  exports_external.array(jsonValueSchema)\n]));\nvar providerMetadataSchema = exports_external.record(exports_external.string(), exports_external.record(exports_external.string(), jsonValueSchema));\nvar textPartSchema = exports_external.object({\n  type: exports_external.literal("text"),\n  text: exports_external.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = exports_external.object({\n  type: exports_external.literal("image"),\n  image: exports_external.union([dataContentSchema, exports_external.instanceof(URL)]),\n  mediaType: exports_external.string().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = exports_external.object({\n  type: exports_external.literal("file"),\n  data: exports_external.union([dataContentSchema, exports_external.instanceof(URL)]),\n  filename: exports_external.string().optional(),\n  mediaType: exports_external.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = exports_external.object({\n  type: exports_external.literal("reasoning"),\n  text: exports_external.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = exports_external.object({\n  type: exports_external.literal("tool-call"),\n  toolCallId: exports_external.string(),\n  toolName: exports_external.string(),\n  input: exports_external.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  providerExecuted: exports_external.boolean().optional()\n});\nvar outputSchema = exports_external.discriminatedUnion("type", [\n  exports_external.object({\n    type: exports_external.literal("text"),\n    value: exports_external.string()\n  }),\n  exports_external.object({\n    type: exports_external.literal("json"),\n    value: jsonValueSchema\n  }),\n  exports_external.object({\n    type: exports_external.literal("error-text"),\n    value: exports_external.string()\n  }),\n  exports_external.object({\n    type: exports_external.literal("error-json"),\n    value: jsonValueSchema\n  }),\n  exports_external.object({\n    type: exports_external.literal("content"),\n    value: exports_external.array(exports_external.union([\n      exports_external.object({\n        type: exports_external.literal("text"),\n        text: exports_external.string()\n      }),\n      exports_external.object({\n        type: exports_external.literal("media"),\n        data: exports_external.string(),\n        mediaType: exports_external.string()\n      })\n    ]))\n  })\n]);\nvar toolResultPartSchema = exports_external.object({\n  type: exports_external.literal("tool-result"),\n  toolCallId: exports_external.string(),\n  toolName: exports_external.string(),\n  output: outputSchema,\n  providerOptions: providerMetadataSchema.optional()\n});\nvar systemModelMessageSchema = exports_external.object({\n  role: exports_external.literal("system"),\n  content: exports_external.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar userModelMessageSchema = exports_external.object({\n  role: exports_external.literal("user"),\n  content: exports_external.union([\n    exports_external.string(),\n    exports_external.array(exports_external.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar assistantModelMessageSchema = exports_external.object({\n  role: exports_external.literal("assistant"),\n  content: exports_external.union([\n    exports_external.string(),\n    exports_external.array(exports_external.union([\n      textPartSchema,\n      filePartSchema,\n      reasoningPartSchema,\n      toolCallPartSchema,\n      toolResultPartSchema\n    ]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolModelMessageSchema = exports_external.object({\n  role: exports_external.literal("tool"),\n  content: exports_external.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar modelMessageSchema = exports_external.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema\n]);\nfunction createToolModelOutput({\n  output,\n  tool: tool2,\n  errorMode\n}) {\n  if (errorMode === "text") {\n    return { type: "error-text", value: getErrorMessage(output) };\n  } else if (errorMode === "json") {\n    return { type: "error-json", value: toJSONValue(output) };\n  }\n  if (tool2 == null ? undefined : tool2.toModelOutput) {\n    return tool2.toModelOutput(output);\n  }\n  return typeof output === "string" ? { type: "text", value: output } : { type: "json", value: toJSONValue(output) };\n}\nfunction toJSONValue(value) {\n  return value === undefined ? null : value;\n}\nvar originalGenerateId = createIdGenerator({\n  prefix: "aitxt",\n  size: 24\n});\nvar JsonToSseTransformStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(part, controller) {\n        controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n      },\n      flush(controller) {\n        controller.enqueue(`data: [DONE]\n\n`);\n      }\n    });\n  }\n};\nvar uiMessageChunkSchema = lazyValidator(() => zodSchema(exports_external.union([\n  exports_external.strictObject({\n    type: exports_external.literal("text-start"),\n    id: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("text-delta"),\n    id: exports_external.string(),\n    delta: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("text-end"),\n    id: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("error"),\n    errorText: exports_external.string()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-input-start"),\n    toolCallId: exports_external.string(),\n    toolName: exports_external.string(),\n    providerExecuted: exports_external.boolean().optional(),\n    dynamic: exports_external.boolean().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-input-delta"),\n    toolCallId: exports_external.string(),\n    inputTextDelta: exports_external.string()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-input-available"),\n    toolCallId: exports_external.string(),\n    toolName: exports_external.string(),\n    input: exports_external.unknown(),\n    providerExecuted: exports_external.boolean().optional(),\n    providerMetadata: providerMetadataSchema.optional(),\n    dynamic: exports_external.boolean().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-input-error"),\n    toolCallId: exports_external.string(),\n    toolName: exports_external.string(),\n    input: exports_external.unknown(),\n    providerExecuted: exports_external.boolean().optional(),\n    providerMetadata: providerMetadataSchema.optional(),\n    dynamic: exports_external.boolean().optional(),\n    errorText: exports_external.string()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-output-available"),\n    toolCallId: exports_external.string(),\n    output: exports_external.unknown(),\n    providerExecuted: exports_external.boolean().optional(),\n    dynamic: exports_external.boolean().optional(),\n    preliminary: exports_external.boolean().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("tool-output-error"),\n    toolCallId: exports_external.string(),\n    errorText: exports_external.string(),\n    providerExecuted: exports_external.boolean().optional(),\n    dynamic: exports_external.boolean().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("reasoning-start"),\n    id: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("reasoning-delta"),\n    id: exports_external.string(),\n    delta: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("reasoning-end"),\n    id: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("source-url"),\n    sourceId: exports_external.string(),\n    url: exports_external.string(),\n    title: exports_external.string().optional(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("source-document"),\n    sourceId: exports_external.string(),\n    mediaType: exports_external.string(),\n    title: exports_external.string(),\n    filename: exports_external.string().optional(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("file"),\n    url: exports_external.string(),\n    mediaType: exports_external.string(),\n    providerMetadata: providerMetadataSchema.optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.custom((value) => typeof value === "string" && value.startsWith("data-"), { message: \'Type must start with "data-"\' }),\n    id: exports_external.string().optional(),\n    data: exports_external.unknown(),\n    transient: exports_external.boolean().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("start-step")\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("finish-step")\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("start"),\n    messageId: exports_external.string().optional(),\n    messageMetadata: exports_external.unknown().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("finish"),\n    finishReason: exports_external.enum([\n      "stop",\n      "length",\n      "content-filter",\n      "tool-calls",\n      "error",\n      "other",\n      "unknown"\n    ]).optional(),\n    messageMetadata: exports_external.unknown().optional()\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("abort")\n  }),\n  exports_external.strictObject({\n    type: exports_external.literal("message-metadata"),\n    messageMetadata: exports_external.unknown()\n  })\n])));\nfunction isDataUIMessageChunk(chunk) {\n  return chunk.type.startsWith("data-");\n}\nfunction mergeObjects(base, overrides) {\n  if (base === undefined && overrides === undefined) {\n    return;\n  }\n  if (base === undefined) {\n    return overrides;\n  }\n  if (overrides === undefined) {\n    return base;\n  }\n  const result = { ...base };\n  for (const key in overrides) {\n    if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n      const overridesValue = overrides[key];\n      if (overridesValue === undefined)\n        continue;\n      const baseValue = key in base ? base[key] : undefined;\n      const isSourceObject = overridesValue !== null && typeof overridesValue === "object" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n      const isTargetObject = baseValue !== null && baseValue !== undefined && typeof baseValue === "object" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n      if (isSourceObject && isTargetObject) {\n        result[key] = mergeObjects(baseValue, overridesValue);\n      } else {\n        result[key] = overridesValue;\n      }\n    }\n  }\n  return result;\n}\nfunction fixJson(input) {\n  const stack = ["ROOT"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i2, swapState) {\n    {\n      switch (char) {\n        case \'"\': {\n          lastValidIndex = i2;\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_STRING");\n          break;\n        }\n        case "f":\n        case "t":\n        case "n": {\n          lastValidIndex = i2;\n          literalStart = i2;\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_LITERAL");\n          break;\n        }\n        case "-": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_NUMBER");\n          break;\n        }\n        case "0":\n        case "1":\n        case "2":\n        case "3":\n        case "4":\n        case "5":\n        case "6":\n        case "7":\n        case "8":\n        case "9": {\n          lastValidIndex = i2;\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_NUMBER");\n          break;\n        }\n        case "{": {\n          lastValidIndex = i2;\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_OBJECT_START");\n          break;\n        }\n        case "[": {\n          lastValidIndex = i2;\n          stack.pop();\n          stack.push(swapState);\n          stack.push("INSIDE_ARRAY_START");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i2) {\n    switch (char) {\n      case ",": {\n        stack.pop();\n        stack.push("INSIDE_OBJECT_AFTER_COMMA");\n        break;\n      }\n      case "}": {\n        lastValidIndex = i2;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i2) {\n    switch (char) {\n      case ",": {\n        stack.pop();\n        stack.push("INSIDE_ARRAY_AFTER_COMMA");\n        break;\n      }\n      case "]": {\n        lastValidIndex = i2;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i2 = 0;i2 < input.length; i2++) {\n    const char = input[i2];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case "ROOT":\n        processValueStart(char, i2, "FINISH");\n        break;\n      case "INSIDE_OBJECT_START": {\n        switch (char) {\n          case \'"\': {\n            stack.pop();\n            stack.push("INSIDE_OBJECT_KEY");\n            break;\n          }\n          case "}": {\n            lastValidIndex = i2;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_OBJECT_AFTER_COMMA": {\n        switch (char) {\n          case \'"\': {\n            stack.pop();\n            stack.push("INSIDE_OBJECT_KEY");\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_OBJECT_KEY": {\n        switch (char) {\n          case \'"\': {\n            stack.pop();\n            stack.push("INSIDE_OBJECT_AFTER_KEY");\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_OBJECT_AFTER_KEY": {\n        switch (char) {\n          case ":": {\n            stack.pop();\n            stack.push("INSIDE_OBJECT_BEFORE_VALUE");\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_OBJECT_BEFORE_VALUE": {\n        processValueStart(char, i2, "INSIDE_OBJECT_AFTER_VALUE");\n        break;\n      }\n      case "INSIDE_OBJECT_AFTER_VALUE": {\n        processAfterObjectValue(char, i2);\n        break;\n      }\n      case "INSIDE_STRING": {\n        switch (char) {\n          case \'"\': {\n            stack.pop();\n            lastValidIndex = i2;\n            break;\n          }\n          case "\\\\": {\n            stack.push("INSIDE_STRING_ESCAPE");\n            break;\n          }\n          default: {\n            lastValidIndex = i2;\n          }\n        }\n        break;\n      }\n      case "INSIDE_ARRAY_START": {\n        switch (char) {\n          case "]": {\n            lastValidIndex = i2;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i2;\n            processValueStart(char, i2, "INSIDE_ARRAY_AFTER_VALUE");\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_ARRAY_AFTER_VALUE": {\n        switch (char) {\n          case ",": {\n            stack.pop();\n            stack.push("INSIDE_ARRAY_AFTER_COMMA");\n            break;\n          }\n          case "]": {\n            lastValidIndex = i2;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i2;\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_ARRAY_AFTER_COMMA": {\n        processValueStart(char, i2, "INSIDE_ARRAY_AFTER_VALUE");\n        break;\n      }\n      case "INSIDE_STRING_ESCAPE": {\n        stack.pop();\n        lastValidIndex = i2;\n        break;\n      }\n      case "INSIDE_NUMBER": {\n        switch (char) {\n          case "0":\n          case "1":\n          case "2":\n          case "3":\n          case "4":\n          case "5":\n          case "6":\n          case "7":\n          case "8":\n          case "9": {\n            lastValidIndex = i2;\n            break;\n          }\n          case "e":\n          case "E":\n          case "-":\n          case ".": {\n            break;\n          }\n          case ",": {\n            stack.pop();\n            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {\n              processAfterArrayValue(char, i2);\n            }\n            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {\n              processAfterObjectValue(char, i2);\n            }\n            break;\n          }\n          case "}": {\n            stack.pop();\n            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {\n              processAfterObjectValue(char, i2);\n            }\n            break;\n          }\n          case "]": {\n            stack.pop();\n            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {\n              processAfterArrayValue(char, i2);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case "INSIDE_LITERAL": {\n        const partialLiteral = input.substring(literalStart, i2 + 1);\n        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {\n            processAfterObjectValue(char, i2);\n          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {\n            processAfterArrayValue(char, i2);\n          }\n        } else {\n          lastValidIndex = i2;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i2 = stack.length - 1;i2 >= 0; i2--) {\n    const state = stack[i2];\n    switch (state) {\n      case "INSIDE_STRING": {\n        result += \'"\';\n        break;\n      }\n      case "INSIDE_OBJECT_KEY":\n      case "INSIDE_OBJECT_AFTER_KEY":\n      case "INSIDE_OBJECT_AFTER_COMMA":\n      case "INSIDE_OBJECT_START":\n      case "INSIDE_OBJECT_BEFORE_VALUE":\n      case "INSIDE_OBJECT_AFTER_VALUE": {\n        result += "}";\n        break;\n      }\n      case "INSIDE_ARRAY_START":\n      case "INSIDE_ARRAY_AFTER_COMMA":\n      case "INSIDE_ARRAY_AFTER_VALUE": {\n        result += "]";\n        break;\n      }\n      case "INSIDE_LITERAL": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if ("true".startsWith(partialLiteral)) {\n          result += "true".slice(partialLiteral.length);\n        } else if ("false".startsWith(partialLiteral)) {\n          result += "false".slice(partialLiteral.length);\n        } else if ("null".startsWith(partialLiteral)) {\n          result += "null".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\nasync function parsePartialJson(jsonText) {\n  if (jsonText === undefined) {\n    return { value: undefined, state: "undefined-input" };\n  }\n  let result = await safeParseJSON({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: "successful-parse" };\n  }\n  result = await safeParseJSON({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: "repaired-parse" };\n  }\n  return { value: undefined, state: "failed-parse" };\n}\nfunction isDataUIPart(part) {\n  return part.type.startsWith("data-");\n}\nfunction isTextUIPart(part) {\n  return part.type === "text";\n}\nfunction isFileUIPart(part) {\n  return part.type === "file";\n}\nfunction isReasoningUIPart(part) {\n  return part.type === "reasoning";\n}\nfunction isToolUIPart(part) {\n  return part.type.startsWith("tool-");\n}\nfunction isDynamicToolUIPart(part) {\n  return part.type === "dynamic-tool";\n}\nfunction isToolOrDynamicToolUIPart(part) {\n  return isToolUIPart(part) || isDynamicToolUIPart(part);\n}\nfunction getToolName(part) {\n  return part.type.split("-").slice(1).join("-");\n}\nfunction getToolOrDynamicToolName(part) {\n  return isDynamicToolUIPart(part) ? part.toolName : getToolName(part);\n}\nfunction createStreamingUIMessageState({\n  lastMessage,\n  messageId\n}) {\n  return {\n    message: (lastMessage == null ? undefined : lastMessage.role) === "assistant" ? lastMessage : {\n      id: messageId,\n      metadata: undefined,\n      role: "assistant",\n      parts: []\n    },\n    activeTextParts: {},\n    activeReasoningParts: {},\n    partialToolCalls: {}\n  };\n}\nfunction processUIMessageStream({\n  stream,\n  messageMetadataSchema,\n  dataPartSchemas,\n  runUpdateMessageJob,\n  onError,\n  onToolCall,\n  onData\n}) {\n  return stream.pipeThrough(new TransformStream({\n    async transform(chunk, controller) {\n      await runUpdateMessageJob(async ({ state, write }) => {\n        var _a16, _b, _c, _d;\n        function getToolInvocation(toolCallId) {\n          const toolInvocations = state.message.parts.filter(isToolUIPart);\n          const toolInvocation = toolInvocations.find((invocation) => invocation.toolCallId === toolCallId);\n          if (toolInvocation == null) {\n            throw new Error("tool-output-error must be preceded by a tool-input-available");\n          }\n          return toolInvocation;\n        }\n        function getDynamicToolInvocation(toolCallId) {\n          const toolInvocations = state.message.parts.filter((part) => part.type === "dynamic-tool");\n          const toolInvocation = toolInvocations.find((invocation) => invocation.toolCallId === toolCallId);\n          if (toolInvocation == null) {\n            throw new Error("tool-output-error must be preceded by a tool-input-available");\n          }\n          return toolInvocation;\n        }\n        function updateToolPart(options) {\n          var _a172;\n          const part = state.message.parts.find((part2) => isToolUIPart(part2) && part2.toolCallId === options.toolCallId);\n          const anyOptions = options;\n          const anyPart = part;\n          if (part != null) {\n            part.state = options.state;\n            anyPart.input = anyOptions.input;\n            anyPart.output = anyOptions.output;\n            anyPart.errorText = anyOptions.errorText;\n            anyPart.rawInput = anyOptions.rawInput;\n            anyPart.preliminary = anyOptions.preliminary;\n            anyPart.providerExecuted = (_a172 = anyOptions.providerExecuted) != null ? _a172 : part.providerExecuted;\n            if (anyOptions.providerMetadata != null && part.state === "input-available") {\n              part.callProviderMetadata = anyOptions.providerMetadata;\n            }\n          } else {\n            state.message.parts.push({\n              type: `tool-${options.toolName}`,\n              toolCallId: options.toolCallId,\n              state: options.state,\n              input: anyOptions.input,\n              output: anyOptions.output,\n              rawInput: anyOptions.rawInput,\n              errorText: anyOptions.errorText,\n              providerExecuted: anyOptions.providerExecuted,\n              preliminary: anyOptions.preliminary,\n              ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n            });\n          }\n        }\n        function updateDynamicToolPart(options) {\n          var _a172, _b2;\n          const part = state.message.parts.find((part2) => part2.type === "dynamic-tool" && part2.toolCallId === options.toolCallId);\n          const anyOptions = options;\n          const anyPart = part;\n          if (part != null) {\n            part.state = options.state;\n            anyPart.toolName = options.toolName;\n            anyPart.input = anyOptions.input;\n            anyPart.output = anyOptions.output;\n            anyPart.errorText = anyOptions.errorText;\n            anyPart.rawInput = (_a172 = anyOptions.rawInput) != null ? _a172 : anyPart.rawInput;\n            anyPart.preliminary = anyOptions.preliminary;\n            anyPart.providerExecuted = (_b2 = anyOptions.providerExecuted) != null ? _b2 : part.providerExecuted;\n            if (anyOptions.providerMetadata != null && part.state === "input-available") {\n              part.callProviderMetadata = anyOptions.providerMetadata;\n            }\n          } else {\n            state.message.parts.push({\n              type: "dynamic-tool",\n              toolName: options.toolName,\n              toolCallId: options.toolCallId,\n              state: options.state,\n              input: anyOptions.input,\n              output: anyOptions.output,\n              errorText: anyOptions.errorText,\n              preliminary: anyOptions.preliminary,\n              providerExecuted: anyOptions.providerExecuted,\n              ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n            });\n          }\n        }\n        async function updateMessageMetadata(metadata) {\n          if (metadata != null) {\n            const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n            if (messageMetadataSchema != null) {\n              await validateTypes({\n                value: mergedMetadata,\n                schema: messageMetadataSchema\n              });\n            }\n            state.message.metadata = mergedMetadata;\n          }\n        }\n        switch (chunk.type) {\n          case "text-start": {\n            const textPart = {\n              type: "text",\n              text: "",\n              providerMetadata: chunk.providerMetadata,\n              state: "streaming"\n            };\n            state.activeTextParts[chunk.id] = textPart;\n            state.message.parts.push(textPart);\n            write();\n            break;\n          }\n          case "text-delta": {\n            const textPart = state.activeTextParts[chunk.id];\n            textPart.text += chunk.delta;\n            textPart.providerMetadata = (_a16 = chunk.providerMetadata) != null ? _a16 : textPart.providerMetadata;\n            write();\n            break;\n          }\n          case "text-end": {\n            const textPart = state.activeTextParts[chunk.id];\n            textPart.state = "done";\n            textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;\n            delete state.activeTextParts[chunk.id];\n            write();\n            break;\n          }\n          case "reasoning-start": {\n            const reasoningPart = {\n              type: "reasoning",\n              text: "",\n              providerMetadata: chunk.providerMetadata,\n              state: "streaming"\n            };\n            state.activeReasoningParts[chunk.id] = reasoningPart;\n            state.message.parts.push(reasoningPart);\n            write();\n            break;\n          }\n          case "reasoning-delta": {\n            const reasoningPart = state.activeReasoningParts[chunk.id];\n            reasoningPart.text += chunk.delta;\n            reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;\n            write();\n            break;\n          }\n          case "reasoning-end": {\n            const reasoningPart = state.activeReasoningParts[chunk.id];\n            reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;\n            reasoningPart.state = "done";\n            delete state.activeReasoningParts[chunk.id];\n            write();\n            break;\n          }\n          case "file": {\n            state.message.parts.push({\n              type: "file",\n              mediaType: chunk.mediaType,\n              url: chunk.url\n            });\n            write();\n            break;\n          }\n          case "source-url": {\n            state.message.parts.push({\n              type: "source-url",\n              sourceId: chunk.sourceId,\n              url: chunk.url,\n              title: chunk.title,\n              providerMetadata: chunk.providerMetadata\n            });\n            write();\n            break;\n          }\n          case "source-document": {\n            state.message.parts.push({\n              type: "source-document",\n              sourceId: chunk.sourceId,\n              mediaType: chunk.mediaType,\n              title: chunk.title,\n              filename: chunk.filename,\n              providerMetadata: chunk.providerMetadata\n            });\n            write();\n            break;\n          }\n          case "tool-input-start": {\n            const toolInvocations = state.message.parts.filter(isToolUIPart);\n            state.partialToolCalls[chunk.toolCallId] = {\n              text: "",\n              toolName: chunk.toolName,\n              index: toolInvocations.length,\n              dynamic: chunk.dynamic\n            };\n            if (chunk.dynamic) {\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "input-streaming",\n                input: undefined,\n                providerExecuted: chunk.providerExecuted\n              });\n            } else {\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "input-streaming",\n                input: undefined,\n                providerExecuted: chunk.providerExecuted\n              });\n            }\n            write();\n            break;\n          }\n          case "tool-input-delta": {\n            const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n            partialToolCall.text += chunk.inputTextDelta;\n            const { value: partialArgs } = await parsePartialJson(partialToolCall.text);\n            if (partialToolCall.dynamic) {\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: partialToolCall.toolName,\n                state: "input-streaming",\n                input: partialArgs\n              });\n            } else {\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: partialToolCall.toolName,\n                state: "input-streaming",\n                input: partialArgs\n              });\n            }\n            write();\n            break;\n          }\n          case "tool-input-available": {\n            if (chunk.dynamic) {\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "input-available",\n                input: chunk.input,\n                providerExecuted: chunk.providerExecuted,\n                providerMetadata: chunk.providerMetadata\n              });\n            } else {\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "input-available",\n                input: chunk.input,\n                providerExecuted: chunk.providerExecuted,\n                providerMetadata: chunk.providerMetadata\n              });\n            }\n            write();\n            if (onToolCall && !chunk.providerExecuted) {\n              await onToolCall({\n                toolCall: chunk\n              });\n            }\n            break;\n          }\n          case "tool-input-error": {\n            if (chunk.dynamic) {\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "output-error",\n                input: chunk.input,\n                errorText: chunk.errorText,\n                providerExecuted: chunk.providerExecuted,\n                providerMetadata: chunk.providerMetadata\n              });\n            } else {\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                state: "output-error",\n                input: undefined,\n                rawInput: chunk.input,\n                errorText: chunk.errorText,\n                providerExecuted: chunk.providerExecuted,\n                providerMetadata: chunk.providerMetadata\n              });\n            }\n            write();\n            break;\n          }\n          case "tool-output-available": {\n            if (chunk.dynamic) {\n              const toolInvocation = getDynamicToolInvocation(chunk.toolCallId);\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: toolInvocation.toolName,\n                state: "output-available",\n                input: toolInvocation.input,\n                output: chunk.output,\n                preliminary: chunk.preliminary\n              });\n            } else {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: getToolName(toolInvocation),\n                state: "output-available",\n                input: toolInvocation.input,\n                output: chunk.output,\n                providerExecuted: chunk.providerExecuted,\n                preliminary: chunk.preliminary\n              });\n            }\n            write();\n            break;\n          }\n          case "tool-output-error": {\n            if (chunk.dynamic) {\n              const toolInvocation = getDynamicToolInvocation(chunk.toolCallId);\n              updateDynamicToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: toolInvocation.toolName,\n                state: "output-error",\n                input: toolInvocation.input,\n                errorText: chunk.errorText,\n                providerExecuted: chunk.providerExecuted\n              });\n            } else {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              updateToolPart({\n                toolCallId: chunk.toolCallId,\n                toolName: getToolName(toolInvocation),\n                state: "output-error",\n                input: toolInvocation.input,\n                rawInput: toolInvocation.rawInput,\n                errorText: chunk.errorText,\n                providerExecuted: chunk.providerExecuted\n              });\n            }\n            write();\n            break;\n          }\n          case "start-step": {\n            state.message.parts.push({ type: "step-start" });\n            break;\n          }\n          case "finish-step": {\n            state.activeTextParts = {};\n            state.activeReasoningParts = {};\n            break;\n          }\n          case "start": {\n            if (chunk.messageId != null) {\n              state.message.id = chunk.messageId;\n            }\n            await updateMessageMetadata(chunk.messageMetadata);\n            if (chunk.messageId != null || chunk.messageMetadata != null) {\n              write();\n            }\n            break;\n          }\n          case "finish": {\n            if (chunk.finishReason != null) {\n              state.finishReason = chunk.finishReason;\n            }\n            await updateMessageMetadata(chunk.messageMetadata);\n            if (chunk.messageMetadata != null) {\n              write();\n            }\n            break;\n          }\n          case "message-metadata": {\n            await updateMessageMetadata(chunk.messageMetadata);\n            if (chunk.messageMetadata != null) {\n              write();\n            }\n            break;\n          }\n          case "error": {\n            onError == null || onError(new Error(chunk.errorText));\n            break;\n          }\n          default: {\n            if (isDataUIMessageChunk(chunk)) {\n              if ((dataPartSchemas == null ? undefined : dataPartSchemas[chunk.type]) != null) {\n                await validateTypes({\n                  value: chunk.data,\n                  schema: dataPartSchemas[chunk.type]\n                });\n              }\n              const dataChunk = chunk;\n              if (dataChunk.transient) {\n                onData == null || onData(dataChunk);\n                break;\n              }\n              const existingUIPart = dataChunk.id != null ? state.message.parts.find((chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id) : undefined;\n              if (existingUIPart != null) {\n                existingUIPart.data = dataChunk.data;\n              } else {\n                state.message.parts.push(dataChunk);\n              }\n              onData == null || onData(dataChunk);\n              write();\n            }\n          }\n        }\n        controller.enqueue(chunk);\n      });\n    }\n  }));\n}\nfunction handleUIMessageStreamFinish({\n  messageId,\n  originalMessages = [],\n  onFinish,\n  onError,\n  stream\n}) {\n  let lastMessage = originalMessages == null ? undefined : originalMessages[originalMessages.length - 1];\n  if ((lastMessage == null ? undefined : lastMessage.role) !== "assistant") {\n    lastMessage = undefined;\n  } else {\n    messageId = lastMessage.id;\n  }\n  let isAborted2 = false;\n  const idInjectedStream = stream.pipeThrough(new TransformStream({\n    transform(chunk, controller) {\n      if (chunk.type === "start") {\n        const startChunk = chunk;\n        if (startChunk.messageId == null && messageId != null) {\n          startChunk.messageId = messageId;\n        }\n      }\n      if (chunk.type === "abort") {\n        isAborted2 = true;\n      }\n      controller.enqueue(chunk);\n    }\n  }));\n  if (onFinish == null) {\n    return idInjectedStream;\n  }\n  const state = createStreamingUIMessageState({\n    lastMessage: lastMessage ? structuredClone(lastMessage) : undefined,\n    messageId: messageId != null ? messageId : ""\n  });\n  const runUpdateMessageJob = async (job) => {\n    await job({ state, write: () => {} });\n  };\n  let finishCalled = false;\n  const callOnFinish = async () => {\n    if (finishCalled || !onFinish) {\n      return;\n    }\n    finishCalled = true;\n    const isContinuation = state.message.id === (lastMessage == null ? undefined : lastMessage.id);\n    await onFinish({\n      isAborted: isAborted2,\n      isContinuation,\n      responseMessage: state.message,\n      messages: [\n        ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,\n        state.message\n      ],\n      finishReason: state.finishReason\n    });\n  };\n  return processUIMessageStream({\n    stream: idInjectedStream,\n    runUpdateMessageJob,\n    onError\n  }).pipeThrough(new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk);\n    },\n    async cancel() {\n      await callOnFinish();\n    },\n    async flush() {\n      await callOnFinish();\n    }\n  }));\n}\nvar originalGenerateId2 = createIdGenerator({\n  prefix: "aitxt",\n  size: 24\n});\nfunction convertToModelMessages(messages, options) {\n  const modelMessages = [];\n  if (options == null ? undefined : options.ignoreIncompleteToolCalls) {\n    messages = messages.map((message) => ({\n      ...message,\n      parts: message.parts.filter((part) => !isToolOrDynamicToolUIPart(part) || part.state !== "input-streaming" && part.state !== "input-available")\n    }));\n  }\n  for (const message of messages) {\n    switch (message.role) {\n      case "system": {\n        const textParts = message.parts.filter((part) => part.type === "text");\n        const providerMetadata = textParts.reduce((acc, part) => {\n          if (part.providerMetadata != null) {\n            return { ...acc, ...part.providerMetadata };\n          }\n          return acc;\n        }, {});\n        modelMessages.push({\n          role: "system",\n          content: textParts.map((part) => part.text).join(""),\n          ...Object.keys(providerMetadata).length > 0 ? { providerOptions: providerMetadata } : {}\n        });\n        break;\n      }\n      case "user": {\n        modelMessages.push({\n          role: "user",\n          content: message.parts.map((part) => {\n            var _a16;\n            if (isTextUIPart(part)) {\n              return {\n                type: "text",\n                text: part.text,\n                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n              };\n            }\n            if (isFileUIPart(part)) {\n              return {\n                type: "file",\n                mediaType: part.mediaType,\n                filename: part.filename,\n                data: part.url,\n                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n              };\n            }\n            if (isDataUIPart(part)) {\n              return (_a16 = options == null ? undefined : options.convertDataPart) == null ? undefined : _a16.call(options, part);\n            }\n          }).filter((part) => part != null)\n        });\n        break;\n      }\n      case "assistant": {\n        if (message.parts != null) {\n          let processBlock2 = function() {\n            var _a16, _b, _c;\n            if (block.length === 0) {\n              return;\n            }\n            const content = [];\n            for (const part of block) {\n              if (isTextUIPart(part)) {\n                content.push({\n                  type: "text",\n                  text: part.text,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                });\n              } else if (isFileUIPart(part)) {\n                content.push({\n                  type: "file",\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url\n                });\n              } else if (isReasoningUIPart(part)) {\n                content.push({\n                  type: "reasoning",\n                  text: part.text,\n                  providerOptions: part.providerMetadata\n                });\n              } else if (isDynamicToolUIPart(part)) {\n                const toolName = part.toolName;\n                if (part.state !== "input-streaming") {\n                  content.push({\n                    type: "tool-call",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.input,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                }\n              } else if (isToolUIPart(part)) {\n                const toolName = getToolName(part);\n                if (part.state !== "input-streaming") {\n                  content.push({\n                    type: "tool-call",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.state === "output-error" ? (_a16 = part.input) != null ? _a16 : part.rawInput : part.input,\n                    providerExecuted: part.providerExecuted,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                  if (part.providerExecuted === true && (part.state === "output-available" || part.state === "output-error")) {\n                    content.push({\n                      type: "tool-result",\n                      toolCallId: part.toolCallId,\n                      toolName,\n                      output: createToolModelOutput({\n                        output: part.state === "output-error" ? part.errorText : part.output,\n                        tool: (_b = options == null ? undefined : options.tools) == null ? undefined : _b[toolName],\n                        errorMode: part.state === "output-error" ? "json" : "none"\n                      }),\n                      ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                    });\n                  }\n                }\n              } else if (isDataUIPart(part)) {\n                const dataPart = (_c = options == null ? undefined : options.convertDataPart) == null ? undefined : _c.call(options, part);\n                if (dataPart != null) {\n                  content.push(dataPart);\n                }\n              } else {\n                const _exhaustiveCheck = part;\n                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n              }\n            }\n            modelMessages.push({\n              role: "assistant",\n              content\n            });\n            const toolParts = block.filter((part) => isToolUIPart(part) && part.providerExecuted !== true || part.type === "dynamic-tool");\n            if (toolParts.length > 0) {\n              modelMessages.push({\n                role: "tool",\n                content: toolParts.map((toolPart) => {\n                  var _a172;\n                  switch (toolPart.state) {\n                    case "output-error":\n                    case "output-available": {\n                      const toolName = getToolOrDynamicToolName(toolPart);\n                      return {\n                        type: "tool-result",\n                        toolCallId: toolPart.toolCallId,\n                        toolName,\n                        output: createToolModelOutput({\n                          output: toolPart.state === "output-error" ? toolPart.errorText : toolPart.output,\n                          tool: (_a172 = options == null ? undefined : options.tools) == null ? undefined : _a172[toolName],\n                          errorMode: toolPart.state === "output-error" ? "text" : "none"\n                        }),\n                        ...toolPart.callProviderMetadata != null ? { providerOptions: toolPart.callProviderMetadata } : {}\n                      };\n                    }\n                    default: {\n                      return null;\n                    }\n                  }\n                }).filter((output) => output != null)\n              });\n            }\n            block = [];\n          };\n          var processBlock = processBlock2;\n          let block = [];\n          for (const part of message.parts) {\n            if (isTextUIPart(part) || isReasoningUIPart(part) || isFileUIPart(part) || isToolOrDynamicToolUIPart(part) || isDataUIPart(part)) {\n              block.push(part);\n            } else if (part.type === "step-start") {\n              processBlock2();\n            }\n          }\n          processBlock2();\n          break;\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = message.role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return modelMessages;\n}\nvar originalGenerateId3 = createIdGenerator({ prefix: "aiobj", size: 24 });\nvar originalGenerateId4 = createIdGenerator({ prefix: "aiobj", size: 24 });\nvar output_exports = {};\n__export2(output_exports, {\n  object: () => object2,\n  text: () => text\n});\nvar text = () => ({\n  type: "text",\n  responseFormat: { type: "text" },\n  async parsePartial({ text: text2 }) {\n    return { partial: text2 };\n  },\n  async parseOutput({ text: text2 }) {\n    return text2;\n  }\n});\nvar object2 = ({\n  schema: inputSchema\n}) => {\n  const schema = asSchema(inputSchema);\n  return {\n    type: "object",\n    responseFormat: {\n      type: "json",\n      schema: schema.jsonSchema\n    },\n    async parsePartial({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case "failed-parse":\n        case "undefined-input":\n          return;\n        case "repaired-parse":\n        case "successful-parse":\n          return {\n            partial: result.value\n          };\n        default: {\n          const _exhaustiveCheck = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    async parseOutput({ text: text2 }, context) {\n      const parseResult = await safeParseJSON({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: "No object generated: could not parse the response.",\n          cause: parseResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      const validationResult = await safeValidateTypes({\n        value: parseResult.value,\n        schema\n      });\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: "No object generated: response did not match schema.",\n          cause: validationResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      return validationResult.value;\n    }\n  };\n};\nvar name15 = "AI_NoSuchProviderError";\nvar marker152 = `vercel.ai.error.${name15}`;\nvar symbol152 = Symbol.for(marker152);\nvar _a152;\n_a152 = symbol152;\nvar uiMessagesSchema = lazyValidator(() => zodSchema(exports_external.array(exports_external.object({\n  id: exports_external.string(),\n  role: exports_external.enum(["system", "user", "assistant"]),\n  metadata: exports_external.unknown().optional(),\n  parts: exports_external.array(exports_external.union([\n    exports_external.object({\n      type: exports_external.literal("text"),\n      text: exports_external.string(),\n      state: exports_external.enum(["streaming", "done"]).optional(),\n      providerMetadata: providerMetadataSchema.optional()\n    }),\n    exports_external.object({\n      type: exports_external.literal("reasoning"),\n      text: exports_external.string(),\n      state: exports_external.enum(["streaming", "done"]).optional(),\n      providerMetadata: providerMetadataSchema.optional()\n    }),\n    exports_external.object({\n      type: exports_external.literal("source-url"),\n      sourceId: exports_external.string(),\n      url: exports_external.string(),\n      title: exports_external.string().optional(),\n      providerMetadata: providerMetadataSchema.optional()\n    }),\n    exports_external.object({\n      type: exports_external.literal("source-document"),\n      sourceId: exports_external.string(),\n      mediaType: exports_external.string(),\n      title: exports_external.string(),\n      filename: exports_external.string().optional(),\n      providerMetadata: providerMetadataSchema.optional()\n    }),\n    exports_external.object({\n      type: exports_external.literal("file"),\n      mediaType: exports_external.string(),\n      filename: exports_external.string().optional(),\n      url: exports_external.string(),\n      providerMetadata: providerMetadataSchema.optional()\n    }),\n    exports_external.object({\n      type: exports_external.literal("step-start")\n    }),\n    exports_external.object({\n      type: exports_external.string().startsWith("data-"),\n      id: exports_external.string().optional(),\n      data: exports_external.unknown()\n    }),\n    exports_external.object({\n      type: exports_external.literal("dynamic-tool"),\n      toolName: exports_external.string(),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("input-streaming"),\n      input: exports_external.unknown().optional(),\n      providerExecuted: exports_external.boolean().optional(),\n      output: exports_external.never().optional(),\n      errorText: exports_external.never().optional()\n    }),\n    exports_external.object({\n      type: exports_external.literal("dynamic-tool"),\n      toolName: exports_external.string(),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("input-available"),\n      input: exports_external.unknown(),\n      providerExecuted: exports_external.boolean().optional(),\n      output: exports_external.never().optional(),\n      errorText: exports_external.never().optional(),\n      callProviderMetadata: providerMetadataSchema.optional()\n    }),\n    exports_external.object({\n      type: exports_external.literal("dynamic-tool"),\n      toolName: exports_external.string(),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("output-available"),\n      input: exports_external.unknown(),\n      providerExecuted: exports_external.boolean().optional(),\n      output: exports_external.unknown(),\n      errorText: exports_external.never().optional(),\n      callProviderMetadata: providerMetadataSchema.optional(),\n      preliminary: exports_external.boolean().optional()\n    }),\n    exports_external.object({\n      type: exports_external.literal("dynamic-tool"),\n      toolName: exports_external.string(),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("output-error"),\n      input: exports_external.unknown(),\n      providerExecuted: exports_external.boolean().optional(),\n      output: exports_external.never().optional(),\n      errorText: exports_external.string(),\n      callProviderMetadata: providerMetadataSchema.optional()\n    }),\n    exports_external.object({\n      type: exports_external.string().startsWith("tool-"),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("input-streaming"),\n      providerExecuted: exports_external.boolean().optional(),\n      input: exports_external.unknown().optional(),\n      output: exports_external.never().optional(),\n      errorText: exports_external.never().optional(),\n      approval: exports_external.never().optional()\n    }),\n    exports_external.object({\n      type: exports_external.string().startsWith("tool-"),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("input-available"),\n      providerExecuted: exports_external.boolean().optional(),\n      input: exports_external.unknown(),\n      output: exports_external.never().optional(),\n      errorText: exports_external.never().optional(),\n      callProviderMetadata: providerMetadataSchema.optional(),\n      approval: exports_external.never().optional()\n    }),\n    exports_external.object({\n      type: exports_external.string().startsWith("tool-"),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("approval-requested"),\n      input: exports_external.unknown(),\n      providerExecuted: exports_external.boolean().optional(),\n      output: exports_external.never().optional(),\n      errorText: exports_external.never().optional(),\n      callProviderMetadata: providerMetadataSchema.optional(),\n      approval: exports_external.object({\n        id: exports_external.string(),\n        approved: exports_external.never().optional(),\n        reason: exports_external.never().optional()\n      })\n    }),\n    exports_external.object({\n      type: exports_external.string().startsWith("tool-"),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("approval-responded"),\n      input: exports_external.unknown(),\n      providerExecuted: exports_external.boolean().optional(),\n      output: exports_external.never().optional(),\n      errorText: exports_external.never().optional(),\n      callProviderMetadata: providerMetadataSchema.optional(),\n      approval: exports_external.object({\n        id: exports_external.string(),\n        approved: exports_external.boolean(),\n        reason: exports_external.string().optional()\n      })\n    }),\n    exports_external.object({\n      type: exports_external.string().startsWith("tool-"),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("output-available"),\n      providerExecuted: exports_external.boolean().optional(),\n      input: exports_external.unknown(),\n      output: exports_external.unknown(),\n      errorText: exports_external.never().optional(),\n      callProviderMetadata: providerMetadataSchema.optional(),\n      preliminary: exports_external.boolean().optional(),\n      approval: exports_external.object({\n        id: exports_external.string(),\n        approved: exports_external.literal(true),\n        reason: exports_external.string().optional()\n      }).optional()\n    }),\n    exports_external.object({\n      type: exports_external.string().startsWith("tool-"),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("output-error"),\n      providerExecuted: exports_external.boolean().optional(),\n      input: exports_external.unknown(),\n      output: exports_external.never().optional(),\n      errorText: exports_external.string(),\n      callProviderMetadata: providerMetadataSchema.optional(),\n      approval: exports_external.object({\n        id: exports_external.string(),\n        approved: exports_external.literal(true),\n        reason: exports_external.string().optional()\n      }).optional()\n    }),\n    exports_external.object({\n      type: exports_external.string().startsWith("tool-"),\n      toolCallId: exports_external.string(),\n      state: exports_external.literal("output-denied"),\n      providerExecuted: exports_external.boolean().optional(),\n      input: exports_external.unknown(),\n      output: exports_external.never().optional(),\n      errorText: exports_external.never().optional(),\n      callProviderMetadata: providerMetadataSchema.optional(),\n      approval: exports_external.object({\n        id: exports_external.string(),\n        approved: exports_external.literal(false),\n        reason: exports_external.string().optional()\n      })\n    })\n  ])).nonempty("Message must contain at least one part")\n})).nonempty("Messages array must not be empty")));\nfunction createUIMessageStream({\n  execute,\n  onError = getErrorMessage2,\n  originalMessages,\n  onFinish,\n  generateId: generateId3 = generateId\n}) {\n  let controller;\n  const ongoingStreamPromises = [];\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    }\n  });\n  function safeEnqueue(data) {\n    try {\n      controller.enqueue(data);\n    } catch (error48) {}\n  }\n  try {\n    const result = execute({\n      writer: {\n        write(part) {\n          safeEnqueue(part);\n        },\n        merge(streamArg) {\n          ongoingStreamPromises.push((async () => {\n            const reader = streamArg.getReader();\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done)\n                break;\n              safeEnqueue(value);\n            }\n          })().catch((error48) => {\n            safeEnqueue({\n              type: "error",\n              errorText: onError(error48)\n            });\n          }));\n        },\n        onError\n      }\n    });\n    if (result) {\n      ongoingStreamPromises.push(result.catch((error48) => {\n        safeEnqueue({\n          type: "error",\n          errorText: onError(error48)\n        });\n      }));\n    }\n  } catch (error48) {\n    safeEnqueue({\n      type: "error",\n      errorText: onError(error48)\n    });\n  }\n  const waitForStreams = new Promise(async (resolve2) => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve2();\n  });\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error48) {}\n  });\n  return handleUIMessageStreamFinish({\n    stream,\n    messageId: generateId3(),\n    originalMessages,\n    onFinish,\n    onError\n  });\n}\n\n// ../../packages/blink/dist/browser/index.browser-DPHICXmy.js\nfunction i2(e2) {\n  return typeof e2 == `object` && !!e2 && typeof e2[Symbol.asyncIterator] == `function`;\n}\nvar a2 = class extends Error {\n  constructor(e2, t2) {\n    super(e2), this.response = t2;\n  }\n};\nvar s = Object.freeze({ withContext(e2, t2) {\n  let n2 = {};\n  for (let r2 of Object.keys(e2))\n    n2[r2] = e2[r2].withContext(t2);\n  return n2;\n}, with(e2, t2) {\n  let n2 = {};\n  for (let r2 of Object.keys(e2))\n    n2[r2] = e2[r2].withContext(t2);\n  return n2;\n}, async withApproval(o) {\n  let s2 = {};\n  for (let [e2, t2] of Object.entries(o.tools)) {\n    let n2 = t2.execute;\n    s2[e2] = { ...t2, execute: async (e3, r2) => t2.autoApprove && n2 && await t2.autoApprove(e3) ? n2(e3, r2) : { type: `tool-approval`, outcome: `pending` } };\n  }\n  let l = o.messages[o.messages.length - 1];\n  if (!l?.parts)\n    return s2;\n  let u = [];\n  for (let e2 of l.parts) {\n    if (!isToolUIPart(e2))\n      continue;\n    let t2 = getToolName(e2), i3 = o.tools[t2];\n    i3 && e2.state === `output-available` && i3.execute && c(e2.output) && e2.output.outcome === `approved` && u.push({ toolName: getToolName(e2), tool: i3, input: e2.input, toolCallId: e2.toolCallId });\n  }\n  if (u.length > 0) {\n    let n2 = createUIMessageStream({ execute: async ({ writer: t2 }) => {\n      t2.write({ type: `start-step` }), await Promise.all(u.map(async (n3) => {\n        if (!n3.tool.execute)\n          throw Error(`Tool does not support execute.`);\n        t2.write({ type: `tool-input-available`, toolCallId: n3.toolCallId, toolName: n3.toolName, input: n3.input });\n        try {\n          let r2 = await n3.tool.execute(n3.input, { toolCallId: n3.toolCallId, messages: convertToModelMessages(o.messages, { tools: o.tools }), abortSignal: o.abortSignal }), a3 = r2;\n          if (i2(r2))\n            for await (let e2 of r2)\n              a3 = e2, t2.write({ type: `tool-output-available`, toolCallId: n3.toolCallId, output: e2, preliminary: true });\n          t2.write({ type: `tool-output-available`, toolCallId: n3.toolCallId, output: a3 });\n        } catch (e2) {\n          t2.write({ type: `tool-output-error`, toolCallId: n3.toolCallId, errorText: e2 instanceof Error ? e2.message : String(e2) });\n        }\n      })), t2.write({ type: `finish` });\n    } });\n    throw new a2(`Executing tools`, n2);\n  }\n  return s2;\n}, prefix(e2, t2) {\n  let n2 = {};\n  for (let [r2, i3] of Object.entries(e2))\n    n2[`${t2}${r2}`] = i3;\n  return n2;\n} });\nfunction c(e2) {\n  return typeof e2 == `object` && !!e2 && `type` in e2 && e2.type === `tool-approval`;\n}\n\n// ../../packages/blink/dist/browser/cookie-C6gQJ2Nm.js\nvar e2 = (e3) => {\n  let t2 = e3.split(`/`);\n  return t2[0] === `` && t2.shift(), t2;\n};\nvar t2 = (t3) => {\n  let { groups: i3, path: a3 } = n2(t3), o = e2(a3);\n  return r2(o, i3);\n};\nvar n2 = (e3) => {\n  let t3 = [];\n  return e3 = e3.replace(/\\{[^}]+\\}/g, (e4, n3) => {\n    let r2 = `@${n3}`;\n    return t3.push([r2, e4]), r2;\n  }), { groups: t3, path: e3 };\n};\nvar r2 = (e3, t3) => {\n  for (let n3 = t3.length - 1;n3 >= 0; n3--) {\n    let [r3] = t3[n3];\n    for (let i3 = e3.length - 1;i3 >= 0; i3--)\n      if (e3[i3].includes(r3)) {\n        e3[i3] = e3[i3].replace(r3, t3[n3][1]);\n        break;\n      }\n  }\n  return e3;\n};\nvar i3 = {};\nvar a3 = (e3, t3) => {\n  if (e3 === `*`)\n    return `*`;\n  let n3 = e3.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n  if (n3) {\n    let r3 = `${e3}#${t3}`;\n    return i3[r3] || (n3[2] ? i3[r3] = t3 && t3[0] !== `:` && t3[0] !== `*` ? [r3, n3[1], RegExp(`^${n3[2]}(?=/${t3})`)] : [e3, n3[1], RegExp(`^${n3[2]}$`)] : i3[r3] = [e3, n3[1], true]), i3[r3];\n  }\n  return null;\n};\nvar o = (e3, t3) => {\n  try {\n    return t3(e3);\n  } catch {\n    return e3.replace(/(?:%[0-9A-Fa-f]{2})+/g, (e4) => {\n      try {\n        return t3(e4);\n      } catch {\n        return e4;\n      }\n    });\n  }\n};\nvar s2 = (e3) => o(e3, decodeURI);\nvar c2 = (e3) => {\n  let t3 = e3.url, n3 = t3.indexOf(`/`, t3.indexOf(`:`) + 4), r3 = n3;\n  for (;r3 < t3.length; r3++) {\n    let e4 = t3.charCodeAt(r3);\n    if (e4 === 37) {\n      let e5 = t3.indexOf(`?`, r3), i4 = t3.slice(n3, e5 === -1 ? undefined : e5);\n      return s2(i4.includes(`%25`) ? i4.replace(/%25/g, `%2525`) : i4);\n    } else if (e4 === 63)\n      break;\n  }\n  return t3.slice(n3, r3);\n};\nvar l = (e3) => {\n  let t3 = c2(e3);\n  return t3.length > 1 && t3.at(-1) === `/` ? t3.slice(0, -1) : t3;\n};\nvar u = (e3, t3, ...n3) => (n3.length && (t3 = u(t3, ...n3)), `${e3?.[0] === `/` ? `` : `/`}${e3}${t3 === `/` ? `` : `${e3?.at(-1) === `/` ? `` : `/`}${t3?.[0] === `/` ? t3.slice(1) : t3}`}`);\nvar d = (e3) => {\n  if (e3.charCodeAt(e3.length - 1) !== 63 || !e3.includes(`:`))\n    return null;\n  let t3 = e3.split(`/`), n3 = [], r3 = ``;\n  return t3.forEach((e4) => {\n    if (e4 !== `` && !/\\:/.test(e4))\n      r3 += `/` + e4;\n    else if (/\\:/.test(e4))\n      if (/\\?/.test(e4)) {\n        n3.length === 0 && r3 === `` ? n3.push(`/`) : n3.push(r3);\n        let t4 = e4.replace(`?`, ``);\n        r3 += `/` + t4, n3.push(r3);\n      } else\n        r3 += `/` + e4;\n  }), n3.filter((e4, t4, n4) => n4.indexOf(e4) === t4);\n};\nvar f = (e3) => /[%+]/.test(e3) ? (e3.indexOf(`+`) !== -1 && (e3 = e3.replace(/\\+/g, ` `)), e3.indexOf(`%`) === -1 ? e3 : o(e3, g)) : e3;\nvar p = (e3, t3, n3) => {\n  let r3;\n  if (!n3 && t3 && !/[%+]/.test(t3)) {\n    let n4 = e3.indexOf(`?${t3}`, 8);\n    for (n4 === -1 && (n4 = e3.indexOf(`&${t3}`, 8));n4 !== -1; ) {\n      let r4 = e3.charCodeAt(n4 + t3.length + 1);\n      if (r4 === 61) {\n        let r5 = n4 + t3.length + 2, i5 = e3.indexOf(`&`, r5);\n        return f(e3.slice(r5, i5 === -1 ? undefined : i5));\n      } else if (r4 == 38 || isNaN(r4))\n        return ``;\n      n4 = e3.indexOf(`&${t3}`, n4 + 1);\n    }\n    if (r3 = /[%+]/.test(e3), !r3)\n      return;\n  }\n  let i4 = {};\n  r3 ??= /[%+]/.test(e3);\n  let a4 = e3.indexOf(`?`, 8);\n  for (;a4 !== -1; ) {\n    let t4 = e3.indexOf(`&`, a4 + 1), o2 = e3.indexOf(`=`, a4);\n    o2 > t4 && t4 !== -1 && (o2 = -1);\n    let s3 = e3.slice(a4 + 1, o2 === -1 ? t4 === -1 ? undefined : t4 : o2);\n    if (r3 && (s3 = f(s3)), a4 = t4, s3 === ``)\n      continue;\n    let c3;\n    o2 === -1 ? c3 = `` : (c3 = e3.slice(o2 + 1, t4 === -1 ? undefined : t4), r3 && (c3 = f(c3))), n3 ? (i4[s3] && Array.isArray(i4[s3]) || (i4[s3] = []), i4[s3].push(c3)) : i4[s3] ??= c3;\n  }\n  return t3 ? i4[t3] : i4;\n};\nvar m = p;\nvar h = (e3, t3) => p(e3, t3, true);\nvar g = decodeURIComponent;\nvar _ = /^[\\w!#$%&\'*.^`|~+-]+$/;\nvar v = /^[ !#-:<-[\\]-~]*$/;\nvar y = (e3, t3) => {\n  if (t3 && e3.indexOf(t3) === -1)\n    return {};\n  let n3 = e3.trim().split(`;`), r3 = {};\n  for (let e4 of n3) {\n    e4 = e4.trim();\n    let n4 = e4.indexOf(`=`);\n    if (n4 === -1)\n      continue;\n    let i4 = e4.substring(0, n4).trim();\n    if (t3 && t3 !== i4 || !_.test(i4))\n      continue;\n    let a4 = e4.substring(n4 + 1).trim();\n    if (a4.startsWith(`"`) && a4.endsWith(`"`) && (a4 = a4.slice(1, -1)), v.test(a4) && (r3[i4] = a4.indexOf(`%`) === -1 ? a4 : o(a4, g), t3))\n      break;\n  }\n  return r3;\n};\n\n// ../../packages/blink/dist/browser/agent/client/index.js\nvar a4 = class extends Error {\n  constructor(e3, t3) {\n    super(e3), this.name = `ParseError`, this.type = t3.type, this.field = t3.field, this.value = t3.value, this.line = t3.line;\n  }\n};\nfunction o2(e3) {}\nfunction s3(e3) {\n  if (typeof e3 == `function`)\n    throw TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");\n  let { onEvent: t3 = o2, onError: n3 = o2, onRetry: r3 = o2, onComment: i4 } = e3, s4 = ``, l2 = true, u3, d2 = ``, f2 = ``;\n  function p2(e4) {\n    let t4 = l2 ? e4.replace(/^\\xEF\\xBB\\xBF/, ``) : e4, [n4, r4] = c3(`${s4}${t4}`);\n    for (let e5 of n4)\n      m2(e5);\n    s4 = r4, l2 = false;\n  }\n  function m2(e4) {\n    if (e4 === ``) {\n      g2();\n      return;\n    }\n    if (e4.startsWith(`:`)) {\n      i4 && i4(e4.slice(e4.startsWith(`: `) ? 2 : 1));\n      return;\n    }\n    let t4 = e4.indexOf(`:`);\n    if (t4 !== -1) {\n      let n4 = e4.slice(0, t4), r4 = e4[t4 + 1] === ` ` ? 2 : 1, i5 = e4.slice(t4 + r4);\n      h2(n4, i5, e4);\n      return;\n    }\n    h2(e4, ``, e4);\n  }\n  function h2(e4, t4, i5) {\n    switch (e4) {\n      case `event`:\n        f2 = t4;\n        break;\n      case `data`:\n        d2 = `${d2}${t4}\n`;\n        break;\n      case `id`:\n        u3 = t4.includes(`\\x00`) ? undefined : t4;\n        break;\n      case `retry`:\n        /^\\d+$/.test(t4) ? r3(parseInt(t4, 10)) : n3(new a4(`Invalid \\`retry\\` value: "${t4}"`, { type: `invalid-retry`, value: t4, line: i5 }));\n        break;\n      default:\n        n3(new a4(`Unknown field "${e4.length > 20 ? `${e4.slice(0, 20)}` : e4}"`, { type: `unknown-field`, field: e4, value: t4, line: i5 }));\n        break;\n    }\n  }\n  function g2() {\n    d2.length > 0 && t3({ id: u3, event: f2 || undefined, data: d2.endsWith(`\n`) ? d2.slice(0, -1) : d2 }), u3 = undefined, d2 = ``, f2 = ``;\n  }\n  function _2(e4 = {}) {\n    s4 && e4.consume && m2(s4), l2 = true, u3 = undefined, d2 = ``, f2 = ``, s4 = ``;\n  }\n  return { feed: p2, reset: _2 };\n}\nfunction c3(e3) {\n  let t3 = [], n3 = ``, r3 = 0;\n  for (;r3 < e3.length; ) {\n    let i4 = e3.indexOf(`\\r`, r3), a5 = e3.indexOf(`\n`, r3), o3 = -1;\n    if (i4 !== -1 && a5 !== -1 ? o3 = Math.min(i4, a5) : i4 === -1 ? a5 !== -1 && (o3 = a5) : o3 = i4 === e3.length - 1 ? -1 : i4, o3 === -1) {\n      n3 = e3.slice(r3);\n      break;\n    } else {\n      let n4 = e3.slice(r3, o3);\n      t3.push(n4), r3 = o3 + 1, e3[r3 - 1] === `\\r` && e3[r3] === `\n` && r3++;\n    }\n  }\n  return [t3, n3];\n}\nvar l2 = class extends TransformStream {\n  constructor({ onError: e3, onRetry: t3, onComment: n3 } = {}) {\n    let r3;\n    super({ start(i4) {\n      r3 = s3({ onEvent: (e4) => {\n        i4.enqueue(e4);\n      }, onError(t4) {\n        e3 === `terminate` ? i4.error(t4) : typeof e3 == `function` && e3(t4);\n      }, onRetry: t3, onComment: n3 });\n    }, transform(e4) {\n      r3.feed(e4);\n    } });\n  }\n};\nvar b = `vercel.ai.error`;\nvar x2 = Symbol.for(b);\nvar S;\nvar C = class e3 extends Error {\n  constructor({ name: e4, message: t3, cause: n3 }) {\n    super(t3), this[S] = true, this.name = e4, this.cause = n3;\n  }\n  static isInstance(t3) {\n    return e3.hasMarker(t3, b);\n  }\n  static hasMarker(e4, t3) {\n    let n3 = Symbol.for(t3);\n    return typeof e4 == `object` && !!e4 && n3 in e4 && typeof e4[n3] == `boolean` && e4[n3] === true;\n  }\n};\nS = x2;\nvar w = C;\nvar ee = `AI_APICallError`;\nvar te = `vercel.ai.error.${ee}`;\nvar ne = Symbol.for(te);\nvar re;\nvar T = class extends w {\n  constructor({ message: e4, url: t3, requestBodyValues: n3, statusCode: r3, responseHeaders: i4, responseBody: a5, cause: o3, isRetryable: s4 = r3 != null && (r3 === 408 || r3 === 409 || r3 === 429 || r3 >= 500), data: c4 }) {\n    super({ name: ee, message: e4, cause: o3 }), this[re] = true, this.url = t3, this.requestBodyValues = n3, this.statusCode = r3, this.responseHeaders = i4, this.responseBody = a5, this.isRetryable = s4, this.data = c4;\n  }\n  static isInstance(e4) {\n    return w.hasMarker(e4, te);\n  }\n};\nre = ne;\nvar ie = `AI_EmptyResponseBodyError`;\nvar ae = `vercel.ai.error.${ie}`;\nvar oe = Symbol.for(ae);\nvar se;\nvar E = class extends w {\n  constructor({ message: e4 = `Empty response body` } = {}) {\n    super({ name: ie, message: e4 }), this[se] = true;\n  }\n  static isInstance(e4) {\n    return w.hasMarker(e4, ae);\n  }\n};\nse = oe;\nfunction ce(e4) {\n  return e4 == null ? `unknown error` : typeof e4 == `string` ? e4 : e4 instanceof Error ? e4.message : JSON.stringify(e4);\n}\nvar le = `AI_InvalidArgumentError`;\nvar ue = `vercel.ai.error.${le}`;\nvar de = Symbol.for(ue);\nvar fe;\nvar D = class extends w {\n  constructor({ message: e4, cause: t3, argument: n3 }) {\n    super({ name: le, message: e4, cause: t3 }), this[fe] = true, this.argument = n3;\n  }\n  static isInstance(e4) {\n    return w.hasMarker(e4, ue);\n  }\n};\nfe = de;\nvar pe = `AI_InvalidPromptError`;\nvar me = `vercel.ai.error.${pe}`;\nvar he = Symbol.for(me);\nvar ge;\nvar _e = class extends w {\n  constructor({ prompt: e4, message: t3, cause: n3 }) {\n    super({ name: pe, message: `Invalid prompt: ${t3}`, cause: n3 }), this[ge] = true, this.prompt = e4;\n  }\n  static isInstance(e4) {\n    return w.hasMarker(e4, me);\n  }\n};\nge = he;\nvar ve = `AI_InvalidResponseDataError`;\nvar ye = `vercel.ai.error.${ve}`;\nvar be = Symbol.for(ye);\nvar xe;\nvar Se = class extends w {\n  constructor({ data: e4, message: t3 = `Invalid response data: ${JSON.stringify(e4)}.` }) {\n    super({ name: ve, message: t3 }), this[xe] = true, this.data = e4;\n  }\n  static isInstance(e4) {\n    return w.hasMarker(e4, ye);\n  }\n};\nxe = be;\nvar Ce = `AI_JSONParseError`;\nvar we = `vercel.ai.error.${Ce}`;\nvar Te = Symbol.for(we);\nvar Ee;\nvar O = class extends w {\n  constructor({ text: e4, cause: t3 }) {\n    super({ name: Ce, message: `JSON parsing failed: Text: ${e4}.\nError message: ${ce(t3)}`, cause: t3 }), this[Ee] = true, this.text = e4;\n  }\n  static isInstance(e4) {\n    return w.hasMarker(e4, we);\n  }\n};\nEe = Te;\nvar De = `AI_LoadAPIKeyError`;\nvar Oe = `vercel.ai.error.${De}`;\nvar ke = Symbol.for(Oe);\nvar Ae;\nvar k = class extends w {\n  constructor({ message: e4 }) {\n    super({ name: De, message: e4 }), this[Ae] = true;\n  }\n  static isInstance(e4) {\n    return w.hasMarker(e4, Oe);\n  }\n};\nAe = ke;\nvar je = `AI_NoSuchModelError`;\nvar Me = `vercel.ai.error.${je}`;\nvar Ne = Symbol.for(Me);\nvar Pe;\nvar Fe = class extends w {\n  constructor({ errorName: e4 = je, modelId: t3, modelType: n3, message: r3 = `No such ${n3}: ${t3}` }) {\n    super({ name: e4, message: r3 }), this[Pe] = true, this.modelId = t3, this.modelType = n3;\n  }\n  static isInstance(e4) {\n    return w.hasMarker(e4, Me);\n  }\n};\nPe = Ne;\nvar Ie = `AI_TooManyEmbeddingValuesForCallError`;\nvar Le = `vercel.ai.error.${Ie}`;\nvar Re = Symbol.for(Le);\nvar ze;\nvar Be = class extends w {\n  constructor(e4) {\n    super({ name: Ie, message: `Too many values for a single embedding call. The ${e4.provider} model "${e4.modelId}" can only embed up to ${e4.maxEmbeddingsPerCall} values per call, but ${e4.values.length} values were provided.` }), this[ze] = true, this.provider = e4.provider, this.modelId = e4.modelId, this.maxEmbeddingsPerCall = e4.maxEmbeddingsPerCall, this.values = e4.values;\n  }\n  static isInstance(e4) {\n    return w.hasMarker(e4, Le);\n  }\n};\nze = Re;\nvar Ve = `AI_TypeValidationError`;\nvar He = `vercel.ai.error.${Ve}`;\nvar Ue = Symbol.for(He);\nvar We;\nvar Ge = class e4 extends w {\n  constructor({ value: e5, cause: t3 }) {\n    super({ name: Ve, message: `Type validation failed: Value: ${JSON.stringify(e5)}.\nError message: ${ce(t3)}`, cause: t3 }), this[We] = true, this.value = e5;\n  }\n  static isInstance(e5) {\n    return w.hasMarker(e5, He);\n  }\n  static wrap({ value: t3, cause: n3 }) {\n    return e4.isInstance(n3) && n3.value === t3 ? n3 : new e4({ value: t3, cause: n3 });\n  }\n};\nWe = Ue;\nvar A = Ge;\nvar Ke = `AI_UnsupportedFunctionalityError`;\nvar qe = `vercel.ai.error.${Ke}`;\nvar Je = Symbol.for(qe);\nvar Ye;\nvar j = class extends w {\n  constructor({ functionality: e5, message: t3 = `\'${e5}\' functionality not supported.` }) {\n    super({ name: Ke, message: t3 }), this[Ye] = true, this.functionality = e5;\n  }\n  static isInstance(e5) {\n    return w.hasMarker(e5, qe);\n  }\n};\nYe = Je;\nfunction Xe(...e5) {\n  return e5.reduce((e6, t3) => ({ ...e6, ...t3 ?? {} }), {});\n}\nfunction M(e5) {\n  return Object.fromEntries([...e5.headers]);\n}\nfunction Ze(e5 = globalThis) {\n  return e5.window ? `runtime/browser` : e5.navigator?.userAgent ? `runtime/${e5.navigator.userAgent.toLowerCase()}` : e5.process?.versions?.node ? `runtime/node.js/${e5.process.version.substring(0)}` : e5.EdgeRuntime ? `runtime/vercel-edge` : `runtime/unknown`;\n}\nfunction Qe(e5) {\n  return Object.fromEntries(Object.entries(e5).filter(([e6, t3]) => t3 != null));\n}\nfunction $e(e5, ...t3) {\n  let n3 = Qe(e5 ?? {}), r3 = new Headers(n3), i4 = r3.get(`user-agent`) || ``;\n  return r3.set(`user-agent`, [i4, ...t3].filter(Boolean).join(` `)), Object.fromEntries(r3);\n}\nvar et = (({ prefix: e5, size: t3 = 16, alphabet: n3 = `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`, separator: r3 = `-` } = {}) => {\n  let i4 = () => {\n    let e6 = n3.length, r4 = Array(t3);\n    for (let i5 = 0;i5 < t3; i5++)\n      r4[i5] = n3[Math.random() * e6 | 0];\n    return r4.join(``);\n  };\n  if (e5 == null)\n    return i4;\n  if (n3.includes(r3))\n    throw new D({ argument: `separator`, message: `The separator "${r3}" must not be part of the alphabet "${n3}".` });\n  return () => `${e5}${r3}${i4()}`;\n})();\nfunction tt(e5) {\n  return (e5 instanceof Error || e5 instanceof DOMException) && (e5.name === `AbortError` || e5.name === `ResponseAborted` || e5.name === `TimeoutError`);\n}\nvar nt = [`fetch failed`, `failed to fetch`];\nfunction rt({ error: e5, url: t3, requestBodyValues: n3 }) {\n  if (tt(e5))\n    return e5;\n  if (e5 instanceof TypeError && nt.includes(e5.message.toLowerCase())) {\n    let r3 = e5.cause;\n    if (r3 != null)\n      return new T({ message: `Cannot connect to API: ${r3.message}`, cause: r3, url: t3, requestBodyValues: n3, isRetryable: true });\n  }\n  return e5;\n}\nvar it = `3.0.10`;\nfunction at({ apiKey: e5, environmentVariableName: t3, apiKeyParameterName: n3 = `apiKey`, description: r3 }) {\n  if (typeof e5 == `string`)\n    return e5;\n  if (e5 != null)\n    throw new k({ message: `${r3} API key must be a string.` });\n  if (typeof process > `u`)\n    throw new k({ message: `${r3} API key is missing. Pass it using the \'${n3}\' parameter. Environment variables is not supported in this environment.` });\n  if (e5 = process.env[t3], e5 == null)\n    throw new k({ message: `${r3} API key is missing. Pass it using the \'${n3}\' parameter or the ${t3} environment variable.` });\n  if (typeof e5 != `string`)\n    throw new k({ message: `${r3} API key must be a string. The value of the ${t3} environment variable is not a string.` });\n  return e5;\n}\nvar ot = /"__proto__"\\s*:/;\nvar st = /"constructor"\\s*:/;\nfunction ct(e5) {\n  let t3 = JSON.parse(e5);\n  return typeof t3 != `object` || !t3 || ot.test(e5) === false && st.test(e5) === false ? t3 : lt(t3);\n}\nfunction lt(e5) {\n  let t3 = [e5];\n  for (;t3.length; ) {\n    let e6 = t3;\n    t3 = [];\n    for (let n3 of e6) {\n      if (Object.prototype.hasOwnProperty.call(n3, `__proto__`) || Object.prototype.hasOwnProperty.call(n3, `constructor`) && Object.prototype.hasOwnProperty.call(n3.constructor, `prototype`))\n        throw SyntaxError(`Object contains forbidden prototype property`);\n      for (let e7 in n3) {\n        let r3 = n3[e7];\n        r3 && typeof r3 == `object` && t3.push(r3);\n      }\n    }\n  }\n  return e5;\n}\nfunction ut(e5) {\n  let { stackTraceLimit: t3 } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return ct(e5);\n  } finally {\n    Error.stackTraceLimit = t3;\n  }\n}\nvar dt = Symbol.for(`vercel.ai.validator`);\nfunction ft(e5) {\n  return { [dt]: true, validate: e5 };\n}\nfunction pt(e5) {\n  return typeof e5 == `object` && !!e5 && dt in e5 && e5[dt] === true && `validate` in e5;\n}\nfunction mt(e5) {\n  return pt(e5) ? e5 : ht(e5);\n}\nfunction ht(e5) {\n  return ft(async (t3) => {\n    let n3 = await e5[`~standard`].validate(t3);\n    return n3.issues == null ? { success: true, value: n3.value } : { success: false, error: new A({ value: t3, cause: n3.issues }) };\n  });\n}\nasync function gt({ value: e5, schema: t3 }) {\n  let n3 = await _t({ value: e5, schema: t3 });\n  if (!n3.success)\n    throw A.wrap({ value: e5, cause: n3.error });\n  return n3.value;\n}\nasync function _t({ value: e5, schema: t3 }) {\n  let n3 = mt(t3);\n  try {\n    if (n3.validate == null)\n      return { success: true, value: e5, rawValue: e5 };\n    let t4 = await n3.validate(e5);\n    return t4.success ? { success: true, value: t4.value, rawValue: e5 } : { success: false, error: A.wrap({ value: e5, cause: t4.error }), rawValue: e5 };\n  } catch (t4) {\n    return { success: false, error: A.wrap({ value: e5, cause: t4 }), rawValue: e5 };\n  }\n}\nasync function vt({ text: e5, schema: t3 }) {\n  try {\n    let n3 = ut(e5);\n    return t3 == null ? n3 : gt({ value: n3, schema: t3 });\n  } catch (t4) {\n    throw O.isInstance(t4) || A.isInstance(t4) ? t4 : new O({ text: e5, cause: t4 });\n  }\n}\nasync function yt({ text: e5, schema: t3 }) {\n  try {\n    let n3 = ut(e5);\n    return t3 == null ? { success: true, value: n3, rawValue: n3 } : await _t({ value: n3, schema: t3 });\n  } catch (t4) {\n    return { success: false, error: O.isInstance(t4) ? t4 : new O({ text: e5, cause: t4 }), rawValue: undefined };\n  }\n}\nfunction bt({ stream: e5, schema: t3 }) {\n  return e5.pipeThrough(new TextDecoderStream).pipeThrough(new l2).pipeThrough(new TransformStream({ async transform({ data: e6 }, n3) {\n    e6 !== `[DONE]` && n3.enqueue(await yt({ text: e6, schema: t3 }));\n  } }));\n}\nasync function N({ provider: e5, providerOptions: t3, schema: n3 }) {\n  if (t3?.[e5] == null)\n    return;\n  let r3 = await _t({ value: t3[e5], schema: n3 });\n  if (!r3.success)\n    throw new D({ argument: `providerOptions`, message: `invalid ${e5} provider options`, cause: r3.error });\n  return r3.value;\n}\nvar xt = () => globalThis.fetch;\nvar St = async ({ url: e5, headers: t3, body: n3, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 }) => Ct({ url: e5, headers: { "Content-Type": `application/json`, ...t3 }, body: { content: JSON.stringify(n3), values: n3 }, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 });\nvar Ct = async ({ url: e5, headers: t3 = {}, body: n3, successfulResponseHandler: r3, failedResponseHandler: i4, abortSignal: a5, fetch: o3 = xt() }) => {\n  try {\n    let s4 = await o3(e5, { method: `POST`, headers: $e(t3, `ai-sdk/provider-utils/${it}`, Ze()), body: n3.content, signal: a5 }), c4 = M(s4);\n    if (!s4.ok) {\n      let t4;\n      try {\n        t4 = await i4({ response: s4, url: e5, requestBodyValues: n3.values });\n      } catch (t5) {\n        throw tt(t5) || T.isInstance(t5) ? t5 : new T({ message: `Failed to process error response`, cause: t5, statusCode: s4.status, url: e5, responseHeaders: c4, requestBodyValues: n3.values });\n      }\n      throw t4.value;\n    }\n    try {\n      return await r3({ response: s4, url: e5, requestBodyValues: n3.values });\n    } catch (t4) {\n      throw t4 instanceof Error && (tt(t4) || T.isInstance(t4)) ? t4 : new T({ message: `Failed to process successful response`, cause: t4, statusCode: s4.status, url: e5, responseHeaders: c4, requestBodyValues: n3.values });\n    }\n  } catch (t4) {\n    throw rt({ error: t4, url: e5, requestBodyValues: n3.values });\n  }\n};\nfunction wt(e5) {\n  return e5;\n}\nfunction P({ id: e5, name: t3, inputSchema: n3 }) {\n  return ({ execute: r3, outputSchema: i4, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4, ...l3 }) => wt({ type: `provider-defined`, id: e5, name: t3, args: l3, inputSchema: n3, outputSchema: i4, execute: r3, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4 });\n}\nfunction Tt({ id: e5, name: t3, inputSchema: n3, outputSchema: r3 }) {\n  return ({ execute: i4, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4, ...l3 }) => wt({ type: `provider-defined`, id: e5, name: t3, args: l3, inputSchema: n3, outputSchema: r3, execute: i4, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4 });\n}\nasync function Et(e5) {\n  return typeof e5 == `function` && (e5 = e5()), Promise.resolve(e5);\n}\nvar Dt = ({ errorSchema: e5, errorToMessage: t3, isRetryable: n3 }) => async ({ response: r3, url: i4, requestBodyValues: a5 }) => {\n  let o3 = await r3.text(), s4 = M(r3);\n  if (o3.trim() === ``)\n    return { responseHeaders: s4, value: new T({ message: r3.statusText, url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, isRetryable: n3?.(r3) }) };\n  try {\n    let c4 = await vt({ text: o3, schema: e5 });\n    return { responseHeaders: s4, value: new T({ message: t3(c4), url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, data: c4, isRetryable: n3?.(r3, c4) }) };\n  } catch {\n    return { responseHeaders: s4, value: new T({ message: r3.statusText, url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, isRetryable: n3?.(r3) }) };\n  }\n};\nvar Ot = (e5) => async ({ response: t3 }) => {\n  let n3 = M(t3);\n  if (t3.body == null)\n    throw new E({});\n  return { responseHeaders: n3, value: bt({ stream: t3.body, schema: e5 }) };\n};\nvar kt = (e5) => async ({ response: t3, url: n3, requestBodyValues: r3 }) => {\n  let i4 = await t3.text(), a5 = await yt({ text: i4, schema: e5 }), o3 = M(t3);\n  if (!a5.success)\n    throw new T({ message: `Invalid JSON response`, cause: a5.error, statusCode: t3.status, responseHeaders: o3, responseBody: i4, url: n3, requestBodyValues: r3 });\n  return { responseHeaders: o3, value: a5.value, rawValue: a5.rawValue };\n};\nvar { btoa: At, atob: jt } = globalThis;\nfunction Mt(e5) {\n  let t3 = ``;\n  for (let n3 = 0;n3 < e5.length; n3++)\n    t3 += String.fromCodePoint(e5[n3]);\n  return At(t3);\n}\nfunction Nt(e5) {\n  return e5 instanceof Uint8Array ? Mt(e5) : e5;\n}\nfunction Pt(e5) {\n  return e5?.replace(/\\/$/, ``);\n}\nvar Ft = `2.0.23`;\nvar It = exports_external.object({ type: exports_external.literal(`error`), error: exports_external.object({ type: exports_external.string(), message: exports_external.string() }) });\nvar Lt = Dt({ errorSchema: It, errorToMessage: (e5) => e5.error.message });\nvar Rt = exports_external.object({ citations: exports_external.object({ enabled: exports_external.boolean() }).optional(), title: exports_external.string().optional(), context: exports_external.string().optional() });\nvar zt = exports_external.object({ sendReasoning: exports_external.boolean().optional(), thinking: exports_external.object({ type: exports_external.union([exports_external.literal(`enabled`), exports_external.literal(`disabled`)]), budgetTokens: exports_external.number().optional() }).optional(), disableParallelToolUse: exports_external.boolean().optional(), cacheControl: exports_external.object({ type: exports_external.literal(`ephemeral`), ttl: exports_external.union([exports_external.literal(`5m`), exports_external.literal(`1h`)]).optional() }).optional() });\nfunction F(e5) {\n  let t3 = e5?.anthropic;\n  return t3?.cacheControl ?? t3?.cache_control;\n}\nvar Bt = exports_external.object({ maxCharacters: exports_external.number().optional() });\nvar Vt = P({ id: `anthropic.text_editor_20250728`, name: `str_replace_based_edit_tool`, inputSchema: exports_external.object({ command: exports_external.enum([`view`, `create`, `str_replace`, `insert`]), path: exports_external.string(), file_text: exports_external.string().optional(), insert_line: exports_external.number().int().optional(), new_str: exports_external.string().optional(), old_str: exports_external.string().optional(), view_range: exports_external.array(exports_external.number().int()).optional() }) });\nvar Ht = (e5 = {}) => Vt(e5);\nvar Ut = exports_external.object({ maxUses: exports_external.number().optional(), allowedDomains: exports_external.array(exports_external.string()).optional(), blockedDomains: exports_external.array(exports_external.string()).optional(), userLocation: exports_external.object({ type: exports_external.literal(`approximate`), city: exports_external.string().optional(), region: exports_external.string().optional(), country: exports_external.string().optional(), timezone: exports_external.string().optional() }).optional() });\nvar Wt = exports_external.array(exports_external.object({ url: exports_external.string(), title: exports_external.string(), pageAge: exports_external.string().nullable(), encryptedContent: exports_external.string(), type: exports_external.literal(`web_search_result`) }));\nvar Gt = Tt({ id: `anthropic.web_search_20250305`, name: `web_search`, inputSchema: exports_external.object({ query: exports_external.string() }), outputSchema: Wt });\nvar Kt = (e5 = {}) => Gt(e5);\nvar qt = exports_external.object({ maxUses: exports_external.number().optional(), allowedDomains: exports_external.array(exports_external.string()).optional(), blockedDomains: exports_external.array(exports_external.string()).optional(), citations: exports_external.object({ enabled: exports_external.boolean() }).optional(), maxContentTokens: exports_external.number().optional() });\nvar Jt = exports_external.object({ type: exports_external.literal(`web_fetch_result`), url: exports_external.string(), content: exports_external.object({ type: exports_external.literal(`document`), title: exports_external.string(), citations: exports_external.object({ enabled: exports_external.boolean() }).optional(), source: exports_external.union([exports_external.object({ type: exports_external.literal(`base64`), mediaType: exports_external.literal(`application/pdf`), data: exports_external.string() }), exports_external.object({ type: exports_external.literal(`text`), mediaType: exports_external.literal(`text/plain`), data: exports_external.string() })]) }), retrievedAt: exports_external.string().nullable() });\nvar Yt = Tt({ id: `anthropic.web_fetch_20250910`, name: `web_fetch`, inputSchema: exports_external.object({ url: exports_external.string() }), outputSchema: Jt });\nvar Xt = (e5 = {}) => Yt(e5);\nfunction Zt({ tools: e5, toolChoice: t3, disableParallelToolUse: n3 }) {\n  e5 = e5?.length ? e5 : undefined;\n  let r3 = [], i4 = new Set;\n  if (e5 == null)\n    return { tools: undefined, toolChoice: undefined, toolWarnings: r3, betas: i4 };\n  let a5 = [];\n  for (let t4 of e5)\n    switch (t4.type) {\n      case `function`: {\n        let e6 = F(t4.providerOptions);\n        a5.push({ name: t4.name, description: t4.description, input_schema: t4.inputSchema, cache_control: e6 });\n        break;\n      }\n      case `provider-defined`:\n        switch (t4.id) {\n          case `anthropic.code_execution_20250522`:\n            i4.add(`code-execution-2025-05-22`), a5.push({ type: `code_execution_20250522`, name: `code_execution` });\n            break;\n          case `anthropic.computer_20250124`:\n            i4.add(`computer-use-2025-01-24`), a5.push({ name: `computer`, type: `computer_20250124`, display_width_px: t4.args.displayWidthPx, display_height_px: t4.args.displayHeightPx, display_number: t4.args.displayNumber });\n            break;\n          case `anthropic.computer_20241022`:\n            i4.add(`computer-use-2024-10-22`), a5.push({ name: `computer`, type: `computer_20241022`, display_width_px: t4.args.displayWidthPx, display_height_px: t4.args.displayHeightPx, display_number: t4.args.displayNumber });\n            break;\n          case `anthropic.text_editor_20250124`:\n            i4.add(`computer-use-2025-01-24`), a5.push({ name: `str_replace_editor`, type: `text_editor_20250124` });\n            break;\n          case `anthropic.text_editor_20241022`:\n            i4.add(`computer-use-2024-10-22`), a5.push({ name: `str_replace_editor`, type: `text_editor_20241022` });\n            break;\n          case `anthropic.text_editor_20250429`:\n            i4.add(`computer-use-2025-01-24`), a5.push({ name: `str_replace_based_edit_tool`, type: `text_editor_20250429` });\n            break;\n          case `anthropic.text_editor_20250728`: {\n            let e6 = Bt.parse(t4.args);\n            a5.push({ name: `str_replace_based_edit_tool`, type: `text_editor_20250728`, max_characters: e6.maxCharacters });\n            break;\n          }\n          case `anthropic.bash_20250124`:\n            i4.add(`computer-use-2025-01-24`), a5.push({ name: `bash`, type: `bash_20250124` });\n            break;\n          case `anthropic.bash_20241022`:\n            i4.add(`computer-use-2024-10-22`), a5.push({ name: `bash`, type: `bash_20241022` });\n            break;\n          case `anthropic.web_fetch_20250910`: {\n            i4.add(`web-fetch-2025-09-10`);\n            let e6 = qt.parse(t4.args);\n            a5.push({ type: `web_fetch_20250910`, name: `web_fetch`, max_uses: e6.maxUses, allowed_domains: e6.allowedDomains, blocked_domains: e6.blockedDomains, citations: e6.citations, max_content_tokens: e6.maxContentTokens });\n            break;\n          }\n          case `anthropic.web_search_20250305`: {\n            let e6 = Ut.parse(t4.args);\n            a5.push({ type: `web_search_20250305`, name: `web_search`, max_uses: e6.maxUses, allowed_domains: e6.allowedDomains, blocked_domains: e6.blockedDomains, user_location: e6.userLocation });\n            break;\n          }\n          default:\n            r3.push({ type: `unsupported-tool`, tool: t4 });\n            break;\n        }\n        break;\n      default:\n        r3.push({ type: `unsupported-tool`, tool: t4 });\n        break;\n    }\n  if (t3 == null)\n    return { tools: a5, toolChoice: n3 ? { type: `auto`, disable_parallel_tool_use: n3 } : undefined, toolWarnings: r3, betas: i4 };\n  let o3 = t3.type;\n  switch (o3) {\n    case `auto`:\n      return { tools: a5, toolChoice: { type: `auto`, disable_parallel_tool_use: n3 }, toolWarnings: r3, betas: i4 };\n    case `required`:\n      return { tools: a5, toolChoice: { type: `any`, disable_parallel_tool_use: n3 }, toolWarnings: r3, betas: i4 };\n    case `none`:\n      return { tools: undefined, toolChoice: undefined, toolWarnings: r3, betas: i4 };\n    case `tool`:\n      return { tools: a5, toolChoice: { type: `tool`, name: t3.toolName, disable_parallel_tool_use: n3 }, toolWarnings: r3, betas: i4 };\n    default:\n      throw new j({ functionality: `tool choice type: ${o3}` });\n  }\n}\nvar Qt = exports_external.object({ type: exports_external.literal(`code_execution_result`), stdout: exports_external.string(), stderr: exports_external.string(), return_code: exports_external.number() });\nvar $t = Tt({ id: `anthropic.code_execution_20250522`, name: `code_execution`, inputSchema: exports_external.object({ code: exports_external.string() }), outputSchema: Qt });\nvar en = (e5 = {}) => $t(e5);\nfunction tn(e5) {\n  if (typeof e5 == `string`)\n    return Buffer.from(e5, `base64`).toString(`utf-8`);\n  if (e5 instanceof Uint8Array)\n    return new TextDecoder().decode(e5);\n  throw e5 instanceof URL ? new j({ functionality: `URL-based text documents are not supported for citations` }) : new j({ functionality: `unsupported data type for text documents: ${typeof e5}` });\n}\nasync function nn({ prompt: e5, sendReasoning: t3, warnings: n3 }) {\n  let r3 = new Set, i4 = rn(e5), a5, o3 = [];\n  async function s4(e6) {\n    return (await N({ provider: `anthropic`, providerOptions: e6, schema: Rt }))?.citations?.enabled ?? false;\n  }\n  async function c4(e6) {\n    let t4 = await N({ provider: `anthropic`, providerOptions: e6, schema: Rt });\n    return { title: t4?.title, context: t4?.context };\n  }\n  for (let e6 = 0;e6 < i4.length; e6++) {\n    let l3 = i4[e6], u3 = e6 === i4.length - 1, d2 = l3.type;\n    switch (d2) {\n      case `system`:\n        if (a5 != null)\n          throw new j({ functionality: `Multiple system messages that are separated by user/assistant messages` });\n        a5 = l3.messages.map(({ content: e7, providerOptions: t4 }) => ({ type: `text`, text: e7, cache_control: F(t4) }));\n        break;\n      case `user`: {\n        let e7 = [];\n        for (let t4 of l3.messages) {\n          let { role: n4, content: i5 } = t4;\n          switch (n4) {\n            case `user`:\n              for (let n5 = 0;n5 < i5.length; n5++) {\n                let a6 = i5[n5], o4 = n5 === i5.length - 1, l4 = F(a6.providerOptions) ?? (o4 ? F(t4.providerOptions) : undefined);\n                switch (a6.type) {\n                  case `text`:\n                    e7.push({ type: `text`, text: a6.text, cache_control: l4 });\n                    break;\n                  case `file`:\n                    if (a6.mediaType.startsWith(`image/`))\n                      e7.push({ type: `image`, source: a6.data instanceof URL ? { type: `url`, url: a6.data.toString() } : { type: `base64`, media_type: a6.mediaType === `image/*` ? `image/jpeg` : a6.mediaType, data: Nt(a6.data) }, cache_control: l4 });\n                    else if (a6.mediaType === `application/pdf`) {\n                      r3.add(`pdfs-2024-09-25`);\n                      let t5 = await s4(a6.providerOptions), n6 = await c4(a6.providerOptions);\n                      e7.push({ type: `document`, source: a6.data instanceof URL ? { type: `url`, url: a6.data.toString() } : { type: `base64`, media_type: `application/pdf`, data: Nt(a6.data) }, title: n6.title ?? a6.filename, ...n6.context && { context: n6.context }, ...t5 && { citations: { enabled: true } }, cache_control: l4 });\n                    } else if (a6.mediaType === `text/plain`) {\n                      let t5 = await s4(a6.providerOptions), n6 = await c4(a6.providerOptions);\n                      e7.push({ type: `document`, source: a6.data instanceof URL ? { type: `url`, url: a6.data.toString() } : { type: `text`, media_type: `text/plain`, data: tn(a6.data) }, title: n6.title ?? a6.filename, ...n6.context && { context: n6.context }, ...t5 && { citations: { enabled: true } }, cache_control: l4 });\n                    } else\n                      throw new j({ functionality: `media type: ${a6.mediaType}` });\n                    break;\n                }\n              }\n              break;\n            case `tool`:\n              for (let n5 = 0;n5 < i5.length; n5++) {\n                let r4 = i5[n5], a6 = n5 === i5.length - 1, o4 = F(r4.providerOptions) ?? (a6 ? F(t4.providerOptions) : undefined), s5 = r4.output, c5;\n                switch (s5.type) {\n                  case `content`:\n                    c5 = s5.value.map((e8) => {\n                      switch (e8.type) {\n                        case `text`:\n                          return { type: `text`, text: e8.text, cache_control: undefined };\n                        case `media`:\n                          if (e8.mediaType.startsWith(`image/`))\n                            return { type: `image`, source: { type: `base64`, media_type: e8.mediaType, data: e8.data }, cache_control: undefined };\n                          throw new j({ functionality: `media type: ${e8.mediaType}` });\n                      }\n                    });\n                    break;\n                  case `text`:\n                  case `error-text`:\n                    c5 = s5.value;\n                    break;\n                  case `json`:\n                  case `error-json`:\n                  default:\n                    c5 = JSON.stringify(s5.value);\n                    break;\n                }\n                e7.push({ type: `tool_result`, tool_use_id: r4.toolCallId, content: c5, is_error: s5.type === `error-text` || s5.type === `error-json` ? true : undefined, cache_control: o4 });\n              }\n              break;\n            default: {\n              let e8 = n4;\n              throw Error(`Unsupported role: ${e8}`);\n            }\n          }\n        }\n        o3.push({ role: `user`, content: e7 });\n        break;\n      }\n      case `assistant`: {\n        let e7 = [];\n        for (let r4 = 0;r4 < l3.messages.length; r4++) {\n          let i5 = l3.messages[r4], a6 = r4 === l3.messages.length - 1, { content: o4 } = i5;\n          for (let r5 = 0;r5 < o4.length; r5++) {\n            let s5 = o4[r5], c5 = r5 === o4.length - 1, l4 = F(s5.providerOptions) ?? (c5 ? F(i5.providerOptions) : undefined);\n            switch (s5.type) {\n              case `text`:\n                e7.push({ type: `text`, text: u3 && a6 && c5 ? s5.text.trim() : s5.text, cache_control: l4 });\n                break;\n              case `reasoning`:\n                if (t3) {\n                  let t4 = await N({ provider: `anthropic`, providerOptions: s5.providerOptions, schema: fn });\n                  t4 == null ? n3.push({ type: `other`, message: `unsupported reasoning metadata` }) : t4.signature == null ? t4.redactedData == null ? n3.push({ type: `other`, message: `unsupported reasoning metadata` }) : e7.push({ type: `redacted_thinking`, data: t4.redactedData, cache_control: l4 }) : e7.push({ type: `thinking`, thinking: s5.text, signature: t4.signature, cache_control: l4 });\n                } else\n                  n3.push({ type: `other`, message: `sending reasoning content is disabled for this model` });\n                break;\n              case `tool-call`:\n                if (s5.providerExecuted) {\n                  s5.toolName === `code_execution` || s5.toolName === `web_fetch` || s5.toolName === `web_search` ? e7.push({ type: `server_tool_use`, id: s5.toolCallId, name: s5.toolName, input: s5.input, cache_control: l4 }) : n3.push({ type: `other`, message: `provider executed tool call for tool ${s5.toolName} is not supported` });\n                  break;\n                }\n                e7.push({ type: `tool_use`, id: s5.toolCallId, name: s5.toolName, input: s5.input, cache_control: l4 });\n                break;\n              case `tool-result`:\n                if (s5.toolName === `code_execution`) {\n                  let t4 = s5.output;\n                  if (t4.type !== `json`) {\n                    n3.push({ type: `other`, message: `provider executed tool result output type ${t4.type} for tool ${s5.toolName} is not supported` });\n                    break;\n                  }\n                  let r6 = Qt.parse(t4.value);\n                  e7.push({ type: `code_execution_tool_result`, tool_use_id: s5.toolCallId, content: { type: r6.type, stdout: r6.stdout, stderr: r6.stderr, return_code: r6.return_code }, cache_control: l4 });\n                  break;\n                }\n                if (s5.toolName === `web_fetch`) {\n                  let t4 = s5.output;\n                  if (t4.type !== `json`) {\n                    n3.push({ type: `other`, message: `provider executed tool result output type ${t4.type} for tool ${s5.toolName} is not supported` });\n                    break;\n                  }\n                  let r6 = Jt.parse(t4.value);\n                  e7.push({ type: `web_fetch_tool_result`, tool_use_id: s5.toolCallId, content: { type: `web_fetch_result`, url: r6.url, retrieved_at: r6.retrievedAt, content: { type: `document`, title: r6.content.title, citations: r6.content.citations, source: { type: r6.content.source.type, media_type: r6.content.source.mediaType, data: r6.content.source.data } } }, cache_control: l4 });\n                  break;\n                }\n                if (s5.toolName === `web_search`) {\n                  let t4 = s5.output;\n                  if (t4.type !== `json`) {\n                    n3.push({ type: `other`, message: `provider executed tool result output type ${t4.type} for tool ${s5.toolName} is not supported` });\n                    break;\n                  }\n                  let r6 = Wt.parse(t4.value);\n                  e7.push({ type: `web_search_tool_result`, tool_use_id: s5.toolCallId, content: r6.map((e8) => ({ url: e8.url, title: e8.title, page_age: e8.pageAge, encrypted_content: e8.encryptedContent, type: e8.type })), cache_control: l4 });\n                  break;\n                }\n                n3.push({ type: `other`, message: `provider executed tool result for tool ${s5.toolName} is not supported` });\n                break;\n            }\n          }\n        }\n        o3.push({ role: `assistant`, content: e7 });\n        break;\n      }\n      default: {\n        let e7 = d2;\n        throw Error(`content type: ${e7}`);\n      }\n    }\n  }\n  return { prompt: { system: a5, messages: o3 }, betas: r3 };\n}\nfunction rn(e5) {\n  let t3 = [], n3;\n  for (let r3 of e5) {\n    let { role: e6 } = r3;\n    switch (e6) {\n      case `system`:\n        n3?.type !== `system` && (n3 = { type: `system`, messages: [] }, t3.push(n3)), n3.messages.push(r3);\n        break;\n      case `assistant`:\n        n3?.type !== `assistant` && (n3 = { type: `assistant`, messages: [] }, t3.push(n3)), n3.messages.push(r3);\n        break;\n      case `user`:\n        n3?.type !== `user` && (n3 = { type: `user`, messages: [] }, t3.push(n3)), n3.messages.push(r3);\n        break;\n      case `tool`:\n        n3?.type !== `user` && (n3 = { type: `user`, messages: [] }, t3.push(n3)), n3.messages.push(r3);\n        break;\n      default: {\n        let t4 = e6;\n        throw Error(`Unsupported role: ${t4}`);\n      }\n    }\n  }\n  return t3;\n}\nfunction an({ finishReason: e5, isJsonResponseFromTool: t3 }) {\n  switch (e5) {\n    case `pause_turn`:\n    case `end_turn`:\n    case `stop_sequence`:\n      return `stop`;\n    case `refusal`:\n      return `content-filter`;\n    case `tool_use`:\n      return t3 ? `stop` : `tool-calls`;\n    case `max_tokens`:\n      return `length`;\n    default:\n      return `unknown`;\n  }\n}\nvar I = { webSearchResult: exports_external.object({ type: exports_external.literal(`web_search_result_location`), cited_text: exports_external.string(), url: exports_external.string(), title: exports_external.string(), encrypted_index: exports_external.string() }), pageLocation: exports_external.object({ type: exports_external.literal(`page_location`), cited_text: exports_external.string(), document_index: exports_external.number(), document_title: exports_external.string().nullable(), start_page_number: exports_external.number(), end_page_number: exports_external.number() }), charLocation: exports_external.object({ type: exports_external.literal(`char_location`), cited_text: exports_external.string(), document_index: exports_external.number(), document_title: exports_external.string().nullable(), start_char_index: exports_external.number(), end_char_index: exports_external.number() }) };\nvar on = exports_external.discriminatedUnion(`type`, [I.webSearchResult, I.pageLocation, I.charLocation]);\nexports_external.discriminatedUnion(`type`, [I.pageLocation, I.charLocation]);\nfunction sn(e5, t3, n3, r3) {\n  if (e5.type === `page_location` || e5.type === `char_location`) {\n    let i4 = cn(e5, t3, n3);\n    i4 && r3(i4);\n  }\n}\nfunction cn(e5, t3, n3) {\n  let r3 = t3[e5.document_index];\n  if (!r3)\n    return null;\n  let i4 = e5.type === `page_location` ? { citedText: e5.cited_text, startPageNumber: e5.start_page_number, endPageNumber: e5.end_page_number } : { citedText: e5.cited_text, startCharIndex: e5.start_char_index, endCharIndex: e5.end_char_index };\n  return { type: `source`, sourceType: `document`, id: n3(), mediaType: r3.mediaType, title: e5.document_title ?? r3.title, filename: r3.filename, providerMetadata: { anthropic: i4 } };\n}\nvar ln = class {\n  constructor(e5, t3) {\n    this.specificationVersion = `v2`, this.modelId = e5, this.config = t3, this.generateId = t3.generateId ?? et;\n  }\n  supportsUrl(e5) {\n    return e5.protocol === `https:`;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get supportedUrls() {\n    var e5;\n    return (e5 = this.config).supportedUrls?.call(e5) ?? {};\n  }\n  async getArgs({ prompt: e5, maxOutputTokens: t3 = 4096, temperature: n3, topP: r3, topK: i4, frequencyPenalty: a5, presencePenalty: o3, stopSequences: s4, responseFormat: c4, seed: l3, tools: u3, toolChoice: d2, providerOptions: f2 }) {\n    let p2 = [];\n    a5 != null && p2.push({ type: `unsupported-setting`, setting: `frequencyPenalty` }), o3 != null && p2.push({ type: `unsupported-setting`, setting: `presencePenalty` }), l3 != null && p2.push({ type: `unsupported-setting`, setting: `seed` }), c4?.type === `json` && (c4.schema == null ? p2.push({ type: `unsupported-setting`, setting: `responseFormat`, details: `JSON response format requires a schema. The response format is ignored.` }) : u3 != null && p2.push({ type: `unsupported-setting`, setting: `tools`, details: `JSON response format does not support tools. The provided tools are ignored.` }));\n    let m2 = c4?.type === `json` && c4.schema != null ? { type: `function`, name: `json`, description: `Respond with a JSON object.`, inputSchema: c4.schema } : undefined, h2 = await N({ provider: `anthropic`, providerOptions: f2, schema: zt }), { prompt: g2, betas: _2 } = await nn({ prompt: e5, sendReasoning: h2?.sendReasoning ?? true, warnings: p2 }), v2 = h2?.thinking?.type === `enabled`, y2 = h2?.thinking?.budgetTokens, b2 = { model: this.modelId, max_tokens: t3, temperature: n3, top_k: i4, top_p: r3, stop_sequences: s4, ...v2 && { thinking: { type: `enabled`, budget_tokens: y2 } }, system: g2.system, messages: g2.messages };\n    if (v2) {\n      if (y2 == null)\n        throw new j({ functionality: `thinking requires a budget` });\n      b2.temperature != null && (b2.temperature = undefined, p2.push({ type: `unsupported-setting`, setting: `temperature`, details: `temperature is not supported when thinking is enabled` })), i4 != null && (b2.top_k = undefined, p2.push({ type: `unsupported-setting`, setting: `topK`, details: `topK is not supported when thinking is enabled` })), r3 != null && (b2.top_p = undefined, p2.push({ type: `unsupported-setting`, setting: `topP`, details: `topP is not supported when thinking is enabled` })), b2.max_tokens = t3 + y2;\n    }\n    let { tools: x3, toolChoice: S2, toolWarnings: C2, betas: w2 } = Zt(m2 == null ? { tools: u3 ?? [], toolChoice: d2, disableParallelToolUse: h2?.disableParallelToolUse } : { tools: [m2], toolChoice: { type: `tool`, toolName: m2.name }, disableParallelToolUse: true });\n    return { args: { ...b2, tools: x3, tool_choice: S2 }, warnings: [...p2, ...C2], betas: new Set([..._2, ...w2]), usesJsonResponseTool: m2 != null };\n  }\n  async getHeaders({ betas: e5, headers: t3 }) {\n    return Xe(await Et(this.config.headers), e5.size > 0 ? { "anthropic-beta": Array.from(e5).join(`,`) } : {}, t3);\n  }\n  buildRequestUrl(e5) {\n    var t3;\n    return (t3 = this.config).buildRequestUrl?.call(t3, this.config.baseURL, e5) ?? `${this.config.baseURL}/messages`;\n  }\n  transformRequestBody(e5) {\n    var t3;\n    return (t3 = this.config).transformRequestBody?.call(t3, e5) ?? e5;\n  }\n  extractCitationDocuments(e5) {\n    return e5.filter((e6) => e6.role === `user`).flatMap((e6) => e6.content).filter((e6) => e6.type !== `file` || e6.mediaType !== `application/pdf` && e6.mediaType !== `text/plain` ? false : e6.providerOptions?.anthropic?.citations?.enabled ?? false).map((e6) => {\n      let t3 = e6;\n      return { title: t3.filename ?? `Untitled Document`, filename: t3.filename, mediaType: t3.mediaType };\n    });\n  }\n  async doGenerate(e5) {\n    let { args: t3, warnings: n3, betas: r3, usesJsonResponseTool: i4 } = await this.getArgs(e5), a5 = this.extractCitationDocuments(e5.prompt), { responseHeaders: o3, value: s4, rawValue: c4 } = await St({ url: this.buildRequestUrl(false), headers: await this.getHeaders({ betas: r3, headers: e5.headers }), body: this.transformRequestBody(t3), failedResponseHandler: Lt, successfulResponseHandler: kt(un), abortSignal: e5.abortSignal, fetch: this.config.fetch }), l3 = [];\n    for (let e6 of s4.content)\n      switch (e6.type) {\n        case `text`:\n          if (!i4 && (l3.push({ type: `text`, text: e6.text }), e6.citations))\n            for (let t4 of e6.citations)\n              sn(t4, a5, this.generateId, (e7) => l3.push(e7));\n          break;\n        case `thinking`:\n          l3.push({ type: `reasoning`, text: e6.thinking, providerMetadata: { anthropic: { signature: e6.signature } } });\n          break;\n        case `redacted_thinking`:\n          l3.push({ type: `reasoning`, text: ``, providerMetadata: { anthropic: { redactedData: e6.data } } });\n          break;\n        case `tool_use`:\n          l3.push(i4 ? { type: `text`, text: JSON.stringify(e6.input) } : { type: `tool-call`, toolCallId: e6.id, toolName: e6.name, input: JSON.stringify(e6.input) });\n          break;\n        case `server_tool_use`:\n          (e6.name === `web_search` || e6.name === `code_execution` || e6.name === `web_fetch`) && l3.push({ type: `tool-call`, toolCallId: e6.id, toolName: e6.name, input: JSON.stringify(e6.input), providerExecuted: true });\n          break;\n        case `web_fetch_tool_result`:\n          e6.content.type === `web_fetch_result` ? l3.push({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `web_fetch`, result: { type: `web_fetch_result`, url: e6.content.url, retrievedAt: e6.content.retrieved_at, content: { type: e6.content.content.type, title: e6.content.content.title, citations: e6.content.content.citations, source: { type: e6.content.content.source.type, mediaType: e6.content.content.source.media_type, data: e6.content.content.source.data } } }, providerExecuted: true }) : e6.content.type === `web_fetch_tool_result_error` && l3.push({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `web_fetch`, isError: true, result: { type: `web_fetch_tool_result_error`, errorCode: e6.content.error_code }, providerExecuted: true });\n          break;\n        case `web_search_tool_result`:\n          if (Array.isArray(e6.content)) {\n            l3.push({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `web_search`, result: e6.content.map((e7) => ({ url: e7.url, title: e7.title, pageAge: e7.page_age ?? null, encryptedContent: e7.encrypted_content, type: e7.type })), providerExecuted: true });\n            for (let t4 of e6.content)\n              l3.push({ type: `source`, sourceType: `url`, id: this.generateId(), url: t4.url, title: t4.title, providerMetadata: { anthropic: { pageAge: t4.page_age ?? null } } });\n          } else\n            l3.push({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `web_search`, isError: true, result: { type: `web_search_tool_result_error`, errorCode: e6.content.error_code }, providerExecuted: true });\n          break;\n        case `code_execution_tool_result`:\n          e6.content.type === `code_execution_result` ? l3.push({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `code_execution`, result: { type: e6.content.type, stdout: e6.content.stdout, stderr: e6.content.stderr, return_code: e6.content.return_code }, providerExecuted: true }) : e6.content.type === `code_execution_tool_result_error` && l3.push({ type: `tool-result`, toolCallId: e6.tool_use_id, toolName: `code_execution`, isError: true, result: { type: `code_execution_tool_result_error`, errorCode: e6.content.error_code }, providerExecuted: true });\n          break;\n      }\n    return { content: l3, finishReason: an({ finishReason: s4.stop_reason, isJsonResponseFromTool: i4 }), usage: { inputTokens: s4.usage.input_tokens, outputTokens: s4.usage.output_tokens, totalTokens: s4.usage.input_tokens + s4.usage.output_tokens, cachedInputTokens: s4.usage.cache_read_input_tokens ?? undefined }, request: { body: t3 }, response: { id: s4.id ?? undefined, modelId: s4.model ?? undefined, headers: o3, body: c4 }, warnings: n3, providerMetadata: { anthropic: { usage: s4.usage, cacheCreationInputTokens: s4.usage.cache_creation_input_tokens ?? null, stopSequence: s4.stop_sequence ?? null } } };\n  }\n  async doStream(e5) {\n    let { args: t3, warnings: n3, betas: r3, usesJsonResponseTool: i4 } = await this.getArgs(e5), a5 = this.extractCitationDocuments(e5.prompt), o3 = { ...t3, stream: true }, { responseHeaders: s4, value: c4 } = await St({ url: this.buildRequestUrl(true), headers: await this.getHeaders({ betas: r3, headers: e5.headers }), body: this.transformRequestBody(o3), failedResponseHandler: Lt, successfulResponseHandler: Ot(dn), abortSignal: e5.abortSignal, fetch: this.config.fetch }), l3 = `unknown`, u3 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, d2 = {}, f2, p2 = null, m2 = null, h2, g2 = this.generateId;\n    return { stream: c4.pipeThrough(new TransformStream({ start(e6) {\n      e6.enqueue({ type: `stream-start`, warnings: n3 });\n    }, transform(t4, n4) {\n      if (e5.includeRawChunks && n4.enqueue({ type: `raw`, rawValue: t4.rawValue }), !t4.success) {\n        n4.enqueue({ type: `error`, error: t4.error });\n        return;\n      }\n      let r4 = t4.value;\n      switch (r4.type) {\n        case `ping`:\n          return;\n        case `content_block_start`: {\n          let e6 = r4.content_block.type;\n          switch (h2 = e6, e6) {\n            case `text`:\n              d2[r4.index] = { type: `text` }, n4.enqueue({ type: `text-start`, id: String(r4.index) });\n              return;\n            case `thinking`:\n              d2[r4.index] = { type: `reasoning` }, n4.enqueue({ type: `reasoning-start`, id: String(r4.index) });\n              return;\n            case `redacted_thinking`:\n              d2[r4.index] = { type: `reasoning` }, n4.enqueue({ type: `reasoning-start`, id: String(r4.index), providerMetadata: { anthropic: { redactedData: r4.content_block.data } } });\n              return;\n            case `tool_use`:\n              d2[r4.index] = i4 ? { type: `text` } : { type: `tool-call`, toolCallId: r4.content_block.id, toolName: r4.content_block.name, input: `` }, n4.enqueue(i4 ? { type: `text-start`, id: String(r4.index) } : { type: `tool-input-start`, id: r4.content_block.id, toolName: r4.content_block.name });\n              return;\n            case `server_tool_use`:\n              (r4.content_block.name === `web_fetch` || r4.content_block.name === `web_search` || r4.content_block.name === `code_execution`) && (d2[r4.index] = { type: `tool-call`, toolCallId: r4.content_block.id, toolName: r4.content_block.name, input: ``, providerExecuted: true }, n4.enqueue({ type: `tool-input-start`, id: r4.content_block.id, toolName: r4.content_block.name, providerExecuted: true }));\n              return;\n            case `web_fetch_tool_result`: {\n              let e7 = r4.content_block;\n              e7.content.type === `web_fetch_result` ? n4.enqueue({ type: `tool-result`, toolCallId: e7.tool_use_id, toolName: `web_fetch`, result: { type: `web_fetch_result`, url: e7.content.url, retrievedAt: e7.content.retrieved_at, content: { type: e7.content.content.type, title: e7.content.content.title, citations: e7.content.content.citations, source: { type: e7.content.content.source.type, mediaType: e7.content.content.source.media_type, data: e7.content.content.source.data } } } }) : e7.content.type === `web_fetch_tool_result_error` && n4.enqueue({ type: `tool-result`, toolCallId: e7.tool_use_id, toolName: `web_fetch`, isError: true, result: { type: `web_fetch_tool_result_error`, errorCode: e7.content.error_code }, providerExecuted: true });\n              return;\n            }\n            case `web_search_tool_result`: {\n              let e7 = r4.content_block;\n              if (Array.isArray(e7.content)) {\n                n4.enqueue({ type: `tool-result`, toolCallId: e7.tool_use_id, toolName: `web_search`, result: e7.content.map((e8) => ({ url: e8.url, title: e8.title, pageAge: e8.page_age ?? null, encryptedContent: e8.encrypted_content, type: e8.type })), providerExecuted: true });\n                for (let t5 of e7.content)\n                  n4.enqueue({ type: `source`, sourceType: `url`, id: g2(), url: t5.url, title: t5.title, providerMetadata: { anthropic: { pageAge: t5.page_age ?? null } } });\n              } else\n                n4.enqueue({ type: `tool-result`, toolCallId: e7.tool_use_id, toolName: `web_search`, isError: true, result: { type: `web_search_tool_result_error`, errorCode: e7.content.error_code }, providerExecuted: true });\n              return;\n            }\n            case `code_execution_tool_result`: {\n              let e7 = r4.content_block;\n              e7.content.type === `code_execution_result` ? n4.enqueue({ type: `tool-result`, toolCallId: e7.tool_use_id, toolName: `code_execution`, result: { type: e7.content.type, stdout: e7.content.stdout, stderr: e7.content.stderr, return_code: e7.content.return_code }, providerExecuted: true }) : e7.content.type === `code_execution_tool_result_error` && n4.enqueue({ type: `tool-result`, toolCallId: e7.tool_use_id, toolName: `code_execution`, isError: true, result: { type: `code_execution_tool_result_error`, errorCode: e7.content.error_code }, providerExecuted: true });\n              return;\n            }\n            default: {\n              let t5 = e6;\n              throw Error(`Unsupported content block type: ${t5}`);\n            }\n          }\n        }\n        case `content_block_stop`:\n          if (d2[r4.index] != null) {\n            let e6 = d2[r4.index];\n            switch (e6.type) {\n              case `text`:\n                n4.enqueue({ type: `text-end`, id: String(r4.index) });\n                break;\n              case `reasoning`:\n                n4.enqueue({ type: `reasoning-end`, id: String(r4.index) });\n                break;\n              case `tool-call`:\n                i4 || (n4.enqueue({ type: `tool-input-end`, id: e6.toolCallId }), n4.enqueue(e6));\n                break;\n            }\n            delete d2[r4.index];\n          }\n          h2 = undefined;\n          return;\n        case `content_block_delta`: {\n          let e6 = r4.delta.type;\n          switch (e6) {\n            case `text_delta`:\n              if (i4)\n                return;\n              n4.enqueue({ type: `text-delta`, id: String(r4.index), delta: r4.delta.text });\n              return;\n            case `thinking_delta`:\n              n4.enqueue({ type: `reasoning-delta`, id: String(r4.index), delta: r4.delta.thinking });\n              return;\n            case `signature_delta`:\n              h2 === `thinking` && n4.enqueue({ type: `reasoning-delta`, id: String(r4.index), delta: ``, providerMetadata: { anthropic: { signature: r4.delta.signature } } });\n              return;\n            case `input_json_delta`: {\n              let e7 = d2[r4.index], t5 = r4.delta.partial_json;\n              if (i4) {\n                if (e7?.type !== `text`)\n                  return;\n                n4.enqueue({ type: `text-delta`, id: String(r4.index), delta: t5 });\n              } else {\n                if (e7?.type !== `tool-call`)\n                  return;\n                n4.enqueue({ type: `tool-input-delta`, id: e7.toolCallId, delta: t5 }), e7.input += t5;\n              }\n              return;\n            }\n            case `citations_delta`: {\n              let e7 = r4.delta.citation;\n              sn(e7, a5, g2, (e8) => n4.enqueue(e8));\n              return;\n            }\n            default: {\n              let t5 = e6;\n              throw Error(`Unsupported delta type: ${t5}`);\n            }\n          }\n        }\n        case `message_start`:\n          u3.inputTokens = r4.message.usage.input_tokens, u3.cachedInputTokens = r4.message.usage.cache_read_input_tokens ?? undefined, f2 = { ...r4.message.usage }, p2 = r4.message.usage.cache_creation_input_tokens ?? null, n4.enqueue({ type: `response-metadata`, id: r4.message.id ?? undefined, modelId: r4.message.model ?? undefined });\n          return;\n        case `message_delta`:\n          u3.outputTokens = r4.usage.output_tokens, u3.totalTokens = (u3.inputTokens ?? 0) + (r4.usage.output_tokens ?? 0), l3 = an({ finishReason: r4.delta.stop_reason, isJsonResponseFromTool: i4 }), m2 = r4.delta.stop_sequence ?? null, f2 = { ...f2, ...r4.usage };\n          return;\n        case `message_stop`:\n          n4.enqueue({ type: `finish`, finishReason: l3, usage: u3, providerMetadata: { anthropic: { usage: f2 ?? null, cacheCreationInputTokens: p2, stopSequence: m2 } } });\n          return;\n        case `error`:\n          n4.enqueue({ type: `error`, error: r4.error });\n          return;\n        default: {\n          let e6 = r4;\n          throw Error(`Unsupported chunk type: ${e6}`);\n        }\n      }\n    } })), request: { body: o3 }, response: { headers: s4 } };\n  }\n};\nvar un = exports_external.object({ type: exports_external.literal(`message`), id: exports_external.string().nullish(), model: exports_external.string().nullish(), content: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`text`), text: exports_external.string(), citations: exports_external.array(on).optional() }), exports_external.object({ type: exports_external.literal(`thinking`), thinking: exports_external.string(), signature: exports_external.string() }), exports_external.object({ type: exports_external.literal(`redacted_thinking`), data: exports_external.string() }), exports_external.object({ type: exports_external.literal(`tool_use`), id: exports_external.string(), name: exports_external.string(), input: exports_external.unknown() }), exports_external.object({ type: exports_external.literal(`server_tool_use`), id: exports_external.string(), name: exports_external.string(), input: exports_external.record(exports_external.string(), exports_external.unknown()).nullish() }), exports_external.object({ type: exports_external.literal(`web_fetch_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.object({ type: exports_external.literal(`web_fetch_result`), url: exports_external.string(), retrieved_at: exports_external.string(), content: exports_external.object({ type: exports_external.literal(`document`), title: exports_external.string().nullable(), citations: exports_external.object({ enabled: exports_external.boolean() }).optional(), source: exports_external.object({ type: exports_external.literal(`text`), media_type: exports_external.string(), data: exports_external.string() }) }) }), exports_external.object({ type: exports_external.literal(`web_fetch_tool_result_error`), error_code: exports_external.string() })]) }), exports_external.object({ type: exports_external.literal(`web_search_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.array(exports_external.object({ type: exports_external.literal(`web_search_result`), url: exports_external.string(), title: exports_external.string(), encrypted_content: exports_external.string(), page_age: exports_external.string().nullish() })), exports_external.object({ type: exports_external.literal(`web_search_tool_result_error`), error_code: exports_external.string() })]) }), exports_external.object({ type: exports_external.literal(`code_execution_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.object({ type: exports_external.literal(`code_execution_result`), stdout: exports_external.string(), stderr: exports_external.string(), return_code: exports_external.number() }), exports_external.object({ type: exports_external.literal(`code_execution_tool_result_error`), error_code: exports_external.string() })]) })])), stop_reason: exports_external.string().nullish(), stop_sequence: exports_external.string().nullish(), usage: exports_external.looseObject({ input_tokens: exports_external.number(), output_tokens: exports_external.number(), cache_creation_input_tokens: exports_external.number().nullish(), cache_read_input_tokens: exports_external.number().nullish() }) });\nvar dn = exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`message_start`), message: exports_external.object({ id: exports_external.string().nullish(), model: exports_external.string().nullish(), usage: exports_external.looseObject({ input_tokens: exports_external.number(), cache_creation_input_tokens: exports_external.number().nullish(), cache_read_input_tokens: exports_external.number().nullish() }) }) }), exports_external.object({ type: exports_external.literal(`content_block_start`), index: exports_external.number(), content_block: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`text`), text: exports_external.string() }), exports_external.object({ type: exports_external.literal(`thinking`), thinking: exports_external.string() }), exports_external.object({ type: exports_external.literal(`tool_use`), id: exports_external.string(), name: exports_external.string() }), exports_external.object({ type: exports_external.literal(`redacted_thinking`), data: exports_external.string() }), exports_external.object({ type: exports_external.literal(`server_tool_use`), id: exports_external.string(), name: exports_external.string(), input: exports_external.record(exports_external.string(), exports_external.unknown()).nullish() }), exports_external.object({ type: exports_external.literal(`web_fetch_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.object({ type: exports_external.literal(`web_fetch_result`), url: exports_external.string(), retrieved_at: exports_external.string(), content: exports_external.object({ type: exports_external.literal(`document`), title: exports_external.string().nullable(), citations: exports_external.object({ enabled: exports_external.boolean() }).optional(), source: exports_external.object({ type: exports_external.literal(`text`), media_type: exports_external.string(), data: exports_external.string() }) }) }), exports_external.object({ type: exports_external.literal(`web_fetch_tool_result_error`), error_code: exports_external.string() })]) }), exports_external.object({ type: exports_external.literal(`web_search_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.array(exports_external.object({ type: exports_external.literal(`web_search_result`), url: exports_external.string(), title: exports_external.string(), encrypted_content: exports_external.string(), page_age: exports_external.string().nullish() })), exports_external.object({ type: exports_external.literal(`web_search_tool_result_error`), error_code: exports_external.string() })]) }), exports_external.object({ type: exports_external.literal(`code_execution_tool_result`), tool_use_id: exports_external.string(), content: exports_external.union([exports_external.object({ type: exports_external.literal(`code_execution_result`), stdout: exports_external.string(), stderr: exports_external.string(), return_code: exports_external.number() }), exports_external.object({ type: exports_external.literal(`code_execution_tool_result_error`), error_code: exports_external.string() })]) })]) }), exports_external.object({ type: exports_external.literal(`content_block_delta`), index: exports_external.number(), delta: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`input_json_delta`), partial_json: exports_external.string() }), exports_external.object({ type: exports_external.literal(`text_delta`), text: exports_external.string() }), exports_external.object({ type: exports_external.literal(`thinking_delta`), thinking: exports_external.string() }), exports_external.object({ type: exports_external.literal(`signature_delta`), signature: exports_external.string() }), exports_external.object({ type: exports_external.literal(`citations_delta`), citation: on })]) }), exports_external.object({ type: exports_external.literal(`content_block_stop`), index: exports_external.number() }), exports_external.object({ type: exports_external.literal(`error`), error: exports_external.object({ type: exports_external.string(), message: exports_external.string() }) }), exports_external.object({ type: exports_external.literal(`message_delta`), delta: exports_external.object({ stop_reason: exports_external.string().nullish(), stop_sequence: exports_external.string().nullish() }), usage: exports_external.looseObject({ output_tokens: exports_external.number(), cache_creation_input_tokens: exports_external.number().nullish() }) }), exports_external.object({ type: exports_external.literal(`message_stop`) }), exports_external.object({ type: exports_external.literal(`ping`) })]);\nvar fn = exports_external.object({ signature: exports_external.string().optional(), redactedData: exports_external.string().optional() });\nvar pn = P({ id: `anthropic.bash_20241022`, name: `bash`, inputSchema: v4_default.object({ command: v4_default.string(), restart: v4_default.boolean().optional() }) });\nvar mn = P({ id: `anthropic.bash_20250124`, name: `bash`, inputSchema: v4_default.object({ command: v4_default.string(), restart: v4_default.boolean().optional() }) });\nvar hn = P({ id: `anthropic.computer_20241022`, name: `computer`, inputSchema: exports_external.object({ action: exports_external.enum([`key`, `type`, `mouse_move`, `left_click`, `left_click_drag`, `right_click`, `middle_click`, `double_click`, `screenshot`, `cursor_position`]), coordinate: exports_external.array(exports_external.number().int()).optional(), text: exports_external.string().optional() }) });\nvar gn = P({ id: `anthropic.computer_20250124`, name: `computer`, inputSchema: exports_external.object({ action: exports_external.enum([`key`, `hold_key`, `type`, `cursor_position`, `mouse_move`, `left_mouse_down`, `left_mouse_up`, `left_click`, `left_click_drag`, `right_click`, `middle_click`, `double_click`, `triple_click`, `scroll`, `wait`, `screenshot`]), coordinate: exports_external.tuple([exports_external.number().int(), exports_external.number().int()]).optional(), duration: exports_external.number().optional(), scroll_amount: exports_external.number().optional(), scroll_direction: exports_external.enum([`up`, `down`, `left`, `right`]).optional(), start_coordinate: exports_external.tuple([exports_external.number().int(), exports_external.number().int()]).optional(), text: exports_external.string().optional() }) });\nvar _n = P({ id: `anthropic.text_editor_20241022`, name: `str_replace_editor`, inputSchema: exports_external.object({ command: exports_external.enum([`view`, `create`, `str_replace`, `insert`, `undo_edit`]), path: exports_external.string(), file_text: exports_external.string().optional(), insert_line: exports_external.number().int().optional(), new_str: exports_external.string().optional(), old_str: exports_external.string().optional(), view_range: exports_external.array(exports_external.number().int()).optional() }) });\nvar vn = P({ id: `anthropic.text_editor_20250124`, name: `str_replace_editor`, inputSchema: exports_external.object({ command: exports_external.enum([`view`, `create`, `str_replace`, `insert`, `undo_edit`]), path: exports_external.string(), file_text: exports_external.string().optional(), insert_line: exports_external.number().int().optional(), new_str: exports_external.string().optional(), old_str: exports_external.string().optional(), view_range: exports_external.array(exports_external.number().int()).optional() }) });\nvar yn = P({ id: `anthropic.text_editor_20250429`, name: `str_replace_based_edit_tool`, inputSchema: exports_external.object({ command: exports_external.enum([`view`, `create`, `str_replace`, `insert`]), path: exports_external.string(), file_text: exports_external.string().optional(), insert_line: exports_external.number().int().optional(), new_str: exports_external.string().optional(), old_str: exports_external.string().optional(), view_range: exports_external.array(exports_external.number().int()).optional() }) });\nvar bn = { bash_20241022: pn, bash_20250124: mn, codeExecution_20250522: en, computer_20241022: hn, computer_20250124: gn, textEditor_20241022: _n, textEditor_20250124: vn, textEditor_20250429: yn, textEditor_20250728: Ht, webFetch_20250910: Xt, webSearch_20250305: Kt };\nfunction xn(e5 = {}) {\n  let t3 = Pt(e5.baseURL) ?? `https://api.anthropic.com/v1`, n3 = () => $e({ "anthropic-version": `2023-06-01`, "x-api-key": at({ apiKey: e5.apiKey, environmentVariableName: `ANTHROPIC_API_KEY`, description: `Anthropic` }), ...e5.headers }, `ai-sdk/anthropic/${Ft}`), r3 = (r4) => new ln(r4, { provider: `anthropic.messages`, baseURL: t3, headers: n3, fetch: e5.fetch, generateId: e5.generateId ?? et, supportedUrls: () => ({ "image/*": [/^https?:\\/\\/.*$/] }) }), i4 = function(e6) {\n    if (new.target)\n      throw Error(`The Anthropic model function cannot be called with the new keyword.`);\n    return r3(e6);\n  };\n  return i4.languageModel = r3, i4.chat = r3, i4.messages = r3, i4.textEmbeddingModel = (e6) => {\n    throw new Fe({ modelId: e6, modelType: `textEmbeddingModel` });\n  }, i4.imageModel = (e6) => {\n    throw new Fe({ modelId: e6, modelType: `imageModel` });\n  }, i4.tools = bn, i4;\n}\nxn();\nfunction L(...e5) {\n  return e5.reduce((e6, t3) => ({ ...e6, ...t3 ?? {} }), {});\n}\nfunction R(e5) {\n  return Object.fromEntries([...e5.headers]);\n}\nfunction Sn(e5 = globalThis) {\n  return e5.window ? `runtime/browser` : e5.navigator?.userAgent ? `runtime/${e5.navigator.userAgent.toLowerCase()}` : e5.process?.versions?.node ? `runtime/node.js/${e5.process.version.substring(0)}` : e5.EdgeRuntime ? `runtime/vercel-edge` : `runtime/unknown`;\n}\nfunction Cn(e5) {\n  return Object.fromEntries(Object.entries(e5).filter(([e6, t3]) => t3 != null));\n}\nfunction wn(e5, ...t3) {\n  let n3 = Cn(e5 ?? {}), r3 = new Headers(n3), i4 = r3.get(`user-agent`) || ``;\n  return r3.set(`user-agent`, [i4, ...t3].filter(Boolean).join(` `)), Object.fromEntries(r3);\n}\nvar Tn = (({ prefix: e5, size: t3 = 16, alphabet: n3 = `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`, separator: r3 = `-` } = {}) => {\n  let i4 = () => {\n    let e6 = n3.length, r4 = Array(t3);\n    for (let i5 = 0;i5 < t3; i5++)\n      r4[i5] = n3[Math.random() * e6 | 0];\n    return r4.join(``);\n  };\n  if (e5 == null)\n    return i4;\n  if (n3.includes(r3))\n    throw new D({ argument: `separator`, message: `The separator "${r3}" must not be part of the alphabet "${n3}".` });\n  return () => `${e5}${r3}${i4()}`;\n})();\nfunction En(e5) {\n  return (e5 instanceof Error || e5 instanceof DOMException) && (e5.name === `AbortError` || e5.name === `ResponseAborted` || e5.name === `TimeoutError`);\n}\nvar Dn = [`fetch failed`, `failed to fetch`];\nfunction On({ error: e5, url: t3, requestBodyValues: n3 }) {\n  if (En(e5))\n    return e5;\n  if (e5 instanceof TypeError && Dn.includes(e5.message.toLowerCase())) {\n    let r3 = e5.cause;\n    if (r3 != null)\n      return new T({ message: `Cannot connect to API: ${r3.message}`, cause: r3, url: t3, requestBodyValues: n3, isRetryable: true });\n  }\n  return e5;\n}\nvar kn = `3.0.10`;\nfunction An({ apiKey: e5, environmentVariableName: t3, apiKeyParameterName: n3 = `apiKey`, description: r3 }) {\n  if (typeof e5 == `string`)\n    return e5;\n  if (e5 != null)\n    throw new k({ message: `${r3} API key must be a string.` });\n  if (typeof process > `u`)\n    throw new k({ message: `${r3} API key is missing. Pass it using the \'${n3}\' parameter. Environment variables is not supported in this environment.` });\n  if (e5 = process.env[t3], e5 == null)\n    throw new k({ message: `${r3} API key is missing. Pass it using the \'${n3}\' parameter or the ${t3} environment variable.` });\n  if (typeof e5 != `string`)\n    throw new k({ message: `${r3} API key must be a string. The value of the ${t3} environment variable is not a string.` });\n  return e5;\n}\nvar jn = /"__proto__"\\s*:/;\nvar Mn = /"constructor"\\s*:/;\nfunction Nn(e5) {\n  let t3 = JSON.parse(e5);\n  return typeof t3 != `object` || !t3 || jn.test(e5) === false && Mn.test(e5) === false ? t3 : Pn(t3);\n}\nfunction Pn(e5) {\n  let t3 = [e5];\n  for (;t3.length; ) {\n    let e6 = t3;\n    t3 = [];\n    for (let n3 of e6) {\n      if (Object.prototype.hasOwnProperty.call(n3, `__proto__`) || Object.prototype.hasOwnProperty.call(n3, `constructor`) && Object.prototype.hasOwnProperty.call(n3.constructor, `prototype`))\n        throw SyntaxError(`Object contains forbidden prototype property`);\n      for (let e7 in n3) {\n        let r3 = n3[e7];\n        r3 && typeof r3 == `object` && t3.push(r3);\n      }\n    }\n  }\n  return e5;\n}\nfunction Fn(e5) {\n  let { stackTraceLimit: t3 } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return Nn(e5);\n  } finally {\n    Error.stackTraceLimit = t3;\n  }\n}\nvar In = Symbol.for(`vercel.ai.validator`);\nfunction Ln(e5) {\n  return { [In]: true, validate: e5 };\n}\nfunction Rn(e5) {\n  return typeof e5 == `object` && !!e5 && In in e5 && e5[In] === true && `validate` in e5;\n}\nfunction zn(e5) {\n  return Rn(e5) ? e5 : Bn(e5);\n}\nfunction Bn(e5) {\n  return Ln(async (t3) => {\n    let n3 = await e5[`~standard`].validate(t3);\n    return n3.issues == null ? { success: true, value: n3.value } : { success: false, error: new A({ value: t3, cause: n3.issues }) };\n  });\n}\nasync function Vn({ value: e5, schema: t3 }) {\n  let n3 = await Hn({ value: e5, schema: t3 });\n  if (!n3.success)\n    throw A.wrap({ value: e5, cause: n3.error });\n  return n3.value;\n}\nasync function Hn({ value: e5, schema: t3 }) {\n  let n3 = zn(t3);\n  try {\n    if (n3.validate == null)\n      return { success: true, value: e5, rawValue: e5 };\n    let t4 = await n3.validate(e5);\n    return t4.success ? { success: true, value: t4.value, rawValue: e5 } : { success: false, error: A.wrap({ value: e5, cause: t4.error }), rawValue: e5 };\n  } catch (t4) {\n    return { success: false, error: A.wrap({ value: e5, cause: t4 }), rawValue: e5 };\n  }\n}\nasync function Un({ text: e5, schema: t3 }) {\n  try {\n    let n3 = Fn(e5);\n    return t3 == null ? n3 : Vn({ value: n3, schema: t3 });\n  } catch (t4) {\n    throw O.isInstance(t4) || A.isInstance(t4) ? t4 : new O({ text: e5, cause: t4 });\n  }\n}\nasync function Wn({ text: e5, schema: t3 }) {\n  try {\n    let n3 = Fn(e5);\n    return t3 == null ? { success: true, value: n3, rawValue: n3 } : await Hn({ value: n3, schema: t3 });\n  } catch (t4) {\n    return { success: false, error: O.isInstance(t4) ? t4 : new O({ text: e5, cause: t4 }), rawValue: undefined };\n  }\n}\nfunction Gn({ stream: e5, schema: t3 }) {\n  return e5.pipeThrough(new TextDecoderStream).pipeThrough(new l2).pipeThrough(new TransformStream({ async transform({ data: e6 }, n3) {\n    e6 !== `[DONE]` && n3.enqueue(await Wn({ text: e6, schema: t3 }));\n  } }));\n}\nasync function Kn({ provider: e5, providerOptions: t3, schema: n3 }) {\n  if (t3?.[e5] == null)\n    return;\n  let r3 = await Hn({ value: t3[e5], schema: n3 });\n  if (!r3.success)\n    throw new D({ argument: `providerOptions`, message: `invalid ${e5} provider options`, cause: r3.error });\n  return r3.value;\n}\nvar qn = () => globalThis.fetch;\nvar z2 = async ({ url: e5, headers: t3, body: n3, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 }) => Jn({ url: e5, headers: { "Content-Type": `application/json`, ...t3 }, body: { content: JSON.stringify(n3), values: n3 }, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 });\nvar Jn = async ({ url: e5, headers: t3 = {}, body: n3, successfulResponseHandler: r3, failedResponseHandler: i4, abortSignal: a5, fetch: o3 = qn() }) => {\n  try {\n    let s4 = await o3(e5, { method: `POST`, headers: wn(t3, `ai-sdk/provider-utils/${kn}`, Sn()), body: n3.content, signal: a5 }), c4 = R(s4);\n    if (!s4.ok) {\n      let t4;\n      try {\n        t4 = await i4({ response: s4, url: e5, requestBodyValues: n3.values });\n      } catch (t5) {\n        throw En(t5) || T.isInstance(t5) ? t5 : new T({ message: `Failed to process error response`, cause: t5, statusCode: s4.status, url: e5, responseHeaders: c4, requestBodyValues: n3.values });\n      }\n      throw t4.value;\n    }\n    try {\n      return await r3({ response: s4, url: e5, requestBodyValues: n3.values });\n    } catch (t4) {\n      throw t4 instanceof Error && (En(t4) || T.isInstance(t4)) ? t4 : new T({ message: `Failed to process successful response`, cause: t4, statusCode: s4.status, url: e5, responseHeaders: c4, requestBodyValues: n3.values });\n    }\n  } catch (t4) {\n    throw On({ error: t4, url: e5, requestBodyValues: n3.values });\n  }\n};\nfunction Yn(e5) {\n  return e5;\n}\nfunction Xn({ id: e5, name: t3, inputSchema: n3 }) {\n  return ({ execute: r3, outputSchema: i4, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4, ...l3 }) => Yn({ type: `provider-defined`, id: e5, name: t3, args: l3, inputSchema: n3, outputSchema: i4, execute: r3, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4 });\n}\nfunction Zn({ id: e5, name: t3, inputSchema: n3, outputSchema: r3 }) {\n  return ({ execute: i4, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4, ...l3 }) => Yn({ type: `provider-defined`, id: e5, name: t3, args: l3, inputSchema: n3, outputSchema: r3, execute: i4, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4 });\n}\nasync function B(e5) {\n  return typeof e5 == `function` && (e5 = e5()), Promise.resolve(e5);\n}\nvar Qn = ({ errorSchema: e5, errorToMessage: t3, isRetryable: n3 }) => async ({ response: r3, url: i4, requestBodyValues: a5 }) => {\n  let o3 = await r3.text(), s4 = R(r3);\n  if (o3.trim() === ``)\n    return { responseHeaders: s4, value: new T({ message: r3.statusText, url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, isRetryable: n3?.(r3) }) };\n  try {\n    let c4 = await Un({ text: o3, schema: e5 });\n    return { responseHeaders: s4, value: new T({ message: t3(c4), url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, data: c4, isRetryable: n3?.(r3, c4) }) };\n  } catch {\n    return { responseHeaders: s4, value: new T({ message: r3.statusText, url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, isRetryable: n3?.(r3) }) };\n  }\n};\nvar $n = (e5) => async ({ response: t3 }) => {\n  let n3 = R(t3);\n  if (t3.body == null)\n    throw new E({});\n  return { responseHeaders: n3, value: Gn({ stream: t3.body, schema: e5 }) };\n};\nvar V = (e5) => async ({ response: t3, url: n3, requestBodyValues: r3 }) => {\n  let i4 = await t3.text(), a5 = await Wn({ text: i4, schema: e5 }), o3 = R(t3);\n  if (!a5.success)\n    throw new T({ message: `Invalid JSON response`, cause: a5.error, statusCode: t3.status, responseHeaders: o3, responseBody: i4, url: n3, requestBodyValues: r3 });\n  return { responseHeaders: o3, value: a5.value, rawValue: a5.rawValue };\n};\nvar { btoa: er, atob: tr } = globalThis;\nfunction nr(e5) {\n  let t3 = ``;\n  for (let n3 = 0;n3 < e5.length; n3++)\n    t3 += String.fromCodePoint(e5[n3]);\n  return er(t3);\n}\nfunction rr(e5) {\n  return e5 instanceof Uint8Array ? nr(e5) : e5;\n}\nfunction ir(e5) {\n  return e5?.replace(/\\/$/, ``);\n}\nvar ar = `2.0.17`;\nvar or = exports_external.object({ error: exports_external.object({ code: exports_external.number().nullable(), message: exports_external.string(), status: exports_external.string() }) });\nvar H = Qn({ errorSchema: or, errorToMessage: (e5) => e5.error.message });\nvar sr = exports_external.object({ outputDimensionality: exports_external.number().optional(), taskType: exports_external.enum([`SEMANTIC_SIMILARITY`, `CLASSIFICATION`, `CLUSTERING`, `RETRIEVAL_DOCUMENT`, `RETRIEVAL_QUERY`, `QUESTION_ANSWERING`, `FACT_VERIFICATION`, `CODE_RETRIEVAL_QUERY`]).optional() });\nvar cr = class {\n  constructor(e5, t3) {\n    this.specificationVersion = `v2`, this.maxEmbeddingsPerCall = 2048, this.supportsParallelCalls = true, this.modelId = e5, this.config = t3;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doEmbed({ values: e5, headers: t3, abortSignal: n3, providerOptions: r3 }) {\n    let i4 = await Kn({ provider: `google`, providerOptions: r3, schema: sr });\n    if (e5.length > this.maxEmbeddingsPerCall)\n      throw new Be({ provider: this.provider, modelId: this.modelId, maxEmbeddingsPerCall: this.maxEmbeddingsPerCall, values: e5 });\n    let a5 = L(await B(this.config.headers), t3);\n    if (e5.length === 1) {\n      let { responseHeaders: t4, value: r4, rawValue: o4 } = await z2({ url: `${this.config.baseURL}/models/${this.modelId}:embedContent`, headers: a5, body: { model: `models/${this.modelId}`, content: { parts: [{ text: e5[0] }] }, outputDimensionality: i4?.outputDimensionality, taskType: i4?.taskType }, failedResponseHandler: H, successfulResponseHandler: V(ur), abortSignal: n3, fetch: this.config.fetch });\n      return { embeddings: [r4.embedding.values], usage: undefined, response: { headers: t4, body: o4 } };\n    }\n    let { responseHeaders: o3, value: s4, rawValue: c4 } = await z2({ url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`, headers: a5, body: { requests: e5.map((e6) => ({ model: `models/${this.modelId}`, content: { role: `user`, parts: [{ text: e6 }] }, outputDimensionality: i4?.outputDimensionality, taskType: i4?.taskType })) }, failedResponseHandler: H, successfulResponseHandler: V(lr), abortSignal: n3, fetch: this.config.fetch });\n    return { embeddings: s4.embeddings.map((e6) => e6.values), usage: undefined, response: { headers: o3, body: c4 } };\n  }\n};\nvar lr = exports_external.object({ embeddings: exports_external.array(exports_external.object({ values: exports_external.array(exports_external.number()) })) });\nvar ur = exports_external.object({ embedding: exports_external.object({ values: exports_external.array(exports_external.number()) }) });\nfunction U(e5) {\n  if (e5 == null || dr(e5))\n    return;\n  if (typeof e5 == `boolean`)\n    return { type: `boolean`, properties: {} };\n  let { type: t3, description: n3, required: r3, properties: i4, items: a5, allOf: o3, anyOf: s4, oneOf: c4, format: l3, const: u3, minLength: d2, enum: f2 } = e5, p2 = {};\n  if (n3 && (p2.description = n3), r3 && (p2.required = r3), l3 && (p2.format = l3), u3 !== undefined && (p2.enum = [u3]), t3 && (Array.isArray(t3) ? t3.includes(`null`) ? (p2.type = t3.filter((e6) => e6 !== `null`)[0], p2.nullable = true) : p2.type = t3 : t3 === `null` ? p2.type = `null` : p2.type = t3), f2 !== undefined && (p2.enum = f2), i4 != null && (p2.properties = Object.entries(i4).reduce((e6, [t4, n4]) => (e6[t4] = U(n4), e6), {})), a5 && (p2.items = Array.isArray(a5) ? a5.map(U) : U(a5)), o3 && (p2.allOf = o3.map(U)), s4)\n    if (s4.some((e6) => typeof e6 == `object` && e6?.type === `null`)) {\n      let e6 = s4.filter((e7) => !(typeof e7 == `object` && e7?.type === `null`));\n      if (e6.length === 1) {\n        let t4 = U(e6[0]);\n        typeof t4 == `object` && (p2.nullable = true, Object.assign(p2, t4));\n      } else\n        p2.anyOf = e6.map(U), p2.nullable = true;\n    } else\n      p2.anyOf = s4.map(U);\n  return c4 && (p2.oneOf = c4.map(U)), d2 !== undefined && (p2.minLength = d2), p2;\n}\nfunction dr(e5) {\n  return typeof e5 == `object` && !!e5 && e5.type === `object` && (e5.properties == null || Object.keys(e5.properties).length === 0) && !e5.additionalProperties;\n}\nfunction fr(e5, t3) {\n  let n3 = [], r3 = [], i4 = true, a5 = t3?.isGemmaModel ?? false;\n  for (let { role: t4, content: a6 } of e5)\n    switch (t4) {\n      case `system`:\n        if (!i4)\n          throw new j({ functionality: `system messages are only supported at the beginning of the conversation` });\n        n3.push({ text: a6 });\n        break;\n      case `user`: {\n        i4 = false;\n        let e6 = [];\n        for (let t5 of a6)\n          switch (t5.type) {\n            case `text`:\n              e6.push({ text: t5.text });\n              break;\n            case `file`: {\n              let n4 = t5.mediaType === `image/*` ? `image/jpeg` : t5.mediaType;\n              e6.push(t5.data instanceof URL ? { fileData: { mimeType: n4, fileUri: t5.data.toString() } } : { inlineData: { mimeType: n4, data: rr(t5.data) } });\n              break;\n            }\n          }\n        r3.push({ role: `user`, parts: e6 });\n        break;\n      }\n      case `assistant`:\n        i4 = false, r3.push({ role: `model`, parts: a6.map((e6) => {\n          switch (e6.type) {\n            case `text`:\n              return e6.text.length === 0 ? undefined : { text: e6.text, thoughtSignature: e6.providerOptions?.google?.thoughtSignature };\n            case `reasoning`:\n              return e6.text.length === 0 ? undefined : { text: e6.text, thought: true, thoughtSignature: e6.providerOptions?.google?.thoughtSignature };\n            case `file`:\n              if (e6.mediaType !== `image/png`)\n                throw new j({ functionality: `Only PNG images are supported in assistant messages` });\n              if (e6.data instanceof URL)\n                throw new j({ functionality: `File data URLs in assistant messages are not supported` });\n              return { inlineData: { mimeType: e6.mediaType, data: rr(e6.data) } };\n            case `tool-call`:\n              return { functionCall: { name: e6.toolName, args: e6.input }, thoughtSignature: e6.providerOptions?.google?.thoughtSignature };\n          }\n        }).filter((e6) => e6 !== undefined) });\n        break;\n      case `tool`: {\n        i4 = false;\n        let e6 = [];\n        for (let t5 of a6) {\n          let n4 = t5.output;\n          if (n4.type === `content`)\n            for (let r4 of n4.value)\n              switch (r4.type) {\n                case `text`:\n                  e6.push({ functionResponse: { name: t5.toolName, response: { name: t5.toolName, content: r4.text } } });\n                  break;\n                case `media`:\n                  e6.push({ inlineData: { mimeType: r4.mediaType, data: r4.data } }, { text: `Tool executed successfully and returned this image as a response` });\n                  break;\n                default:\n                  e6.push({ text: JSON.stringify(r4) });\n                  break;\n              }\n          else\n            e6.push({ functionResponse: { name: t5.toolName, response: { name: t5.toolName, content: n4.value } } });\n        }\n        r3.push({ role: `user`, parts: e6 });\n        break;\n      }\n    }\n  if (a5 && n3.length > 0 && r3.length > 0 && r3[0].role === `user`) {\n    let e6 = n3.map((e7) => e7.text).join(`\n\n`);\n    r3[0].parts.unshift({ text: e6 + `\n\n` });\n  }\n  return { systemInstruction: n3.length > 0 && !a5 ? { parts: n3 } : undefined, contents: r3 };\n}\nfunction pr(e5) {\n  return e5.includes(`/`) ? e5 : `models/${e5}`;\n}\nvar mr = exports_external.object({ responseModalities: exports_external.array(exports_external.enum([`TEXT`, `IMAGE`])).optional(), thinkingConfig: exports_external.object({ thinkingBudget: exports_external.number().optional(), includeThoughts: exports_external.boolean().optional() }).optional(), cachedContent: exports_external.string().optional(), structuredOutputs: exports_external.boolean().optional(), safetySettings: exports_external.array(exports_external.object({ category: exports_external.enum([`HARM_CATEGORY_UNSPECIFIED`, `HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_DANGEROUS_CONTENT`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`, `HARM_CATEGORY_CIVIC_INTEGRITY`]), threshold: exports_external.enum([`HARM_BLOCK_THRESHOLD_UNSPECIFIED`, `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`]) })).optional(), threshold: exports_external.enum([`HARM_BLOCK_THRESHOLD_UNSPECIFIED`, `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`]).optional(), audioTimestamp: exports_external.boolean().optional(), labels: exports_external.record(exports_external.string(), exports_external.string()).optional() });\nfunction hr({ tools: e5, toolChoice: t3, modelId: n3 }) {\n  e5 = e5?.length ? e5 : undefined;\n  let r3 = [], i4 = n3.includes(`gemini-2`), a5 = n3.includes(`gemini-1.5-flash`) && !n3.includes(`-8b`);\n  if (e5 == null)\n    return { tools: undefined, toolConfig: undefined, toolWarnings: r3 };\n  let o3 = e5.some((e6) => e6.type === `function`), s4 = e5.some((e6) => e6.type === `provider-defined`);\n  if (o3 && s4 && r3.push({ type: `unsupported-tool`, tool: e5.find((e6) => e6.type === `function`), details: `Cannot mix function tools with provider-defined tools in the same request. Please use either function tools or provider-defined tools, but not both.` }), s4) {\n    let t4 = {};\n    return e5.filter((e6) => e6.type === `provider-defined`).forEach((e6) => {\n      switch (e6.id) {\n        case `google.google_search`:\n          i4 ? t4.googleSearch = {} : a5 ? t4.googleSearchRetrieval = { dynamicRetrievalConfig: { mode: e6.args.mode, dynamicThreshold: e6.args.dynamicThreshold } } : t4.googleSearchRetrieval = {};\n          break;\n        case `google.url_context`:\n          i4 ? t4.urlContext = {} : r3.push({ type: `unsupported-tool`, tool: e6, details: `The URL context tool is not supported with other Gemini models than Gemini 2.` });\n          break;\n        case `google.code_execution`:\n          i4 ? t4.codeExecution = {} : r3.push({ type: `unsupported-tool`, tool: e6, details: `The code execution tools is not supported with other Gemini models than Gemini 2.` });\n          break;\n        default:\n          r3.push({ type: `unsupported-tool`, tool: e6 });\n          break;\n      }\n    }), { tools: Object.keys(t4).length > 0 ? t4 : undefined, toolConfig: undefined, toolWarnings: r3 };\n  }\n  let c4 = [];\n  for (let t4 of e5)\n    switch (t4.type) {\n      case `function`:\n        c4.push({ name: t4.name, description: t4.description ?? ``, parameters: U(t4.inputSchema) });\n        break;\n      default:\n        r3.push({ type: `unsupported-tool`, tool: t4 });\n        break;\n    }\n  if (t3 == null)\n    return { tools: { functionDeclarations: c4 }, toolConfig: undefined, toolWarnings: r3 };\n  let l3 = t3.type;\n  switch (l3) {\n    case `auto`:\n      return { tools: { functionDeclarations: c4 }, toolConfig: { functionCallingConfig: { mode: `AUTO` } }, toolWarnings: r3 };\n    case `none`:\n      return { tools: { functionDeclarations: c4 }, toolConfig: { functionCallingConfig: { mode: `NONE` } }, toolWarnings: r3 };\n    case `required`:\n      return { tools: { functionDeclarations: c4 }, toolConfig: { functionCallingConfig: { mode: `ANY` } }, toolWarnings: r3 };\n    case `tool`:\n      return { tools: { functionDeclarations: c4 }, toolConfig: { functionCallingConfig: { mode: `ANY`, allowedFunctionNames: [t3.toolName] } }, toolWarnings: r3 };\n    default:\n      throw new j({ functionality: `tool choice type: ${l3}` });\n  }\n}\nfunction gr({ finishReason: e5, hasToolCalls: t3 }) {\n  switch (e5) {\n    case `STOP`:\n      return t3 ? `tool-calls` : `stop`;\n    case `MAX_TOKENS`:\n      return `length`;\n    case `IMAGE_SAFETY`:\n    case `RECITATION`:\n    case `SAFETY`:\n    case `BLOCKLIST`:\n    case `PROHIBITED_CONTENT`:\n    case `SPII`:\n      return `content-filter`;\n    case `FINISH_REASON_UNSPECIFIED`:\n    case `OTHER`:\n      return `other`;\n    case `MALFORMED_FUNCTION_CALL`:\n      return `error`;\n    default:\n      return `unknown`;\n  }\n}\nvar _r = exports_external.object({ web: exports_external.object({ uri: exports_external.string(), title: exports_external.string() }).nullish(), retrievedContext: exports_external.object({ uri: exports_external.string(), title: exports_external.string() }).nullish() });\nvar vr = exports_external.object({ webSearchQueries: exports_external.array(exports_external.string()).nullish(), retrievalQueries: exports_external.array(exports_external.string()).nullish(), searchEntryPoint: exports_external.object({ renderedContent: exports_external.string() }).nullish(), groundingChunks: exports_external.array(_r).nullish(), groundingSupports: exports_external.array(exports_external.object({ segment: exports_external.object({ startIndex: exports_external.number().nullish(), endIndex: exports_external.number().nullish(), text: exports_external.string().nullish() }), segment_text: exports_external.string().nullish(), groundingChunkIndices: exports_external.array(exports_external.number()).nullish(), supportChunkIndices: exports_external.array(exports_external.number()).nullish(), confidenceScores: exports_external.array(exports_external.number()).nullish(), confidenceScore: exports_external.array(exports_external.number()).nullish() })).nullish(), retrievalMetadata: exports_external.union([exports_external.object({ webDynamicRetrievalScore: exports_external.number() }), exports_external.object({})]).nullish() });\nvar yr = Xn({ id: `google.google_search`, name: `google_search`, inputSchema: exports_external.object({ mode: exports_external.enum([`MODE_DYNAMIC`, `MODE_UNSPECIFIED`]).default(`MODE_UNSPECIFIED`), dynamicThreshold: exports_external.number().default(1) }) });\nvar br = exports_external.object({ retrievedUrl: exports_external.string(), urlRetrievalStatus: exports_external.string() });\nvar xr = exports_external.object({ urlMetadata: exports_external.array(br) });\nvar Sr = Xn({ id: `google.url_context`, name: `url_context`, inputSchema: exports_external.object({}) });\nvar Cr = class {\n  constructor(e5, t3) {\n    this.specificationVersion = `v2`, this.modelId = e5, this.config = t3, this.generateId = t3.generateId ?? Tn;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get supportedUrls() {\n    var e5;\n    return (e5 = this.config).supportedUrls?.call(e5) ?? {};\n  }\n  async getArgs({ prompt: e5, maxOutputTokens: t3, temperature: n3, topP: r3, topK: i4, frequencyPenalty: a5, presencePenalty: o3, stopSequences: s4, responseFormat: c4, seed: l3, tools: u3, toolChoice: d2, providerOptions: f2 }) {\n    let p2 = [], m2 = await Kn({ provider: `google`, providerOptions: f2, schema: mr });\n    m2?.thinkingConfig?.includeThoughts === true && !this.config.provider.startsWith(`google.vertex.`) && p2.push({ type: `other`, message: `The \'includeThoughts\' option is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).` });\n    let h2 = this.modelId.toLowerCase().startsWith(`gemma-`), { contents: g2, systemInstruction: _2 } = fr(e5, { isGemmaModel: h2 }), { tools: v2, toolConfig: y2, toolWarnings: b2 } = hr({ tools: u3, toolChoice: d2, modelId: this.modelId });\n    return { args: { generationConfig: { maxOutputTokens: t3, temperature: n3, topK: i4, topP: r3, frequencyPenalty: a5, presencePenalty: o3, stopSequences: s4, seed: l3, responseMimeType: c4?.type === `json` ? `application/json` : undefined, responseSchema: c4?.type === `json` && c4.schema != null && (m2?.structuredOutputs ?? true) ? U(c4.schema) : undefined, ...m2?.audioTimestamp && { audioTimestamp: m2.audioTimestamp }, responseModalities: m2?.responseModalities, thinkingConfig: m2?.thinkingConfig }, contents: g2, systemInstruction: h2 ? undefined : _2, safetySettings: m2?.safetySettings, tools: v2, toolConfig: y2, cachedContent: m2?.cachedContent, labels: m2?.labels }, warnings: [...p2, ...b2] };\n  }\n  async doGenerate(e5) {\n    let { args: t3, warnings: n3 } = await this.getArgs(e5), r3 = JSON.stringify(t3), i4 = L(await B(this.config.headers), e5.headers), { responseHeaders: a5, value: o3, rawValue: s4 } = await z2({ url: `${this.config.baseURL}/${pr(this.modelId)}:generateContent`, headers: i4, body: t3, failedResponseHandler: H, successfulResponseHandler: V(kr), abortSignal: e5.abortSignal, fetch: this.config.fetch }), c4 = o3.candidates[0], l3 = [], u3 = c4.content?.parts ?? [], d2 = o3.usageMetadata, f2;\n    for (let e6 of u3)\n      if (`executableCode` in e6 && e6.executableCode?.code) {\n        let t4 = this.config.generateId();\n        f2 = t4, l3.push({ type: `tool-call`, toolCallId: t4, toolName: `code_execution`, input: JSON.stringify(e6.executableCode), providerExecuted: true });\n      } else\n        `codeExecutionResult` in e6 && e6.codeExecutionResult ? (l3.push({ type: `tool-result`, toolCallId: f2, toolName: `code_execution`, result: { outcome: e6.codeExecutionResult.outcome, output: e6.codeExecutionResult.output }, providerExecuted: true }), f2 = undefined) : (`text` in e6) && e6.text != null && e6.text.length > 0 ? l3.push({ type: e6.thought === true ? `reasoning` : `text`, text: e6.text, providerMetadata: e6.thoughtSignature ? { google: { thoughtSignature: e6.thoughtSignature } } : undefined }) : (`functionCall` in e6) ? l3.push({ type: `tool-call`, toolCallId: this.config.generateId(), toolName: e6.functionCall.name, input: JSON.stringify(e6.functionCall.args), providerMetadata: e6.thoughtSignature ? { google: { thoughtSignature: e6.thoughtSignature } } : undefined }) : (`inlineData` in e6) && l3.push({ type: `file`, data: e6.inlineData.data, mediaType: e6.inlineData.mimeType });\n    let p2 = Er({ groundingMetadata: c4.groundingMetadata, generateId: this.config.generateId }) ?? [];\n    for (let e6 of p2)\n      l3.push(e6);\n    return { content: l3, finishReason: gr({ finishReason: c4.finishReason, hasToolCalls: l3.some((e6) => e6.type === `tool-call`) }), usage: { inputTokens: d2?.promptTokenCount ?? undefined, outputTokens: d2?.candidatesTokenCount ?? undefined, totalTokens: d2?.totalTokenCount ?? undefined, reasoningTokens: d2?.thoughtsTokenCount ?? undefined, cachedInputTokens: d2?.cachedContentTokenCount ?? undefined }, warnings: n3, providerMetadata: { google: { promptFeedback: o3.promptFeedback ?? null, groundingMetadata: c4.groundingMetadata ?? null, urlContextMetadata: c4.urlContextMetadata ?? null, safetyRatings: c4.safetyRatings ?? null, usageMetadata: d2 ?? null } }, request: { body: r3 }, response: { headers: a5, body: s4 } };\n  }\n  async doStream(e5) {\n    let { args: t3, warnings: n3 } = await this.getArgs(e5), r3 = JSON.stringify(t3), i4 = L(await B(this.config.headers), e5.headers), { responseHeaders: a5, value: o3 } = await z2({ url: `${this.config.baseURL}/${pr(this.modelId)}:streamGenerateContent?alt=sse`, headers: i4, body: t3, failedResponseHandler: H, successfulResponseHandler: $n(Ar), abortSignal: e5.abortSignal, fetch: this.config.fetch }), s4 = `unknown`, c4 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, l3, u3 = this.config.generateId, d2 = false, f2 = null, p2 = null, m2 = 0, h2 = new Set, g2;\n    return { stream: o3.pipeThrough(new TransformStream({ start(e6) {\n      e6.enqueue({ type: `stream-start`, warnings: n3 });\n    }, transform(t4, n4) {\n      if (e5.includeRawChunks && n4.enqueue({ type: `raw`, rawValue: t4.rawValue }), !t4.success) {\n        n4.enqueue({ type: `error`, error: t4.error });\n        return;\n      }\n      let r4 = t4.value, i5 = r4.usageMetadata;\n      i5 != null && (c4.inputTokens = i5.promptTokenCount ?? undefined, c4.outputTokens = i5.candidatesTokenCount ?? undefined, c4.totalTokens = i5.totalTokenCount ?? undefined, c4.reasoningTokens = i5.thoughtsTokenCount ?? undefined, c4.cachedInputTokens = i5.cachedContentTokenCount ?? undefined);\n      let a6 = r4.candidates?.[0];\n      if (a6 == null)\n        return;\n      let o4 = a6.content, _2 = Er({ groundingMetadata: a6.groundingMetadata, generateId: u3 });\n      if (_2 != null)\n        for (let e6 of _2)\n          e6.sourceType === `url` && !h2.has(e6.url) && (h2.add(e6.url), n4.enqueue(e6));\n      if (o4 != null) {\n        let e6 = o4.parts ?? [];\n        for (let t6 of e6)\n          if (`executableCode` in t6 && t6.executableCode?.code) {\n            let e7 = u3();\n            g2 = e7, n4.enqueue({ type: `tool-call`, toolCallId: e7, toolName: `code_execution`, input: JSON.stringify(t6.executableCode), providerExecuted: true }), d2 = true;\n          } else if (`codeExecutionResult` in t6 && t6.codeExecutionResult) {\n            let e7 = g2;\n            e7 && (n4.enqueue({ type: `tool-result`, toolCallId: e7, toolName: `code_execution`, result: { outcome: t6.codeExecutionResult.outcome, output: t6.codeExecutionResult.output }, providerExecuted: true }), g2 = undefined);\n          } else\n            `text` in t6 && t6.text != null && t6.text.length > 0 && (t6.thought === true ? (f2 !== null && (n4.enqueue({ type: `text-end`, id: f2 }), f2 = null), p2 === null && (p2 = String(m2++), n4.enqueue({ type: `reasoning-start`, id: p2, providerMetadata: t6.thoughtSignature ? { google: { thoughtSignature: t6.thoughtSignature } } : undefined })), n4.enqueue({ type: `reasoning-delta`, id: p2, delta: t6.text, providerMetadata: t6.thoughtSignature ? { google: { thoughtSignature: t6.thoughtSignature } } : undefined })) : (p2 !== null && (n4.enqueue({ type: `reasoning-end`, id: p2 }), p2 = null), f2 === null && (f2 = String(m2++), n4.enqueue({ type: `text-start`, id: f2, providerMetadata: t6.thoughtSignature ? { google: { thoughtSignature: t6.thoughtSignature } } : undefined })), n4.enqueue({ type: `text-delta`, id: f2, delta: t6.text, providerMetadata: t6.thoughtSignature ? { google: { thoughtSignature: t6.thoughtSignature } } : undefined })));\n        let t5 = Tr(o4.parts);\n        if (t5 != null)\n          for (let e7 of t5)\n            n4.enqueue({ type: `file`, mediaType: e7.inlineData.mimeType, data: e7.inlineData.data });\n        let r5 = wr({ parts: o4.parts, generateId: u3 });\n        if (r5 != null)\n          for (let e7 of r5)\n            n4.enqueue({ type: `tool-input-start`, id: e7.toolCallId, toolName: e7.toolName, providerMetadata: e7.providerMetadata }), n4.enqueue({ type: `tool-input-delta`, id: e7.toolCallId, delta: e7.args, providerMetadata: e7.providerMetadata }), n4.enqueue({ type: `tool-input-end`, id: e7.toolCallId, providerMetadata: e7.providerMetadata }), n4.enqueue({ type: `tool-call`, toolCallId: e7.toolCallId, toolName: e7.toolName, input: e7.args, providerMetadata: e7.providerMetadata }), d2 = true;\n      }\n      a6.finishReason != null && (s4 = gr({ finishReason: a6.finishReason, hasToolCalls: d2 }), l3 = { google: { promptFeedback: r4.promptFeedback ?? null, groundingMetadata: a6.groundingMetadata ?? null, urlContextMetadata: a6.urlContextMetadata ?? null, safetyRatings: a6.safetyRatings ?? null } }, i5 != null && (l3.google.usageMetadata = i5));\n    }, flush(e6) {\n      f2 !== null && e6.enqueue({ type: `text-end`, id: f2 }), p2 !== null && e6.enqueue({ type: `reasoning-end`, id: p2 }), e6.enqueue({ type: `finish`, finishReason: s4, usage: c4, providerMetadata: l3 });\n    } })), response: { headers: a5 }, request: { body: r3 } };\n  }\n};\nfunction wr({ parts: e5, generateId: t3 }) {\n  let n3 = e5?.filter((e6) => (`functionCall` in e6));\n  return n3 == null || n3.length === 0 ? undefined : n3.map((e6) => ({ type: `tool-call`, toolCallId: t3(), toolName: e6.functionCall.name, args: JSON.stringify(e6.functionCall.args), providerMetadata: e6.thoughtSignature ? { google: { thoughtSignature: e6.thoughtSignature } } : undefined }));\n}\nfunction Tr(e5) {\n  return e5?.filter((e6) => (`inlineData` in e6));\n}\nfunction Er({ groundingMetadata: e5, generateId: t3 }) {\n  return e5?.groundingChunks?.filter((e6) => e6.web != null).map((e6) => ({ type: `source`, sourceType: `url`, id: t3(), url: e6.web.uri, title: e6.web.title }));\n}\nvar Dr = exports_external.object({ parts: exports_external.array(exports_external.union([exports_external.object({ functionCall: exports_external.object({ name: exports_external.string(), args: exports_external.unknown() }), thoughtSignature: exports_external.string().nullish() }), exports_external.object({ inlineData: exports_external.object({ mimeType: exports_external.string(), data: exports_external.string() }) }), exports_external.object({ executableCode: exports_external.object({ language: exports_external.string(), code: exports_external.string() }).nullish(), codeExecutionResult: exports_external.object({ outcome: exports_external.string(), output: exports_external.string() }).nullish(), text: exports_external.string().nullish(), thought: exports_external.boolean().nullish(), thoughtSignature: exports_external.string().nullish() })])).nullish() });\nvar W = exports_external.object({ category: exports_external.string().nullish(), probability: exports_external.string().nullish(), probabilityScore: exports_external.number().nullish(), severity: exports_external.string().nullish(), severityScore: exports_external.number().nullish(), blocked: exports_external.boolean().nullish() });\nvar Or = exports_external.object({ cachedContentTokenCount: exports_external.number().nullish(), thoughtsTokenCount: exports_external.number().nullish(), promptTokenCount: exports_external.number().nullish(), candidatesTokenCount: exports_external.number().nullish(), totalTokenCount: exports_external.number().nullish() });\nvar kr = exports_external.object({ candidates: exports_external.array(exports_external.object({ content: Dr.nullish().or(exports_external.object({}).strict()), finishReason: exports_external.string().nullish(), safetyRatings: exports_external.array(W).nullish(), groundingMetadata: vr.nullish(), urlContextMetadata: xr.nullish() })), usageMetadata: Or.nullish(), promptFeedback: exports_external.object({ blockReason: exports_external.string().nullish(), safetyRatings: exports_external.array(W).nullish() }).nullish() });\nvar Ar = exports_external.object({ candidates: exports_external.array(exports_external.object({ content: Dr.nullish(), finishReason: exports_external.string().nullish(), safetyRatings: exports_external.array(W).nullish(), groundingMetadata: vr.nullish(), urlContextMetadata: xr.nullish() })).nullish(), usageMetadata: Or.nullish(), promptFeedback: exports_external.object({ blockReason: exports_external.string().nullish(), safetyRatings: exports_external.array(W).nullish() }).nullish() });\nvar jr = Zn({ id: `google.code_execution`, name: `code_execution`, inputSchema: exports_external.object({ language: exports_external.string().describe(`The programming language of the code.`), code: exports_external.string().describe(`The code to be executed.`) }), outputSchema: exports_external.object({ outcome: exports_external.string().describe(`The outcome of the execution (e.g., "OUTCOME_OK").`), output: exports_external.string().describe(`The output from the code execution.`) }) });\nvar Mr = { googleSearch: yr, urlContext: Sr, codeExecution: jr };\nvar Nr = class {\n  constructor(e5, t3, n3) {\n    this.modelId = e5, this.settings = t3, this.config = n3, this.specificationVersion = `v2`;\n  }\n  get maxImagesPerCall() {\n    return this.settings.maxImagesPerCall ?? 4;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate(e5) {\n    var t3;\n    let { prompt: n3, n: r3 = 1, size: i4 = `1024x1024`, aspectRatio: a5 = `1:1`, seed: o3, providerOptions: s4, headers: c4, abortSignal: l3 } = e5, u3 = [];\n    i4 != null && u3.push({ type: `unsupported-setting`, setting: `size`, details: "This model does not support the `size` option. Use `aspectRatio` instead." }), o3 != null && u3.push({ type: `unsupported-setting`, setting: `seed`, details: "This model does not support the `seed` option through this provider." });\n    let d2 = await Kn({ provider: `google`, providerOptions: s4, schema: Fr }), f2 = (t3 = this.config._internal)?.currentDate?.call(t3) ?? new Date, p2 = { sampleCount: r3 };\n    a5 != null && (p2.aspectRatio = a5), d2 && Object.assign(p2, d2);\n    let m2 = { instances: [{ prompt: n3 }], parameters: p2 }, { responseHeaders: h2, value: g2 } = await z2({ url: `${this.config.baseURL}/models/${this.modelId}:predict`, headers: L(await B(this.config.headers), c4), body: m2, failedResponseHandler: H, successfulResponseHandler: V(Pr), abortSignal: l3, fetch: this.config.fetch });\n    return { images: g2.predictions.map((e6) => e6.bytesBase64Encoded), warnings: u3 ?? [], providerMetadata: { google: { images: g2.predictions.map((e6) => ({})) } }, response: { timestamp: f2, modelId: this.modelId, headers: h2 } };\n  }\n};\nvar Pr = exports_external.object({ predictions: exports_external.array(exports_external.object({ bytesBase64Encoded: exports_external.string() })).default([]) });\nvar Fr = exports_external.object({ personGeneration: exports_external.enum([`dont_allow`, `allow_adult`, `allow_all`]).nullish(), aspectRatio: exports_external.enum([`1:1`, `3:4`, `4:3`, `9:16`, `16:9`]).nullish() });\nfunction Ir(e5 = {}) {\n  let t3 = ir(e5.baseURL) ?? `https://generativelanguage.googleapis.com/v1beta`, n3 = () => wn({ "x-goog-api-key": An({ apiKey: e5.apiKey, environmentVariableName: `GOOGLE_GENERATIVE_AI_API_KEY`, description: `Google Generative AI` }), ...e5.headers }, `ai-sdk/google/${ar}`), r3 = (r4) => new Cr(r4, { provider: `google.generative-ai`, baseURL: t3, headers: n3, generateId: e5.generateId ?? Tn, supportedUrls: () => ({ "*": [RegExp(`^${t3}/files/.*$`), RegExp(`^https://(?:www\\\\.)?youtube\\\\.com/watch\\\\?v=[\\\\w-]+(?:&[\\\\w=&.-]*)?$`), RegExp(`^https://youtu\\\\.be/[\\\\w-]+(?:\\\\?[\\\\w=&.-]*)?$`)] }), fetch: e5.fetch }), i4 = (r4) => new cr(r4, { provider: `google.generative-ai`, baseURL: t3, headers: n3, fetch: e5.fetch }), a5 = (r4, i5 = {}) => new Nr(r4, i5, { provider: `google.generative-ai`, baseURL: t3, headers: n3, fetch: e5.fetch }), o3 = function(e6) {\n    if (new.target)\n      throw Error(`The Google Generative AI model function cannot be called with the new keyword.`);\n    return r3(e6);\n  };\n  return o3.languageModel = r3, o3.chat = r3, o3.generativeAI = r3, o3.embedding = i4, o3.textEmbedding = i4, o3.textEmbeddingModel = i4, o3.image = a5, o3.imageModel = a5, o3.tools = Mr, o3;\n}\nIr();\nfunction G(...e5) {\n  return e5.reduce((e6, t3) => ({ ...e6, ...t3 ?? {} }), {});\n}\nfunction K(e5) {\n  return Object.fromEntries([...e5.headers]);\n}\nfunction Lr(e5 = globalThis) {\n  return e5.window ? `runtime/browser` : e5.navigator?.userAgent ? `runtime/${e5.navigator.userAgent.toLowerCase()}` : e5.process?.versions?.node ? `runtime/node.js/${e5.process.version.substring(0)}` : e5.EdgeRuntime ? `runtime/vercel-edge` : `runtime/unknown`;\n}\nfunction Rr(e5) {\n  return Object.fromEntries(Object.entries(e5).filter(([e6, t3]) => t3 != null));\n}\nfunction zr(e5, ...t3) {\n  let n3 = Rr(e5 ?? {}), r3 = new Headers(n3), i4 = r3.get(`user-agent`) || ``;\n  return r3.set(`user-agent`, [i4, ...t3].filter(Boolean).join(` `)), Object.fromEntries(r3);\n}\nvar q = (({ prefix: e5, size: t3 = 16, alphabet: n3 = `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`, separator: r3 = `-` } = {}) => {\n  let i4 = () => {\n    let e6 = n3.length, r4 = Array(t3);\n    for (let i5 = 0;i5 < t3; i5++)\n      r4[i5] = n3[Math.random() * e6 | 0];\n    return r4.join(``);\n  };\n  if (e5 == null)\n    return i4;\n  if (n3.includes(r3))\n    throw new D({ argument: `separator`, message: `The separator "${r3}" must not be part of the alphabet "${n3}".` });\n  return () => `${e5}${r3}${i4()}`;\n})();\nfunction Br(e5) {\n  return (e5 instanceof Error || e5 instanceof DOMException) && (e5.name === `AbortError` || e5.name === `ResponseAborted` || e5.name === `TimeoutError`);\n}\nvar Vr = [`fetch failed`, `failed to fetch`];\nfunction Hr({ error: e5, url: t3, requestBodyValues: n3 }) {\n  if (Br(e5))\n    return e5;\n  if (e5 instanceof TypeError && Vr.includes(e5.message.toLowerCase())) {\n    let r3 = e5.cause;\n    if (r3 != null)\n      return new T({ message: `Cannot connect to API: ${r3.message}`, cause: r3, url: t3, requestBodyValues: n3, isRetryable: true });\n  }\n  return e5;\n}\nvar Ur = `3.0.10`;\nfunction Wr({ apiKey: e5, environmentVariableName: t3, apiKeyParameterName: n3 = `apiKey`, description: r3 }) {\n  if (typeof e5 == `string`)\n    return e5;\n  if (e5 != null)\n    throw new k({ message: `${r3} API key must be a string.` });\n  if (typeof process > `u`)\n    throw new k({ message: `${r3} API key is missing. Pass it using the \'${n3}\' parameter. Environment variables is not supported in this environment.` });\n  if (e5 = process.env[t3], e5 == null)\n    throw new k({ message: `${r3} API key is missing. Pass it using the \'${n3}\' parameter or the ${t3} environment variable.` });\n  if (typeof e5 != `string`)\n    throw new k({ message: `${r3} API key must be a string. The value of the ${t3} environment variable is not a string.` });\n  return e5;\n}\nfunction Gr({ settingValue: e5, environmentVariableName: t3 }) {\n  if (typeof e5 == `string` || !(e5 != null || typeof process > `u`) && (e5 = process.env[t3], !(e5 == null || typeof e5 != `string`)))\n    return e5;\n}\nfunction Kr(e5) {\n  let [t3, n3 = ``] = e5.toLowerCase().split(`/`);\n  return { mpeg: `mp3`, "x-wav": `wav`, opus: `ogg`, mp4: `m4a`, "x-m4a": `m4a` }[n3] ?? n3;\n}\nvar qr = /"__proto__"\\s*:/;\nvar Jr = /"constructor"\\s*:/;\nfunction Yr(e5) {\n  let t3 = JSON.parse(e5);\n  return typeof t3 != `object` || !t3 || qr.test(e5) === false && Jr.test(e5) === false ? t3 : Xr(t3);\n}\nfunction Xr(e5) {\n  let t3 = [e5];\n  for (;t3.length; ) {\n    let e6 = t3;\n    t3 = [];\n    for (let n3 of e6) {\n      if (Object.prototype.hasOwnProperty.call(n3, `__proto__`) || Object.prototype.hasOwnProperty.call(n3, `constructor`) && Object.prototype.hasOwnProperty.call(n3.constructor, `prototype`))\n        throw SyntaxError(`Object contains forbidden prototype property`);\n      for (let e7 in n3) {\n        let r3 = n3[e7];\n        r3 && typeof r3 == `object` && t3.push(r3);\n      }\n    }\n  }\n  return e5;\n}\nfunction Zr(e5) {\n  let { stackTraceLimit: t3 } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return Yr(e5);\n  } finally {\n    Error.stackTraceLimit = t3;\n  }\n}\nvar Qr = Symbol.for(`vercel.ai.validator`);\nfunction $r(e5) {\n  return { [Qr]: true, validate: e5 };\n}\nfunction ei(e5) {\n  return typeof e5 == `object` && !!e5 && Qr in e5 && e5[Qr] === true && `validate` in e5;\n}\nfunction ti(e5) {\n  return ei(e5) ? e5 : ni(e5);\n}\nfunction ni(e5) {\n  return $r(async (t3) => {\n    let n3 = await e5[`~standard`].validate(t3);\n    return n3.issues == null ? { success: true, value: n3.value } : { success: false, error: new A({ value: t3, cause: n3.issues }) };\n  });\n}\nasync function ri({ value: e5, schema: t3 }) {\n  let n3 = await ii({ value: e5, schema: t3 });\n  if (!n3.success)\n    throw A.wrap({ value: e5, cause: n3.error });\n  return n3.value;\n}\nasync function ii({ value: e5, schema: t3 }) {\n  let n3 = ti(t3);\n  try {\n    if (n3.validate == null)\n      return { success: true, value: e5, rawValue: e5 };\n    let t4 = await n3.validate(e5);\n    return t4.success ? { success: true, value: t4.value, rawValue: e5 } : { success: false, error: A.wrap({ value: e5, cause: t4.error }), rawValue: e5 };\n  } catch (t4) {\n    return { success: false, error: A.wrap({ value: e5, cause: t4 }), rawValue: e5 };\n  }\n}\nasync function ai({ text: e5, schema: t3 }) {\n  try {\n    let n3 = Zr(e5);\n    return t3 == null ? n3 : ri({ value: n3, schema: t3 });\n  } catch (t4) {\n    throw O.isInstance(t4) || A.isInstance(t4) ? t4 : new O({ text: e5, cause: t4 });\n  }\n}\nasync function oi({ text: e5, schema: t3 }) {\n  try {\n    let n3 = Zr(e5);\n    return t3 == null ? { success: true, value: n3, rawValue: n3 } : await ii({ value: n3, schema: t3 });\n  } catch (t4) {\n    return { success: false, error: O.isInstance(t4) ? t4 : new O({ text: e5, cause: t4 }), rawValue: undefined };\n  }\n}\nfunction si(e5) {\n  try {\n    return Zr(e5), true;\n  } catch {\n    return false;\n  }\n}\nfunction ci({ stream: e5, schema: t3 }) {\n  return e5.pipeThrough(new TextDecoderStream).pipeThrough(new l2).pipeThrough(new TransformStream({ async transform({ data: e6 }, n3) {\n    e6 !== `[DONE]` && n3.enqueue(await oi({ text: e6, schema: t3 }));\n  } }));\n}\nasync function J({ provider: e5, providerOptions: t3, schema: n3 }) {\n  if (t3?.[e5] == null)\n    return;\n  let r3 = await ii({ value: t3[e5], schema: n3 });\n  if (!r3.success)\n    throw new D({ argument: `providerOptions`, message: `invalid ${e5} provider options`, cause: r3.error });\n  return r3.value;\n}\nvar li = () => globalThis.fetch;\nvar Y = async ({ url: e5, headers: t3, body: n3, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 }) => di({ url: e5, headers: { "Content-Type": `application/json`, ...t3 }, body: { content: JSON.stringify(n3), values: n3 }, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 });\nvar ui = async ({ url: e5, headers: t3, formData: n3, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 }) => di({ url: e5, headers: t3, body: { content: n3, values: Object.fromEntries(n3.entries()) }, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 });\nvar di = async ({ url: e5, headers: t3 = {}, body: n3, successfulResponseHandler: r3, failedResponseHandler: i4, abortSignal: a5, fetch: o3 = li() }) => {\n  try {\n    let s4 = await o3(e5, { method: `POST`, headers: zr(t3, `ai-sdk/provider-utils/${Ur}`, Lr()), body: n3.content, signal: a5 }), c4 = K(s4);\n    if (!s4.ok) {\n      let t4;\n      try {\n        t4 = await i4({ response: s4, url: e5, requestBodyValues: n3.values });\n      } catch (t5) {\n        throw Br(t5) || T.isInstance(t5) ? t5 : new T({ message: `Failed to process error response`, cause: t5, statusCode: s4.status, url: e5, responseHeaders: c4, requestBodyValues: n3.values });\n      }\n      throw t4.value;\n    }\n    try {\n      return await r3({ response: s4, url: e5, requestBodyValues: n3.values });\n    } catch (t4) {\n      throw t4 instanceof Error && (Br(t4) || T.isInstance(t4)) ? t4 : new T({ message: `Failed to process successful response`, cause: t4, statusCode: s4.status, url: e5, responseHeaders: c4, requestBodyValues: n3.values });\n    }\n  } catch (t4) {\n    throw Hr({ error: t4, url: e5, requestBodyValues: n3.values });\n  }\n};\nfunction fi(e5) {\n  return e5;\n}\nfunction pi({ id: e5, name: t3, inputSchema: n3 }) {\n  return ({ execute: r3, outputSchema: i4, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4, ...l3 }) => fi({ type: `provider-defined`, id: e5, name: t3, args: l3, inputSchema: n3, outputSchema: i4, execute: r3, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4 });\n}\nfunction X({ id: e5, name: t3, inputSchema: n3, outputSchema: r3 }) {\n  return ({ execute: i4, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4, ...l3 }) => fi({ type: `provider-defined`, id: e5, name: t3, args: l3, inputSchema: n3, outputSchema: r3, execute: i4, toModelOutput: a5, onInputStart: o3, onInputDelta: s4, onInputAvailable: c4 });\n}\nvar mi = ({ errorSchema: e5, errorToMessage: t3, isRetryable: n3 }) => async ({ response: r3, url: i4, requestBodyValues: a5 }) => {\n  let o3 = await r3.text(), s4 = K(r3);\n  if (o3.trim() === ``)\n    return { responseHeaders: s4, value: new T({ message: r3.statusText, url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, isRetryable: n3?.(r3) }) };\n  try {\n    let c4 = await ai({ text: o3, schema: e5 });\n    return { responseHeaders: s4, value: new T({ message: t3(c4), url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, data: c4, isRetryable: n3?.(r3, c4) }) };\n  } catch {\n    return { responseHeaders: s4, value: new T({ message: r3.statusText, url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, isRetryable: n3?.(r3) }) };\n  }\n};\nvar hi = (e5) => async ({ response: t3 }) => {\n  let n3 = K(t3);\n  if (t3.body == null)\n    throw new E({});\n  return { responseHeaders: n3, value: ci({ stream: t3.body, schema: e5 }) };\n};\nvar Z = (e5) => async ({ response: t3, url: n3, requestBodyValues: r3 }) => {\n  let i4 = await t3.text(), a5 = await oi({ text: i4, schema: e5 }), o3 = K(t3);\n  if (!a5.success)\n    throw new T({ message: `Invalid JSON response`, cause: a5.error, statusCode: t3.status, responseHeaders: o3, responseBody: i4, url: n3, requestBodyValues: r3 });\n  return { responseHeaders: o3, value: a5.value, rawValue: a5.rawValue };\n};\nvar gi = () => async ({ response: e5, url: t3, requestBodyValues: n3 }) => {\n  let r3 = K(e5);\n  if (!e5.body)\n    throw new T({ message: `Response body is empty`, url: t3, requestBodyValues: n3, statusCode: e5.status, responseHeaders: r3, responseBody: undefined });\n  try {\n    let t4 = await e5.arrayBuffer();\n    return { responseHeaders: r3, value: new Uint8Array(t4) };\n  } catch (i4) {\n    throw new T({ message: `Failed to read response as array buffer`, url: t3, requestBodyValues: n3, statusCode: e5.status, responseHeaders: r3, responseBody: undefined, cause: i4 });\n  }\n};\nvar { btoa: _i, atob: vi } = globalThis;\nfunction yi(e5) {\n  let t3 = e5.replace(/-/g, `+`).replace(/_/g, `/`), n3 = vi(t3);\n  return Uint8Array.from(n3, (e6) => e6.codePointAt(0));\n}\nfunction bi(e5) {\n  let t3 = ``;\n  for (let n3 = 0;n3 < e5.length; n3++)\n    t3 += String.fromCodePoint(e5[n3]);\n  return _i(t3);\n}\nfunction Q(e5) {\n  return e5 instanceof Uint8Array ? bi(e5) : e5;\n}\nfunction xi(e5) {\n  return e5?.replace(/\\/$/, ``);\n}\nvar Si = exports_external.object({ error: exports_external.object({ message: exports_external.string(), type: exports_external.string().nullish(), param: exports_external.any().nullish(), code: exports_external.union([exports_external.string(), exports_external.number()]).nullish() }) });\nvar $ = mi({ errorSchema: Si, errorToMessage: (e5) => e5.error.message });\nfunction Ci({ prompt: e5, systemMessageMode: t3 = `system` }) {\n  let n3 = [], r3 = [];\n  for (let { role: i4, content: a5 } of e5)\n    switch (i4) {\n      case `system`:\n        switch (t3) {\n          case `system`:\n            n3.push({ role: `system`, content: a5 });\n            break;\n          case `developer`:\n            n3.push({ role: `developer`, content: a5 });\n            break;\n          case `remove`:\n            r3.push({ type: `other`, message: `system messages are removed for this model` });\n            break;\n          default: {\n            let e6 = t3;\n            throw Error(`Unsupported system message mode: ${e6}`);\n          }\n        }\n        break;\n      case `user`:\n        if (a5.length === 1 && a5[0].type === `text`) {\n          n3.push({ role: `user`, content: a5[0].text });\n          break;\n        }\n        n3.push({ role: `user`, content: a5.map((e6, t4) => {\n          switch (e6.type) {\n            case `text`:\n              return { type: `text`, text: e6.text };\n            case `file`:\n              if (e6.mediaType.startsWith(`image/`)) {\n                let t5 = e6.mediaType === `image/*` ? `image/jpeg` : e6.mediaType;\n                return { type: `image_url`, image_url: { url: e6.data instanceof URL ? e6.data.toString() : `data:${t5};base64,${Q(e6.data)}`, detail: e6.providerOptions?.openai?.imageDetail } };\n              } else if (e6.mediaType.startsWith(`audio/`)) {\n                if (e6.data instanceof URL)\n                  throw new j({ functionality: `audio file parts with URLs` });\n                switch (e6.mediaType) {\n                  case `audio/wav`:\n                    return { type: `input_audio`, input_audio: { data: Q(e6.data), format: `wav` } };\n                  case `audio/mp3`:\n                  case `audio/mpeg`:\n                    return { type: `input_audio`, input_audio: { data: Q(e6.data), format: `mp3` } };\n                  default:\n                    throw new j({ functionality: `audio content parts with media type ${e6.mediaType}` });\n                }\n              } else if (e6.mediaType === `application/pdf`) {\n                if (e6.data instanceof URL)\n                  throw new j({ functionality: `PDF file parts with URLs` });\n                return { type: `file`, file: typeof e6.data == `string` && e6.data.startsWith(`file-`) ? { file_id: e6.data } : { filename: e6.filename ?? `part-${t4}.pdf`, file_data: `data:application/pdf;base64,${Q(e6.data)}` } };\n              } else\n                throw new j({ functionality: `file part media type ${e6.mediaType}` });\n          }\n        }) });\n        break;\n      case `assistant`: {\n        let e6 = ``, t4 = [];\n        for (let n4 of a5)\n          switch (n4.type) {\n            case `text`:\n              e6 += n4.text;\n              break;\n            case `tool-call`:\n              t4.push({ id: n4.toolCallId, type: `function`, function: { name: n4.toolName, arguments: JSON.stringify(n4.input) } });\n              break;\n          }\n        n3.push({ role: `assistant`, content: e6, tool_calls: t4.length > 0 ? t4 : undefined });\n        break;\n      }\n      case `tool`:\n        for (let e6 of a5) {\n          let t4 = e6.output, r4;\n          switch (t4.type) {\n            case `text`:\n            case `error-text`:\n              r4 = t4.value;\n              break;\n            case `content`:\n            case `json`:\n            case `error-json`:\n              r4 = JSON.stringify(t4.value);\n              break;\n          }\n          n3.push({ role: `tool`, tool_call_id: e6.toolCallId, content: r4 });\n        }\n        break;\n      default: {\n        let e6 = i4;\n        throw Error(`Unsupported role: ${e6}`);\n      }\n    }\n  return { messages: n3, warnings: r3 };\n}\nfunction wi({ id: e5, model: t3, created: n3 }) {\n  return { id: e5 ?? undefined, modelId: t3 ?? undefined, timestamp: n3 == null ? undefined : new Date(n3 * 1000) };\n}\nfunction Ti(e5) {\n  switch (e5) {\n    case `stop`:\n      return `stop`;\n    case `length`:\n      return `length`;\n    case `content_filter`:\n      return `content-filter`;\n    case `function_call`:\n    case `tool_calls`:\n      return `tool-calls`;\n    default:\n      return `unknown`;\n  }\n}\nvar Ei = exports_external.object({ logitBias: exports_external.record(exports_external.coerce.number(), exports_external.number()).optional(), logprobs: exports_external.union([exports_external.boolean(), exports_external.number()]).optional(), parallelToolCalls: exports_external.boolean().optional(), user: exports_external.string().optional(), reasoningEffort: exports_external.enum([`minimal`, `low`, `medium`, `high`]).optional(), maxCompletionTokens: exports_external.number().optional(), store: exports_external.boolean().optional(), metadata: exports_external.record(exports_external.string().max(64), exports_external.string().max(512)).optional(), prediction: exports_external.record(exports_external.string(), exports_external.any()).optional(), structuredOutputs: exports_external.boolean().optional(), serviceTier: exports_external.enum([`auto`, `flex`, `priority`]).optional(), strictJsonSchema: exports_external.boolean().optional(), textVerbosity: exports_external.enum([`low`, `medium`, `high`]).optional(), promptCacheKey: exports_external.string().optional(), safetyIdentifier: exports_external.string().optional() });\nfunction Di({ tools: e5, toolChoice: t3, structuredOutputs: n3, strictJsonSchema: r3 }) {\n  e5 = e5?.length ? e5 : undefined;\n  let i4 = [];\n  if (e5 == null)\n    return { tools: undefined, toolChoice: undefined, toolWarnings: i4 };\n  let a5 = [];\n  for (let t4 of e5)\n    switch (t4.type) {\n      case `function`:\n        a5.push({ type: `function`, function: { name: t4.name, description: t4.description, parameters: t4.inputSchema, strict: n3 ? r3 : undefined } });\n        break;\n      default:\n        i4.push({ type: `unsupported-tool`, tool: t4 });\n        break;\n    }\n  if (t3 == null)\n    return { tools: a5, toolChoice: undefined, toolWarnings: i4 };\n  let o3 = t3.type;\n  switch (o3) {\n    case `auto`:\n    case `none`:\n    case `required`:\n      return { tools: a5, toolChoice: o3, toolWarnings: i4 };\n    case `tool`:\n      return { tools: a5, toolChoice: { type: `function`, function: { name: t3.toolName } }, toolWarnings: i4 };\n    default:\n      throw new j({ functionality: `tool choice type: ${o3}` });\n  }\n}\nvar Oi = class {\n  constructor(e5, t3) {\n    this.specificationVersion = `v2`, this.supportedUrls = { "image/*": [/^https?:\\/\\/.*$/] }, this.modelId = e5, this.config = t3;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ prompt: e5, maxOutputTokens: t3, temperature: n3, topP: r3, topK: i4, frequencyPenalty: a5, presencePenalty: o3, stopSequences: s4, responseFormat: c4, seed: l3, tools: u3, toolChoice: d2, providerOptions: f2 }) {\n    let p2 = [], m2 = await J({ provider: `openai`, providerOptions: f2, schema: Ei }) ?? {}, h2 = m2.structuredOutputs ?? true;\n    i4 != null && p2.push({ type: `unsupported-setting`, setting: `topK` }), c4?.type === `json` && c4.schema != null && !h2 && p2.push({ type: `unsupported-setting`, setting: `responseFormat`, details: `JSON response format schema is only supported with structuredOutputs` });\n    let { messages: g2, warnings: _2 } = Ci({ prompt: e5, systemMessageMode: Fi(this.modelId) });\n    p2.push(..._2);\n    let v2 = m2.strictJsonSchema ?? false, y2 = { model: this.modelId, logit_bias: m2.logitBias, logprobs: m2.logprobs === true || typeof m2.logprobs == `number` ? true : undefined, top_logprobs: typeof m2.logprobs == `number` ? m2.logprobs : typeof m2.logprobs == `boolean` && m2.logprobs ? 0 : undefined, user: m2.user, parallel_tool_calls: m2.parallelToolCalls, max_tokens: t3, temperature: n3, top_p: r3, frequency_penalty: a5, presence_penalty: o3, response_format: c4?.type === `json` ? h2 && c4.schema != null ? { type: `json_schema`, json_schema: { schema: c4.schema, strict: v2, name: c4.name ?? `response`, description: c4.description } } : { type: `json_object` } : undefined, stop: s4, seed: l3, verbosity: m2.textVerbosity, max_completion_tokens: m2.maxCompletionTokens, store: m2.store, metadata: m2.metadata, prediction: m2.prediction, reasoning_effort: m2.reasoningEffort, service_tier: m2.serviceTier, prompt_cache_key: m2.promptCacheKey, safety_identifier: m2.safetyIdentifier, messages: g2 };\n    Mi(this.modelId) ? (y2.temperature != null && (y2.temperature = undefined, p2.push({ type: `unsupported-setting`, setting: `temperature`, details: `temperature is not supported for reasoning models` })), y2.top_p != null && (y2.top_p = undefined, p2.push({ type: `unsupported-setting`, setting: `topP`, details: `topP is not supported for reasoning models` })), y2.frequency_penalty != null && (y2.frequency_penalty = undefined, p2.push({ type: `unsupported-setting`, setting: `frequencyPenalty`, details: `frequencyPenalty is not supported for reasoning models` })), y2.presence_penalty != null && (y2.presence_penalty = undefined, p2.push({ type: `unsupported-setting`, setting: `presencePenalty`, details: `presencePenalty is not supported for reasoning models` })), y2.logit_bias != null && (y2.logit_bias = undefined, p2.push({ type: `other`, message: `logitBias is not supported for reasoning models` })), y2.logprobs != null && (y2.logprobs = undefined, p2.push({ type: `other`, message: `logprobs is not supported for reasoning models` })), y2.top_logprobs != null && (y2.top_logprobs = undefined, p2.push({ type: `other`, message: `topLogprobs is not supported for reasoning models` })), y2.max_tokens != null && (y2.max_completion_tokens ??= y2.max_tokens, y2.max_tokens = undefined)) : (this.modelId.startsWith(`gpt-4o-search-preview`) || this.modelId.startsWith(`gpt-4o-mini-search-preview`)) && y2.temperature != null && (y2.temperature = undefined, p2.push({ type: `unsupported-setting`, setting: `temperature`, details: `temperature is not supported for the search preview models and has been removed.` })), m2.serviceTier === `flex` && !Ni(this.modelId) && (p2.push({ type: `unsupported-setting`, setting: `serviceTier`, details: `flex processing is only available for o3, o4-mini, and gpt-5 models` }), y2.service_tier = undefined), m2.serviceTier === `priority` && !Pi(this.modelId) && (p2.push({ type: `unsupported-setting`, setting: `serviceTier`, details: `priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported` }), y2.service_tier = undefined);\n    let { tools: b2, toolChoice: x3, toolWarnings: S2 } = Di({ tools: u3, toolChoice: d2, structuredOutputs: h2, strictJsonSchema: v2 });\n    return { args: { ...y2, tools: b2, tool_choice: x3 }, warnings: [...p2, ...S2] };\n  }\n  async doGenerate(e5) {\n    let { args: t3, warnings: n3 } = await this.getArgs(e5), { responseHeaders: r3, value: i4, rawValue: a5 } = await Y({ url: this.config.url({ path: `/chat/completions`, modelId: this.modelId }), headers: G(this.config.headers(), e5.headers), body: t3, failedResponseHandler: $, successfulResponseHandler: Z(Ai), abortSignal: e5.abortSignal, fetch: this.config.fetch }), o3 = i4.choices[0], s4 = [], c4 = o3.message.content;\n    c4 != null && c4.length > 0 && s4.push({ type: `text`, text: c4 });\n    for (let e6 of o3.message.tool_calls ?? [])\n      s4.push({ type: `tool-call`, toolCallId: e6.id ?? q(), toolName: e6.function.name, input: e6.function.arguments });\n    for (let e6 of o3.message.annotations ?? [])\n      s4.push({ type: `source`, sourceType: `url`, id: q(), url: e6.url, title: e6.title });\n    let l3 = i4.usage?.completion_tokens_details, u3 = i4.usage?.prompt_tokens_details, d2 = { openai: {} };\n    return l3?.accepted_prediction_tokens != null && (d2.openai.acceptedPredictionTokens = l3?.accepted_prediction_tokens), l3?.rejected_prediction_tokens != null && (d2.openai.rejectedPredictionTokens = l3?.rejected_prediction_tokens), o3.logprobs?.content != null && (d2.openai.logprobs = o3.logprobs.content), { content: s4, finishReason: Ti(o3.finish_reason), usage: { inputTokens: i4.usage?.prompt_tokens ?? undefined, outputTokens: i4.usage?.completion_tokens ?? undefined, totalTokens: i4.usage?.total_tokens ?? undefined, reasoningTokens: l3?.reasoning_tokens ?? undefined, cachedInputTokens: u3?.cached_tokens ?? undefined }, request: { body: t3 }, response: { ...wi(i4), headers: r3, body: a5 }, warnings: n3, providerMetadata: d2 };\n  }\n  async doStream(e5) {\n    let { args: t3, warnings: n3 } = await this.getArgs(e5), r3 = { ...t3, stream: true, stream_options: { include_usage: true } }, { responseHeaders: i4, value: a5 } = await Y({ url: this.config.url({ path: `/chat/completions`, modelId: this.modelId }), headers: G(this.config.headers(), e5.headers), body: r3, failedResponseHandler: $, successfulResponseHandler: hi(ji), abortSignal: e5.abortSignal, fetch: this.config.fetch }), o3 = [], s4 = `unknown`, c4 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, l3 = true, u3 = false, d2 = { openai: {} };\n    return { stream: a5.pipeThrough(new TransformStream({ start(e6) {\n      e6.enqueue({ type: `stream-start`, warnings: n3 });\n    }, transform(t4, n4) {\n      if (e5.includeRawChunks && n4.enqueue({ type: `raw`, rawValue: t4.rawValue }), !t4.success) {\n        s4 = `error`, n4.enqueue({ type: `error`, error: t4.error });\n        return;\n      }\n      let r4 = t4.value;\n      if (`error` in r4) {\n        s4 = `error`, n4.enqueue({ type: `error`, error: r4.error });\n        return;\n      }\n      l3 && (l3 = false, n4.enqueue({ type: `response-metadata`, ...wi(r4) })), r4.usage != null && (c4.inputTokens = r4.usage.prompt_tokens ?? undefined, c4.outputTokens = r4.usage.completion_tokens ?? undefined, c4.totalTokens = r4.usage.total_tokens ?? undefined, c4.reasoningTokens = r4.usage.completion_tokens_details?.reasoning_tokens ?? undefined, c4.cachedInputTokens = r4.usage.prompt_tokens_details?.cached_tokens ?? undefined, r4.usage.completion_tokens_details?.accepted_prediction_tokens != null && (d2.openai.acceptedPredictionTokens = r4.usage.completion_tokens_details?.accepted_prediction_tokens), r4.usage.completion_tokens_details?.rejected_prediction_tokens != null && (d2.openai.rejectedPredictionTokens = r4.usage.completion_tokens_details?.rejected_prediction_tokens));\n      let i5 = r4.choices[0];\n      if (i5?.finish_reason != null && (s4 = Ti(i5.finish_reason)), i5?.logprobs?.content != null && (d2.openai.logprobs = i5.logprobs.content), i5?.delta == null)\n        return;\n      let a6 = i5.delta;\n      if (a6.content != null && (u3 ||= (n4.enqueue({ type: `text-start`, id: `0` }), true), n4.enqueue({ type: `text-delta`, id: `0`, delta: a6.content })), a6.tool_calls != null)\n        for (let e6 of a6.tool_calls) {\n          let t5 = e6.index;\n          if (o3[t5] == null) {\n            if (e6.type !== `function`)\n              throw new Se({ data: e6, message: `Expected \'function\' type.` });\n            if (e6.id == null)\n              throw new Se({ data: e6, message: `Expected \'id\' to be a string.` });\n            if (e6.function?.name == null)\n              throw new Se({ data: e6, message: `Expected \'function.name\' to be a string.` });\n            n4.enqueue({ type: `tool-input-start`, id: e6.id, toolName: e6.function.name }), o3[t5] = { id: e6.id, type: `function`, function: { name: e6.function.name, arguments: e6.function.arguments ?? `` }, hasFinished: false };\n            let r6 = o3[t5];\n            r6.function?.name != null && r6.function?.arguments != null && (r6.function.arguments.length > 0 && n4.enqueue({ type: `tool-input-delta`, id: r6.id, delta: r6.function.arguments }), si(r6.function.arguments) && (n4.enqueue({ type: `tool-input-end`, id: r6.id }), n4.enqueue({ type: `tool-call`, toolCallId: r6.id ?? q(), toolName: r6.function.name, input: r6.function.arguments }), r6.hasFinished = true));\n            continue;\n          }\n          let r5 = o3[t5];\n          r5.hasFinished || (e6.function?.arguments != null && (r5.function.arguments += e6.function?.arguments ?? ``), n4.enqueue({ type: `tool-input-delta`, id: r5.id, delta: e6.function.arguments ?? `` }), r5.function?.name != null && r5.function?.arguments != null && si(r5.function.arguments) && (n4.enqueue({ type: `tool-input-end`, id: r5.id }), n4.enqueue({ type: `tool-call`, toolCallId: r5.id ?? q(), toolName: r5.function.name, input: r5.function.arguments }), r5.hasFinished = true));\n        }\n      if (a6.annotations != null)\n        for (let e6 of a6.annotations)\n          n4.enqueue({ type: `source`, sourceType: `url`, id: q(), url: e6.url, title: e6.title });\n    }, flush(e6) {\n      u3 && e6.enqueue({ type: `text-end`, id: `0` }), e6.enqueue({ type: `finish`, finishReason: s4, usage: c4, ...d2 == null ? {} : { providerMetadata: d2 } });\n    } })), request: { body: r3 }, response: { headers: i4 } };\n  }\n};\nvar ki = exports_external.object({ prompt_tokens: exports_external.number().nullish(), completion_tokens: exports_external.number().nullish(), total_tokens: exports_external.number().nullish(), prompt_tokens_details: exports_external.object({ cached_tokens: exports_external.number().nullish() }).nullish(), completion_tokens_details: exports_external.object({ reasoning_tokens: exports_external.number().nullish(), accepted_prediction_tokens: exports_external.number().nullish(), rejected_prediction_tokens: exports_external.number().nullish() }).nullish() }).nullish();\nvar Ai = exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ message: exports_external.object({ role: exports_external.literal(`assistant`).nullish(), content: exports_external.string().nullish(), tool_calls: exports_external.array(exports_external.object({ id: exports_external.string().nullish(), type: exports_external.literal(`function`), function: exports_external.object({ name: exports_external.string(), arguments: exports_external.string() }) })).nullish(), annotations: exports_external.array(exports_external.object({ type: exports_external.literal(`url_citation`), start_index: exports_external.number(), end_index: exports_external.number(), url: exports_external.string(), title: exports_external.string() })).nullish() }), index: exports_external.number(), logprobs: exports_external.object({ content: exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number(), top_logprobs: exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number() })) })).nullish() }).nullish(), finish_reason: exports_external.string().nullish() })), usage: ki });\nvar ji = exports_external.union([exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ delta: exports_external.object({ role: exports_external.enum([`assistant`]).nullish(), content: exports_external.string().nullish(), tool_calls: exports_external.array(exports_external.object({ index: exports_external.number(), id: exports_external.string().nullish(), type: exports_external.literal(`function`).nullish(), function: exports_external.object({ name: exports_external.string().nullish(), arguments: exports_external.string().nullish() }) })).nullish(), annotations: exports_external.array(exports_external.object({ type: exports_external.literal(`url_citation`), start_index: exports_external.number(), end_index: exports_external.number(), url: exports_external.string(), title: exports_external.string() })).nullish() }).nullish(), logprobs: exports_external.object({ content: exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number(), top_logprobs: exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number() })) })).nullish() }).nullish(), finish_reason: exports_external.string().nullish(), index: exports_external.number() })), usage: ki }), Si]);\nfunction Mi(e5) {\n  return (e5.startsWith(`o`) || e5.startsWith(`gpt-5`)) && !e5.startsWith(`gpt-5-chat`);\n}\nfunction Ni(e5) {\n  return e5.startsWith(`o3`) || e5.startsWith(`o4-mini`) || e5.startsWith(`gpt-5`) && !e5.startsWith(`gpt-5-chat`);\n}\nfunction Pi(e5) {\n  return e5.startsWith(`gpt-4`) || e5.startsWith(`gpt-5-mini`) || e5.startsWith(`gpt-5`) && !e5.startsWith(`gpt-5-nano`) && !e5.startsWith(`gpt-5-chat`) || e5.startsWith(`o3`) || e5.startsWith(`o4-mini`);\n}\nfunction Fi(e5) {\n  return Mi(e5) ? Ii[e5]?.systemMessageMode ?? `developer` : `system`;\n}\nvar Ii = { "o1-mini": { systemMessageMode: `remove` }, "o1-mini-2024-09-12": { systemMessageMode: `remove` }, "o1-preview": { systemMessageMode: `remove` }, "o1-preview-2024-09-12": { systemMessageMode: `remove` }, o3: { systemMessageMode: `developer` }, "o3-2025-04-16": { systemMessageMode: `developer` }, "o3-mini": { systemMessageMode: `developer` }, "o3-mini-2025-01-31": { systemMessageMode: `developer` }, "o4-mini": { systemMessageMode: `developer` }, "o4-mini-2025-04-16": { systemMessageMode: `developer` } };\nfunction Li({ prompt: e5, user: t3 = `user`, assistant: n3 = `assistant` }) {\n  let r3 = ``;\n  e5[0].role === `system` && (r3 += `${e5[0].content}\n\n`, e5 = e5.slice(1));\n  for (let { role: i4, content: a5 } of e5)\n    switch (i4) {\n      case `system`:\n        throw new _e({ message: "Unexpected system message in prompt: ${content}", prompt: e5 });\n      case `user`: {\n        let e6 = a5.map((e7) => {\n          switch (e7.type) {\n            case `text`:\n              return e7.text;\n          }\n        }).filter(Boolean).join(``);\n        r3 += `${t3}:\n${e6}\n\n`;\n        break;\n      }\n      case `assistant`: {\n        let e6 = a5.map((e7) => {\n          switch (e7.type) {\n            case `text`:\n              return e7.text;\n            case `tool-call`:\n              throw new j({ functionality: `tool-call messages` });\n          }\n        }).join(``);\n        r3 += `${n3}:\n${e6}\n\n`;\n        break;\n      }\n      case `tool`:\n        throw new j({ functionality: `tool messages` });\n      default: {\n        let e6 = i4;\n        throw Error(`Unsupported role: ${e6}`);\n      }\n    }\n  return r3 += `${n3}:\n`, { prompt: r3, stopSequences: [`\n${t3}:`] };\n}\nfunction Ri({ id: e5, model: t3, created: n3 }) {\n  return { id: e5 ?? undefined, modelId: t3 ?? undefined, timestamp: n3 == null ? undefined : new Date(n3 * 1000) };\n}\nfunction zi(e5) {\n  switch (e5) {\n    case `stop`:\n      return `stop`;\n    case `length`:\n      return `length`;\n    case `content_filter`:\n      return `content-filter`;\n    case `function_call`:\n    case `tool_calls`:\n      return `tool-calls`;\n    default:\n      return `unknown`;\n  }\n}\nvar Bi = exports_external.object({ echo: exports_external.boolean().optional(), logitBias: exports_external.record(exports_external.string(), exports_external.number()).optional(), suffix: exports_external.string().optional(), user: exports_external.string().optional(), logprobs: exports_external.union([exports_external.boolean(), exports_external.number()]).optional() });\nvar Vi = class {\n  constructor(e5, t3) {\n    this.specificationVersion = `v2`, this.supportedUrls = {}, this.modelId = e5, this.config = t3;\n  }\n  get providerOptionsName() {\n    return this.config.provider.split(`.`)[0].trim();\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ prompt: e5, maxOutputTokens: t3, temperature: n3, topP: r3, topK: i4, frequencyPenalty: a5, presencePenalty: o3, stopSequences: s4, responseFormat: c4, tools: l3, toolChoice: u3, seed: d2, providerOptions: f2 }) {\n    let p2 = [], m2 = { ...await J({ provider: `openai`, providerOptions: f2, schema: Bi }), ...await J({ provider: this.providerOptionsName, providerOptions: f2, schema: Bi }) };\n    i4 != null && p2.push({ type: `unsupported-setting`, setting: `topK` }), l3?.length && p2.push({ type: `unsupported-setting`, setting: `tools` }), u3 != null && p2.push({ type: `unsupported-setting`, setting: `toolChoice` }), c4 != null && c4.type !== `text` && p2.push({ type: `unsupported-setting`, setting: `responseFormat`, details: `JSON response format is not supported.` });\n    let { prompt: h2, stopSequences: g2 } = Li({ prompt: e5 }), _2 = [...g2 ?? [], ...s4 ?? []];\n    return { args: { model: this.modelId, echo: m2.echo, logit_bias: m2.logitBias, logprobs: m2?.logprobs === true ? 0 : m2?.logprobs === false ? undefined : m2?.logprobs, suffix: m2.suffix, user: m2.user, max_tokens: t3, temperature: n3, top_p: r3, frequency_penalty: a5, presence_penalty: o3, seed: d2, prompt: h2, stop: _2.length > 0 ? _2 : undefined }, warnings: p2 };\n  }\n  async doGenerate(e5) {\n    let { args: t3, warnings: n3 } = await this.getArgs(e5), { responseHeaders: r3, value: i4, rawValue: a5 } = await Y({ url: this.config.url({ path: `/completions`, modelId: this.modelId }), headers: G(this.config.headers(), e5.headers), body: t3, failedResponseHandler: $, successfulResponseHandler: Z(Ui), abortSignal: e5.abortSignal, fetch: this.config.fetch }), o3 = i4.choices[0], s4 = { openai: {} };\n    return o3.logprobs != null && (s4.openai.logprobs = o3.logprobs), { content: [{ type: `text`, text: o3.text }], usage: { inputTokens: i4.usage?.prompt_tokens, outputTokens: i4.usage?.completion_tokens, totalTokens: i4.usage?.total_tokens }, finishReason: zi(o3.finish_reason), request: { body: t3 }, response: { ...Ri(i4), headers: r3, body: a5 }, providerMetadata: s4, warnings: n3 };\n  }\n  async doStream(e5) {\n    let { args: t3, warnings: n3 } = await this.getArgs(e5), r3 = { ...t3, stream: true, stream_options: { include_usage: true } }, { responseHeaders: i4, value: a5 } = await Y({ url: this.config.url({ path: `/completions`, modelId: this.modelId }), headers: G(this.config.headers(), e5.headers), body: r3, failedResponseHandler: $, successfulResponseHandler: hi(Wi), abortSignal: e5.abortSignal, fetch: this.config.fetch }), o3 = `unknown`, s4 = { openai: {} }, c4 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, l3 = true;\n    return { stream: a5.pipeThrough(new TransformStream({ start(e6) {\n      e6.enqueue({ type: `stream-start`, warnings: n3 });\n    }, transform(t4, n4) {\n      if (e5.includeRawChunks && n4.enqueue({ type: `raw`, rawValue: t4.rawValue }), !t4.success) {\n        o3 = `error`, n4.enqueue({ type: `error`, error: t4.error });\n        return;\n      }\n      let r4 = t4.value;\n      if (`error` in r4) {\n        o3 = `error`, n4.enqueue({ type: `error`, error: r4.error });\n        return;\n      }\n      l3 && (l3 = false, n4.enqueue({ type: `response-metadata`, ...Ri(r4) }), n4.enqueue({ type: `text-start`, id: `0` })), r4.usage != null && (c4.inputTokens = r4.usage.prompt_tokens, c4.outputTokens = r4.usage.completion_tokens, c4.totalTokens = r4.usage.total_tokens);\n      let i5 = r4.choices[0];\n      i5?.finish_reason != null && (o3 = zi(i5.finish_reason)), i5?.logprobs != null && (s4.openai.logprobs = i5.logprobs), i5?.text != null && i5.text.length > 0 && n4.enqueue({ type: `text-delta`, id: `0`, delta: i5.text });\n    }, flush(e6) {\n      l3 || e6.enqueue({ type: `text-end`, id: `0` }), e6.enqueue({ type: `finish`, finishReason: o3, providerMetadata: s4, usage: c4 });\n    } })), request: { body: r3 }, response: { headers: i4 } };\n  }\n};\nvar Hi = exports_external.object({ prompt_tokens: exports_external.number(), completion_tokens: exports_external.number(), total_tokens: exports_external.number() });\nvar Ui = exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ text: exports_external.string(), finish_reason: exports_external.string(), logprobs: exports_external.object({ tokens: exports_external.array(exports_external.string()), token_logprobs: exports_external.array(exports_external.number()), top_logprobs: exports_external.array(exports_external.record(exports_external.string(), exports_external.number())).nullish() }).nullish() })), usage: Hi.nullish() });\nvar Wi = exports_external.union([exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ text: exports_external.string(), finish_reason: exports_external.string().nullish(), index: exports_external.number(), logprobs: exports_external.object({ tokens: exports_external.array(exports_external.string()), token_logprobs: exports_external.array(exports_external.number()), top_logprobs: exports_external.array(exports_external.record(exports_external.string(), exports_external.number())).nullish() }).nullish() })), usage: Hi.nullish() }), Si]);\nvar Gi = exports_external.object({ dimensions: exports_external.number().optional(), user: exports_external.string().optional() });\nvar Ki = class {\n  constructor(e5, t3) {\n    this.specificationVersion = `v2`, this.maxEmbeddingsPerCall = 2048, this.supportsParallelCalls = true, this.modelId = e5, this.config = t3;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doEmbed({ values: e5, headers: t3, abortSignal: n3, providerOptions: r3 }) {\n    if (e5.length > this.maxEmbeddingsPerCall)\n      throw new Be({ provider: this.provider, modelId: this.modelId, maxEmbeddingsPerCall: this.maxEmbeddingsPerCall, values: e5 });\n    let i4 = await J({ provider: `openai`, providerOptions: r3, schema: Gi }) ?? {}, { responseHeaders: a5, value: o3, rawValue: s4 } = await Y({ url: this.config.url({ path: `/embeddings`, modelId: this.modelId }), headers: G(this.config.headers(), t3), body: { model: this.modelId, input: e5, encoding_format: `float`, dimensions: i4.dimensions, user: i4.user }, failedResponseHandler: $, successfulResponseHandler: Z(qi), abortSignal: n3, fetch: this.config.fetch });\n    return { embeddings: o3.data.map((e6) => e6.embedding), usage: o3.usage ? { tokens: o3.usage.prompt_tokens } : undefined, response: { headers: a5, body: s4 } };\n  }\n};\nvar qi = exports_external.object({ data: exports_external.array(exports_external.object({ embedding: exports_external.array(exports_external.number()) })), usage: exports_external.object({ prompt_tokens: exports_external.number() }).nullish() });\nvar Ji = { "dall-e-3": 1, "dall-e-2": 10, "gpt-image-1": 10 };\nvar Yi = new Set([`gpt-image-1`]);\nvar Xi = class {\n  constructor(e5, t3) {\n    this.modelId = e5, this.config = t3, this.specificationVersion = `v2`;\n  }\n  get maxImagesPerCall() {\n    return Ji[this.modelId] ?? 1;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate({ prompt: e5, n: t3, size: n3, aspectRatio: r3, seed: i4, providerOptions: a5, headers: o3, abortSignal: s4 }) {\n    var c4;\n    let l3 = [];\n    r3 != null && l3.push({ type: `unsupported-setting`, setting: `aspectRatio`, details: "This model does not support aspect ratio. Use `size` instead." }), i4 != null && l3.push({ type: `unsupported-setting`, setting: `seed` });\n    let u3 = (c4 = this.config._internal)?.currentDate?.call(c4) ?? new Date, { value: d2, responseHeaders: f2 } = await Y({ url: this.config.url({ path: `/images/generations`, modelId: this.modelId }), headers: G(this.config.headers(), o3), body: { model: this.modelId, prompt: e5, n: t3, size: n3, ...a5.openai ?? {}, ...Yi.has(this.modelId) ? {} : { response_format: `b64_json` } }, failedResponseHandler: $, successfulResponseHandler: Z(Zi), abortSignal: s4, fetch: this.config.fetch });\n    return { images: d2.data.map((e6) => e6.b64_json), warnings: l3, response: { timestamp: u3, modelId: this.modelId, headers: f2 }, providerMetadata: { openai: { images: d2.data.map((e6) => e6.revised_prompt ? { revisedPrompt: e6.revised_prompt } : null) } } };\n  }\n};\nvar Zi = exports_external.object({ data: exports_external.array(exports_external.object({ b64_json: exports_external.string(), revised_prompt: exports_external.string().optional() })) });\nvar Qi = exports_external.object({ code: exports_external.string().nullish(), containerId: exports_external.string() });\nvar $i = exports_external.object({ outputs: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`logs`), logs: exports_external.string() }), exports_external.object({ type: exports_external.literal(`image`), url: exports_external.string() })])).nullish() });\nvar ea = exports_external.object({ container: exports_external.union([exports_external.string(), exports_external.object({ fileIds: exports_external.array(exports_external.string()).optional() })]).optional() });\nvar ta = X({ id: `openai.code_interpreter`, name: `code_interpreter`, inputSchema: Qi, outputSchema: $i });\nvar na = (e5 = {}) => ta(e5);\nvar ra = exports_external.object({ key: exports_external.string(), type: exports_external.enum([`eq`, `ne`, `gt`, `gte`, `lt`, `lte`]), value: exports_external.union([exports_external.string(), exports_external.number(), exports_external.boolean()]) });\nvar ia = exports_external.object({ type: exports_external.enum([`and`, `or`]), filters: exports_external.array(exports_external.union([ra, exports_external.lazy(() => ia)])) });\nvar aa = exports_external.object({ vectorStoreIds: exports_external.array(exports_external.string()), maxNumResults: exports_external.number().optional(), ranking: exports_external.object({ ranker: exports_external.string().optional(), scoreThreshold: exports_external.number().optional() }).optional(), filters: exports_external.union([ra, ia]).optional() });\nvar oa = exports_external.object({ queries: exports_external.array(exports_external.string()), results: exports_external.array(exports_external.object({ attributes: exports_external.record(exports_external.string(), exports_external.unknown()), fileId: exports_external.string(), filename: exports_external.string(), score: exports_external.number(), text: exports_external.string() })).nullable() });\nvar sa = X({ id: `openai.file_search`, name: `file_search`, inputSchema: exports_external.object({}), outputSchema: oa });\nvar ca = exports_external.object({ background: exports_external.enum([`auto`, `opaque`, `transparent`]).optional(), inputFidelity: exports_external.enum([`low`, `high`]).optional(), inputImageMask: exports_external.object({ fileId: exports_external.string().optional(), imageUrl: exports_external.string().optional() }).optional(), model: exports_external.string().optional(), moderation: exports_external.enum([`auto`]).optional(), outputCompression: exports_external.number().int().min(0).max(100).optional(), outputFormat: exports_external.enum([`png`, `jpeg`, `webp`]).optional(), quality: exports_external.enum([`auto`, `low`, `medium`, `high`]).optional(), size: exports_external.enum([`1024x1024`, `1024x1536`, `1536x1024`, `auto`]).optional() }).strict();\nvar la = exports_external.object({ result: exports_external.string() });\nvar ua = X({ id: `openai.image_generation`, name: `image_generation`, inputSchema: exports_external.object({}), outputSchema: la });\nvar da = (e5 = {}) => ua(e5);\nvar fa = exports_external.object({ action: exports_external.object({ type: exports_external.literal(`exec`), command: exports_external.array(exports_external.string()), timeoutMs: exports_external.number().optional(), user: exports_external.string().optional(), workingDirectory: exports_external.string().optional(), env: exports_external.record(exports_external.string(), exports_external.string()).optional() }) });\nvar pa = exports_external.object({ output: exports_external.string() });\nvar ma = X({ id: `openai.local_shell`, name: `local_shell`, inputSchema: fa, outputSchema: pa });\nvar ha = exports_external.object({ filters: exports_external.object({ allowedDomains: exports_external.array(exports_external.string()).optional() }).optional(), searchContextSize: exports_external.enum([`low`, `medium`, `high`]).optional(), userLocation: exports_external.object({ type: exports_external.literal(`approximate`), country: exports_external.string().optional(), city: exports_external.string().optional(), region: exports_external.string().optional(), timezone: exports_external.string().optional() }).optional() });\nvar ga = pi({ id: `openai.web_search`, name: `web_search`, inputSchema: exports_external.object({ action: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`search`), query: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`open_page`), url: exports_external.string() }), exports_external.object({ type: exports_external.literal(`find`), url: exports_external.string(), pattern: exports_external.string() })]).nullish() }) });\nvar _a18 = (e5 = {}) => ga(e5);\nvar va = exports_external.object({ searchContextSize: exports_external.enum([`low`, `medium`, `high`]).optional(), userLocation: exports_external.object({ type: exports_external.literal(`approximate`), country: exports_external.string().optional(), city: exports_external.string().optional(), region: exports_external.string().optional(), timezone: exports_external.string().optional() }).optional() });\nvar ya = pi({ id: `openai.web_search_preview`, name: `web_search_preview`, inputSchema: exports_external.object({ action: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`search`), query: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`open_page`), url: exports_external.string() }), exports_external.object({ type: exports_external.literal(`find`), url: exports_external.string(), pattern: exports_external.string() })]).nullish() }) });\nvar ba = { codeInterpreter: na, fileSearch: sa, imageGeneration: da, localShell: ma, webSearchPreview: ya, webSearch: _a18 };\nfunction xa(e5, t3) {\n  return t3 ? t3.some((t4) => e5.startsWith(t4)) : false;\n}\nasync function Sa({ prompt: e5, systemMessageMode: t3, fileIdPrefixes: n3, store: r3, hasLocalShellTool: i4 = false }) {\n  let a5 = [], o3 = [];\n  for (let { role: s4, content: c4 } of e5)\n    switch (s4) {\n      case `system`:\n        switch (t3) {\n          case `system`:\n            a5.push({ role: `system`, content: c4 });\n            break;\n          case `developer`:\n            a5.push({ role: `developer`, content: c4 });\n            break;\n          case `remove`:\n            o3.push({ type: `other`, message: `system messages are removed for this model` });\n            break;\n          default: {\n            let e6 = t3;\n            throw Error(`Unsupported system message mode: ${e6}`);\n          }\n        }\n        break;\n      case `user`:\n        a5.push({ role: `user`, content: c4.map((e6, t4) => {\n          switch (e6.type) {\n            case `text`:\n              return { type: `input_text`, text: e6.text };\n            case `file`:\n              if (e6.mediaType.startsWith(`image/`)) {\n                let t5 = e6.mediaType === `image/*` ? `image/jpeg` : e6.mediaType;\n                return { type: `input_image`, ...e6.data instanceof URL ? { image_url: e6.data.toString() } : typeof e6.data == `string` && xa(e6.data, n3) ? { file_id: e6.data } : { image_url: `data:${t5};base64,${Q(e6.data)}` }, detail: e6.providerOptions?.openai?.imageDetail };\n              } else if (e6.mediaType === `application/pdf`)\n                return e6.data instanceof URL ? { type: `input_file`, file_url: e6.data.toString() } : { type: `input_file`, ...typeof e6.data == `string` && xa(e6.data, n3) ? { file_id: e6.data } : { filename: e6.filename ?? `part-${t4}.pdf`, file_data: `data:application/pdf;base64,${Q(e6.data)}` } };\n              else\n                throw new j({ functionality: `file part media type ${e6.mediaType}` });\n          }\n        }) });\n        break;\n      case `assistant`: {\n        let e6 = {}, t4 = {};\n        for (let n4 of c4)\n          switch (n4.type) {\n            case `text`:\n              a5.push({ role: `assistant`, content: [{ type: `output_text`, text: n4.text }], id: n4.providerOptions?.openai?.itemId ?? undefined });\n              break;\n            case `tool-call`:\n              if (t4[n4.toolCallId] = n4, n4.providerExecuted)\n                break;\n              if (i4 && n4.toolName === `local_shell`) {\n                let e7 = fa.parse(n4.input);\n                a5.push({ type: `local_shell_call`, call_id: n4.toolCallId, id: n4.providerOptions?.openai?.itemId ?? undefined, action: { type: `exec`, command: e7.action.command, timeout_ms: e7.action.timeoutMs, user: e7.action.user, working_directory: e7.action.workingDirectory, env: e7.action.env } });\n                break;\n              }\n              a5.push({ type: `function_call`, call_id: n4.toolCallId, name: n4.toolName, arguments: JSON.stringify(n4.input), id: n4.providerOptions?.openai?.itemId ?? undefined });\n              break;\n            case `tool-result`:\n              r3 ? a5.push({ type: `item_reference`, id: n4.toolCallId }) : o3.push({ type: `other`, message: `Results for OpenAI tool ${n4.toolName} are not sent to the API when store is false` });\n              break;\n            case `reasoning`: {\n              let t5 = await J({ provider: `openai`, providerOptions: n4.providerOptions, schema: Ca }), i5 = t5?.itemId;\n              if (i5 != null) {\n                let s5 = e6[i5];\n                if (r3)\n                  s5 === undefined && (a5.push({ type: `item_reference`, id: i5 }), e6[i5] = { type: `reasoning`, id: i5, summary: [] });\n                else {\n                  let r4 = [];\n                  n4.text.length > 0 ? r4.push({ type: `summary_text`, text: n4.text }) : s5 !== undefined && o3.push({ type: `other`, message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(n4)}.` }), s5 === undefined ? (e6[i5] = { type: `reasoning`, id: i5, encrypted_content: t5?.reasoningEncryptedContent, summary: r4 }, a5.push(e6[i5])) : s5.summary.push(...r4);\n                }\n              } else\n                o3.push({ type: `other`, message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(n4)}.` });\n              break;\n            }\n          }\n        break;\n      }\n      case `tool`:\n        for (let e6 of c4) {\n          let t4 = e6.output;\n          if (i4 && e6.toolName === `local_shell` && t4.type === `json`) {\n            a5.push({ type: `local_shell_call_output`, call_id: e6.toolCallId, output: pa.parse(t4.value).output });\n            break;\n          }\n          let n4;\n          switch (t4.type) {\n            case `text`:\n            case `error-text`:\n              n4 = t4.value;\n              break;\n            case `content`:\n            case `json`:\n            case `error-json`:\n              n4 = JSON.stringify(t4.value);\n              break;\n          }\n          a5.push({ type: `function_call_output`, call_id: e6.toolCallId, output: n4 });\n        }\n        break;\n      default: {\n        let e6 = s4;\n        throw Error(`Unsupported role: ${e6}`);\n      }\n    }\n  return { input: a5, warnings: o3 };\n}\nvar Ca = exports_external.object({ itemId: exports_external.string().nullish(), reasoningEncryptedContent: exports_external.string().nullish() });\nfunction wa({ finishReason: e5, hasFunctionCall: t3 }) {\n  switch (e5) {\n    case undefined:\n    case null:\n      return t3 ? `tool-calls` : `stop`;\n    case `max_output_tokens`:\n      return `length`;\n    case `content_filter`:\n      return `content-filter`;\n    default:\n      return t3 ? `tool-calls` : `unknown`;\n  }\n}\nfunction Ta({ tools: e5, toolChoice: t3, strictJsonSchema: n3 }) {\n  e5 = e5?.length ? e5 : undefined;\n  let r3 = [];\n  if (e5 == null)\n    return { tools: undefined, toolChoice: undefined, toolWarnings: r3 };\n  let i4 = [];\n  for (let t4 of e5)\n    switch (t4.type) {\n      case `function`:\n        i4.push({ type: `function`, name: t4.name, description: t4.description, parameters: t4.inputSchema, strict: n3 });\n        break;\n      case `provider-defined`:\n        switch (t4.id) {\n          case `openai.file_search`: {\n            let e6 = aa.parse(t4.args);\n            i4.push({ type: `file_search`, vector_store_ids: e6.vectorStoreIds, max_num_results: e6.maxNumResults, ranking_options: e6.ranking ? { ranker: e6.ranking.ranker, score_threshold: e6.ranking.scoreThreshold } : undefined, filters: e6.filters });\n            break;\n          }\n          case `openai.local_shell`:\n            i4.push({ type: `local_shell` });\n            break;\n          case `openai.web_search_preview`: {\n            let e6 = va.parse(t4.args);\n            i4.push({ type: `web_search_preview`, search_context_size: e6.searchContextSize, user_location: e6.userLocation });\n            break;\n          }\n          case `openai.web_search`: {\n            let e6 = ha.parse(t4.args);\n            i4.push({ type: `web_search`, filters: e6.filters == null ? undefined : { allowed_domains: e6.filters.allowedDomains }, search_context_size: e6.searchContextSize, user_location: e6.userLocation });\n            break;\n          }\n          case `openai.code_interpreter`: {\n            let e6 = ea.parse(t4.args);\n            i4.push({ type: `code_interpreter`, container: e6.container == null ? { type: `auto`, file_ids: undefined } : typeof e6.container == `string` ? e6.container : { type: `auto`, file_ids: e6.container.fileIds } });\n            break;\n          }\n          case `openai.image_generation`: {\n            let e6 = ca.parse(t4.args);\n            i4.push({ type: `image_generation`, background: e6.background, input_fidelity: e6.inputFidelity, input_image_mask: e6.inputImageMask ? { file_id: e6.inputImageMask.fileId, image_url: e6.inputImageMask.imageUrl } : undefined, model: e6.model, size: e6.size, quality: e6.quality, moderation: e6.moderation, output_format: e6.outputFormat, output_compression: e6.outputCompression });\n            break;\n          }\n        }\n        break;\n      default:\n        r3.push({ type: `unsupported-tool`, tool: t4 });\n        break;\n    }\n  if (t3 == null)\n    return { tools: i4, toolChoice: undefined, toolWarnings: r3 };\n  let a5 = t3.type;\n  switch (a5) {\n    case `auto`:\n    case `none`:\n    case `required`:\n      return { tools: i4, toolChoice: a5, toolWarnings: r3 };\n    case `tool`:\n      return { tools: i4, toolChoice: t3.toolName === `code_interpreter` || t3.toolName === `file_search` || t3.toolName === `image_generation` || t3.toolName === `web_search_preview` || t3.toolName === `web_search` ? { type: t3.toolName } : { type: `function`, name: t3.toolName }, toolWarnings: r3 };\n    default:\n      throw new j({ functionality: `tool choice type: ${a5}` });\n  }\n}\nvar Ea = exports_external.object({ type: exports_external.literal(`web_search_call`), id: exports_external.string(), status: exports_external.string(), action: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`search`), query: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`open_page`), url: exports_external.string() }), exports_external.object({ type: exports_external.literal(`find`), url: exports_external.string(), pattern: exports_external.string() })]).nullish() });\nvar Da = exports_external.object({ type: exports_external.literal(`file_search_call`), id: exports_external.string(), queries: exports_external.array(exports_external.string()), results: exports_external.array(exports_external.object({ attributes: exports_external.record(exports_external.string(), exports_external.unknown()), file_id: exports_external.string(), filename: exports_external.string(), score: exports_external.number(), text: exports_external.string() })).nullish() });\nvar Oa = exports_external.object({ type: exports_external.literal(`code_interpreter_call`), id: exports_external.string(), code: exports_external.string().nullable(), container_id: exports_external.string(), outputs: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`logs`), logs: exports_external.string() }), exports_external.object({ type: exports_external.literal(`image`), url: exports_external.string() })])).nullable() });\nvar ka = exports_external.object({ type: exports_external.literal(`local_shell_call`), id: exports_external.string(), call_id: exports_external.string(), action: exports_external.object({ type: exports_external.literal(`exec`), command: exports_external.array(exports_external.string()), timeout_ms: exports_external.number().optional(), user: exports_external.string().optional(), working_directory: exports_external.string().optional(), env: exports_external.record(exports_external.string(), exports_external.string()).optional() }) });\nvar Aa = exports_external.object({ type: exports_external.literal(`image_generation_call`), id: exports_external.string(), result: exports_external.string() });\nvar ja = 20;\nvar Ma = exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number(), top_logprobs: exports_external.array(exports_external.object({ token: exports_external.string(), logprob: exports_external.number() })) }));\nvar Na = class {\n  constructor(e5, t3) {\n    this.specificationVersion = `v2`, this.supportedUrls = { "image/*": [/^https?:\\/\\/.*$/], "application/pdf": [/^https?:\\/\\/.*$/] }, this.modelId = e5, this.config = t3;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ maxOutputTokens: e5, temperature: t3, stopSequences: n3, topP: r3, topK: i4, presencePenalty: a5, frequencyPenalty: o3, seed: s4, prompt: c4, providerOptions: l3, tools: u3, toolChoice: d2, responseFormat: f2 }) {\n    let p2 = [], m2 = co(this.modelId);\n    i4 != null && p2.push({ type: `unsupported-setting`, setting: `topK` }), s4 != null && p2.push({ type: `unsupported-setting`, setting: `seed` }), a5 != null && p2.push({ type: `unsupported-setting`, setting: `presencePenalty` }), o3 != null && p2.push({ type: `unsupported-setting`, setting: `frequencyPenalty` }), n3 != null && p2.push({ type: `unsupported-setting`, setting: `stopSequences` });\n    let h2 = await J({ provider: `openai`, providerOptions: l3, schema: lo }), { input: g2, warnings: _2 } = await Sa({ prompt: c4, systemMessageMode: m2.systemMessageMode, fileIdPrefixes: this.config.fileIdPrefixes, store: h2?.store ?? true, hasLocalShellTool: x3(`openai.local_shell`) });\n    p2.push(..._2);\n    let v2 = h2?.strictJsonSchema ?? false, y2 = h2?.include;\n    function b2(e6) {\n      y2 = y2 == null ? [e6] : [...y2, e6];\n    }\n    function x3(e6) {\n      return u3?.find((t4) => t4.type === `provider-defined` && t4.id === e6) != null;\n    }\n    let S2 = typeof h2?.logprobs == `number` ? h2?.logprobs : h2?.logprobs === true ? ja : undefined;\n    S2 && b2(`message.output_text.logprobs`);\n    let C2 = u3?.find((e6) => e6.type === `provider-defined` && (e6.id === `openai.web_search` || e6.id === `openai.web_search_preview`))?.name;\n    C2 && b2(`web_search_call.action.sources`), x3(`openai.code_interpreter`) && b2(`code_interpreter_call.outputs`);\n    let w2 = { model: this.modelId, input: g2, temperature: t3, top_p: r3, max_output_tokens: e5, ...(f2?.type === `json` || h2?.textVerbosity) && { text: { ...f2?.type === `json` && { format: f2.schema == null ? { type: `json_object` } : { type: `json_schema`, strict: v2, name: f2.name ?? `response`, description: f2.description, schema: f2.schema } }, ...h2?.textVerbosity && { verbosity: h2.textVerbosity } } }, max_tool_calls: h2?.maxToolCalls, metadata: h2?.metadata, parallel_tool_calls: h2?.parallelToolCalls, previous_response_id: h2?.previousResponseId, store: h2?.store, user: h2?.user, instructions: h2?.instructions, service_tier: h2?.serviceTier, include: y2, prompt_cache_key: h2?.promptCacheKey, safety_identifier: h2?.safetyIdentifier, top_logprobs: S2, ...m2.isReasoningModel && (h2?.reasoningEffort != null || h2?.reasoningSummary != null) && { reasoning: { ...h2?.reasoningEffort != null && { effort: h2.reasoningEffort }, ...h2?.reasoningSummary != null && { summary: h2.reasoningSummary } } }, ...m2.requiredAutoTruncation && { truncation: `auto` } };\n    m2.isReasoningModel ? (w2.temperature != null && (w2.temperature = undefined, p2.push({ type: `unsupported-setting`, setting: `temperature`, details: `temperature is not supported for reasoning models` })), w2.top_p != null && (w2.top_p = undefined, p2.push({ type: `unsupported-setting`, setting: `topP`, details: `topP is not supported for reasoning models` }))) : (h2?.reasoningEffort != null && p2.push({ type: `unsupported-setting`, setting: `reasoningEffort`, details: `reasoningEffort is not supported for non-reasoning models` }), h2?.reasoningSummary != null && p2.push({ type: `unsupported-setting`, setting: `reasoningSummary`, details: `reasoningSummary is not supported for non-reasoning models` })), h2?.serviceTier === `flex` && !m2.supportsFlexProcessing && (p2.push({ type: `unsupported-setting`, setting: `serviceTier`, details: `flex processing is only available for o3, o4-mini, and gpt-5 models` }), delete w2.service_tier), h2?.serviceTier === `priority` && !m2.supportsPriorityProcessing && (p2.push({ type: `unsupported-setting`, setting: `serviceTier`, details: `priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported` }), delete w2.service_tier);\n    let { tools: ee2, toolChoice: te2, toolWarnings: ne2 } = Ta({ tools: u3, toolChoice: d2, strictJsonSchema: v2 });\n    return { webSearchToolName: C2, args: { ...w2, tools: ee2, tool_choice: te2 }, warnings: [...p2, ...ne2] };\n  }\n  async doGenerate(e5) {\n    var t3, n3;\n    let { args: r3, warnings: a5, webSearchToolName: o3 } = await this.getArgs(e5), s4 = this.config.url({ path: `/responses`, modelId: this.modelId }), { responseHeaders: c4, value: l3, rawValue: u3 } = await Y({ url: s4, headers: G(this.config.headers(), e5.headers), body: r3, failedResponseHandler: $, successfulResponseHandler: Z(exports_external.object({ id: exports_external.string(), created_at: exports_external.number(), error: exports_external.object({ code: exports_external.string(), message: exports_external.string() }).nullish(), model: exports_external.string(), output: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`message`), role: exports_external.literal(`assistant`), id: exports_external.string(), content: exports_external.array(exports_external.object({ type: exports_external.literal(`output_text`), text: exports_external.string(), logprobs: Ma.nullish(), annotations: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`url_citation`), start_index: exports_external.number(), end_index: exports_external.number(), url: exports_external.string(), title: exports_external.string() }), exports_external.object({ type: exports_external.literal(`file_citation`), file_id: exports_external.string(), filename: exports_external.string().nullish(), index: exports_external.number().nullish(), start_index: exports_external.number().nullish(), end_index: exports_external.number().nullish(), quote: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`container_file_citation`) })])) })) }), Ea, Da, Oa, Aa, ka, exports_external.object({ type: exports_external.literal(`function_call`), call_id: exports_external.string(), name: exports_external.string(), arguments: exports_external.string(), id: exports_external.string() }), exports_external.object({ type: exports_external.literal(`computer_call`), id: exports_external.string(), status: exports_external.string().optional() }), exports_external.object({ type: exports_external.literal(`reasoning`), id: exports_external.string(), encrypted_content: exports_external.string().nullish(), summary: exports_external.array(exports_external.object({ type: exports_external.literal(`summary_text`), text: exports_external.string() })) })])), service_tier: exports_external.string().nullish(), incomplete_details: exports_external.object({ reason: exports_external.string() }).nullish(), usage: Pa })), abortSignal: e5.abortSignal, fetch: this.config.fetch });\n    if (l3.error)\n      throw new T({ message: l3.error.message, url: s4, requestBodyValues: r3, statusCode: 400, responseHeaders: c4, responseBody: u3, isRetryable: false });\n    let d2 = [], f2 = [], p2 = false;\n    for (let r4 of l3.output)\n      switch (r4.type) {\n        case `reasoning`:\n          r4.summary.length === 0 && r4.summary.push({ type: `summary_text`, text: `` });\n          for (let e6 of r4.summary)\n            d2.push({ type: `reasoning`, text: e6.text, providerMetadata: { openai: { itemId: r4.id, reasoningEncryptedContent: r4.encrypted_content ?? null } } });\n          break;\n        case `image_generation_call`:\n          d2.push({ type: `tool-call`, toolCallId: r4.id, toolName: `image_generation`, input: `{}`, providerExecuted: true }), d2.push({ type: `tool-result`, toolCallId: r4.id, toolName: `image_generation`, result: { result: r4.result }, providerExecuted: true });\n          break;\n        case `local_shell_call`:\n          d2.push({ type: `tool-call`, toolCallId: r4.call_id, toolName: `local_shell`, input: JSON.stringify({ action: r4.action }), providerMetadata: { openai: { itemId: r4.id } } });\n          break;\n        case `message`:\n          for (let i4 of r4.content) {\n            e5.providerOptions?.openai?.logprobs && i4.logprobs && f2.push(i4.logprobs), d2.push({ type: `text`, text: i4.text, providerMetadata: { openai: { itemId: r4.id } } });\n            for (let e6 of i4.annotations)\n              e6.type === `url_citation` ? d2.push({ type: `source`, sourceType: `url`, id: (t3 = this.config).generateId?.call(t3) ?? q(), url: e6.url, title: e6.title }) : e6.type === `file_citation` && d2.push({ type: `source`, sourceType: `document`, id: (n3 = this.config).generateId?.call(n3) ?? q(), mediaType: `text/plain`, title: e6.quote ?? e6.filename ?? `Document`, filename: e6.filename ?? e6.file_id });\n          }\n          break;\n        case `function_call`:\n          p2 = true, d2.push({ type: `tool-call`, toolCallId: r4.call_id, toolName: r4.name, input: r4.arguments, providerMetadata: { openai: { itemId: r4.id } } });\n          break;\n        case `web_search_call`:\n          d2.push({ type: `tool-call`, toolCallId: r4.id, toolName: o3 ?? `web_search`, input: JSON.stringify({ action: r4.action }), providerExecuted: true }), d2.push({ type: `tool-result`, toolCallId: r4.id, toolName: o3 ?? `web_search`, result: { status: r4.status }, providerExecuted: true });\n          break;\n        case `computer_call`:\n          d2.push({ type: `tool-call`, toolCallId: r4.id, toolName: `computer_use`, input: ``, providerExecuted: true }), d2.push({ type: `tool-result`, toolCallId: r4.id, toolName: `computer_use`, result: { type: `computer_use_tool_result`, status: r4.status || `completed` }, providerExecuted: true });\n          break;\n        case `file_search_call`:\n          d2.push({ type: `tool-call`, toolCallId: r4.id, toolName: `file_search`, input: `{}`, providerExecuted: true }), d2.push({ type: `tool-result`, toolCallId: r4.id, toolName: `file_search`, result: { queries: r4.queries, results: r4.results?.map((e6) => ({ attributes: e6.attributes, fileId: e6.file_id, filename: e6.filename, score: e6.score, text: e6.text })) ?? null }, providerExecuted: true });\n          break;\n        case `code_interpreter_call`:\n          d2.push({ type: `tool-call`, toolCallId: r4.id, toolName: `code_interpreter`, input: JSON.stringify({ code: r4.code, containerId: r4.container_id }), providerExecuted: true }), d2.push({ type: `tool-result`, toolCallId: r4.id, toolName: `code_interpreter`, result: { outputs: r4.outputs }, providerExecuted: true });\n          break;\n      }\n    let m2 = { openai: { responseId: l3.id } };\n    return f2.length > 0 && (m2.openai.logprobs = f2), typeof l3.service_tier == `string` && (m2.openai.serviceTier = l3.service_tier), { content: d2, finishReason: wa({ finishReason: l3.incomplete_details?.reason, hasFunctionCall: p2 }), usage: { inputTokens: l3.usage.input_tokens, outputTokens: l3.usage.output_tokens, totalTokens: l3.usage.input_tokens + l3.usage.output_tokens, reasoningTokens: l3.usage.output_tokens_details?.reasoning_tokens ?? undefined, cachedInputTokens: l3.usage.input_tokens_details?.cached_tokens ?? undefined }, request: { body: r3 }, response: { id: l3.id, timestamp: new Date(l3.created_at * 1000), modelId: l3.model, headers: c4, body: u3 }, providerMetadata: m2, warnings: a5 };\n  }\n  async doStream(e5) {\n    let { args: t3, warnings: n3, webSearchToolName: r3 } = await this.getArgs(e5), { responseHeaders: i4, value: a5 } = await Y({ url: this.config.url({ path: `/responses`, modelId: this.modelId }), headers: G(this.config.headers(), e5.headers), body: { ...t3, stream: true }, failedResponseHandler: $, successfulResponseHandler: hi(qa), abortSignal: e5.abortSignal, fetch: this.config.fetch }), o3 = this, s4 = `unknown`, c4 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, l3 = [], u3 = null, d2 = {}, f2 = false, p2 = {}, m2;\n    return { stream: a5.pipeThrough(new TransformStream({ start(e6) {\n      e6.enqueue({ type: `stream-start`, warnings: n3 });\n    }, transform(t4, n4) {\n      var i5, a6, h2;\n      if (e5.includeRawChunks && n4.enqueue({ type: `raw`, rawValue: t4.rawValue }), !t4.success) {\n        s4 = `error`, n4.enqueue({ type: `error`, error: t4.error });\n        return;\n      }\n      let g2 = t4.value;\n      if (no(g2))\n        g2.item.type === `function_call` ? (d2[g2.output_index] = { toolName: g2.item.name, toolCallId: g2.item.call_id }, n4.enqueue({ type: `tool-input-start`, id: g2.item.call_id, toolName: g2.item.name })) : g2.item.type === `web_search_call` ? (d2[g2.output_index] = { toolName: r3 ?? `web_search`, toolCallId: g2.item.id }, n4.enqueue({ type: `tool-input-start`, id: g2.item.id, toolName: r3 ?? `web_search` })) : g2.item.type === `computer_call` ? (d2[g2.output_index] = { toolName: `computer_use`, toolCallId: g2.item.id }, n4.enqueue({ type: `tool-input-start`, id: g2.item.id, toolName: `computer_use` })) : g2.item.type === `code_interpreter_call` ? (d2[g2.output_index] = { toolName: `code_interpreter`, toolCallId: g2.item.id, codeInterpreter: { containerId: g2.item.container_id } }, n4.enqueue({ type: `tool-input-start`, id: g2.item.id, toolName: `code_interpreter` }), n4.enqueue({ type: `tool-input-delta`, id: g2.item.id, delta: `{"containerId":"${g2.item.container_id}","code":"` })) : g2.item.type === `file_search_call` ? n4.enqueue({ type: `tool-call`, toolCallId: g2.item.id, toolName: `file_search`, input: `{}`, providerExecuted: true }) : g2.item.type === `image_generation_call` ? n4.enqueue({ type: `tool-call`, toolCallId: g2.item.id, toolName: `image_generation`, input: `{}`, providerExecuted: true }) : g2.item.type === `message` ? n4.enqueue({ type: `text-start`, id: g2.item.id, providerMetadata: { openai: { itemId: g2.item.id } } }) : ro(g2) && (p2[g2.item.id] = { encryptedContent: g2.item.encrypted_content, summaryParts: [0] }, n4.enqueue({ type: `reasoning-start`, id: `${g2.item.id}:0`, providerMetadata: { openai: { itemId: g2.item.id, reasoningEncryptedContent: g2.item.encrypted_content ?? null } } }));\n      else if (Ya(g2)) {\n        if (g2.item.type === `function_call`)\n          d2[g2.output_index] = undefined, f2 = true, n4.enqueue({ type: `tool-input-end`, id: g2.item.call_id }), n4.enqueue({ type: `tool-call`, toolCallId: g2.item.call_id, toolName: g2.item.name, input: g2.item.arguments, providerMetadata: { openai: { itemId: g2.item.id } } });\n        else if (g2.item.type === `web_search_call`)\n          d2[g2.output_index] = undefined, n4.enqueue({ type: `tool-input-end`, id: g2.item.id }), n4.enqueue({ type: `tool-call`, toolCallId: g2.item.id, toolName: `web_search`, input: JSON.stringify({ action: g2.item.action }), providerExecuted: true }), n4.enqueue({ type: `tool-result`, toolCallId: g2.item.id, toolName: `web_search`, result: { status: g2.item.status }, providerExecuted: true });\n        else if (g2.item.type === `computer_call`)\n          d2[g2.output_index] = undefined, n4.enqueue({ type: `tool-input-end`, id: g2.item.id }), n4.enqueue({ type: `tool-call`, toolCallId: g2.item.id, toolName: `computer_use`, input: ``, providerExecuted: true }), n4.enqueue({ type: `tool-result`, toolCallId: g2.item.id, toolName: `computer_use`, result: { type: `computer_use_tool_result`, status: g2.item.status || `completed` }, providerExecuted: true });\n        else if (g2.item.type === `file_search_call`)\n          d2[g2.output_index] = undefined, n4.enqueue({ type: `tool-result`, toolCallId: g2.item.id, toolName: `file_search`, result: { queries: g2.item.queries, results: g2.item.results?.map((e6) => ({ attributes: e6.attributes, fileId: e6.file_id, filename: e6.filename, score: e6.score, text: e6.text })) ?? null }, providerExecuted: true });\n        else if (g2.item.type === `code_interpreter_call`)\n          d2[g2.output_index] = undefined, n4.enqueue({ type: `tool-result`, toolCallId: g2.item.id, toolName: `code_interpreter`, result: { outputs: g2.item.outputs }, providerExecuted: true });\n        else if (g2.item.type === `image_generation_call`)\n          n4.enqueue({ type: `tool-result`, toolCallId: g2.item.id, toolName: `image_generation`, result: { result: g2.item.result }, providerExecuted: true });\n        else if (g2.item.type === `local_shell_call`)\n          d2[g2.output_index] = undefined, n4.enqueue({ type: `tool-call`, toolCallId: g2.item.call_id, toolName: `local_shell`, input: JSON.stringify({ action: { type: `exec`, command: g2.item.action.command, timeoutMs: g2.item.action.timeout_ms, user: g2.item.action.user, workingDirectory: g2.item.action.working_directory, env: g2.item.action.env } }), providerMetadata: { openai: { itemId: g2.item.id } } });\n        else if (g2.item.type === `message`)\n          n4.enqueue({ type: `text-end`, id: g2.item.id });\n        else if (Xa(g2)) {\n          let e6 = p2[g2.item.id];\n          for (let t5 of e6.summaryParts)\n            n4.enqueue({ type: `reasoning-end`, id: `${g2.item.id}:${t5}`, providerMetadata: { openai: { itemId: g2.item.id, reasoningEncryptedContent: g2.item.encrypted_content ?? null } } });\n          delete p2[g2.item.id];\n        }\n      } else if ($a(g2)) {\n        let e6 = d2[g2.output_index];\n        e6 != null && n4.enqueue({ type: `tool-input-delta`, id: e6.toolCallId, delta: g2.delta });\n      } else if (eo(g2)) {\n        let e6 = d2[g2.output_index];\n        e6 != null && n4.enqueue({ type: `tool-input-delta`, id: e6.toolCallId, delta: JSON.stringify(g2.delta).slice(1, -1) });\n      } else if (to(g2)) {\n        let e6 = d2[g2.output_index];\n        e6 != null && (n4.enqueue({ type: `tool-input-delta`, id: e6.toolCallId, delta: `"}` }), n4.enqueue({ type: `tool-input-end`, id: e6.toolCallId }), n4.enqueue({ type: `tool-call`, toolCallId: e6.toolCallId, toolName: `code_interpreter`, input: JSON.stringify({ code: g2.code, containerId: e6.codeInterpreter.containerId }), providerExecuted: true }));\n      } else\n        Qa(g2) ? (u3 = g2.response.id, n4.enqueue({ type: `response-metadata`, id: g2.response.id, timestamp: new Date(g2.response.created_at * 1000), modelId: g2.response.model })) : Ja(g2) ? (n4.enqueue({ type: `text-delta`, id: g2.item_id, delta: g2.delta }), e5.providerOptions?.openai?.logprobs && g2.logprobs && l3.push(g2.logprobs)) : ao(g2) ? g2.summary_index > 0 && ((i5 = p2[g2.item_id]) == null || i5.summaryParts.push(g2.summary_index), n4.enqueue({ type: `reasoning-start`, id: `${g2.item_id}:${g2.summary_index}`, providerMetadata: { openai: { itemId: g2.item_id, reasoningEncryptedContent: p2[g2.item_id]?.encryptedContent ?? null } } })) : oo(g2) ? n4.enqueue({ type: `reasoning-delta`, id: `${g2.item_id}:${g2.summary_index}`, delta: g2.delta, providerMetadata: { openai: { itemId: g2.item_id } } }) : Za(g2) ? (s4 = wa({ finishReason: g2.response.incomplete_details?.reason, hasFunctionCall: f2 }), c4.inputTokens = g2.response.usage.input_tokens, c4.outputTokens = g2.response.usage.output_tokens, c4.totalTokens = g2.response.usage.input_tokens + g2.response.usage.output_tokens, c4.reasoningTokens = g2.response.usage.output_tokens_details?.reasoning_tokens ?? undefined, c4.cachedInputTokens = g2.response.usage.input_tokens_details?.cached_tokens ?? undefined, typeof g2.response.service_tier == `string` && (m2 = g2.response.service_tier)) : io(g2) ? g2.annotation.type === `url_citation` ? n4.enqueue({ type: `source`, sourceType: `url`, id: (a6 = o3.config).generateId?.call(a6) ?? q(), url: g2.annotation.url, title: g2.annotation.title }) : g2.annotation.type === `file_citation` && n4.enqueue({ type: `source`, sourceType: `document`, id: (h2 = o3.config).generateId?.call(h2) ?? q(), mediaType: `text/plain`, title: g2.annotation.quote ?? g2.annotation.filename ?? `Document`, filename: g2.annotation.filename ?? g2.annotation.file_id }) : so(g2) && n4.enqueue({ type: `error`, error: g2 });\n    }, flush(e6) {\n      let t4 = { openai: { responseId: u3 } };\n      l3.length > 0 && (t4.openai.logprobs = l3), m2 !== undefined && (t4.openai.serviceTier = m2), e6.enqueue({ type: `finish`, finishReason: s4, usage: c4, providerMetadata: t4 });\n    } })), request: { body: t3 }, response: { headers: i4 } };\n  }\n};\nvar Pa = exports_external.object({ input_tokens: exports_external.number(), input_tokens_details: exports_external.object({ cached_tokens: exports_external.number().nullish() }).nullish(), output_tokens: exports_external.number(), output_tokens_details: exports_external.object({ reasoning_tokens: exports_external.number().nullish() }).nullish() });\nvar Fa = exports_external.object({ type: exports_external.literal(`response.output_text.delta`), item_id: exports_external.string(), delta: exports_external.string(), logprobs: Ma.nullish() });\nvar Ia = exports_external.object({ type: exports_external.literal(`error`), code: exports_external.string(), message: exports_external.string(), param: exports_external.string().nullish(), sequence_number: exports_external.number() });\nvar La = exports_external.object({ type: exports_external.enum([`response.completed`, `response.incomplete`]), response: exports_external.object({ incomplete_details: exports_external.object({ reason: exports_external.string() }).nullish(), usage: Pa, service_tier: exports_external.string().nullish() }) });\nvar Ra = exports_external.object({ type: exports_external.literal(`response.created`), response: exports_external.object({ id: exports_external.string(), created_at: exports_external.number(), model: exports_external.string(), service_tier: exports_external.string().nullish() }) });\nvar za = exports_external.object({ type: exports_external.literal(`response.output_item.added`), output_index: exports_external.number(), item: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`message`), id: exports_external.string() }), exports_external.object({ type: exports_external.literal(`reasoning`), id: exports_external.string(), encrypted_content: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`function_call`), id: exports_external.string(), call_id: exports_external.string(), name: exports_external.string(), arguments: exports_external.string() }), exports_external.object({ type: exports_external.literal(`web_search_call`), id: exports_external.string(), status: exports_external.string(), action: exports_external.object({ type: exports_external.literal(`search`), query: exports_external.string().optional() }).nullish() }), exports_external.object({ type: exports_external.literal(`computer_call`), id: exports_external.string(), status: exports_external.string() }), exports_external.object({ type: exports_external.literal(`file_search_call`), id: exports_external.string() }), exports_external.object({ type: exports_external.literal(`image_generation_call`), id: exports_external.string() }), exports_external.object({ type: exports_external.literal(`code_interpreter_call`), id: exports_external.string(), container_id: exports_external.string(), code: exports_external.string().nullable(), outputs: exports_external.array(exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`logs`), logs: exports_external.string() }), exports_external.object({ type: exports_external.literal(`image`), url: exports_external.string() })])).nullable(), status: exports_external.string() })]) });\nvar Ba = exports_external.object({ type: exports_external.literal(`response.output_item.done`), output_index: exports_external.number(), item: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`message`), id: exports_external.string() }), exports_external.object({ type: exports_external.literal(`reasoning`), id: exports_external.string(), encrypted_content: exports_external.string().nullish() }), exports_external.object({ type: exports_external.literal(`function_call`), id: exports_external.string(), call_id: exports_external.string(), name: exports_external.string(), arguments: exports_external.string(), status: exports_external.literal(`completed`) }), Oa, Aa, Ea, Da, ka, exports_external.object({ type: exports_external.literal(`computer_call`), id: exports_external.string(), status: exports_external.literal(`completed`) })]) });\nvar Va = exports_external.object({ type: exports_external.literal(`response.function_call_arguments.delta`), item_id: exports_external.string(), output_index: exports_external.number(), delta: exports_external.string() });\nvar Ha = exports_external.object({ type: exports_external.literal(`response.code_interpreter_call_code.delta`), item_id: exports_external.string(), output_index: exports_external.number(), delta: exports_external.string() });\nvar Ua = exports_external.object({ type: exports_external.literal(`response.code_interpreter_call_code.done`), item_id: exports_external.string(), output_index: exports_external.number(), code: exports_external.string() });\nvar Wa = exports_external.object({ type: exports_external.literal(`response.output_text.annotation.added`), annotation: exports_external.discriminatedUnion(`type`, [exports_external.object({ type: exports_external.literal(`url_citation`), url: exports_external.string(), title: exports_external.string() }), exports_external.object({ type: exports_external.literal(`file_citation`), file_id: exports_external.string(), filename: exports_external.string().nullish(), index: exports_external.number().nullish(), start_index: exports_external.number().nullish(), end_index: exports_external.number().nullish(), quote: exports_external.string().nullish() })]) });\nvar Ga = exports_external.object({ type: exports_external.literal(`response.reasoning_summary_part.added`), item_id: exports_external.string(), summary_index: exports_external.number() });\nvar Ka = exports_external.object({ type: exports_external.literal(`response.reasoning_summary_text.delta`), item_id: exports_external.string(), summary_index: exports_external.number(), delta: exports_external.string() });\nvar qa = exports_external.union([Fa, La, Ra, za, Ba, Va, Ha, Ua, Wa, Ga, Ka, Ia, exports_external.object({ type: exports_external.string() }).loose()]);\nfunction Ja(e5) {\n  return e5.type === `response.output_text.delta`;\n}\nfunction Ya(e5) {\n  return e5.type === `response.output_item.done`;\n}\nfunction Xa(e5) {\n  return Ya(e5) && e5.item.type === `reasoning`;\n}\nfunction Za(e5) {\n  return e5.type === `response.completed` || e5.type === `response.incomplete`;\n}\nfunction Qa(e5) {\n  return e5.type === `response.created`;\n}\nfunction $a(e5) {\n  return e5.type === `response.function_call_arguments.delta`;\n}\nfunction eo(e5) {\n  return e5.type === `response.code_interpreter_call_code.delta`;\n}\nfunction to(e5) {\n  return e5.type === `response.code_interpreter_call_code.done`;\n}\nfunction no(e5) {\n  return e5.type === `response.output_item.added`;\n}\nfunction ro(e5) {\n  return no(e5) && e5.item.type === `reasoning`;\n}\nfunction io(e5) {\n  return e5.type === `response.output_text.annotation.added`;\n}\nfunction ao(e5) {\n  return e5.type === `response.reasoning_summary_part.added`;\n}\nfunction oo(e5) {\n  return e5.type === `response.reasoning_summary_text.delta`;\n}\nfunction so(e5) {\n  return e5.type === `error`;\n}\nfunction co(e5) {\n  let t3 = e5.startsWith(`o3`) || e5.startsWith(`o4-mini`) || e5.startsWith(`gpt-5`) && !e5.startsWith(`gpt-5-chat`), n3 = e5.startsWith(`gpt-4`) || e5.startsWith(`gpt-5-mini`) || e5.startsWith(`gpt-5`) && !e5.startsWith(`gpt-5-nano`) && !e5.startsWith(`gpt-5-chat`) || e5.startsWith(`o3`) || e5.startsWith(`o4-mini`), r3 = { requiredAutoTruncation: false, systemMessageMode: `system`, supportsFlexProcessing: t3, supportsPriorityProcessing: n3 };\n  return e5.startsWith(`gpt-5-chat`) ? { ...r3, isReasoningModel: false } : e5.startsWith(`o`) || e5.startsWith(`gpt-5`) || e5.startsWith(`codex-`) || e5.startsWith(`computer-use`) ? e5.startsWith(`o1-mini`) || e5.startsWith(`o1-preview`) ? { ...r3, isReasoningModel: true, systemMessageMode: `remove` } : { ...r3, isReasoningModel: true, systemMessageMode: `developer` } : { ...r3, isReasoningModel: false };\n}\nvar lo = exports_external.object({ include: exports_external.array(exports_external.enum([`reasoning.encrypted_content`, `file_search_call.results`, `message.output_text.logprobs`])).nullish(), instructions: exports_external.string().nullish(), logprobs: exports_external.union([exports_external.boolean(), exports_external.number().min(1).max(ja)]).optional(), maxToolCalls: exports_external.number().nullish(), metadata: exports_external.any().nullish(), parallelToolCalls: exports_external.boolean().nullish(), previousResponseId: exports_external.string().nullish(), promptCacheKey: exports_external.string().nullish(), reasoningEffort: exports_external.string().nullish(), reasoningSummary: exports_external.string().nullish(), safetyIdentifier: exports_external.string().nullish(), serviceTier: exports_external.enum([`auto`, `flex`, `priority`]).nullish(), store: exports_external.boolean().nullish(), strictJsonSchema: exports_external.boolean().nullish(), textVerbosity: exports_external.enum([`low`, `medium`, `high`]).nullish(), user: exports_external.string().nullish() });\nvar uo = exports_external.object({ instructions: exports_external.string().nullish(), speed: exports_external.number().min(0.25).max(4).default(1).nullish() });\nvar fo = class {\n  constructor(e5, t3) {\n    this.modelId = e5, this.config = t3, this.specificationVersion = `v2`;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ text: e5, voice: t3 = `alloy`, outputFormat: n3 = `mp3`, speed: r3, instructions: i4, language: a5, providerOptions: o3 }) {\n    let s4 = [], c4 = await J({ provider: `openai`, providerOptions: o3, schema: uo }), l3 = { model: this.modelId, input: e5, voice: t3, response_format: `mp3`, speed: r3, instructions: i4 };\n    if (n3 && ([`mp3`, `opus`, `aac`, `flac`, `wav`, `pcm`].includes(n3) ? l3.response_format = n3 : s4.push({ type: `unsupported-setting`, setting: `outputFormat`, details: `Unsupported output format: ${n3}. Using mp3 instead.` })), c4) {\n      let e6 = {};\n      for (let t4 in e6) {\n        let n4 = e6[t4];\n        n4 !== undefined && (l3[t4] = n4);\n      }\n    }\n    return a5 && s4.push({ type: `unsupported-setting`, setting: `language`, details: `OpenAI speech models do not support language selection. Language parameter "${a5}" was ignored.` }), { requestBody: l3, warnings: s4 };\n  }\n  async doGenerate(e5) {\n    var t3;\n    let n3 = (t3 = this.config._internal)?.currentDate?.call(t3) ?? new Date, { requestBody: r3, warnings: i4 } = await this.getArgs(e5), { value: a5, responseHeaders: o3, rawValue: s4 } = await Y({ url: this.config.url({ path: `/audio/speech`, modelId: this.modelId }), headers: G(this.config.headers(), e5.headers), body: r3, failedResponseHandler: $, successfulResponseHandler: gi(), abortSignal: e5.abortSignal, fetch: this.config.fetch });\n    return { audio: a5, warnings: i4, request: { body: JSON.stringify(r3) }, response: { timestamp: n3, modelId: this.modelId, headers: o3, body: s4 } };\n  }\n};\nvar po = exports_external.object({ include: exports_external.array(exports_external.string()).optional(), language: exports_external.string().optional(), prompt: exports_external.string().optional(), temperature: exports_external.number().min(0).max(1).default(0).optional(), timestampGranularities: exports_external.array(exports_external.enum([`word`, `segment`])).default([`segment`]).optional() });\nvar mo = { afrikaans: `af`, arabic: `ar`, armenian: `hy`, azerbaijani: `az`, belarusian: `be`, bosnian: `bs`, bulgarian: `bg`, catalan: `ca`, chinese: `zh`, croatian: `hr`, czech: `cs`, danish: `da`, dutch: `nl`, english: `en`, estonian: `et`, finnish: `fi`, french: `fr`, galician: `gl`, german: `de`, greek: `el`, hebrew: `he`, hindi: `hi`, hungarian: `hu`, icelandic: `is`, indonesian: `id`, italian: `it`, japanese: `ja`, kannada: `kn`, kazakh: `kk`, korean: `ko`, latvian: `lv`, lithuanian: `lt`, macedonian: `mk`, malay: `ms`, marathi: `mr`, maori: `mi`, nepali: `ne`, norwegian: `no`, persian: `fa`, polish: `pl`, portuguese: `pt`, romanian: `ro`, russian: `ru`, serbian: `sr`, slovak: `sk`, slovenian: `sl`, spanish: `es`, swahili: `sw`, swedish: `sv`, tagalog: `tl`, tamil: `ta`, thai: `th`, turkish: `tr`, ukrainian: `uk`, urdu: `ur`, vietnamese: `vi`, welsh: `cy` };\nvar ho = class {\n  constructor(e5, t3) {\n    this.modelId = e5, this.config = t3, this.specificationVersion = `v2`;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ audio: e5, mediaType: t3, providerOptions: n3 }) {\n    let r3 = [], i4 = await J({ provider: `openai`, providerOptions: n3, schema: po }), a5 = new FormData, o3 = e5 instanceof Uint8Array ? new Blob([e5]) : new Blob([yi(e5)]);\n    a5.append(`model`, this.modelId);\n    let s4 = Kr(t3);\n    if (a5.append(`file`, new File([o3], `audio`, { type: t3 }), `audio.${s4}`), i4) {\n      let e6 = { include: i4.include, language: i4.language, prompt: i4.prompt, response_format: [`gpt-4o-transcribe`, `gpt-4o-mini-transcribe`].includes(this.modelId) ? `json` : `verbose_json`, temperature: i4.temperature, timestamp_granularities: i4.timestampGranularities };\n      for (let [t4, n4] of Object.entries(e6))\n        if (n4 != null)\n          if (Array.isArray(n4))\n            for (let e7 of n4)\n              a5.append(`${t4}[]`, String(e7));\n          else\n            a5.append(t4, String(n4));\n    }\n    return { formData: a5, warnings: r3 };\n  }\n  async doGenerate(e5) {\n    var t3;\n    let n3 = (t3 = this.config._internal)?.currentDate?.call(t3) ?? new Date, { formData: r3, warnings: i4 } = await this.getArgs(e5), { value: a5, responseHeaders: o3, rawValue: s4 } = await ui({ url: this.config.url({ path: `/audio/transcriptions`, modelId: this.modelId }), headers: G(this.config.headers(), e5.headers), formData: r3, failedResponseHandler: $, successfulResponseHandler: Z(go), abortSignal: e5.abortSignal, fetch: this.config.fetch }), c4 = a5.language != null && a5.language in mo ? mo[a5.language] : undefined;\n    return { text: a5.text, segments: a5.segments?.map((e6) => ({ text: e6.text, startSecond: e6.start, endSecond: e6.end })) ?? a5.words?.map((e6) => ({ text: e6.word, startSecond: e6.start, endSecond: e6.end })) ?? [], language: c4, durationInSeconds: a5.duration ?? undefined, warnings: i4, response: { timestamp: n3, modelId: this.modelId, headers: o3, body: s4 } };\n  }\n};\nvar go = exports_external.object({ text: exports_external.string(), language: exports_external.string().nullish(), duration: exports_external.number().nullish(), words: exports_external.array(exports_external.object({ word: exports_external.string(), start: exports_external.number(), end: exports_external.number() })).nullish(), segments: exports_external.array(exports_external.object({ id: exports_external.number(), seek: exports_external.number(), start: exports_external.number(), end: exports_external.number(), text: exports_external.string(), tokens: exports_external.array(exports_external.number()), temperature: exports_external.number(), avg_logprob: exports_external.number(), compression_ratio: exports_external.number(), no_speech_prob: exports_external.number() })).nullish() });\nvar _o = `2.0.42`;\nfunction vo(e5 = {}) {\n  let t3 = xi(Gr({ settingValue: e5.baseURL, environmentVariableName: `OPENAI_BASE_URL` })) ?? `https://api.openai.com/v1`, n3 = e5.name ?? `openai`, r3 = () => zr({ Authorization: `Bearer ${Wr({ apiKey: e5.apiKey, environmentVariableName: `OPENAI_API_KEY`, description: `OpenAI` })}`, "OpenAI-Organization": e5.organization, "OpenAI-Project": e5.project, ...e5.headers }, `ai-sdk/openai/${_o}`), i4 = (i5) => new Oi(i5, { provider: `${n3}.chat`, url: ({ path: e6 }) => `${t3}${e6}`, headers: r3, fetch: e5.fetch }), a5 = (i5) => new Vi(i5, { provider: `${n3}.completion`, url: ({ path: e6 }) => `${t3}${e6}`, headers: r3, fetch: e5.fetch }), o3 = (i5) => new Ki(i5, { provider: `${n3}.embedding`, url: ({ path: e6 }) => `${t3}${e6}`, headers: r3, fetch: e5.fetch }), s4 = (i5) => new Xi(i5, { provider: `${n3}.image`, url: ({ path: e6 }) => `${t3}${e6}`, headers: r3, fetch: e5.fetch }), c4 = (i5) => new ho(i5, { provider: `${n3}.transcription`, url: ({ path: e6 }) => `${t3}${e6}`, headers: r3, fetch: e5.fetch }), l3 = (i5) => new fo(i5, { provider: `${n3}.speech`, url: ({ path: e6 }) => `${t3}${e6}`, headers: r3, fetch: e5.fetch }), u3 = (e6) => {\n    if (new.target)\n      throw Error(`The OpenAI model function cannot be called with the new keyword.`);\n    return d2(e6);\n  }, d2 = (i5) => new Na(i5, { provider: `${n3}.responses`, url: ({ path: e6 }) => `${t3}${e6}`, headers: r3, fetch: e5.fetch, fileIdPrefixes: [`file-`] }), f2 = function(e6) {\n    return u3(e6);\n  };\n  return f2.languageModel = u3, f2.chat = i4, f2.completion = a5, f2.responses = d2, f2.embedding = o3, f2.textEmbedding = o3, f2.textEmbeddingModel = o3, f2.image = s4, f2.imageModel = s4, f2.transcription = c4, f2.transcriptionModel = c4, f2.speech = l3, f2.speechModel = l3, f2.tools = ba, f2;\n}\nvo();\nfunction yo(...e5) {\n  return e5.reduce((e6, t3) => ({ ...e6, ...t3 ?? {} }), {});\n}\nfunction bo(e5) {\n  return Object.fromEntries([...e5.headers]);\n}\nfunction xo(e5 = globalThis) {\n  return e5.window ? `runtime/browser` : e5.navigator?.userAgent ? `runtime/${e5.navigator.userAgent.toLowerCase()}` : e5.process?.versions?.node ? `runtime/node.js/${e5.process.version.substring(0)}` : e5.EdgeRuntime ? `runtime/vercel-edge` : `runtime/unknown`;\n}\nfunction So(e5) {\n  return Object.fromEntries(Object.entries(e5).filter(([e6, t3]) => t3 != null));\n}\nfunction Co(e5, ...t3) {\n  let n3 = So(e5 ?? {}), r3 = new Headers(n3), i4 = r3.get(`user-agent`) || ``;\n  return r3.set(`user-agent`, [i4, ...t3].filter(Boolean).join(` `)), Object.fromEntries(r3);\n}\n(({ prefix: e5, size: t3 = 16, alphabet: n3 = `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`, separator: r3 = `-` } = {}) => {\n  let i4 = () => {\n    let e6 = n3.length, r4 = Array(t3);\n    for (let i5 = 0;i5 < t3; i5++)\n      r4[i5] = n3[Math.random() * e6 | 0];\n    return r4.join(``);\n  };\n  if (e5 == null)\n    return i4;\n  if (n3.includes(r3))\n    throw new D({ argument: `separator`, message: `The separator "${r3}" must not be part of the alphabet "${n3}".` });\n  return () => `${e5}${r3}${i4()}`;\n})();\nfunction wo(e5) {\n  return (e5 instanceof Error || e5 instanceof DOMException) && (e5.name === `AbortError` || e5.name === `ResponseAborted` || e5.name === `TimeoutError`);\n}\nvar To = [`fetch failed`, `failed to fetch`];\nfunction Eo({ error: e5, url: t3, requestBodyValues: n3 }) {\n  if (wo(e5))\n    return e5;\n  if (e5 instanceof TypeError && To.includes(e5.message.toLowerCase())) {\n    let r3 = e5.cause;\n    if (r3 != null)\n      return new T({ message: `Cannot connect to API: ${r3.message}`, cause: r3, url: t3, requestBodyValues: n3, isRetryable: true });\n  }\n  return e5;\n}\nvar Do = `3.0.10`;\nvar Oo = /"__proto__"\\s*:/;\nvar ko = /"constructor"\\s*:/;\nfunction Ao(e5) {\n  let t3 = JSON.parse(e5);\n  return typeof t3 != `object` || !t3 || Oo.test(e5) === false && ko.test(e5) === false ? t3 : jo(t3);\n}\nfunction jo(e5) {\n  let t3 = [e5];\n  for (;t3.length; ) {\n    let e6 = t3;\n    t3 = [];\n    for (let n3 of e6) {\n      if (Object.prototype.hasOwnProperty.call(n3, `__proto__`) || Object.prototype.hasOwnProperty.call(n3, `constructor`) && Object.prototype.hasOwnProperty.call(n3.constructor, `prototype`))\n        throw SyntaxError(`Object contains forbidden prototype property`);\n      for (let e7 in n3) {\n        let r3 = n3[e7];\n        r3 && typeof r3 == `object` && t3.push(r3);\n      }\n    }\n  }\n  return e5;\n}\nfunction Mo(e5) {\n  let { stackTraceLimit: t3 } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return Ao(e5);\n  } finally {\n    Error.stackTraceLimit = t3;\n  }\n}\nvar No = Symbol.for(`vercel.ai.validator`);\nfunction Po(e5) {\n  return { [No]: true, validate: e5 };\n}\nfunction Fo(e5) {\n  return typeof e5 == `object` && !!e5 && No in e5 && e5[No] === true && `validate` in e5;\n}\nfunction Io(e5) {\n  return Fo(e5) ? e5 : Lo(e5);\n}\nfunction Lo(e5) {\n  return Po(async (t3) => {\n    let n3 = await e5[`~standard`].validate(t3);\n    return n3.issues == null ? { success: true, value: n3.value } : { success: false, error: new A({ value: t3, cause: n3.issues }) };\n  });\n}\nasync function Ro({ value: e5, schema: t3 }) {\n  let n3 = await zo({ value: e5, schema: t3 });\n  if (!n3.success)\n    throw A.wrap({ value: e5, cause: n3.error });\n  return n3.value;\n}\nasync function zo({ value: e5, schema: t3 }) {\n  let n3 = Io(t3);\n  try {\n    if (n3.validate == null)\n      return { success: true, value: e5, rawValue: e5 };\n    let t4 = await n3.validate(e5);\n    return t4.success ? { success: true, value: t4.value, rawValue: e5 } : { success: false, error: A.wrap({ value: e5, cause: t4.error }), rawValue: e5 };\n  } catch (t4) {\n    return { success: false, error: A.wrap({ value: e5, cause: t4 }), rawValue: e5 };\n  }\n}\nasync function Bo({ text: e5, schema: t3 }) {\n  try {\n    let n3 = Mo(e5);\n    return t3 == null ? n3 : Ro({ value: n3, schema: t3 });\n  } catch (t4) {\n    throw O.isInstance(t4) || A.isInstance(t4) ? t4 : new O({ text: e5, cause: t4 });\n  }\n}\nasync function Vo({ text: e5, schema: t3 }) {\n  try {\n    let n3 = Mo(e5);\n    return t3 == null ? { success: true, value: n3, rawValue: n3 } : await zo({ value: n3, schema: t3 });\n  } catch (t4) {\n    return { success: false, error: O.isInstance(t4) ? t4 : new O({ text: e5, cause: t4 }), rawValue: undefined };\n  }\n}\nvar Ho = () => globalThis.fetch;\nvar Uo = async ({ url: e5, headers: t3, body: n3, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 }) => Wo({ url: e5, headers: { "Content-Type": `application/json`, ...t3 }, body: { content: JSON.stringify(n3), values: n3 }, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 });\nvar Wo = async ({ url: e5, headers: t3 = {}, body: n3, successfulResponseHandler: r3, failedResponseHandler: i4, abortSignal: a5, fetch: o3 = Ho() }) => {\n  try {\n    let s4 = await o3(e5, { method: `POST`, headers: Co(t3, `ai-sdk/provider-utils/${Do}`, xo()), body: n3.content, signal: a5 }), c4 = bo(s4);\n    if (!s4.ok) {\n      let t4;\n      try {\n        t4 = await i4({ response: s4, url: e5, requestBodyValues: n3.values });\n      } catch (t5) {\n        throw wo(t5) || T.isInstance(t5) ? t5 : new T({ message: `Failed to process error response`, cause: t5, statusCode: s4.status, url: e5, responseHeaders: c4, requestBodyValues: n3.values });\n      }\n      throw t4.value;\n    }\n    try {\n      return await r3({ response: s4, url: e5, requestBodyValues: n3.values });\n    } catch (t4) {\n      throw t4 instanceof Error && (wo(t4) || T.isInstance(t4)) ? t4 : new T({ message: `Failed to process successful response`, cause: t4, statusCode: s4.status, url: e5, responseHeaders: c4, requestBodyValues: n3.values });\n    }\n  } catch (t4) {\n    throw Eo({ error: t4, url: e5, requestBodyValues: n3.values });\n  }\n};\nvar Go = ({ errorSchema: e5, errorToMessage: t3, isRetryable: n3 }) => async ({ response: r3, url: i4, requestBodyValues: a5 }) => {\n  let o3 = await r3.text(), s4 = bo(r3);\n  if (o3.trim() === ``)\n    return { responseHeaders: s4, value: new T({ message: r3.statusText, url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, isRetryable: n3?.(r3) }) };\n  try {\n    let c4 = await Bo({ text: o3, schema: e5 });\n    return { responseHeaders: s4, value: new T({ message: t3(c4), url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, data: c4, isRetryable: n3?.(r3, c4) }) };\n  } catch {\n    return { responseHeaders: s4, value: new T({ message: r3.statusText, url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, isRetryable: n3?.(r3) }) };\n  }\n};\nvar Ko = (e5) => async ({ response: t3, url: n3, requestBodyValues: r3 }) => {\n  let i4 = await t3.text(), a5 = await Vo({ text: i4, schema: e5 }), o3 = bo(t3);\n  if (!a5.success)\n    throw new T({ message: `Invalid JSON response`, cause: a5.error, statusCode: t3.status, responseHeaders: o3, responseBody: i4, url: n3, requestBodyValues: r3 });\n  return { responseHeaders: o3, value: a5.value, rawValue: a5.rawValue };\n};\nexports_external.object({ user: exports_external.string().optional(), reasoningEffort: exports_external.string().optional() });\nvar Yo = { errorSchema: exports_external.object({ error: exports_external.object({ message: exports_external.string(), type: exports_external.string().nullish(), param: exports_external.any().nullish(), code: exports_external.union([exports_external.string(), exports_external.number()]).nullish() }) }), errorToMessage: (e5) => e5.error.message };\nvar Xo = exports_external.object({ prompt_tokens: exports_external.number().nullish(), completion_tokens: exports_external.number().nullish(), total_tokens: exports_external.number().nullish(), prompt_tokens_details: exports_external.object({ cached_tokens: exports_external.number().nullish() }).nullish(), completion_tokens_details: exports_external.object({ reasoning_tokens: exports_external.number().nullish(), accepted_prediction_tokens: exports_external.number().nullish(), rejected_prediction_tokens: exports_external.number().nullish() }).nullish() }).nullish();\nexports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ message: exports_external.object({ role: exports_external.literal(`assistant`).nullish(), content: exports_external.string().nullish(), reasoning_content: exports_external.string().nullish(), reasoning: exports_external.string().nullish(), tool_calls: exports_external.array(exports_external.object({ id: exports_external.string().nullish(), function: exports_external.object({ name: exports_external.string(), arguments: exports_external.string() }) })).nullish() }), finish_reason: exports_external.string().nullish() })), usage: Xo }), exports_external.object({ echo: exports_external.boolean().optional(), logitBias: exports_external.record(exports_external.string(), exports_external.number()).optional(), suffix: exports_external.string().optional(), user: exports_external.string().optional() });\nvar Zo = exports_external.object({ prompt_tokens: exports_external.number(), completion_tokens: exports_external.number(), total_tokens: exports_external.number() });\nexports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ text: exports_external.string(), finish_reason: exports_external.string() })), usage: Zo.nullish() }), exports_external.object({ dimensions: exports_external.number().optional(), user: exports_external.string().optional() }), exports_external.object({ data: exports_external.array(exports_external.object({ embedding: exports_external.array(exports_external.number()) })), usage: exports_external.object({ prompt_tokens: exports_external.number() }).nullish(), providerMetadata: exports_external.record(exports_external.string(), exports_external.record(exports_external.string(), exports_external.any())).optional() });\nvar Qo = class {\n  constructor(e5, t3) {\n    this.modelId = e5, this.config = t3, this.specificationVersion = `v2`, this.maxImagesPerCall = 10;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate({ prompt: e5, n: t3, size: n3, aspectRatio: r3, seed: i4, providerOptions: a5, headers: o3, abortSignal: s4 }) {\n    var c4;\n    let l3 = [];\n    r3 != null && l3.push({ type: `unsupported-setting`, setting: `aspectRatio`, details: "This model does not support aspect ratio. Use `size` instead." }), i4 != null && l3.push({ type: `unsupported-setting`, setting: `seed` });\n    let u3 = (c4 = this.config._internal)?.currentDate?.call(c4) ?? new Date, { value: d2, responseHeaders: f2 } = await Uo({ url: this.config.url({ path: `/images/generations`, modelId: this.modelId }), headers: yo(this.config.headers(), o3), body: { model: this.modelId, prompt: e5, n: t3, size: n3, ...a5.openai ?? {}, response_format: `b64_json` }, failedResponseHandler: Go(this.config.errorStructure ?? Yo), successfulResponseHandler: Ko($o), abortSignal: s4, fetch: this.config.fetch });\n    return { images: d2.data.map((e6) => e6.b64_json), warnings: l3, response: { timestamp: u3, modelId: this.modelId, headers: f2 } };\n  }\n};\nvar $o = exports_external.object({ data: exports_external.array(exports_external.object({ b64_json: exports_external.string() })) });\nfunction es(...e5) {\n  return e5.reduce((e6, t3) => ({ ...e6, ...t3 ?? {} }), {});\n}\nfunction ts(e5) {\n  return Object.fromEntries([...e5.headers]);\n}\nfunction ns(e5 = globalThis) {\n  return e5.window ? `runtime/browser` : e5.navigator?.userAgent ? `runtime/${e5.navigator.userAgent.toLowerCase()}` : e5.process?.versions?.node ? `runtime/node.js/${e5.process.version.substring(0)}` : e5.EdgeRuntime ? `runtime/vercel-edge` : `runtime/unknown`;\n}\nfunction rs(e5) {\n  return Object.fromEntries(Object.entries(e5).filter(([e6, t3]) => t3 != null));\n}\nfunction os(e5, ...t3) {\n  let n3 = rs(e5 ?? {}), r3 = new Headers(n3), i4 = r3.get(`user-agent`) || ``;\n  return r3.set(`user-agent`, [i4, ...t3].filter(Boolean).join(` `)), Object.fromEntries(r3);\n}\nvar ss = (({ prefix: e5, size: t3 = 16, alphabet: n3 = `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`, separator: r3 = `-` } = {}) => {\n  let i4 = () => {\n    let e6 = n3.length, r4 = Array(t3);\n    for (let i5 = 0;i5 < t3; i5++)\n      r4[i5] = n3[Math.random() * e6 | 0];\n    return r4.join(``);\n  };\n  if (e5 == null)\n    return i4;\n  if (n3.includes(r3))\n    throw new D({ argument: `separator`, message: `The separator "${r3}" must not be part of the alphabet "${n3}".` });\n  return () => `${e5}${r3}${i4()}`;\n})();\nfunction cs(e5) {\n  return (e5 instanceof Error || e5 instanceof DOMException) && (e5.name === `AbortError` || e5.name === `ResponseAborted` || e5.name === `TimeoutError`);\n}\nvar ls = [`fetch failed`, `failed to fetch`];\nfunction us({ error: e5, url: t3, requestBodyValues: n3 }) {\n  if (cs(e5))\n    return e5;\n  if (e5 instanceof TypeError && ls.includes(e5.message.toLowerCase())) {\n    let r3 = e5.cause;\n    if (r3 != null)\n      return new T({ message: `Cannot connect to API: ${r3.message}`, cause: r3, url: t3, requestBodyValues: n3, isRetryable: true });\n  }\n  return e5;\n}\nvar ds = `3.0.10`;\nfunction fs({ apiKey: e5, environmentVariableName: t3, apiKeyParameterName: n3 = `apiKey`, description: r3 }) {\n  if (typeof e5 == `string`)\n    return e5;\n  if (e5 != null)\n    throw new k({ message: `${r3} API key must be a string.` });\n  if (typeof process > `u`)\n    throw new k({ message: `${r3} API key is missing. Pass it using the \'${n3}\' parameter. Environment variables is not supported in this environment.` });\n  if (e5 = process.env[t3], e5 == null)\n    throw new k({ message: `${r3} API key is missing. Pass it using the \'${n3}\' parameter or the ${t3} environment variable.` });\n  if (typeof e5 != `string`)\n    throw new k({ message: `${r3} API key must be a string. The value of the ${t3} environment variable is not a string.` });\n  return e5;\n}\nvar ps = /"__proto__"\\s*:/;\nvar ms = /"constructor"\\s*:/;\nfunction hs(e5) {\n  let t3 = JSON.parse(e5);\n  return typeof t3 != `object` || !t3 || ps.test(e5) === false && ms.test(e5) === false ? t3 : gs(t3);\n}\nfunction gs(e5) {\n  let t3 = [e5];\n  for (;t3.length; ) {\n    let e6 = t3;\n    t3 = [];\n    for (let n3 of e6) {\n      if (Object.prototype.hasOwnProperty.call(n3, `__proto__`) || Object.prototype.hasOwnProperty.call(n3, `constructor`) && Object.prototype.hasOwnProperty.call(n3.constructor, `prototype`))\n        throw SyntaxError(`Object contains forbidden prototype property`);\n      for (let e7 in n3) {\n        let r3 = n3[e7];\n        r3 && typeof r3 == `object` && t3.push(r3);\n      }\n    }\n  }\n  return e5;\n}\nfunction _s(e5) {\n  let { stackTraceLimit: t3 } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return hs(e5);\n  } finally {\n    Error.stackTraceLimit = t3;\n  }\n}\nvar vs = Symbol.for(`vercel.ai.validator`);\nfunction ys(e5) {\n  return { [vs]: true, validate: e5 };\n}\nfunction bs(e5) {\n  return typeof e5 == `object` && !!e5 && vs in e5 && e5[vs] === true && `validate` in e5;\n}\nfunction xs(e5) {\n  return bs(e5) ? e5 : Ss(e5);\n}\nfunction Ss(e5) {\n  return ys(async (t3) => {\n    let n3 = await e5[`~standard`].validate(t3);\n    return n3.issues == null ? { success: true, value: n3.value } : { success: false, error: new A({ value: t3, cause: n3.issues }) };\n  });\n}\nasync function Cs({ value: e5, schema: t3 }) {\n  let n3 = await ws({ value: e5, schema: t3 });\n  if (!n3.success)\n    throw A.wrap({ value: e5, cause: n3.error });\n  return n3.value;\n}\nasync function ws({ value: e5, schema: t3 }) {\n  let n3 = xs(t3);\n  try {\n    if (n3.validate == null)\n      return { success: true, value: e5, rawValue: e5 };\n    let t4 = await n3.validate(e5);\n    return t4.success ? { success: true, value: t4.value, rawValue: e5 } : { success: false, error: A.wrap({ value: e5, cause: t4.error }), rawValue: e5 };\n  } catch (t4) {\n    return { success: false, error: A.wrap({ value: e5, cause: t4 }), rawValue: e5 };\n  }\n}\nasync function Ts({ text: e5, schema: t3 }) {\n  try {\n    let n3 = _s(e5);\n    return t3 == null ? n3 : Cs({ value: n3, schema: t3 });\n  } catch (t4) {\n    throw O.isInstance(t4) || A.isInstance(t4) ? t4 : new O({ text: e5, cause: t4 });\n  }\n}\nasync function Es({ text: e5, schema: t3 }) {\n  try {\n    let n3 = _s(e5);\n    return t3 == null ? { success: true, value: n3, rawValue: n3 } : await ws({ value: n3, schema: t3 });\n  } catch (t4) {\n    return { success: false, error: O.isInstance(t4) ? t4 : new O({ text: e5, cause: t4 }), rawValue: undefined };\n  }\n}\nfunction Ds({ stream: e5, schema: t3 }) {\n  return e5.pipeThrough(new TextDecoderStream).pipeThrough(new l2).pipeThrough(new TransformStream({ async transform({ data: e6 }, n3) {\n    e6 !== `[DONE]` && n3.enqueue(await Es({ text: e6, schema: t3 }));\n  } }));\n}\nasync function Os({ provider: e5, providerOptions: t3, schema: n3 }) {\n  if (t3?.[e5] == null)\n    return;\n  let r3 = await ws({ value: t3[e5], schema: n3 });\n  if (!r3.success)\n    throw new D({ argument: `providerOptions`, message: `invalid ${e5} provider options`, cause: r3.error });\n  return r3.value;\n}\nvar ks = () => globalThis.fetch;\nvar As = async ({ url: e5, headers: t3, body: n3, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 }) => js({ url: e5, headers: { "Content-Type": `application/json`, ...t3 }, body: { content: JSON.stringify(n3), values: n3 }, failedResponseHandler: r3, successfulResponseHandler: i4, abortSignal: a5, fetch: o3 });\nvar js = async ({ url: e5, headers: t3 = {}, body: n3, successfulResponseHandler: r3, failedResponseHandler: i4, abortSignal: a5, fetch: o3 = ks() }) => {\n  try {\n    let s4 = await o3(e5, { method: `POST`, headers: os(t3, `ai-sdk/provider-utils/${ds}`, ns()), body: n3.content, signal: a5 }), c4 = ts(s4);\n    if (!s4.ok) {\n      let t4;\n      try {\n        t4 = await i4({ response: s4, url: e5, requestBodyValues: n3.values });\n      } catch (t5) {\n        throw cs(t5) || T.isInstance(t5) ? t5 : new T({ message: `Failed to process error response`, cause: t5, statusCode: s4.status, url: e5, responseHeaders: c4, requestBodyValues: n3.values });\n      }\n      throw t4.value;\n    }\n    try {\n      return await r3({ response: s4, url: e5, requestBodyValues: n3.values });\n    } catch (t4) {\n      throw t4 instanceof Error && (cs(t4) || T.isInstance(t4)) ? t4 : new T({ message: `Failed to process successful response`, cause: t4, statusCode: s4.status, url: e5, responseHeaders: c4, requestBodyValues: n3.values });\n    }\n  } catch (t4) {\n    throw us({ error: t4, url: e5, requestBodyValues: n3.values });\n  }\n};\nvar Ms = ({ errorSchema: e5, errorToMessage: t3, isRetryable: n3 }) => async ({ response: r3, url: i4, requestBodyValues: a5 }) => {\n  let o3 = await r3.text(), s4 = ts(r3);\n  if (o3.trim() === ``)\n    return { responseHeaders: s4, value: new T({ message: r3.statusText, url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, isRetryable: n3?.(r3) }) };\n  try {\n    let c4 = await Ts({ text: o3, schema: e5 });\n    return { responseHeaders: s4, value: new T({ message: t3(c4), url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, data: c4, isRetryable: n3?.(r3, c4) }) };\n  } catch {\n    return { responseHeaders: s4, value: new T({ message: r3.statusText, url: i4, requestBodyValues: a5, statusCode: r3.status, responseHeaders: s4, responseBody: o3, isRetryable: n3?.(r3) }) };\n  }\n};\nvar Ns = (e5) => async ({ response: t3 }) => {\n  let n3 = ts(t3);\n  if (t3.body == null)\n    throw new E({});\n  return { responseHeaders: n3, value: Ds({ stream: t3.body, schema: e5 }) };\n};\nvar Ps = (e5) => async ({ response: t3, url: n3, requestBodyValues: r3 }) => {\n  let i4 = await t3.text(), a5 = await Es({ text: i4, schema: e5 }), o3 = ts(t3);\n  if (!a5.success)\n    throw new T({ message: `Invalid JSON response`, cause: a5.error, statusCode: t3.status, responseHeaders: o3, responseBody: i4, url: n3, requestBodyValues: r3 });\n  return { responseHeaders: o3, value: a5.value, rawValue: a5.rawValue };\n};\nvar { btoa: Fs, atob: Is } = globalThis;\nfunction Ls(e5) {\n  let t3 = ``;\n  for (let n3 = 0;n3 < e5.length; n3++)\n    t3 += String.fromCodePoint(e5[n3]);\n  return Fs(t3);\n}\nfunction Rs(e5) {\n  return e5 instanceof Uint8Array ? Ls(e5) : e5;\n}\nfunction zs(e5) {\n  return e5?.replace(/\\/$/, ``);\n}\nfunction Bs(e5) {\n  let t3 = [], n3 = [];\n  for (let { role: n4, content: r3 } of e5)\n    switch (n4) {\n      case `system`:\n        t3.push({ role: `system`, content: r3 });\n        break;\n      case `user`:\n        if (r3.length === 1 && r3[0].type === `text`) {\n          t3.push({ role: `user`, content: r3[0].text });\n          break;\n        }\n        t3.push({ role: `user`, content: r3.map((e6) => {\n          switch (e6.type) {\n            case `text`:\n              return { type: `text`, text: e6.text };\n            case `file`:\n              if (e6.mediaType.startsWith(`image/`)) {\n                let t4 = e6.mediaType === `image/*` ? `image/jpeg` : e6.mediaType;\n                return { type: `image_url`, image_url: { url: e6.data instanceof URL ? e6.data.toString() : `data:${t4};base64,${Rs(e6.data)}` } };\n              } else\n                throw new j({ functionality: `file part media type ${e6.mediaType}` });\n          }\n        }) });\n        break;\n      case `assistant`: {\n        let e6 = ``, n5 = [];\n        for (let t4 of r3)\n          switch (t4.type) {\n            case `text`:\n              e6 += t4.text;\n              break;\n            case `tool-call`:\n              n5.push({ id: t4.toolCallId, type: `function`, function: { name: t4.toolName, arguments: JSON.stringify(t4.input) } });\n              break;\n          }\n        t3.push({ role: `assistant`, content: e6, tool_calls: n5.length > 0 ? n5 : undefined });\n        break;\n      }\n      case `tool`:\n        for (let e6 of r3) {\n          let n5 = e6.output, r4;\n          switch (n5.type) {\n            case `text`:\n            case `error-text`:\n              r4 = n5.value;\n              break;\n            case `content`:\n            case `json`:\n            case `error-json`:\n              r4 = JSON.stringify(n5.value);\n              break;\n          }\n          t3.push({ role: `tool`, tool_call_id: e6.toolCallId, content: r4 });\n        }\n        break;\n      default: {\n        let e6 = n4;\n        throw Error(`Unsupported role: ${e6}`);\n      }\n    }\n  return { messages: t3, warnings: n3 };\n}\nfunction Vs({ id: e5, model: t3, created: n3 }) {\n  return { id: e5 ?? undefined, modelId: t3 ?? undefined, timestamp: n3 == null ? undefined : new Date(n3 * 1000) };\n}\nfunction Hs(e5) {\n  switch (e5) {\n    case `stop`:\n      return `stop`;\n    case `length`:\n      return `length`;\n    case `tool_calls`:\n    case `function_call`:\n      return `tool-calls`;\n    case `content_filter`:\n      return `content-filter`;\n    default:\n      return `unknown`;\n  }\n}\nvar Us = exports_external.object({ type: exports_external.literal(`web`), country: exports_external.string().length(2).optional(), excludedWebsites: exports_external.array(exports_external.string()).max(5).optional(), allowedWebsites: exports_external.array(exports_external.string()).max(5).optional(), safeSearch: exports_external.boolean().optional() });\nvar Ws = exports_external.object({ type: exports_external.literal(`x`), excludedXHandles: exports_external.array(exports_external.string()).optional(), includedXHandles: exports_external.array(exports_external.string()).optional(), postFavoriteCount: exports_external.number().int().optional(), postViewCount: exports_external.number().int().optional(), xHandles: exports_external.array(exports_external.string()).optional() });\nvar Gs = exports_external.object({ type: exports_external.literal(`news`), country: exports_external.string().length(2).optional(), excludedWebsites: exports_external.array(exports_external.string()).max(5).optional(), safeSearch: exports_external.boolean().optional() });\nvar Ks = exports_external.object({ type: exports_external.literal(`rss`), links: exports_external.array(exports_external.string().url()).max(1) });\nvar qs = exports_external.discriminatedUnion(`type`, [Us, Ws, Gs, Ks]);\nvar Js = exports_external.object({ reasoningEffort: exports_external.enum([`low`, `high`]).optional(), searchParameters: exports_external.object({ mode: exports_external.enum([`off`, `auto`, `on`]), returnCitations: exports_external.boolean().optional(), fromDate: exports_external.string().optional(), toDate: exports_external.string().optional(), maxSearchResults: exports_external.number().min(1).max(50).optional(), sources: exports_external.array(qs).optional() }).optional() });\nvar Ys = exports_external.object({ error: exports_external.object({ message: exports_external.string(), type: exports_external.string().nullish(), param: exports_external.any().nullish(), code: exports_external.union([exports_external.string(), exports_external.number()]).nullish() }) });\nvar Xs = Ms({ errorSchema: Ys, errorToMessage: (e5) => e5.error.message });\nfunction Zs({ tools: e5, toolChoice: t3 }) {\n  e5 = e5?.length ? e5 : undefined;\n  let n3 = [];\n  if (e5 == null)\n    return { tools: undefined, toolChoice: undefined, toolWarnings: n3 };\n  let r3 = [];\n  for (let t4 of e5)\n    t4.type === `provider-defined` ? n3.push({ type: `unsupported-tool`, tool: t4 }) : r3.push({ type: `function`, function: { name: t4.name, description: t4.description, parameters: t4.inputSchema } });\n  if (t3 == null)\n    return { tools: r3, toolChoice: undefined, toolWarnings: n3 };\n  let i4 = t3.type;\n  switch (i4) {\n    case `auto`:\n    case `none`:\n      return { tools: r3, toolChoice: i4, toolWarnings: n3 };\n    case `required`:\n      return { tools: r3, toolChoice: `required`, toolWarnings: n3 };\n    case `tool`:\n      return { tools: r3, toolChoice: { type: `function`, function: { name: t3.toolName } }, toolWarnings: n3 };\n    default:\n      throw new j({ functionality: `tool choice type: ${i4}` });\n  }\n}\nvar Qs = class {\n  constructor(e5, t3) {\n    this.specificationVersion = `v2`, this.supportedUrls = { "image/*": [/^https?:\\/\\/.*$/] }, this.modelId = e5, this.config = t3;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async getArgs({ prompt: e5, maxOutputTokens: t3, temperature: n3, topP: r3, topK: i4, frequencyPenalty: a5, presencePenalty: o3, stopSequences: s4, seed: c4, responseFormat: l3, providerOptions: u3, tools: d2, toolChoice: f2 }) {\n    let p2 = [], m2 = await Os({ provider: `xai`, providerOptions: u3, schema: Js }) ?? {};\n    i4 != null && p2.push({ type: `unsupported-setting`, setting: `topK` }), a5 != null && p2.push({ type: `unsupported-setting`, setting: `frequencyPenalty` }), o3 != null && p2.push({ type: `unsupported-setting`, setting: `presencePenalty` }), s4 != null && p2.push({ type: `unsupported-setting`, setting: `stopSequences` }), l3 != null && l3.type === `json` && l3.schema != null && p2.push({ type: `unsupported-setting`, setting: `responseFormat`, details: `JSON response format schema is not supported` });\n    let { messages: h2, warnings: g2 } = Bs(e5);\n    p2.push(...g2);\n    let { tools: _2, toolChoice: v2, toolWarnings: y2 } = Zs({ tools: d2, toolChoice: f2 });\n    return p2.push(...y2), { args: { model: this.modelId, max_tokens: t3, temperature: n3, top_p: r3, seed: c4, reasoning_effort: m2.reasoningEffort, response_format: l3?.type === `json` ? l3.schema == null ? { type: `json_object` } : { type: `json_schema`, json_schema: { name: l3.name ?? `response`, schema: l3.schema, strict: true } } : undefined, search_parameters: m2.searchParameters ? { mode: m2.searchParameters.mode, return_citations: m2.searchParameters.returnCitations, from_date: m2.searchParameters.fromDate, to_date: m2.searchParameters.toDate, max_search_results: m2.searchParameters.maxSearchResults, sources: m2.searchParameters.sources?.map((e6) => ({ type: e6.type, ...e6.type === `web` && { country: e6.country, excluded_websites: e6.excludedWebsites, allowed_websites: e6.allowedWebsites, safe_search: e6.safeSearch }, ...e6.type === `x` && { excluded_x_handles: e6.excludedXHandles, included_x_handles: e6.includedXHandles ?? e6.xHandles, post_favorite_count: e6.postFavoriteCount, post_view_count: e6.postViewCount }, ...e6.type === `news` && { country: e6.country, excluded_websites: e6.excludedWebsites, safe_search: e6.safeSearch }, ...e6.type === `rss` && { links: e6.links } })) } : undefined, messages: h2, tools: _2, tool_choice: v2 }, warnings: p2 };\n  }\n  async doGenerate(e5) {\n    let { args: t3, warnings: n3 } = await this.getArgs(e5), { responseHeaders: r3, value: i4, rawValue: a5 } = await As({ url: `${this.config.baseURL ?? `https://api.x.ai/v1`}/chat/completions`, headers: es(this.config.headers(), e5.headers), body: t3, failedResponseHandler: Xs, successfulResponseHandler: Ps(ec), abortSignal: e5.abortSignal, fetch: this.config.fetch }), o3 = i4.choices[0], s4 = [];\n    if (o3.message.content != null && o3.message.content.length > 0) {\n      let e6 = o3.message.content, n4 = t3.messages[t3.messages.length - 1];\n      n4?.role === `assistant` && e6 === n4.content && (e6 = ``), e6.length > 0 && s4.push({ type: `text`, text: e6 });\n    }\n    if (o3.message.reasoning_content != null && o3.message.reasoning_content.length > 0 && s4.push({ type: `reasoning`, text: o3.message.reasoning_content }), o3.message.tool_calls != null)\n      for (let e6 of o3.message.tool_calls)\n        s4.push({ type: `tool-call`, toolCallId: e6.id, toolName: e6.function.name, input: e6.function.arguments });\n    if (i4.citations != null)\n      for (let e6 of i4.citations)\n        s4.push({ type: `source`, sourceType: `url`, id: this.config.generateId(), url: e6 });\n    return { content: s4, finishReason: Hs(o3.finish_reason), usage: { inputTokens: i4.usage.prompt_tokens, outputTokens: i4.usage.completion_tokens, totalTokens: i4.usage.total_tokens, reasoningTokens: i4.usage.completion_tokens_details?.reasoning_tokens ?? undefined }, request: { body: t3 }, response: { ...Vs(i4), headers: r3, body: a5 }, warnings: n3 };\n  }\n  async doStream(e5) {\n    let { args: t3, warnings: n3 } = await this.getArgs(e5), r3 = { ...t3, stream: true, stream_options: { include_usage: true } }, { responseHeaders: i4, value: a5 } = await As({ url: `${this.config.baseURL ?? `https://api.x.ai/v1`}/chat/completions`, headers: es(this.config.headers(), e5.headers), body: r3, failedResponseHandler: Xs, successfulResponseHandler: Ns(tc), abortSignal: e5.abortSignal, fetch: this.config.fetch }), o3 = `unknown`, s4 = { inputTokens: undefined, outputTokens: undefined, totalTokens: undefined }, c4 = true, l3 = {}, u3 = {}, d2 = this;\n    return { stream: a5.pipeThrough(new TransformStream({ start(e6) {\n      e6.enqueue({ type: `stream-start`, warnings: n3 });\n    }, transform(t4, n4) {\n      if (e5.includeRawChunks && n4.enqueue({ type: `raw`, rawValue: t4.rawValue }), !t4.success) {\n        n4.enqueue({ type: `error`, error: t4.error });\n        return;\n      }\n      let i5 = t4.value;\n      if (c4 &&= (n4.enqueue({ type: `response-metadata`, ...Vs(i5) }), false), i5.citations != null)\n        for (let e6 of i5.citations)\n          n4.enqueue({ type: `source`, sourceType: `url`, id: d2.config.generateId(), url: e6 });\n      i5.usage != null && (s4.inputTokens = i5.usage.prompt_tokens, s4.outputTokens = i5.usage.completion_tokens, s4.totalTokens = i5.usage.total_tokens, s4.reasoningTokens = i5.usage.completion_tokens_details?.reasoning_tokens ?? undefined);\n      let a6 = i5.choices[0];\n      if (a6?.finish_reason != null && (o3 = Hs(a6.finish_reason)), a6?.delta == null)\n        return;\n      let { delta: f2, index: p2 } = a6;\n      if (f2.content != null && f2.content.length > 0) {\n        let e6 = f2.content, t5 = r3.messages[r3.messages.length - 1];\n        if (t5?.role === `assistant` && e6 === t5.content)\n          return;\n        let a7 = `text-${i5.id || p2}`;\n        l3[a7] ?? (l3[a7] = { type: `text` }, n4.enqueue({ type: `text-start`, id: a7 })), n4.enqueue({ type: `text-delta`, id: a7, delta: e6 });\n      }\n      if (f2.reasoning_content != null && f2.reasoning_content.length > 0) {\n        let e6 = `reasoning-${i5.id || p2}`;\n        if (u3[e6] === f2.reasoning_content)\n          return;\n        u3[e6] = f2.reasoning_content, l3[e6] ?? (l3[e6] = { type: `reasoning` }, n4.enqueue({ type: `reasoning-start`, id: e6 })), n4.enqueue({ type: `reasoning-delta`, id: e6, delta: f2.reasoning_content });\n      }\n      if (f2.tool_calls != null)\n        for (let e6 of f2.tool_calls) {\n          let t5 = e6.id;\n          n4.enqueue({ type: `tool-input-start`, id: t5, toolName: e6.function.name }), n4.enqueue({ type: `tool-input-delta`, id: t5, delta: e6.function.arguments }), n4.enqueue({ type: `tool-input-end`, id: t5 }), n4.enqueue({ type: `tool-call`, toolCallId: t5, toolName: e6.function.name, input: e6.function.arguments });\n        }\n    }, flush(e6) {\n      for (let [t4, n4] of Object.entries(l3))\n        e6.enqueue({ type: n4.type === `text` ? `text-end` : `reasoning-end`, id: t4 });\n      e6.enqueue({ type: `finish`, finishReason: o3, usage: s4 });\n    } })), request: { body: r3 }, response: { headers: i4 } };\n  }\n};\nvar $s = exports_external.object({ prompt_tokens: exports_external.number(), completion_tokens: exports_external.number(), total_tokens: exports_external.number(), completion_tokens_details: exports_external.object({ reasoning_tokens: exports_external.number().nullish() }).nullish() });\nvar ec = exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ message: exports_external.object({ role: exports_external.literal(`assistant`), content: exports_external.string().nullish(), reasoning_content: exports_external.string().nullish(), tool_calls: exports_external.array(exports_external.object({ id: exports_external.string(), type: exports_external.literal(`function`), function: exports_external.object({ name: exports_external.string(), arguments: exports_external.string() }) })).nullish() }), index: exports_external.number(), finish_reason: exports_external.string().nullish() })), object: exports_external.literal(`chat.completion`), usage: $s, citations: exports_external.array(exports_external.string().url()).nullish() });\nvar tc = exports_external.object({ id: exports_external.string().nullish(), created: exports_external.number().nullish(), model: exports_external.string().nullish(), choices: exports_external.array(exports_external.object({ delta: exports_external.object({ role: exports_external.enum([`assistant`]).optional(), content: exports_external.string().nullish(), reasoning_content: exports_external.string().nullish(), tool_calls: exports_external.array(exports_external.object({ id: exports_external.string(), type: exports_external.literal(`function`), function: exports_external.object({ name: exports_external.string(), arguments: exports_external.string() }) })).nullish() }), finish_reason: exports_external.string().nullish(), index: exports_external.number() })), usage: $s.nullish(), citations: exports_external.array(exports_external.string().url()).nullish() });\nvar nc = `2.0.23`;\nvar rc = { errorSchema: Ys, errorToMessage: (e5) => e5.error.message };\nfunction ic(e5 = {}) {\n  let t3 = zs(e5.baseURL ?? `https://api.x.ai/v1`), n3 = () => os({ Authorization: `Bearer ${fs({ apiKey: e5.apiKey, environmentVariableName: `XAI_API_KEY`, description: `xAI API key` })}`, ...e5.headers }, `ai-sdk/xai/${nc}`), r3 = (r4) => new Qs(r4, { provider: `xai.chat`, baseURL: t3, headers: n3, generateId: ss, fetch: e5.fetch }), i4 = (r4) => new Qo(r4, { provider: `xai.image`, url: ({ path: e6 }) => `${t3}${e6}`, headers: n3, fetch: e5.fetch, errorStructure: rc }), a5 = (e6) => r3(e6);\n  return a5.languageModel = r3, a5.chat = r3, a5.textEmbeddingModel = (e6) => {\n    throw new Fe({ modelId: e6, modelType: `textEmbeddingModel` });\n  }, a5.imageModel = i4, a5.image = i4, a5;\n}\nic();\nvar oc = `BLINK_API_URL`;\n\n// ../../packages/blink/dist/browser/control/index.js\nvar f2 = (e5, t3, n3) => (r3, i4) => {\n  let a5 = -1;\n  return o3(0);\n  async function o3(s4) {\n    if (s4 <= a5)\n      throw Error(`next() called multiple times`);\n    a5 = s4;\n    let c4, l3 = false, u3;\n    if (e5[s4] ? (u3 = e5[s4][0][0], r3.req.routeIndex = s4) : u3 = s4 === e5.length && i4 || undefined, u3)\n      try {\n        c4 = await u3(r3, () => o3(s4 + 1));\n      } catch (e6) {\n        if (e6 instanceof Error && t3)\n          r3.error = e6, c4 = await t3(e6, r3), l3 = true;\n        else\n          throw e6;\n      }\n    else\n      r3.finalized === false && n3 && (c4 = await n3(r3));\n    return c4 && (r3.finalized === false || l3) && (r3.res = c4), r3;\n  }\n};\nvar p2 = Symbol();\nvar m2 = async (e5, t3 = Object.create(null)) => {\n  let { all: n3 = false, dot: r3 = false } = t3, i4 = (e5 instanceof y2 ? e5.raw.headers : e5.headers).get(`Content-Type`);\n  return i4?.startsWith(`multipart/form-data`) || i4?.startsWith(`application/x-www-form-urlencoded`) ? h2(e5, { all: n3, dot: r3 }) : {};\n};\nasync function h2(e5, t3) {\n  let n3 = await e5.formData();\n  return n3 ? g2(n3, t3) : {};\n}\nfunction g2(e5, t3) {\n  let n3 = Object.create(null);\n  return e5.forEach((e6, r3) => {\n    t3.all || r3.endsWith(`[]`) ? ee2(n3, r3, e6) : n3[r3] = e6;\n  }), t3.dot && Object.entries(n3).forEach(([e6, t4]) => {\n    e6.includes(`.`) && (_2(n3, e6, t4), delete n3[e6]);\n  }), n3;\n}\nvar ee2 = (e5, t3, n3) => {\n  e5[t3] === undefined ? t3.endsWith(`[]`) ? e5[t3] = [n3] : e5[t3] = n3 : Array.isArray(e5[t3]) ? e5[t3].push(n3) : e5[t3] = [e5[t3], n3];\n};\nvar _2 = (e5, t3, n3) => {\n  let r3 = e5, i4 = t3.split(`.`);\n  i4.forEach((e6, t4) => {\n    t4 === i4.length - 1 ? r3[e6] = n3 : ((!r3[e6] || typeof r3[e6] != `object` || Array.isArray(r3[e6]) || r3[e6] instanceof File) && (r3[e6] = Object.create(null)), r3 = r3[e6]);\n  });\n};\nvar v2 = (e5) => o(e5, g);\nvar y2 = class {\n  raw;\n  #validatedData;\n  #matchResult;\n  routeIndex = 0;\n  path;\n  bodyCache = {};\n  constructor(e5, t3 = `/`, n3 = [[]]) {\n    this.raw = e5, this.path = t3, this.#matchResult = n3, this.#validatedData = {};\n  }\n  param(e5) {\n    return e5 ? this.#getDecodedParam(e5) : this.#getAllDecodedParams();\n  }\n  #getDecodedParam(e5) {\n    let t3 = this.#matchResult[0][this.routeIndex][1][e5], n3 = this.#getParamValue(t3);\n    return n3 && /\\%/.test(n3) ? v2(n3) : n3;\n  }\n  #getAllDecodedParams() {\n    let e5 = {}, t3 = Object.keys(this.#matchResult[0][this.routeIndex][1]);\n    for (let n3 of t3) {\n      let t4 = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][n3]);\n      t4 !== undefined && (e5[n3] = /\\%/.test(t4) ? v2(t4) : t4);\n    }\n    return e5;\n  }\n  #getParamValue(e5) {\n    return this.#matchResult[1] ? this.#matchResult[1][e5] : e5;\n  }\n  query(e5) {\n    return m(this.url, e5);\n  }\n  queries(e5) {\n    return h(this.url, e5);\n  }\n  header(e5) {\n    if (e5)\n      return this.raw.headers.get(e5) ?? undefined;\n    let t3 = {};\n    return this.raw.headers.forEach((e6, n3) => {\n      t3[n3] = e6;\n    }), t3;\n  }\n  async parseBody(e5) {\n    return this.bodyCache.parsedBody ??= await m2(this, e5);\n  }\n  #cachedBody = (e5) => {\n    let { bodyCache: t3, raw: n3 } = this, r3 = t3[e5];\n    if (r3)\n      return r3;\n    let i4 = Object.keys(t3)[0];\n    return i4 ? t3[i4].then((t4) => (i4 === `json` && (t4 = JSON.stringify(t4)), new Response(t4)[e5]())) : t3[e5] = n3[e5]();\n  };\n  json() {\n    return this.#cachedBody(`text`).then((e5) => JSON.parse(e5));\n  }\n  text() {\n    return this.#cachedBody(`text`);\n  }\n  arrayBuffer() {\n    return this.#cachedBody(`arrayBuffer`);\n  }\n  blob() {\n    return this.#cachedBody(`blob`);\n  }\n  formData() {\n    return this.#cachedBody(`formData`);\n  }\n  addValidatedData(e5, t3) {\n    this.#validatedData[e5] = t3;\n  }\n  valid(e5) {\n    return this.#validatedData[e5];\n  }\n  get url() {\n    return this.raw.url;\n  }\n  get method() {\n    return this.raw.method;\n  }\n  get [p2]() {\n    return this.#matchResult;\n  }\n  get matchedRoutes() {\n    return this.#matchResult[0].map(([[, e5]]) => e5);\n  }\n  get routePath() {\n    return this.#matchResult[0].map(([[, e5]]) => e5)[this.routeIndex].path;\n  }\n};\nvar te2 = { Stringify: 1, BeforeStream: 2, Stream: 3 };\nvar ne2 = (e5, t3) => {\n  let n3 = new String(e5);\n  return n3.isEscaped = true, n3.callbacks = t3, n3;\n};\nvar b2 = async (e5, t3, n3, r3, i4) => {\n  typeof e5 == `object` && !(e5 instanceof String) && (e5 instanceof Promise || (e5 = e5.toString()), e5 instanceof Promise && (e5 = await e5));\n  let a5 = e5.callbacks;\n  if (!a5?.length)\n    return Promise.resolve(e5);\n  i4 ? i4[0] += e5 : i4 = [e5];\n  let o3 = Promise.all(a5.map((e6) => e6({ phase: t3, buffer: i4, context: r3 }))).then((e6) => Promise.all(e6.filter(Boolean).map((e7) => b2(e7, t3, false, r3, i4))).then(() => i4[0]));\n  return n3 ? ne2(await o3, a5) : o3;\n};\nvar x3 = `text/plain; charset=UTF-8`;\nvar S2 = (e5, t3) => ({ "Content-Type": e5, ...t3 });\nvar re2 = class {\n  #rawRequest;\n  #req;\n  env = {};\n  #var;\n  finalized = false;\n  error;\n  #status;\n  #executionCtx;\n  #res;\n  #layout;\n  #renderer;\n  #notFoundHandler;\n  #preparedHeaders;\n  #matchResult;\n  #path;\n  constructor(e5, t3) {\n    this.#rawRequest = e5, t3 && (this.#executionCtx = t3.executionCtx, this.env = t3.env, this.#notFoundHandler = t3.notFoundHandler, this.#path = t3.path, this.#matchResult = t3.matchResult);\n  }\n  get req() {\n    return this.#req ??= new y2(this.#rawRequest, this.#path, this.#matchResult), this.#req;\n  }\n  get event() {\n    if (this.#executionCtx && `respondWith` in this.#executionCtx)\n      return this.#executionCtx;\n    throw Error(`This context has no FetchEvent`);\n  }\n  get executionCtx() {\n    if (this.#executionCtx)\n      return this.#executionCtx;\n    throw Error(`This context has no ExecutionContext`);\n  }\n  get res() {\n    return this.#res ||= new Response(null, { headers: this.#preparedHeaders ??= new Headers });\n  }\n  set res(e5) {\n    if (this.#res && e5) {\n      e5 = new Response(e5.body, e5);\n      for (let [t3, n3] of this.#res.headers.entries())\n        if (t3 !== `content-type`)\n          if (t3 === `set-cookie`) {\n            let t4 = this.#res.headers.getSetCookie();\n            e5.headers.delete(`set-cookie`);\n            for (let n4 of t4)\n              e5.headers.append(`set-cookie`, n4);\n          } else\n            e5.headers.set(t3, n3);\n    }\n    this.#res = e5, this.finalized = true;\n  }\n  render = (...e5) => (this.#renderer ??= (e6) => this.html(e6), this.#renderer(...e5));\n  setLayout = (e5) => this.#layout = e5;\n  getLayout = () => this.#layout;\n  setRenderer = (e5) => {\n    this.#renderer = e5;\n  };\n  header = (e5, t3, n3) => {\n    this.finalized && (this.#res = new Response(this.#res.body, this.#res));\n    let r3 = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers;\n    t3 === undefined ? r3.delete(e5) : n3?.append ? r3.append(e5, t3) : r3.set(e5, t3);\n  };\n  status = (e5) => {\n    this.#status = e5;\n  };\n  set = (e5, t3) => {\n    this.#var ??= new Map, this.#var.set(e5, t3);\n  };\n  get = (e5) => this.#var ? this.#var.get(e5) : undefined;\n  get var() {\n    return this.#var ? Object.fromEntries(this.#var) : {};\n  }\n  #newResponse(e5, t3, n3) {\n    let r3 = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers;\n    if (typeof t3 == `object` && `headers` in t3) {\n      let e6 = t3.headers instanceof Headers ? t3.headers : new Headers(t3.headers);\n      for (let [t4, n4] of e6)\n        t4.toLowerCase() === `set-cookie` ? r3.append(t4, n4) : r3.set(t4, n4);\n    }\n    if (n3)\n      for (let [e6, t4] of Object.entries(n3))\n        if (typeof t4 == `string`)\n          r3.set(e6, t4);\n        else {\n          r3.delete(e6);\n          for (let n4 of t4)\n            r3.append(e6, n4);\n        }\n    let i4 = typeof t3 == `number` ? t3 : t3?.status ?? this.#status;\n    return new Response(e5, { status: i4, headers: r3 });\n  }\n  newResponse = (...e5) => this.#newResponse(...e5);\n  body = (e5, t3, n3) => this.#newResponse(e5, t3, n3);\n  text = (e5, t3, n3) => !this.#preparedHeaders && !this.#status && !t3 && !n3 && !this.finalized ? new Response(e5) : this.#newResponse(e5, t3, S2(x3, n3));\n  json = (e5, t3, n3) => this.#newResponse(JSON.stringify(e5), t3, S2(`application/json`, n3));\n  html = (e5, t3, n3) => {\n    let r3 = (e6) => this.#newResponse(e6, t3, S2(`text/html; charset=UTF-8`, n3));\n    return typeof e5 == `object` ? b2(e5, te2.Stringify, false, {}).then(r3) : r3(e5);\n  };\n  redirect = (e5, t3) => {\n    let n3 = String(e5);\n    return this.header(`Location`, /[^\\x00-\\xFF]/.test(n3) ? encodeURI(n3) : n3), this.newResponse(null, t3 ?? 302);\n  };\n  notFound = () => (this.#notFoundHandler ??= () => new Response, this.#notFoundHandler(this));\n};\nvar C2 = `ALL`;\nvar ie2 = `all`;\nvar ae2 = [`get`, `post`, `put`, `delete`, `options`, `patch`];\nvar w2 = `Can not add a route since the matcher is already built.`;\nvar T2 = class extends Error {\n};\nvar E2 = `__COMPOSED_HANDLER`;\nvar D2 = (e5) => e5.text(`404 Not Found`, 404);\nvar O2 = (e5, t3) => {\n  if (`getResponse` in e5) {\n    let n3 = e5.getResponse();\n    return t3.newResponse(n3.body, n3);\n  }\n  return console.error(e5), t3.text(`Internal Server Error`, 500);\n};\nvar k2 = class {\n  get;\n  post;\n  put;\n  delete;\n  options;\n  patch;\n  all;\n  on;\n  use;\n  router;\n  getPath;\n  _basePath = `/`;\n  #path = `/`;\n  routes = [];\n  constructor(e5 = {}) {\n    [...ae2, ie2].forEach((e6) => {\n      this[e6] = (t4, ...n3) => (typeof t4 == `string` ? this.#path = t4 : this.#addRoute(e6, this.#path, t4), n3.forEach((t5) => {\n        this.#addRoute(e6, this.#path, t5);\n      }), this);\n    }), this.on = (e6, t4, ...n3) => {\n      for (let r3 of [t4].flat()) {\n        this.#path = r3;\n        for (let t5 of [e6].flat())\n          n3.map((e7) => {\n            this.#addRoute(t5.toUpperCase(), this.#path, e7);\n          });\n      }\n      return this;\n    }, this.use = (e6, ...t4) => (typeof e6 == `string` ? this.#path = e6 : (this.#path = `*`, t4.unshift(e6)), t4.forEach((e7) => {\n      this.#addRoute(C2, this.#path, e7);\n    }), this);\n    let { strict: t3, ...i4 } = e5;\n    Object.assign(this, i4), this.getPath = t3 ?? true ? e5.getPath ?? c2 : l;\n  }\n  #clone() {\n    let e5 = new k2({ router: this.router, getPath: this.getPath });\n    return e5.errorHandler = this.errorHandler, e5.#notFoundHandler = this.#notFoundHandler, e5.routes = this.routes, e5;\n  }\n  #notFoundHandler = D2;\n  errorHandler = O2;\n  route(e5, t3) {\n    let n3 = this.basePath(e5);\n    return t3.routes.map((e6) => {\n      let r3;\n      t3.errorHandler === O2 ? r3 = e6.handler : (r3 = async (n4, r4) => (await f2([], t3.errorHandler)(n4, () => e6.handler(n4, r4))).res, r3[E2] = e6.handler), n3.#addRoute(e6.method, e6.path, r3);\n    }), this;\n  }\n  basePath(e5) {\n    let t3 = this.#clone();\n    return t3._basePath = u(this._basePath, e5), t3;\n  }\n  onError = (e5) => (this.errorHandler = e5, this);\n  notFound = (e5) => (this.#notFoundHandler = e5, this);\n  mount(e5, t3, n3) {\n    let r3, i4;\n    n3 && (typeof n3 == `function` ? i4 = n3 : (i4 = n3.optionHandler, r3 = n3.replaceRequest === false ? (e6) => e6 : n3.replaceRequest));\n    let a5 = i4 ? (e6) => {\n      let t4 = i4(e6);\n      return Array.isArray(t4) ? t4 : [t4];\n    } : (e6) => {\n      let t4;\n      try {\n        t4 = e6.executionCtx;\n      } catch {}\n      return [e6.env, t4];\n    };\n    return r3 ||= (() => {\n      let t4 = u(this._basePath, e5), n4 = t4 === `/` ? 0 : t4.length;\n      return (e6) => {\n        let t5 = new URL(e6.url);\n        return t5.pathname = t5.pathname.slice(n4) || `/`, new Request(t5, e6);\n      };\n    })(), this.#addRoute(C2, u(e5, `*`), async (e6, n4) => {\n      let i5 = await t3(r3(e6.req.raw), ...a5(e6));\n      if (i5)\n        return i5;\n      await n4();\n    }), this;\n  }\n  #addRoute(e5, t3, n3) {\n    e5 = e5.toUpperCase(), t3 = u(this._basePath, t3);\n    let r3 = { basePath: this._basePath, path: t3, method: e5, handler: n3 };\n    this.router.add(e5, t3, [n3, r3]), this.routes.push(r3);\n  }\n  #handleError(e5, t3) {\n    if (e5 instanceof Error)\n      return this.errorHandler(e5, t3);\n    throw e5;\n  }\n  #dispatch(e5, t3, n3, r3) {\n    if (r3 === `HEAD`)\n      return (async () => new Response(null, await this.#dispatch(e5, t3, n3, `GET`)))();\n    let i4 = this.getPath(e5, { env: n3 }), a5 = this.router.match(r3, i4), o3 = new re2(e5, { path: i4, matchResult: a5, env: n3, executionCtx: t3, notFoundHandler: this.#notFoundHandler });\n    if (a5[0].length === 1) {\n      let e6;\n      try {\n        e6 = a5[0][0][0][0](o3, async () => {\n          o3.res = await this.#notFoundHandler(o3);\n        });\n      } catch (e7) {\n        return this.#handleError(e7, o3);\n      }\n      return e6 instanceof Promise ? e6.then((e7) => e7 || (o3.finalized ? o3.res : this.#notFoundHandler(o3))).catch((e7) => this.#handleError(e7, o3)) : e6 ?? this.#notFoundHandler(o3);\n    }\n    let s4 = f2(a5[0], this.errorHandler, this.#notFoundHandler);\n    return (async () => {\n      try {\n        let e6 = await s4(o3);\n        if (!e6.finalized)\n          throw Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");\n        return e6.res;\n      } catch (e6) {\n        return this.#handleError(e6, o3);\n      }\n    })();\n  }\n  fetch = (e5, ...t3) => this.#dispatch(e5, t3[1], t3[0], e5.method);\n  request = (e5, t3, n3, r3) => e5 instanceof Request ? this.fetch(t3 ? new Request(e5, t3) : e5, n3, r3) : (e5 = e5.toString(), this.fetch(new Request(/^https?:\\/\\//.test(e5) ? e5 : `http://localhost${u(`/`, e5)}`, t3), n3, r3));\n  fire = () => {\n    addEventListener(`fetch`, (e5) => {\n      e5.respondWith(this.#dispatch(e5.request, e5, undefined, e5.request.method));\n    });\n  };\n};\nvar A2 = `[^/]+`;\nvar j2 = `.*`;\nvar M2 = `(?:|/.*)`;\nvar N2 = Symbol();\nvar oe2 = new Set(`.\\\\+*[^]$()`);\nfunction se2(e5, t3) {\n  return e5.length === 1 ? t3.length === 1 ? e5 < t3 ? -1 : 1 : -1 : t3.length === 1 || e5 === j2 || e5 === M2 ? 1 : t3 === j2 || t3 === M2 ? -1 : e5 === A2 ? 1 : t3 === A2 ? -1 : e5.length === t3.length ? e5 < t3 ? -1 : 1 : t3.length - e5.length;\n}\nvar P2 = class {\n  #index;\n  #varIndex;\n  #children = Object.create(null);\n  insert(e5, t3, n3, r3, i4) {\n    if (e5.length === 0) {\n      if (this.#index !== undefined)\n        throw N2;\n      if (i4)\n        return;\n      this.#index = t3;\n      return;\n    }\n    let [a5, ...o3] = e5, s4 = a5 === `*` ? o3.length === 0 ? [``, ``, j2] : [``, ``, A2] : a5 === `/*` ? [``, ``, M2] : a5.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/), c4;\n    if (s4) {\n      let e6 = s4[1], t4 = s4[2] || A2;\n      if (e6 && s4[2] && (t4 === `.*` || (t4 = t4.replace(/^\\((?!\\?:)(?=[^)]+\\)$)/, `(?:`), /\\((?!\\?:)/.test(t4))))\n        throw N2;\n      if (c4 = this.#children[t4], !c4) {\n        if (Object.keys(this.#children).some((e7) => e7 !== j2 && e7 !== M2))\n          throw N2;\n        if (i4)\n          return;\n        c4 = this.#children[t4] = new P2, e6 !== `` && (c4.#varIndex = r3.varIndex++);\n      }\n      !i4 && e6 !== `` && n3.push([e6, c4.#varIndex]);\n    } else if (c4 = this.#children[a5], !c4) {\n      if (Object.keys(this.#children).some((e6) => e6.length > 1 && e6 !== j2 && e6 !== M2))\n        throw N2;\n      if (i4)\n        return;\n      c4 = this.#children[a5] = new P2;\n    }\n    c4.insert(o3, t3, n3, r3, i4);\n  }\n  buildRegExpStr() {\n    let e5 = Object.keys(this.#children).sort(se2).map((e6) => {\n      let t3 = this.#children[e6];\n      return (typeof t3.#varIndex == `number` ? `(${e6})@${t3.#varIndex}` : oe2.has(e6) ? `\\\\${e6}` : e6) + t3.buildRegExpStr();\n    });\n    return typeof this.#index == `number` && e5.unshift(`#${this.#index}`), e5.length === 0 ? `` : e5.length === 1 ? e5[0] : `(?:` + e5.join(`|`) + `)`;\n  }\n};\nvar ce2 = class {\n  #context = { varIndex: 0 };\n  #root = new P2;\n  insert(e5, t3, n3) {\n    let r3 = [], i4 = [];\n    for (let t4 = 0;; ) {\n      let n4 = false;\n      if (e5 = e5.replace(/\\{[^}]+\\}/g, (e6) => {\n        let r4 = `@\\\\${t4}`;\n        return i4[t4] = [r4, e6], t4++, n4 = true, r4;\n      }), !n4)\n        break;\n    }\n    let a5 = e5.match(/(?::[^\\/]+)|(?:\\/\\*$)|./g) || [];\n    for (let e6 = i4.length - 1;e6 >= 0; e6--) {\n      let [t4] = i4[e6];\n      for (let n4 = a5.length - 1;n4 >= 0; n4--)\n        if (a5[n4].indexOf(t4) !== -1) {\n          a5[n4] = a5[n4].replace(t4, i4[e6][1]);\n          break;\n        }\n    }\n    return this.#root.insert(a5, t3, r3, this.#context, n3), r3;\n  }\n  buildRegExp() {\n    let e5 = this.#root.buildRegExpStr();\n    if (e5 === ``)\n      return [/^$/, [], []];\n    let t3 = 0, n3 = [], r3 = [];\n    return e5 = e5.replace(/#(\\d+)|@(\\d+)|\\.\\*\\$/g, (e6, i4, a5) => i4 === undefined ? (a5 === undefined || (r3[Number(a5)] = ++t3), ``) : (n3[++t3] = Number(i4), `$()`)), [RegExp(`^${e5}`), n3, r3];\n  }\n};\nvar F2 = [];\nvar I2 = [/^$/, [], Object.create(null)];\nvar L2 = Object.create(null);\nfunction R2(e5) {\n  return L2[e5] ??= RegExp(e5 === `*` ? `` : `^${e5.replace(/\\/\\*$|([.\\\\+*[^\\]$()])/g, (e6, t3) => t3 ? `\\\\${t3}` : `(?:|/.*)`)}$`);\n}\nfunction z3() {\n  L2 = Object.create(null);\n}\nfunction B2(e5) {\n  let t3 = new ce2, n3 = [];\n  if (e5.length === 0)\n    return I2;\n  let r3 = e5.map((e6) => [!/\\*|\\/:/.test(e6[0]), ...e6]).sort(([e6, t4], [n4, r4]) => e6 ? 1 : n4 ? -1 : t4.length - r4.length), i4 = Object.create(null);\n  for (let e6 = 0, a6 = -1, o4 = r3.length;e6 < o4; e6++) {\n    let [o5, s5, c5] = r3[e6];\n    o5 ? i4[s5] = [c5.map(([e7]) => [e7, Object.create(null)]), F2] : a6++;\n    let l3;\n    try {\n      l3 = t3.insert(s5, a6, o5);\n    } catch (e7) {\n      throw e7 === N2 ? new T2(s5) : e7;\n    }\n    o5 || (n3[a6] = c5.map(([e7, t4]) => {\n      let n4 = Object.create(null);\n      for (--t4;t4 >= 0; t4--) {\n        let [e8, r4] = l3[t4];\n        n4[e8] = r4;\n      }\n      return [e7, n4];\n    }));\n  }\n  let [a5, o3, s4] = t3.buildRegExp();\n  for (let e6 = 0, t4 = n3.length;e6 < t4; e6++)\n    for (let t5 = 0, r4 = n3[e6].length;t5 < r4; t5++) {\n      let r5 = n3[e6][t5]?.[1];\n      if (!r5)\n        continue;\n      let i5 = Object.keys(r5);\n      for (let e7 = 0, t6 = i5.length;e7 < t6; e7++)\n        r5[i5[e7]] = s4[r5[i5[e7]]];\n    }\n  let c4 = [];\n  for (let e6 in o3)\n    c4[e6] = n3[o3[e6]];\n  return [a5, c4, i4];\n}\nfunction V2(e5, t3) {\n  if (e5) {\n    for (let n3 of Object.keys(e5).sort((e6, t4) => t4.length - e6.length))\n      if (R2(n3).test(t3))\n        return [...e5[n3]];\n  }\n}\nvar H2 = class {\n  name = `RegExpRouter`;\n  #middleware;\n  #routes;\n  constructor() {\n    this.#middleware = { [C2]: Object.create(null) }, this.#routes = { [C2]: Object.create(null) };\n  }\n  add(t3, n3, r3) {\n    let i4 = this.#middleware, a5 = this.#routes;\n    if (!i4 || !a5)\n      throw Error(w2);\n    i4[t3] || [i4, a5].forEach((e5) => {\n      e5[t3] = Object.create(null), Object.keys(e5[C2]).forEach((n4) => {\n        e5[t3][n4] = [...e5[C2][n4]];\n      });\n    }), n3 === `/*` && (n3 = `*`);\n    let o3 = (n3.match(/\\/:/g) || []).length;\n    if (/\\*$/.test(n3)) {\n      let e5 = R2(n3);\n      t3 === C2 ? Object.keys(i4).forEach((e6) => {\n        i4[e6][n3] ||= V2(i4[e6], n3) || V2(i4[C2], n3) || [];\n      }) : i4[t3][n3] ||= V2(i4[t3], n3) || V2(i4[C2], n3) || [], Object.keys(i4).forEach((n4) => {\n        (t3 === C2 || t3 === n4) && Object.keys(i4[n4]).forEach((t4) => {\n          e5.test(t4) && i4[n4][t4].push([r3, o3]);\n        });\n      }), Object.keys(a5).forEach((n4) => {\n        (t3 === C2 || t3 === n4) && Object.keys(a5[n4]).forEach((t4) => e5.test(t4) && a5[n4][t4].push([r3, o3]));\n      });\n      return;\n    }\n    let s4 = d(n3) || [n3];\n    for (let e5 = 0, n4 = s4.length;e5 < n4; e5++) {\n      let c4 = s4[e5];\n      Object.keys(a5).forEach((s5) => {\n        (t3 === C2 || t3 === s5) && (a5[s5][c4] ||= [...V2(i4[s5], c4) || V2(i4[C2], c4) || []], a5[s5][c4].push([r3, o3 - n4 + e5 + 1]));\n      });\n    }\n  }\n  match(e5, t3) {\n    z3();\n    let n3 = this.#buildAllMatchers();\n    return this.match = (e6, t4) => {\n      let r3 = n3[e6] || n3[C2], i4 = r3[2][t4];\n      if (i4)\n        return i4;\n      let a5 = t4.match(r3[0]);\n      if (!a5)\n        return [[], F2];\n      let o3 = a5.indexOf(``, 1);\n      return [r3[1][o3], a5];\n    }, this.match(e5, t3);\n  }\n  #buildAllMatchers() {\n    let e5 = Object.create(null);\n    return Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((t3) => {\n      e5[t3] ||= this.#buildMatcher(t3);\n    }), this.#middleware = this.#routes = undefined, e5;\n  }\n  #buildMatcher(e5) {\n    let t3 = [], n3 = e5 === C2;\n    return [this.#middleware, this.#routes].forEach((r3) => {\n      let i4 = r3[e5] ? Object.keys(r3[e5]).map((t4) => [t4, r3[e5][t4]]) : [];\n      i4.length === 0 ? e5 !== C2 && t3.push(...Object.keys(r3[C2]).map((e6) => [e6, r3[C2][e6]])) : (n3 ||= true, t3.push(...i4));\n    }), n3 ? B2(t3) : null;\n  }\n};\nvar U2 = class {\n  name = `SmartRouter`;\n  #routers = [];\n  #routes = [];\n  constructor(e5) {\n    this.#routers = e5.routers;\n  }\n  add(e5, t3, n3) {\n    if (!this.#routes)\n      throw Error(w2);\n    this.#routes.push([e5, t3, n3]);\n  }\n  match(e5, t3) {\n    if (!this.#routes)\n      throw Error(`Fatal error`);\n    let n3 = this.#routers, r3 = this.#routes, i4 = n3.length, a5 = 0, o3;\n    for (;a5 < i4; a5++) {\n      let i5 = n3[a5];\n      try {\n        for (let e6 = 0, t4 = r3.length;e6 < t4; e6++)\n          i5.add(...r3[e6]);\n        o3 = i5.match(e5, t3);\n      } catch (e6) {\n        if (e6 instanceof T2)\n          continue;\n        throw e6;\n      }\n      this.match = i5.match.bind(i5), this.#routers = [i5], this.#routes = undefined;\n      break;\n    }\n    if (a5 === i4)\n      throw Error(`Fatal error`);\n    return this.name = `SmartRouter + ${this.activeRouter.name}`, o3;\n  }\n  get activeRouter() {\n    if (this.#routes || this.#routers.length !== 1)\n      throw Error(`No active router has been determined yet.`);\n    return this.#routers[0];\n  }\n};\nvar W2 = Object.create(null);\nvar G2 = class {\n  #methods;\n  #children;\n  #patterns;\n  #order = 0;\n  #params = W2;\n  constructor(e5, t3, n3) {\n    if (this.#children = n3 || Object.create(null), this.#methods = [], e5 && t3) {\n      let n4 = Object.create(null);\n      n4[e5] = { handler: t3, possibleKeys: [], score: 0 }, this.#methods = [n4];\n    }\n    this.#patterns = [];\n  }\n  insert(e5, t3, n3) {\n    this.#order = ++this.#order;\n    let r3 = this, a5 = t2(t3), o3 = [];\n    for (let e6 = 0, t4 = a5.length;e6 < t4; e6++) {\n      let t5 = a5[e6], n4 = a5[e6 + 1], s4 = a3(t5, n4), c4 = Array.isArray(s4) ? s4[0] : t5;\n      if (c4 in r3.#children) {\n        r3 = r3.#children[c4], s4 && o3.push(s4[1]);\n        continue;\n      }\n      r3.#children[c4] = new G2, s4 && (r3.#patterns.push(s4), o3.push(s4[1])), r3 = r3.#children[c4];\n    }\n    return r3.#methods.push({ [e5]: { handler: n3, possibleKeys: o3.filter((e6, t4, n4) => n4.indexOf(e6) === t4), score: this.#order } }), r3;\n  }\n  #getHandlerSets(e5, t3, n3, r3) {\n    let i4 = [];\n    for (let a5 = 0, o3 = e5.#methods.length;a5 < o3; a5++) {\n      let o4 = e5.#methods[a5], s4 = o4[t3] || o4[C2], c4 = {};\n      if (s4 !== undefined && (s4.params = Object.create(null), i4.push(s4), n3 !== W2 || r3 && r3 !== W2))\n        for (let e6 = 0, t4 = s4.possibleKeys.length;e6 < t4; e6++) {\n          let t5 = s4.possibleKeys[e6], i5 = c4[s4.score];\n          s4.params[t5] = r3?.[t5] && !i5 ? r3[t5] : n3[t5] ?? r3?.[t5], c4[s4.score] = true;\n        }\n    }\n    return i4;\n  }\n  search(e5, t3) {\n    let n3 = [];\n    this.#params = W2;\n    let r3 = [this], i4 = e2(t3), a5 = [];\n    for (let t4 = 0, o3 = i4.length;t4 < o3; t4++) {\n      let s4 = i4[t4], c4 = t4 === o3 - 1, l3 = [];\n      for (let o4 = 0, u3 = r3.length;o4 < u3; o4++) {\n        let u4 = r3[o4], d2 = u4.#children[s4];\n        d2 && (d2.#params = u4.#params, c4 ? (d2.#children[`*`] && n3.push(...this.#getHandlerSets(d2.#children[`*`], e5, u4.#params)), n3.push(...this.#getHandlerSets(d2, e5, u4.#params))) : l3.push(d2));\n        for (let r4 = 0, o5 = u4.#patterns.length;r4 < o5; r4++) {\n          let o6 = u4.#patterns[r4], d3 = u4.#params === W2 ? {} : { ...u4.#params };\n          if (o6 === `*`) {\n            let t5 = u4.#children[`*`];\n            t5 && (n3.push(...this.#getHandlerSets(t5, e5, u4.#params)), t5.#params = d3, l3.push(t5));\n            continue;\n          }\n          let [f3, p3, m3] = o6;\n          if (!s4 && !(m3 instanceof RegExp))\n            continue;\n          let h3 = u4.#children[f3], g3 = i4.slice(t4).join(`/`);\n          if (m3 instanceof RegExp) {\n            let t5 = m3.exec(g3);\n            if (t5) {\n              if (d3[p3] = t5[0], n3.push(...this.#getHandlerSets(h3, e5, u4.#params, d3)), Object.keys(h3.#children).length) {\n                h3.#params = d3;\n                let e6 = t5[0].match(/\\//)?.length ?? 0;\n                (a5[e6] ||= []).push(h3);\n              }\n              continue;\n            }\n          }\n          (m3 === true || m3.test(s4)) && (d3[p3] = s4, c4 ? (n3.push(...this.#getHandlerSets(h3, e5, d3, u4.#params)), h3.#children[`*`] && n3.push(...this.#getHandlerSets(h3.#children[`*`], e5, d3, u4.#params))) : (h3.#params = d3, l3.push(h3)));\n        }\n      }\n      r3 = l3.concat(a5.shift() ?? []);\n    }\n    return n3.length > 1 && n3.sort((e6, t4) => e6.score - t4.score), [n3.map(({ handler: e6, params: t4 }) => [e6, t4])];\n  }\n};\nvar le2 = class {\n  name = `TrieRouter`;\n  #node;\n  constructor() {\n    this.#node = new G2;\n  }\n  add(t3, n3, r3) {\n    let i4 = d(n3);\n    if (i4) {\n      for (let e5 = 0, n4 = i4.length;e5 < n4; e5++)\n        this.#node.insert(t3, i4[e5], r3);\n      return;\n    }\n    this.#node.insert(t3, n3, r3);\n  }\n  match(e5, t3) {\n    return this.#node.search(e5, t3);\n  }\n};\nvar K2 = class extends k2 {\n  constructor(e5 = {}) {\n    super(e5), this.router = e5.router ?? new U2({ routers: [new H2, new le2] });\n  }\n};\nvar ue2 = (e5, t3, n3) => {\n  let r3 = e5.req.raw.headers.get(`Cookie`);\n  if (typeof t3 == `string`) {\n    if (!r3)\n      return;\n    let e6 = t3;\n    return n3 === `secure` ? e6 = `__Secure-` + t3 : n3 === `host` && (e6 = `__Host-` + t3), y(r3, e6)[e6];\n  }\n  return r3 ? y(r3) : {};\n};\nvar q2 = class extends Error {\n  res;\n  status;\n  constructor(e5 = 500, t3) {\n    super(t3?.message, { cause: t3?.cause }), this.res = t3?.res, this.status = e5;\n  }\n  getResponse() {\n    return this.res ? new Response(this.res.body, { status: this.status, headers: this.res.headers }) : new Response(this.message, { status: this.status });\n  }\n};\nvar de2 = (e5, t3) => new Response(e5, { headers: { "Content-Type": t3 } }).formData();\nvar fe2 = /^application\\/([a-z-\\.]+\\+)?json(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar pe2 = /^multipart\\/form-data(;\\s?boundary=[a-zA-Z0-9\'"()+_,\\-./:=?]+)?$/;\nvar me2 = /^application\\/x-www-form-urlencoded(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar J2 = (e5, t3) => async (n3, r3) => {\n  let i4 = {}, a5 = n3.req.header(`Content-Type`);\n  switch (e5) {\n    case `json`:\n      if (!a5 || !fe2.test(a5))\n        break;\n      try {\n        i4 = await n3.req.json();\n      } catch {\n        throw new q2(400, { message: `Malformed JSON in request body` });\n      }\n      break;\n    case `form`: {\n      if (!a5 || !(pe2.test(a5) || me2.test(a5)))\n        break;\n      let e6;\n      if (n3.req.bodyCache.formData)\n        e6 = await n3.req.bodyCache.formData;\n      else\n        try {\n          let t5 = await n3.req.arrayBuffer();\n          e6 = await de2(t5, a5), n3.req.bodyCache.formData = e6;\n        } catch (e7) {\n          let t5 = `Malformed FormData request.`;\n          throw t5 += e7 instanceof Error ? ` ${e7.message}` : ` ${String(e7)}`, new q2(400, { message: t5 });\n        }\n      let t4 = {};\n      e6.forEach((e7, n4) => {\n        n4.endsWith(`[]`) ? (t4[n4] ??= []).push(e7) : Array.isArray(t4[n4]) ? t4[n4].push(e7) : (n4 in t4) ? t4[n4] = [t4[n4], e7] : t4[n4] = e7;\n      }), i4 = t4;\n      break;\n    }\n    case `query`:\n      i4 = Object.fromEntries(Object.entries(n3.req.queries()).map(([e6, t4]) => t4.length === 1 ? [e6, t4[0]] : [e6, t4]));\n      break;\n    case `param`:\n      i4 = n3.req.param();\n      break;\n    case `header`:\n      i4 = n3.req.header();\n      break;\n    case `cookie`:\n      i4 = ue2(n3);\n      break;\n  }\n  let o3 = await t3(i4, n3);\n  if (o3 instanceof Response)\n    return o3;\n  n3.req.addValidatedData(e5, o3), await r3();\n};\nvar Y2 = (e5, t3) => e5.json({ error: t3 }, 400);\nvar X2 = (e5) => {\n  let t3 = e5.req.param(`key`);\n  return !t3 || t3 === `` ? { key: t3, err: `Key is required` } : t3.length > 475 ? { key: t3, err: `Key is too long. Max length is 475 characters.` } : { key: t3 };\n};\nvar Z2 = () => new K2;\nvar he2 = Z2().get(`/:key`, async (e5) => {\n  let { key: t3, err: n3 } = X2(e5);\n  if (n3)\n    return Y2(e5, n3);\n  let r3 = await e5.env.store.get(t3);\n  return e5.json({ value: r3 }, 200);\n}).post(`/:key`, J2(`json`, (e5, t3) => {\n  let n3 = e5.value;\n  return n3 ? typeof n3 == `string` ? n3.length > 20000 ? Y2(t3, `Value is too long. Max length is 20,000 characters.`) : { value: n3 } : Y2(t3, `Value must be a string`) : Y2(t3, `Value is required`);\n}), async (e5) => {\n  let { key: t3, err: n3 } = X2(e5);\n  if (n3)\n    return Y2(e5, n3);\n  let { value: r3 } = e5.req.valid(`json`);\n  return await e5.env.store.set(t3, r3), e5.body(null, 204);\n}).delete(`/:key`, async (e5) => {\n  let { key: t3, err: n3 } = X2(e5);\n  return n3 ? Y2(e5, n3) : (await e5.env.store.delete(t3), e5.body(null, 204));\n}).get(`/`, async (e5) => {\n  let { cursor: t3, limit: n3, prefix: r3 } = e5.req.query(), { entries: i4, cursor: a5 } = await e5.env.store.list(r3, { cursor: t3 ? String(t3) : undefined, limit: n3 ? Number(n3) : 100 });\n  return e5.json({ entries: i4, cursor: a5 });\n});\nvar ge2 = (e5) => {\n  let t3 = e5.req.param(`key`);\n  return t3 ? t3.length > 475 ? { key: t3, err: `Key is too long. Max length is 475 characters.` } : { key: t3 } : { key: t3, err: `Key is required` };\n};\nvar Q2 = J2(`param`, (e5) => ({ id: e5.id }));\nvar $2 = Z2().post(`/:key`, async (e5) => {\n  let { key: t3, err: n3 } = ge2(e5);\n  return n3 ? Y2(e5, n3) : e5.json(await e5.env.chat.upsert(t3), 200);\n}).get(`/:id`, Q2, async (e5) => {\n  let { id: t3 } = e5.req.valid(`param`);\n  return e5.json(await e5.env.chat.get(t3), 200);\n}).get(`/:id/messages`, Q2, async (e5) => {\n  let { id: t3 } = e5.req.valid(`param`);\n  return e5.json(await e5.env.chat.getMessages(t3), 200);\n}).post(`/:id/sendMessages`, J2(`json`, (e5) => ({ id: e5.id, messages: e5.messages, options: e5.options })), async (e5) => {\n  let { id: t3, messages: n3, options: r3 } = e5.req.valid(`json`);\n  return t3 ? (await e5.env.chat.sendMessages(t3, n3, r3), e5.body(null, 204)) : Y2(e5, `ID is required`);\n}).delete(`/:id/messages`, Q2, J2(`query`, (e5) => (typeof e5.message == `string` && (e5.message = [e5.message]), { messages: e5.message })), async (e5) => {\n  let { id: t3 } = e5.req.valid(`param`), { messages: n3 } = e5.req.valid(`query`);\n  return await e5.env.chat.deleteMessages(t3, n3), e5.body(null, 204);\n}).post(`/:id/start`, Q2, async (e5) => {\n  let { id: t3 } = e5.req.valid(`param`);\n  return await e5.env.chat.start(t3), e5.body(null, 204);\n}).post(`/:id/stop`, Q2, async (e5) => {\n  let { id: t3 } = e5.req.valid(`param`);\n  return await e5.env.chat.stop(t3), e5.body(null, 204);\n}).delete(`/:id`, Q2, async (e5) => {\n  let { id: t3 } = e5.req.valid(`param`);\n  return await e5.env.chat.delete(t3), e5.body(null, 204);\n});\nvar _e2 = Z2().post(`/v1/traces`, async (e5) => e5.env.otlp ? e5.env.otlp.traces(e5.req.raw) : e5.body(null, 204));\nvar ve2 = new K2().onError((e5, t3) => t3.json({ error: e5 instanceof Error ? e5.message : `Unknown error` }, 500)).route(`/kv`, he2).route(`/chat`, $2).route(`/otlp`, _e2);\n\n// src/server.ts\nimport { createServer, Server } from "node:http";\nvar InternalAuthHeader = "x-blink-internal-auth";\nfunction patchFetchWithAuth(internalAPIOrigin) {\n  const originalFetch = globalThis.fetch;\n  const patchedFetch = (input, init) => {\n    const url2 = typeof input === "string" ? input : input instanceof URL ? input.href : input.url;\n    if (url2.startsWith(internalAPIOrigin)) {\n      const authToken = i() ?? process.env[BlinkInvocationAuthTokenEnvironmentVariable];\n      if (authToken) {\n        const headers = new Headers(init?.headers);\n        headers.set(InternalAuthHeader, authToken);\n        init = { ...init, headers };\n      }\n    }\n    return originalFetch(input, init);\n  };\n  Object.assign(patchedFetch, originalFetch);\n  globalThis.fetch = patchedFetch;\n}\nasync function startInternalAPIServer() {\n  const port = process.env[InternalAPIServerListenPortEnvironmentVariable] ? parseInt(process.env[InternalAPIServerListenPortEnvironmentVariable], 10) : 12345;\n  const server = createServer(createServerAdapter((request) => {\n    const authToken = request.headers.get(InternalAuthHeader) ?? undefined;\n    const client = new AgentInvocationClient({\n      baseURL: process.env[InternalAPIServerURLEnvironmentVariable],\n      authToken,\n      deploymentToken: process.env[BlinkDeploymentTokenEnvironmentVariable]\n    });\n    const store = {\n      get(key) {\n        return client.getStorage(key);\n      },\n      set(key, value) {\n        return client.setStorage(key, value);\n      },\n      delete(key) {\n        return client.deleteStorage(key);\n      },\n      list(prefix, options) {\n        return client.listStorage(prefix, options);\n      }\n    };\n    const otlp = {\n      traces(req) {\n        return client.proxyOtlpTraces(req);\n      }\n    };\n    const chat = {\n      upsert: async (key) => {\n        const resp = await client.upsertChat(JSON.stringify(key));\n        return {\n          created: resp.created,\n          id: resp.id,\n          createdAt: resp.created_at\n        };\n      },\n      delete: async (id) => {\n        await client.deleteChat(id);\n      },\n      deleteMessages: async (id, messageIds) => {\n        await client.deleteMessages(id, messageIds);\n      },\n      get: async (id) => {\n        const resp = await client.getChat(id);\n        if (!resp) {\n          return;\n        }\n        return {\n          id: resp.id,\n          createdAt: resp.createdAt\n        };\n      },\n      getMessages: async (id) => {\n        const messages = await client.getMessages(id);\n        return messages.map((message) => ({\n          id: message.id,\n          role: message.role,\n          parts: message.parts,\n          metadata: message.metadata\n        }));\n      },\n      start: async (id) => {\n        await client.startChat(id);\n      },\n      stop: async (id) => {\n        await client.stopChat(id);\n      },\n      sendMessages: async (id, messages, options) => {\n        await client.sendMessages(id, {\n          messages: messages.map((msg) => ({\n            id: msg.id,\n            role: msg.role,\n            parts: msg.parts,\n            metadata: msg.metadata\n          })),\n          behavior: options?.behavior ?? "enqueue"\n        });\n      }\n    };\n    return ve2.fetch(request, {\n      chat,\n      store,\n      otlp\n    });\n  }));\n  const actualPort = await new Promise((resolve, reject) => {\n    const onError = (err) => reject(err);\n    server.once("error", onError);\n    server.listen(port, "127.0.0.1", () => {\n      server.off("error", onError);\n      const address = server.address();\n      if (address && typeof address !== "string") {\n        resolve(address.port);\n      } else {\n        resolve(port);\n      }\n    });\n  });\n  process.env[oc] = `http://127.0.0.1:${actualPort}`;\n  return {\n    server,\n    port: actualPort\n  };\n}\nasync function startAgentServer(entrypoint, port, unref = false) {\n  const priorEnvPort = process.env.PORT;\n  process.env.PORT = port.toString();\n  const originalListen = Server.prototype.listen;\n  let restored = false;\n  const restoreListen = () => {\n    if (!restored) {\n      Server.prototype.listen = originalListen;\n      restored = true;\n    }\n  };\n  const listeningPromise = new Promise((resolve, reject) => {\n    Server.prototype.listen = function(...args) {\n      this.once("listening", () => {\n        const address = this.address();\n        const resolvedPort = address && typeof address !== "string" ? address.port : port;\n        restoreListen();\n        resolve(resolvedPort);\n      });\n      this.once("error", (err) => {\n        restoreListen();\n        reject(err);\n      });\n      if (unref) {\n        this.unref();\n      }\n      return originalListen.apply(this, args);\n    };\n  });\n  try {\n    await import(entrypoint);\n  } catch (error48) {\n    restoreListen();\n    throw error48;\n  } finally {\n    process.env.PORT = priorEnvPort;\n  }\n  const actualPort = await listeningPromise;\n  const agentUrl = `http://127.0.0.1:${actualPort}`;\n  const handler = createServerAdapter((request) => {\n    const reqURL = new URL(request.url);\n    const newURL = new URL(agentUrl);\n    newURL.pathname = reqURL.pathname;\n    newURL.search = reqURL.search;\n    const authToken = i();\n    const headers = new Headers(request.headers);\n    if (authToken) {\n      headers.set(InternalAuthHeader, authToken);\n    }\n    return fetch(newURL.toString(), {\n      method: request.method,\n      headers,\n      body: request.body,\n      duplex: "half"\n    });\n  });\n  return { handler, port: actualPort };\n}\n\n// src/lambda/wrapper-lambda.ts\nvar { server, port } = await startInternalAPIServer();\nserver.unref();\npatchFetchWithAuth(`http://127.0.0.1:${port}`);\nif (!process.env.ENTRYPOINT) {\n  throw new Error("developer error: ENTRYPOINT is not set");\n}\nvar { handler: agent } = await startAgentServer(resolve(process.env.ENTRYPOINT), 0, true);\nvar handler = awslambda.streamifyResponse(async (event, responseStream, context) => {\n  const headers = buildHeaders(event);\n  let authToken;\n  for (const [k3, v3] of headers.entries()) {\n    if (k3.toLowerCase() === BlinkInvocationTokenHeader.toLowerCase()) {\n      authToken = v3;\n      headers.delete(k3);\n      break;\n    }\n  }\n  process.env[BlinkInvocationAuthTokenEnvironmentVariable] = authToken ?? "";\n  return a(authToken ?? "", async () => {\n    const waitUntilSymbol = Symbol.for("@blink/waitUntil");\n    const waitUntilPromises = [];\n    globalThis[waitUntilSymbol] = (promise2) => {\n      waitUntilPromises.push(promise2);\n    };\n    const isV2 = "rawPath" in event;\n    const path = isV2 ? event.rawPath : event.path;\n    const query = isV2 ? event.rawQueryString : new URLSearchParams(event.queryStringParameters || {}).toString();\n    const method = isV2 ? event.requestContext?.http?.method : event.httpMethod;\n    const url2 = new URL(path + (query ? `?${query}` : ""), "https://lambda.internal");\n    let body;\n    if (event.body != null && method !== "GET" && method !== "HEAD") {\n      body = event.isBase64Encoded ? Buffer.from(event.body, "base64") : event.body;\n    }\n    const controller = new AbortController;\n    const onCloseOrError = () => {\n      controller.abort();\n    };\n    responseStream.on("close", onCloseOrError);\n    responseStream.on("error", onCloseOrError);\n    const msLeft = Math.max(0, context.getRemainingTimeInMillis() - 5000);\n    const timeout = setTimeout(() => controller.abort(), msLeft);\n    try {\n      const res = await agent.fetch(url2, { method, body, headers, signal: controller.signal }, { event, lambdaContext: context });\n      const resHeaders = {};\n      res.headers.forEach((value, key) => {\n        resHeaders[key] = value;\n      });\n      const cookies = res.headers.getSetCookie?.() ?? (res.headers.get("set-cookie") ? [res.headers.get("set-cookie")] : []);\n      const http = awslambda.HttpResponseStream.from(responseStream, {\n        statusCode: res.status,\n        headers: resHeaders,\n        cookies\n      });\n      if (res.body) {\n        await res.body.pipeTo(Writable.toWeb(http), { signal: controller.signal });\n      } else {\n        http.end();\n      }\n    } catch (err) {\n      try {\n        const http = awslambda.HttpResponseStream.from(responseStream, {\n          statusCode: controller.signal.aborted ? 499 : 502,\n          headers: { "content-type": "application/json" }\n        });\n        http.write(JSON.stringify({\n          message: controller.signal.aborted ? "client closed" : "upstream error"\n        }));\n        http.end();\n      } catch {}\n    } finally {\n      clearTimeout(timeout);\n      responseStream.off("close", onCloseOrError);\n      responseStream.off("error", onCloseOrError);\n      const flushController = new AbortController;\n      const flushTimeout = setTimeout(() => flushController.abort("timeout"), 5000);\n      try {\n        await Promise.allSettled(waitUntilPromises);\n        await agent.fetch(new URL("/_agent/flush-otel", "http://lambda.internal"), {\n          method: "POST",\n          signal: flushController.signal\n        });\n      } catch {} finally {\n        clearTimeout(flushTimeout);\n      }\n    }\n  });\n});\nfunction buildHeaders(event) {\n  const out = new Headers;\n  const hv1 = event?.headers ?? {};\n  for (const [k3, v3] of Object.entries(hv1)) {\n    if (v3 == null)\n      continue;\n    out.set(k3, String(v3));\n  }\n  const mv = event?.multiValueHeaders ?? {};\n  for (const [k3, arr] of Object.entries(mv)) {\n    if (!Array.isArray(arr))\n      continue;\n    out.delete(k3);\n    for (const v3 of arr)\n      out.append(k3, String(v3));\n  }\n  if (Array.isArray(event?.cookies) && event.cookies.length) {\n    const existing = out.get("cookie");\n    const merged = [existing, event.cookies.join("; ")].filter(Boolean).join("; ");\n    out.set("cookie", merged);\n  }\n  if (!out.has("x-forwarded-proto"))\n    out.set("x-forwarded-proto", "https");\n  if (!out.has("x-forwarded-host") && out.has("host")) {\n    out.set("x-forwarded-host", out.get("host"));\n  }\n  const sourceIp = event?.requestContext?.http?.sourceIp ?? event?.requestContext?.identity?.sourceIp;\n  if (sourceIp) {\n    const xff = out.get("x-forwarded-for");\n    out.set("x-forwarded-for", xff ? `${xff}, ${sourceIp}` : sourceIp);\n  }\n  return out;\n}\nexport {\n  handler\n};\n';
